// ===== src\app\admin\banners\page.tsx =====
// src/app/admin/banners/page.tsx
"use client";

import { useMemo, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { PlusCircle, Edit, Trash2 } from "lucide-react";
import Image from "next/image";
import { IBanner } from "@/models/Banner";
import BannerFormModal from "@/components/admin/BannerFormModal";
import { AD_SLOTS } from "@/config/adSlots";

const fetchBanners = async (): Promise<IBanner[]> => {
  const { data } = await axios.get("/api/banners");
  return data;
};

export default function AdminBannersPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingBanner, setEditingBanner] = useState<IBanner | null>(null);

  // Create a lookup map for user-friendly location names
  const locationNameMap = useMemo(
    () => new Map(AD_SLOTS.map((s) => [s.id, s.name])),
    []
  );

  const {
    data: banners,
    isLoading,
    error,
  } = useQuery<IBanner[]>({
    queryKey: ["adminBanners"],
    queryFn: fetchBanners,
  });

  const deleteMutation = useMutation({
    mutationFn: (bannerId: string) => axios.delete(`/api/banners/${bannerId}`),
    onSuccess: () => {
      toast.success("Banner deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["adminBanners"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete banner.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingBanner(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (banner: IBanner) => {
    setEditingBanner(banner);
    setIsModalOpen(true);
  };

  const handleDelete = (bannerId: string) => {
    if (
      window.confirm(
        "Are you sure you want to delete this banner? This action cannot be undone."
      )
    ) {
      deleteMutation.mutate(bannerId);
    }
  };

  if (isLoading) return <p className="text-brand-muted">Loading banners...</p>;
  if (error) return <p className="text-red-400">Failed to load banners.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Manage Ad Banners</h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Banner</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Preview</th>
              <th className="p-4">Title</th>
              <th className="p-4">Location</th> {/* <-- NEW COLUMN */}
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {banners?.map((banner) => (
              <tr
                key={banner._id as string}
                className="border-t border-gray-700/50"
              >
                <td className="p-4">
                  {/* --- THE FIX IS HERE --- */}
                  <Image
                    src={banner.imageUrl}
                    alt={banner.title}
                    width={120}
                    height={60}
                    // Add the objectFit="contain" property here as well.
                    // This was the missing piece from my previous implementation.
                    objectFit="contain"
                    className="rounded-md bg-gray-700"
                  />
                </td>
                <td className="p-4 font-medium">{banner.title}</td>
                <td className="p-4 font-semibold text-brand-light">
                  {locationNameMap.get(banner.location) || banner.location}
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      banner.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {banner.isActive ? "Active" : "Inactive"}
                  </span>
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <button
                    onClick={() => handleOpenEditModal(banner)}
                    className="text-blue-400 hover:text-blue-300"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() => handleDelete(banner._id as string)}
                    className="text-red-400 hover:text-red-300"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {banners?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No banners found. Click "New Banner" to create one.
          </p>
        )}
      </div>

      <BannerFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        banner={editingBanner}
      />
    </div>
  );
}


// ===== src\app\admin\dashboard\page.tsx =====
"use client"
import { useTranslation } from '@/hooks/useTranslation';

// This can be a simple server component for now
export default function AdminDashboardPage() {
  const { t } = useTranslation();

  return (
    <div>
      <h1 className="text-3xl font-bold text-white mb-4">{t('admin_dashboard')}</h1>
      <p className="text-brand-muted">{t('welcome_to_admin_area')}</p>
      <div className="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6">
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t('manage_users')}</h3>
          <p className="text-sm text-brand-muted mt-2">{t('view_and_edit_user_roles')}</p>
        </div>
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t('manage_matches')}</h3>
          <p className="text-sm text-brand-muted mt-2">{t('update_match_details')}</p>
        </div>
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t('view_analytics')}</h3>
          <p className="text-sm text-brand-muted mt-2">{t('check_site_traffic')}</p>
        </div>
      </div>
    </div>
  );
}

// ===== src\app\admin\layout.tsx =====
// src/app/admin/layout.tsx

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { redirect } from "next/navigation";
import AdminSidebar from "@/components/admin/AdminSidebar";
import { LanguageProvider } from "@/context/LanguageContext";

export default async function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await getServerSession(authOptions);

  // 1. UNCOMMENT THIS BLOCK
  if (!session) {
    // Redirect to the login page with an error message indicating forbidden access
    redirect("/login?error=Forbidden");
  }

  // 2. If user is an admin, render the layout...
  return (
     <LanguageProvider>
    <div className="flex min-h-screen">
      <AdminSidebar />
      <main className="flex-1 p-8 bg-brand-dark">
        {children}
      </main>
    </div>
    </LanguageProvider>
  );
}

// ===== src\app\admin\news\create\page.tsx =====
// src/app/admin/news/create/page.tsx
"use client";

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useMutation } from '@tanstack/react-query';
import axios from 'axios';
import toast from 'react-hot-toast';
import Link from '@/components/StyledLink'; 
import Image from 'next/image';
import { UploadCloud, XCircle } from 'lucide-react';

import RichTextEditor from '@/components/admin/RichTextEditor';

export default function CreateNewsPostPage() {
  const router = useRouter();
  // --- STATE FOR NEW FIELDS ---
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [status, setStatus] = useState<'draft' | 'published'>('draft');
  const [metaTitle, setMetaTitle] = useState('');
  const [metaDescription, setMetaDescription] = useState('');
  const [featuredImage, setFeaturedImage] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [imageTitle, setImageTitle] = useState('');
  const [imageAltText, setImageAltText] = useState('');
  const [sport, setSport] = useState('football');

  // --- IMAGE UPLOAD HANDLER ---
  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setIsUploading(true);
    const formData = new FormData();
    formData.append('file', file);

    try {
      const { data } = await axios.post('/api/upload', formData);
      setFeaturedImage(data.url);
      toast.success('Image uploaded!');
    } catch (error) {
      toast.error('Image upload failed.');
    } finally {
      setIsUploading(false);
    }
  };

  // --- MUTATION TO CREATE POST (NOW INCLUDES NEW FIELDS) ---
  const createPostMutation = useMutation({
    mutationFn: (newPost: {
      title: string;
      content: string;
      status: string;
      metaTitle?: string;
      metaDescription?: string;
      featuredImage?: string | null;
      featuredImageTitle?: string;
      featuredImageAltText?: string;
      sport: string,

    }) => {
      return axios.post('/api/posts', newPost);
    },
    onSuccess: () => {
      toast.success('Post created successfully!');
      router.push('/admin/news');
      router.refresh();
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.error || 'Failed to create post.');
    }
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!title.trim() || !content.trim()) {
        toast.error('Title and content cannot be empty.');
        return;
    }
    createPostMutation.mutate({
      title,
      content,
      status,
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle: imageTitle,
      featuredImageAltText: imageAltText,
      sport,
    });
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Create New Post</h1>
      </div>

      <form onSubmit={handleSubmit} className="bg-brand-secondary p-6 rounded-lg space-y-6">
        
        {/* --- ENHANCED: FEATURED IMAGE SECTION --- */}
        <div className="p-4 border border-gray-600 rounded-lg">
          <label className="block text-sm font-medium text-brand-light mb-2">Featured Image</label>
          <div className="mt-2 flex justify-center rounded-lg border border-dashed border-gray-600 px-6 py-10">
            {featuredImage ? (
              <div className="relative group w-full h-64">
                <Image src={featuredImage} alt={imageAltText || 'Featured preview'} layout="fill" objectFit="contain" />
                <button
                  type="button"
                  onClick={() => setFeaturedImage(null)}
                  className="absolute top-2 right-2 bg-red-600 rounded-full p-1 text-white opacity-0 group-hover:opacity-100 transition-opacity"
                >
                  <XCircle size={20} />
                </button>
              </div>
            ) : (
              <div className="text-center">
                <UploadCloud className="mx-auto h-12 w-12 text-gray-500" />
                <div className="mt-4 flex text-sm leading-6 text-gray-400">
                  <label htmlFor="file-upload" className="relative cursor-pointer rounded-md font-semibold text-brand-purple focus-within:outline-none focus-within:ring-2 focus-within:ring-brand-purple focus-within:ring-offset-2 focus-within:ring-offset-brand-dark hover:text-brand-purple/80">
                    <span>{isUploading ? 'Uploading...' : 'Upload a file'}</span>
                    <input id="file-upload" name="file-upload" type="file" className="sr-only" onChange={handleImageUpload} disabled={isUploading} accept="image/*" />
                  </label>
                  <p className="pl-1">or drag and drop</p>
                </div>
                <p className="text-xs leading-5 text-gray-500">PNG, JPG, GIF up to 10MB</p>
              </div>
            )}
          </div>
        </div>

        {featuredImage && (
            <div className="mt-4 space-y-4">
              <div>
                <label htmlFor="imageTitle" className="block text-sm font-medium text-brand-light mb-2">Image Title (Tooltip)</label>
                <input id="imageTitle" type="text" value={imageTitle} onChange={(e) => setImageTitle(e.target.value)} placeholder="e.g., Team celebrating a goal" className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple" />
              </div>
              <div>
                <label htmlFor="imageAltText" className="block text-sm font-medium text-brand-light mb-2">Image Alt Text (Accessibility & SEO)</label>
                <input id="imageAltText" type="text" value={imageAltText} onChange={(e) => setImageAltText(e.target.value)} placeholder="e.g., Player in red jersey kicking a football" className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple" />
                 <p className="text-xs text-brand-muted mt-1">Describe the image for screen readers and search engines.</p>
              </div>
            </div>
          )}

        {/* Title Field (No change) */}
        <div>
          <label htmlFor="title" className="block text-sm font-medium text-brand-light mb-2">Title</label>
          <input id="title" type="text" value={title} onChange={(e) => setTitle(e.target.value)} required className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple" />
        </div>

        {/* Content Field (No change) */}
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">Content</label>
          <RichTextEditor value={content} onChange={setContent} />
        </div>

        {/* --- SEO & META FIELDS SECTION --- */}
        <div className="space-y-4 p-4 border border-gray-600 rounded-lg">
            <h3 className="text-lg font-semibold text-white">SEO Settings</h3>
            <div>
              <label htmlFor="metaTitle" className="block text-sm font-medium text-brand-light mb-2">Meta Title</label>
              <input id="metaTitle" type="text" value={metaTitle} onChange={(e) => setMetaTitle(e.target.value)} placeholder="e.g., Ultimate Guide to Sunday's Match" className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple" />
              <p className="text-xs text-brand-muted mt-1">Recommended: 50-60 characters.</p>
            </div>
            <div>
              <label htmlFor="metaDescription" className="block text-sm font-medium text-brand-light mb-2">Meta Description</label>
              <textarea id="metaDescription" rows={3} value={metaDescription} onChange={(e) => setMetaDescription(e.target.value)} placeholder="A brief summary for search engines..." className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple" />
              <p className="text-xs text-brand-muted mt-1">Recommended: 150-160 characters.</p>
            </div>
        </div>

        {/* Status Field (No change) */}
        <div>
          <label htmlFor="status" className="block text-sm font-medium text-brand-light mb-2">Status</label>
          <select id="status" value={status} onChange={(e) => setStatus(e.target.value as 'draft' | 'published')} className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple">
            <option value="draft">Draft</option>
            <option value="published">Published</option>
          </select>
        </div>

                  <div>
            <label htmlFor="sport" className="block text-sm font-medium text-brand-light mb-2">Sport Category</label>
            <select 
              id="sport" 
              value={sport} 
              onChange={(e) => setSport(e.target.value)} 
              className="w-full p-3 rounded bg-gray-700 text-white ..."
            >
              <option value="football">Football</option>
              <option value="basketball">Basketball</option>
              <option value="tennis">Tennis</option>
              <option value="general">General</option>
            </select>
          </div>

        {/* Action Buttons (No change) */}
        <div className="flex justify-end gap-4 pt-4 border-t border-gray-600">
          <Link href="/admin/news" className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90">Cancel</Link>
          <button type="submit" disabled={createPostMutation.isPending || isUploading} className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed">
            {createPostMutation.isPending ? 'Saving...' : 'Save Post'}
          </button>
        </div>
      </form>
    </div>
  );
}

// ===== src\app\admin\news\edit\[postId]\page.tsx =====
// src/app/admin/news/edit/[postId]/page.tsx
"use client";

import { useState, useEffect } from 'react';
import { useRouter, useParams } from 'next/navigation';
import { useQuery, useMutation } from '@tanstack/react-query';
import axios from 'axios';
import toast from 'react-hot-toast';
import Link from '@/components/StyledLink'; 
import RichTextEditor from '@/components/admin/RichTextEditor';
import { IPost } from '@/models/Post';

// Fetcher function for a single post
const fetchPost = async (postId: string): Promise<IPost> => {
    const { data } = await axios.get(`/api/posts/${postId}`);
    return data;
};

export default function EditNewsPostPage() {
  const router = useRouter();
  const params = useParams();
  const postId = params.postId as string;

  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [status, setStatus] = useState<'draft' | 'published'>('draft');

  // 1. Fetch the existing post data
  const { data: postData, isLoading, isError } = useQuery<IPost>({
    queryKey: ['post', postId],
    queryFn: () => fetchPost(postId),
    enabled: !!postId, // Only run query if postId exists
  });

  // 2. Pre-fill the form once data is fetched
  useEffect(() => {
    if (postData) {
      setTitle(postData.title);
      setContent(postData.content);
      setStatus(postData.status);
    }
  }, [postData]);

  // 3. Mutation to update the post
  const updatePostMutation = useMutation({
    mutationFn: (updatedPost: { title: string; content: string; status: string; }) => {
      return axios.put(`/api/posts/${postId}`, updatedPost);
    },
    onSuccess: () => {
      toast.success('Post updated successfully!');
      router.push('/admin/news');
      router.refresh();
    },
    onError: (error: any) => {
      const errorMessage = error.response?.data?.error || 'Failed to update post.';
      toast.error(errorMessage);
    }
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!title.trim() || !content.trim()) {
        toast.error('Title and content cannot be empty.');
        return;
    }
    updatePostMutation.mutate({ title, content, status });
  };
  
  if (isLoading) return <p className="text-brand-muted">Loading post data...</p>;
  if (isError) return <p className="text-red-400">Failed to load post data.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Edit Post</h1>
        <Link href="/admin/news" className="text-sm text-brand-muted hover:text-white">
          ← Back to News List
        </Link>
      </div>

      <form onSubmit={handleSubmit} className="bg-brand-secondary p-6 rounded-lg space-y-6">
        {/* Title Field */}
        <div>
          <label htmlFor="title" className="block text-sm font-medium text-brand-light mb-2">Title</label>
          <input id="title" type="text" value={title} onChange={(e) => setTitle(e.target.value)} className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple" required/>
        </div>
        
        {/* Content Field (Rich Text Editor) */}
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">Content</label>
          {/* We must wait for content to be loaded before rendering the editor */}
          {content && <RichTextEditor value={content} onChange={setContent} />}
        </div>

        {/* Status Field */}
        <div>
          <label htmlFor="status" className="block text-sm font-medium text-brand-light mb-2">Status</label>
          <select id="status" value={status} onChange={(e) => setStatus(e.target.value as 'draft' | 'published')} className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple">
            <option value="draft">Draft</option>
            <option value="published">Published</option>
          </select>
        </div>

        {/* Action Buttons */}
        <div className="flex justify-end gap-4">
          <Link href="/admin/news" className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 transition-opacity">Cancel</Link>
          <button type="submit" disabled={updatePostMutation.isPending} className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 transition-opacity disabled:opacity-50 disabled:cursor-not-allowed">
            {updatePostMutation.isPending ? 'Saving...' : 'Save Changes'}
          </button>
        </div>
      </form>
    </div>
  );
}

// ===== src\app\admin\news\page.tsx =====
"use client";

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'axios';
import Link from '@/components/StyledLink'; 
import { PlusCircle, Edit, Trash2 } from 'lucide-react';
import { format } from 'date-fns';
import { IPost } from '@/models/Post';
import toast from 'react-hot-toast'; 

// Fetcher function
const fetchPosts = async (): Promise<IPost[]> => {
    const { data } = await axios.get('/api/posts');
    return data;
};

export default function AdminNewsPage() {
    const queryClient = useQueryClient();

    const { data: posts, isLoading, error } = useQuery<IPost[]>({
        queryKey: ['adminPosts'],
        queryFn: fetchPosts,
    });

        const deleteMutation = useMutation({
        mutationFn: (postId: string) => axios.delete(`/api/posts/${postId}`),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['adminPosts'] });
            // BEFORE: alert('Post deleted!');
            toast.success('Post deleted successfully!'); //
        },
        onError: (error: any) => {
            // BEFORE: alert('Error deleting post.');
            const message = error.response?.data?.message || 'Error deleting post.';
            toast.error(message); //
        }
    });

    const handleDelete = (postId: string) => {
        if (window.confirm('Are you sure you want to delete this post?')) {
            deleteMutation.mutate(postId);
        }
    };

    if (isLoading) return <p className="text-brand-muted">Loading posts...</p>;
    if (error) return <p className="text-red-400">Failed to load posts.</p>;

    return (
        <div>
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-3xl font-bold text-white">Manage News</h1>
                <Link href="/admin/news/create" className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 transition-opacity">
                    <PlusCircle size={20} />
                    <span>New Post</span>
                </Link>
            </div>
            
            <div className="bg-brand-secondary rounded-lg overflow-hidden">
                <table className="w-full text-left text-brand-light">
                    <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
                        <tr>
                            <th className="p-4">Title</th>
                            <th className="p-4">Status</th>
                            <th className="p-4">Created At</th>
                            <th className="p-4">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {posts?.map(post => (
                            <tr key={post._id as string} className="border-t border-gray-700/50">
                                <td className="p-4 font-medium">{post.title}</td>
                                <td className="p-4">
                                    <span className={`px-2 py-1 text-xs font-semibold rounded-full ${post.status === 'published' ? 'bg-green-500/20 text-green-400' : 'bg-yellow-500/20 text-yellow-400'}`}>
                                        {post.status}
                                    </span>
                                </td>
                                <td className="p-4 text-brand-muted">{format(new Date(post.createdAt), 'dd MMM yyyy')}</td>
                                <td className="p-4 flex gap-3">
                                    <Link href={`/admin/news/edit/${post._id}`} className="text-blue-400 hover:text-blue-300"><Edit size={18} /></Link>
                                    <button onClick={() => handleDelete(post._id as string)} className="text-red-400 hover:text-red-300"><Trash2 size={18} /></button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </div>
    );
}

// ===== src\app\api\active-leagues\route.ts =====
// src/app/api/active-leagues/route.ts
import { NextResponse } from "next/server";
import axios from "axios";
import { format, addDays } from "date-fns";

// A curated list of leagues to check for activity.
// Checking EVERY single league would be too slow and hit API rate limits.
// This list should contain leagues you generally expect to be active.
const LEAGUES_TO_CHECK = [
  39,
  140,
  135,
  78,
  61,
  2,
  3,
  88,
  94,
  253,
  45,
  48,
  71,
  62,
  144,
  203,
  197,
  218, // Premier League, La Liga, Serie A, Bundesliga, Ligue 1, UCL, UEL, Eredivisie, etc.
];

export async function GET() {
  const today = format(new Date(), "yyyy-MM-dd");
  const nextSevenDays = format(addDays(new Date(), 7), "yyyy-MM-dd");

  const options = (leagueId: number) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: {
      league: leagueId,
      season: new Date().getFullYear().toString(),
      from: today,
      to: nextSevenDays,
    },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    // Create an array of promises, one for each league check
    const fixtureChecks = LEAGUES_TO_CHECK.map((id) =>
      axios.request(options(id)).then((response) => ({
        leagueId: id,
        hasFixtures: response.data.results > 0,
      }))
    );

    // Execute all checks in parallel
    const results = await Promise.allSettled(fixtureChecks);

    // Filter out failed requests and leagues with no fixtures
    const activeLeagueIds = results
      .filter(
        (result) => result.status === "fulfilled" && result.value.hasFixtures
      )
      .map(
        (result) =>
          (result as PromiseFulfilledResult<{ leagueId: number }>).value
            .leagueId
      );

    return NextResponse.json(activeLeagueIds);
  } catch (error) {
    console.error("Error fetching active leagues:", error);
    return NextResponse.json(
      { error: "Failed to determine active leagues." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\auth\[...nextauth]\route.ts =====
// src/app/api/auth/[...nextauth]/route.ts

import NextAuth, { NextAuthOptions } from "next-auth";
// --- Adapter Imports ---
import { MongoDBAdapter } from "@auth/mongodb-adapter";
import clientPromise from "@/lib/mongoClient";

// --- Provider Imports ---
import GoogleProvider from "next-auth/providers/google";
import CredentialsProvider from "next-auth/providers/credentials";

// --- Mongoose Imports (for Credentials Provider) ---
import dbConnect from "@/lib/dbConnect";
import User, { IUser } from "@/models/User"; // <-- Import IUser
import bcrypt from "bcrypt";

export const authOptions: NextAuthOptions = {
  adapter: MongoDBAdapter(clientPromise),

  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
    CredentialsProvider({
      name: 'Credentials',
      credentials: { },
      async authorize(credentials: any) {
        if (!credentials?.email || !credentials.password) {
          throw new Error('Please enter an email and password');
        }
        
        await dbConnect(); 
        
        const user = await User.findOne({ email: credentials.email }).select('+password');
        
        if (!user || !user.password) {
          throw new Error('Invalid credentials');
        }

        const isPasswordCorrect = await bcrypt.compare(
          credentials.password,
          user.password
        );

        if (!isPasswordCorrect) {
          throw new Error('Invalid credentials');
        }

        // Return the full user object on success
        return user;
      }
    })
  ],
  
  session: { strategy: "jwt" },

  // --- THIS IS THE NEW/UPDATED PART ---
  callbacks: {
    // This callback is called whenever a JWT is created or updated.
    // We want to add the user's role and ID to the token.
    jwt: async ({ token, user }) => {
      if (user) {
        const u = user as IUser; // Cast to our user type
        token.role = u.role;
        token.id = u.id;
      }
      return token;
    },

    // This callback is called whenever a session is checked.
    // We want to add the role and ID from the token to the session object.
    session: async ({ session, token }) => {
      if (session?.user) {
        session.user.role = token.role as 'user' | 'admin';
        session.user.id = token.id as string;
      }
      return session;
    },
  },
  // --- END OF NEW/UPDATED PART ---

  pages: { signIn: "/login" },
  secret: process.env.NEXT_PUBLIC_NEXTAUTH_SECRET,
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };

// ===== src\app\api\banners\route.ts =====
// src/app/api/banners/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Banner, { IBanner } from "@/models/Banner";

// GET handler remains the same...
export async function GET(request: Request) {
  // ... no changes here
  const { searchParams } = new URL(request.url);
  const activeOnly = searchParams.get("active") === "true";
  const location = searchParams.get("location");

  const query: { isActive?: boolean; location?: string } = {};
  if (activeOnly) {
    query.isActive = true;
  }
  if (location) {
    query.location = location;
  }

  try {
    await dbConnect();
    const banners = await Banner.find(query).sort({ createdAt: -1 });
    return NextResponse.json(banners);
  } catch (error) {
    console.error("Failed to fetch banners:", error);
    return NextResponse.json(
      { error: "Server error fetching banners" },
      { status: 500 }
    );
  }
}

// --- POST a New Banner ---
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body: Partial<IBanner> = await request.json();

    console.log(
      "[API/Banners] Received POST request with body:",
      JSON.stringify(body, null, 2)
    );

    const { title, imageUrl, linkUrl, isActive, location } = body;

    if (!title || !imageUrl || !linkUrl || !location) {
      console.error(
        "[API/Banners] Validation failed. Missing required fields."
      );
      return NextResponse.json(
        { error: "Title, Image URL, Link URL, and Location are required" },
        { status: 400 }
      );
    }

    await dbConnect();

    // Mongoose will now correctly use the schema that includes 'location'
    const newBanner = new Banner({
      title,
      imageUrl,
      linkUrl,
      isActive,
      location,
    });

    await newBanner.save(); // This would throw an error if location was missing and the schema was loaded correctly
    console.log("[API/Banners] New banner created successfully:", newBanner);
    return NextResponse.json(newBanner, { status: 201 });
  } catch (error: any) {
    console.error("[API/Banners] Failed to create banner:", error.message);
    return NextResponse.json(
      { error: "Server error creating banner" },
      { status: 500 }
    );
  }
}


// ===== src\app\api\banners\[bannerId]\route.ts =====
// src/app/api/banners/[bannerId]/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Banner, { IBanner } from "@/models/Banner";

interface Params {
  params: { bannerId: string };
}

// --- PUT (Update) a Banner ---
// Protected: Only admins can update.
export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { bannerId } = params;
  try {
    const body: Partial<IBanner> = await request.json();
    // --- THE FIX IS HERE ---
    // Destructure ALL fields from the body that you intend to update.
    const { title, imageUrl, linkUrl, isActive, location } = body;

    await dbConnect();

    const updatedBanner = await Banner.findByIdAndUpdate(
      bannerId,
      {
        // Pass an explicit object with all the fields to Mongoose.
        // This ensures 'location' is included in the update.
        title,
        imageUrl,
        linkUrl,
        isActive,
        location,
      },
      { new: true, runValidators: true }
    );

    if (!updatedBanner) {
      return NextResponse.json({ error: "Banner not found" }, { status: 404 });
    }

    return NextResponse.json(updatedBanner);
  } catch (error) {
    console.error("Error updating banner:", error);
    return NextResponse.json(
      { error: "Server error updating banner" },
      { status: 500 }
    );
  }
}

// --- DELETE a Banner ---
// (No changes needed for the DELETE handler)
export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { bannerId } = params;
  try {
    await dbConnect();
    const deletedBanner = await Banner.findByIdAndDelete(bannerId);
    if (!deletedBanner) {
      return NextResponse.json({ error: "Banner not found" }, { status: 404 });
    }
    return NextResponse.json({ message: "Banner deleted successfully" });
  } catch (error) {
    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}


// ===== src\app\api\countries\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';
import { Country } from '@/types/api-football'; // We will define this type

// This function handles GET requests to /api/countries
export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/countries`,
    headers: {
      // Securely read API key and host from environment variables
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };


  try {
    const response = await axios.request(options);

    // --- Data Transformation ---
    // We will clean and simplify the data before sending it to the frontend.
    const transformedCountries: Country[] = response.data.response
      // 1. Filter out any countries that are missing essential data
      .filter((country: any) => country.name && country.code && country.flag)
      // 2. Map the raw data to our clean, simplified `Country` type
      .map((country: any) => ({
        name: country.name,
        code: country.code,
        flagUrl: country.flag,
      }));

    // 3. Sort the countries alphabetically for a better user experience
    transformedCountries.sort((a, b) => a.name.localeCompare(b.name));
    

    return NextResponse.json(transformedCountries);

  } catch (error) {
    console.error("Error fetching countries:", error);
    return NextResponse.json(
      { error: 'Failed to fetch country data.' },
      { status: 500 }
    );
  }
}

// ===== src\app\api\country-stats\route.ts =====
// src/app/api/country-stats/route.ts
import { NextResponse } from "next/server";
import axios from "axios";

// A curated list of popular league IDs to source teams from.
const POPULAR_LEAGUE_IDS = [
  39, 140, 135, 78, 61, 88, 94, 253, 2, 3, 45, 48, 71, 62, 144, 203, 197, 218,
];
const season = new Date().getFullYear();

export async function GET() {
  const options = (leagueId: number) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
    params: { league: leagueId, season: season },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    const teamPromises = POPULAR_LEAGUE_IDS.map((id) =>
      axios.request(options(id))
    );
    const responses = await Promise.allSettled(teamPromises);

    const allTeamsResponses = responses
      .filter(
        (result) => result.status === "fulfilled" && result.value.data.response
      )
      .flatMap(
        (result) => (result as PromiseFulfilledResult<any>).value.data.response
      );

    // --- THIS IS THE FIX ---
    // 1. De-duplicate the teams first using a Map based on the unique team ID.
    // This ensures that a team like "Manchester City" which is in both the Premier League (39)
    // and the Champions League (2) is only processed once.
    const uniqueTeams = Array.from(
      new Map(allTeamsResponses.map((item) => [item.team.id, item])).values()
    );

    // 2. Now, count the de-duplicated teams.
    const countryTeamCounts: { [key: string]: number } = {};
    uniqueTeams.forEach((item) => {
      const countryName = item.team.country;
      if (countryName) {
        if (!countryTeamCounts[countryName]) {
          countryTeamCounts[countryName] = 0;
        }
        countryTeamCounts[countryName]++;
      }
    });

    return NextResponse.json(countryTeamCounts);
  } catch (error) {
    console.error("Error fetching country stats:", error);
    return NextResponse.json(
      { error: "Failed to fetch country statistics." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\directory\countries\route.ts =====
// src/app/api/directory/countries/route.ts
import { NextResponse, NextRequest } from "next/server"; // Import NextRequest
import axios from "axios";

// The GET function now accepts the 'request' object
export async function GET(request: NextRequest) {
  try {
    // --- THIS IS THE FIX ---
    // 1. Get the protocol (http or https) and host (localhost:3000 or your domain)
    //    from the incoming request headers. This is the most reliable method.
    const protocol = request.headers.get("x-forwarded-proto") || "http";
    const host = request.headers.get("host");

    // 2. Construct the absolute URL for the internal API call.
    const internalApiUrl = `${protocol}://${host}/api/leagues?fetchAll=true`;

    // 3. Make the internal API call using the constructed URL.
    const leaguesResponse = await axios.get(internalApiUrl);
    const allLeagues = leaguesResponse.data;

    if (!allLeagues || allLeagues.length === 0) {
      return NextResponse.json([]);
    }

    const leagueCounts: { [key: string]: number } = {};
    allLeagues.forEach((league: any) => {
      if (league.countryName) {
        leagueCounts[league.countryName] =
          (leagueCounts[league.countryName] || 0) + 1;
      }
    });

    const countriesResponse = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/countries`,
      {
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );

    const allCountries = countriesResponse.data.response;

    let enrichedCountries = allCountries
      .map((country: any) => ({
        name: country.name,
        code: country.code,
        flagUrl: country.flag,
        leagueCount: leagueCounts[country.name] || 0,
      }))
      .filter(
        (country: any) =>
          country.leagueCount > 0 &&
          country.name &&
          country.code &&
          country.flagUrl
      );

    enrichedCountries.sort((a, b) => a.name.localeCompare(b.name));

    return NextResponse.json(enrichedCountries);
  } catch (error) {
    console.error("Error building country directory from all leagues:", error);
    if (axios.isAxiosError(error)) {
      console.error("Axios error details:", error.response?.data);
    }
    return NextResponse.json(
      { error: "Failed to build country directory." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\directory\teams\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';

// A curated list of popular league IDs to source teams from.
const POPULAR_LEAGUE_IDS = [
  39,  // England - Premier League
  140, // Spain - La Liga
  135, // Italy - Serie A
  78,  // Germany - Bundesliga
  61,  // France - Ligue 1
  88,  // Netherlands - Eredivisie
  94,  // Portugal - Primeira Liga
  253, // USA - MLS
  2,   // UEFA Champions League
];

const season = new Date().getFullYear();

// This function handles GET requests to /api/directory/teams
export async function GET() {
  const options = (leagueId: number) => ({
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
    params: { league: leagueId, season: season },
    headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    // 1. Fetch all teams from all popular leagues in parallel
    const teamPromises = POPULAR_LEAGUE_IDS.map(id => axios.request(options(id)));
    const responses = await Promise.allSettled(teamPromises);

    // 2. Aggregate all teams and filter out any failed requests
    const allTeamsResponses = responses
      .filter(result => result.status === 'fulfilled')
      .flatMap(result => (result as PromiseFulfilledResult<any>).value.data.response);

    // 3. De-duplicate the teams using a Map (a team can be in a league and a cup)
    const uniqueTeams = Array.from(new Map(allTeamsResponses.map(item => [item.team.id, item])).values());

    // 4. Sort the final list alphabetically for a better user experience
    uniqueTeams.sort((a, b) => a.team.name.localeCompare(b.team.name));
    
    return NextResponse.json(uniqueTeams);

  } catch (error) {
    console.error("Error fetching teams for directory:", error);
    return NextResponse.json(
      { error: 'Failed to fetch teams data.' },
      { status: 500 }
    );
  }
}

// ===== src\app\api\find-live-matches\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';

// This function handles GET requests to /api/live-matches
export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: { live: 'all' },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    // Directly return the array of live fixtures
    
    return NextResponse.json(response.data.response);
  } catch (error) {
    console.error("Error fetching live matches:", error);
    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src\app\api\fixtures\route.ts =====
import { NextResponse } from "next/server";
import axios from "axios";
import { format, addDays } from "date-fns";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get("league");
  const date = searchParams.get("date");
  const season = searchParams.get("season");

  // Base options for axios requests
  const axiosOptions = (params: object) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params,
    headers: {
      "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  });

  try {
    // --- PATTERN 1: Get all fixtures for a specific LEAGUE and SEASON ---
    // Used by the new "Season View" in the LeagueFixturesTab.
    if (leagueId && season) {
      console.log(
        `API: Fetching all fixtures for league ${leagueId}, season ${season}`
      );
      const response = await axios.request(
        axiosOptions({
          league: leagueId,
          season: season,
        })
      );
      // Sort matches by date, as the API might not return them in chronological order
      const sortedMatches = response.data.response.sort(
        (a: any, b: any) =>
          new Date(a.fixture.date).getTime() -
          new Date(b.fixture.date).getTime()
      );
      return NextResponse.json(sortedMatches);
    }

    // --- PATTERN 2: Get all fixtures for a specific LEAGUE and DATE ---
    // Used by the original day-by-day fixtures tab.
    if (leagueId && date) {
      console.log(
        `API: Fetching fixtures for league ${leagueId}, date ${date}`
      );
      const response = await axios.request(
        axiosOptions({
          league: leagueId,
          season: new Date(date).getFullYear().toString(), // Use the year from the date for the season
          date: date,
        })
      );
      return NextResponse.json(response.data.response);
    }

    // --- PATTERN 3: Get upcoming matches for a specific LEAGUE ---
    // Used by the homepage slider when a league is selected.
    if (leagueId) {
      console.log(`API: Fetching upcoming fixtures for league ${leagueId}`);
      const today = format(new Date(), "yyyy-MM-dd");
      const nextSevenDays = format(addDays(new Date(), 7), "yyyy-MM-dd");
      const response = await axios.request(
        axiosOptions({
          league: leagueId,
          season: new Date().getFullYear().toString(),
          from: today,
          to: nextSevenDays,
        })
      );
      return NextResponse.json(response.data.response);
    }

    // --- PATTERN 4: Get GLOBAL matches (live, today, tomorrow) if no league is specified ---
    // This is the default for the homepage.
    if (!leagueId) {
      // If a specific date is provided for the global view, use it.
      if (date) {
        console.log(`API: Fetching global fixtures for date ${date}`);
        const response = await axios.request(axiosOptions({ date: date }));
        return NextResponse.json(response.data.response);
      }

      // Fallback to the original "live, today, tomorrow" logic if no date is provided.
      console.log("API: Fetching global matches (live, today, tomorrow)");
      const todayStr = format(new Date(), "yyyy-MM-dd");
      const tomorrowStr = format(addDays(new Date(), 1), "yyyy-MM-dd");

      const [liveResponse, todayResponse, tomorrowResponse] = await Promise.all(
        [
          axios.request(axiosOptions({ live: "all" })),
          axios.request(axiosOptions({ date: todayStr })),
          axios.request(axiosOptions({ date: tomorrowStr })),
        ]
      );

      const allMatches = [
        ...liveResponse.data.response,
        ...todayResponse.data.response,
        ...tomorrowResponse.data.response,
      ];

      const uniqueMatches = Array.from(
        new Map(allMatches.map((m) => [m.fixture.id, m])).values()
      );
      return NextResponse.json(uniqueMatches);
    }

    return NextResponse.json([]);
  } catch (error) {
    console.error("Error in /api/fixtures:", error);
    return NextResponse.json(
      { error: "Failed to fetch fixture data." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\global-live\route.ts =====
// src/app/api/global-live/route.ts
import { NextResponse } from 'next/server';
import axios from 'axios';

// This function handles GET requests to /api/global-live
export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    // The key is to use the `live: 'all'` parameter
    params: { live: 'all' },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    // Directly return the array of live fixtures
    return NextResponse.json(response.data.response);
  } catch (error) {
    console.error("Error fetching global live matches:", error);
    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src\app\api\image-proxy\route.ts =====
// src/app/api/image-proxy/route.ts

import { NextRequest, NextResponse } from "next/server";
import axios from "axios";

// --- SECURITY: A whitelist of allowed domains to prevent abuse ---
// This ensures our proxy can only be used to fetch images from trusted sources.
const ALLOWED_DOMAINS = [
  "media.api-sports.io",
  // Add other trusted image source domains here if needed in the future
];

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const imageUrl = searchParams.get("url");

  // 1. Validate input
  if (!imageUrl) {
    return NextResponse.json(
      { error: "Image URL is required" },
      { status: 400 }
    );
  }

  // 2. Security Check: Ensure the requested URL is from an allowed domain
  try {
    const urlObject = new URL(imageUrl);
    if (!ALLOWED_DOMAINS.includes(urlObject.hostname)) {
      return NextResponse.json(
        { error: "Domain not allowed" },
        { status: 403 }
      );
    }
  } catch (error) {
    return NextResponse.json({ error: "Invalid URL format" }, { status: 400 });
  }

  try {
    // 3. Fetch the image from the external source
    const response = await axios.get(imageUrl, {
      responseType: "arraybuffer", // Fetch as raw data
    });

    const imageBuffer = Buffer.from(response.data, "binary");
    const contentType = response.headers["content-type"] || "image/png";

    // 4. Return the image with our custom, strong caching headers
    return new NextResponse(imageBuffer, {
      status: 200,
      headers: {
        "Content-Type": contentType,
        // Cache for 7 days, immutable means the browser won't even check for updates
        "Cache-Control": "public, max-age=604800, immutable",
      },
    });
  } catch (error) {
    console.error(`[Image Proxy] Failed to fetch ${imageUrl}:`, error);
    // You could return a placeholder image here if you wanted
    return NextResponse.json(
      { error: "Failed to fetch image" },
      { status: 502 }
    ); // 502 Bad Gateway
  }
}


// ===== src\app\api\leagues\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';
import { League } from '@/types/api-football';
import { generateLeagueSlug } from '@/lib/generate-league-slug';

// --- DEFINE CURATED LISTS OF POPULAR COMPETITIONS ---
// This is a list of well-known league IDs used for the sidebar's default view.
const POPULAR_LEAGUE_IDS = new Set([
  39,  // England - Premier League
  140, // Spain - La Liga
  135, // Italy - Serie A
  78,  // Germany - Bundesliga
  61,  // France - Ligue 1
  88,  // Netherlands - Eredivisie
  94,  // Portugal - Primeira Liga
  253, // USA - MLS
  203, // Turkey - Süper Lig
]);

const POPULAR_CUP_IDS = new Set([
  2,   // UEFA Champions League
  3,   // UEFA Europa League
  531, // UEFA Conference League
  45,  // England - FA Cup
  9,   // Copa Libertadores
  11,  // Copa Sudamericana
]);

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const country = searchParams.get('country');
  const type = searchParams.get('type'); // Can be 'league' or 'cup'
  const fetchAll = searchParams.get('fetchAll'); // <-- NEW PARAMETER

  const params: { current: string; country?: string, type?: string } = {
    current: 'true',
  };

  if (country) {
    params.country = country;
  }
  if (type) {
    params.type = type;
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/leagues`,
    params: params, 
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    let allLeagues = response.data.response;

    // --- UPDATED FILTERING LOGIC ---
    // If we are on the global view (no country selected) AND we are NOT fetching for a directory page,
    // then filter the results to only show popular competitions.
    if (!country && !fetchAll) {
      const popularIds = type === 'cup' ? POPULAR_CUP_IDS : POPULAR_LEAGUE_IDS;
      allLeagues = allLeagues.filter((item: any) => popularIds.has(item.league.id));
    }
    
    // Perform data transformation for all cases
    const transformedData: League[] = allLeagues
      .filter((item: any) => item.league.id && item.league.name && item.league.logo)
      .map((item: any) => ({
        id: item.league.id,
        name: item.league.name,
        logoUrl: item.league.logo,
        countryName: item.country.name,
        countryFlagUrl: item.country.flag,
        type: item.league.type,    
        href: generateLeagueSlug(item.league.name, item.league.id),
      }));
    
    // Sort the results alphabetically for a consistent order
    transformedData.sort((a, b) => a.name.localeCompare(b.name));

    return NextResponse.json(transformedData);

  } catch (error) {
    console.error("Error fetching leagues:", error);
    return NextResponse.json(
      { error: 'Failed to fetch league data.' },
      { status: 500 }
    );
  }
}

// ===== src\app\api\live-matches\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');

  if (!leagueId) {
    return NextResponse.json({ error: 'League ID is required' }, { status: 400 });
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: {
      league: leagueId,
      live: 'all',
    },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    // Directly return the response data, which is an array of live fixtures
    return NextResponse.json(response.data.response);
  } catch (error) {
    console.error("Error fetching live matches:", error);
    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src\app\api\live-odds\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';

/**
 * API route to fetch LIVE odds for all currently live matches.
 * This is a bulk fetch operation. It returns a map-like object
 * where keys are fixture IDs and values are the odds for that match.
 * This is far more efficient than fetching odds for each live match individually.
 */
export async function GET() {
    // Configure the request to the external API.
    // We are optimizing by only asking for the "Match Winner" bet type (id: 1).
    const options = {
        method: 'GET',
        url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds/live`,
        params: { bet: '1' }, 
        headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    };

    try {
        const response = await axios.request(options);

        // If the external API returns no live odds, we successfully found that out.
        // Return a 200 OK status with an empty object.
        if (!response.data.response || response.data.response.length === 0) {
            return NextResponse.json({}, { status: 200 });
        }

        // Transform the array response into a more efficient key-value object (a map).
        // This allows our frontend to look up odds by fixture ID in O(1) time.
        // The final object will look like: { "12345": { home: "1.50", ... }, "67890": { ... } }
        const liveOddsObject = response.data.response.reduce((acc: any, fixtureData: any) => {
            const fixtureId = fixtureData.fixture.id;
            const bookmaker = fixtureData.bookmakers?.[0]; // Get the first available bookmaker
            const matchWinnerBet = bookmaker?.bets.find((bet: any) => bet.id === 1);

            // Ensure we found a valid "Match Winner" bet
            if (matchWinnerBet) {
                const odds = matchWinnerBet.values.reduce((oddAcc: any, curr: any) => {
                    if (curr.value === 'Home') oddAcc.home = curr.odd;
                    if (curr.value === 'Draw') oddAcc.draw = curr.odd;
                    if (curr.value === 'Away') oddAcc.away = curr.odd;
                    return oddAcc;
                }, {});
                acc[fixtureId] = odds;
            }
            return acc;
        }, {});

        // Return the successfully transformed odds object.
        return NextResponse.json(liveOddsObject, { status: 200 });

    } catch (error) {
        console.error('[API/LIVE-ODDS] Error fetching live odds:', error);
        return NextResponse.json(
            { error: 'Failed to fetch live odds data from the provider.' },
            { status: 500 }
        );
    }
}

// ===== src\app\api\live-odds-by-fixture\route.ts =====
// src/app/api/live-odds-by-fixture/route.ts
import { NextResponse } from "next/server";
import axios from "axios";

// --- Data Transformation Helper ---
// This function finds a specific bet type by its ID and extracts the main odds.
const extractMainOdds = (odds: any[], betId: number, valueKeys: string[]) => {
  const betData = odds.find((o) => o.id === betId);
  if (!betData) return null;

  // Prefer the 'main' market if available, otherwise take the first valid one.
  let targetValues = betData.values.find((v: any) => v.main === true)
    ? betData.values.filter((v: any) => v.main === true)
    : betData.values;

  const result: { [key: string]: string | null } = {};
  valueKeys.forEach((key) => {
    result[key.toLowerCase()] =
      targetValues.find((v: any) => v.value === key)?.odd || null;
  });

  // Also extract the handicap if present
  result.handicap = targetValues[0]?.handicap || null;

  // Check if we found any valid odds
  const hasValues = Object.values(result).some(
    (v) => v !== null && v !== undefined
  );
  return hasValues ? result : null;
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get("fixture");

  if (!fixtureId) {
    return NextResponse.json(
      { error: "Fixture ID is required" },
      { status: 400 }
    );
  }

  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds/live`,
    params: { fixture: fixtureId },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };

  try {
    const response = await axios.request(options);
    const liveData = response.data.response[0];

    if (!liveData || !liveData.odds) {
      return NextResponse.json(null); // Return null if no live odds are available
    }

    const odds = liveData.odds;

    // Curate and simplify the data before sending to the frontend
    const curatedOdds = {
      asianHandicap: extractMainOdds(odds, 33, ["Home", "Away"]),
      overUnder: extractMainOdds(odds, 36, ["Over", "Under"]),
      matchCorners: extractMainOdds(odds, 20, ["Over", "Under"]),
      nextGoal: extractMainOdds(odds, 85, ["1", "No goal", "2"]),
    };

    return NextResponse.json(curatedOdds);
  } catch (error) {
    console.error(`Error fetching live odds for fixture ${fixtureId}:`, error);
    return NextResponse.json(
      { error: "Failed to fetch live odds" },
      { status: 500 }
    );
  }
}


// ===== src\app\api\match-details\route.ts =====
// src/app/api/match-details/route.ts

import { NextResponse } from "next/server";
import axios from "axios";

// ====================================================================
// --- FANSKOR PREDICTION ENGINE V2.1 ---
// Now robust against incomplete API data by using optional chaining.
// ====================================================================
const calculateCustomPrediction = (
  h2h: any[],
  homeTeamStats: any,
  awayTeamStats: any,
  homeTeamId: number,
  homeTeamRank: number | undefined,
  awayTeamRank: number | undefined
) => {
  // --- Configuration Object: All "magic numbers" are here for easy tuning ---
  const config = {
    weights: {
      homeAdvantage: 12, // Points for playing at home
      form: 1.5, // Multiplier for form points
      h2h: 2.5, // Points per H2H win
      rankDifference: 0.8, // Points per rank difference
      goalDifference: 6, // Multiplier for average goal difference
    },
    h2hMaxGames: 5, // Only consider the last 5 H2H games
    drawWeight: 0.85, // How heavily to factor in the possibility of a draw
  };

  // --- Data Validation: Exit early if necessary data is missing ---
  if (
    !homeTeamStats?.form ||
    !awayTeamStats?.form ||
    homeTeamRank == null ||
    awayTeamRank == null
  ) {
    return null;
  }

  let homeScore = 0;
  let awayScore = 0;

  // 1. Home Advantage
  homeScore += config.weights.homeAdvantage;

  // 2. Momentum (Recent Form)
  const calculateForm = (formString: string): number => {
    return (
      (formString.match(/W/g) || []).length * 3 +
      (formString.match(/D/g) || []).length * 1
    );
  };
  const homeFormString =
    homeTeamStats.fixtures.played.home > 0
      ? homeTeamStats.form
      : homeTeamStats.form.slice(-5);
  const awayFormString =
    awayTeamStats.fixtures.played.away > 0
      ? awayTeamStats.form
      : awayTeamStats.form.slice(-5);
  homeScore += calculateForm(homeFormString) * config.weights.form;
  awayScore += calculateForm(awayFormString) * config.weights.form;

  // 3. Goal Form (Safely accessed with optional chaining `?.` and nullish coalescing `?? 0`)
  const homeGoalsForAvg = homeTeamStats.goals?.for?.average?.total ?? 0;
  const homeGoalsAgainstAvg = homeTeamStats.goals?.against?.average?.total ?? 0;
  const awayGoalsForAvg = awayTeamStats.goals?.for?.average?.total ?? 0;
  const awayGoalsAgainstAvg = awayTeamStats.goals?.against?.average?.total ?? 0;

  const homeGoalDiff = homeGoalsForAvg - homeGoalsAgainstAvg;
  const awayGoalDiff = awayGoalsForAvg - awayGoalsAgainstAvg;
  homeScore += homeGoalDiff * config.weights.goalDifference;
  awayScore += awayGoalDiff * config.weights.goalDifference;

  // 4. Head-to-Head (H2H) Records
  if (h2h && h2h.length > 0) {
    h2h.slice(0, config.h2hMaxGames).forEach((match) => {
      if (match.teams.home.winner) {
        homeTeamId === match.teams.home.id
          ? (homeScore += config.weights.h2h)
          : (awayScore += config.weights.h2h);
      } else if (match.teams.away.winner) {
        homeTeamId === match.teams.away.id
          ? (homeScore += config.weights.h2h)
          : (awayScore += config.weights.h2h);
      } else {
        // It was a draw
        homeScore += config.weights.h2h / 2;
        awayScore += config.weights.h2h / 2;
      }
    });
  }

  // 5. League Rank Difference
  const rankDiff = Math.abs(homeTeamRank - awayTeamRank);
  if (homeTeamRank < awayTeamRank) {
    homeScore += rankDiff * config.weights.rankDifference;
  } else if (awayTeamRank < homeTeamRank) {
    awayScore += rankDiff * config.weights.rankDifference;
  }

  // --- Final Calculation & Normalization ---
  homeScore = Math.max(1, homeScore);
  awayScore = Math.max(1, awayScore);
  const drawScore =
    (homeScore + awayScore) *
    (1 - Math.abs(homeScore - awayScore) / (homeScore + awayScore)) *
    config.drawWeight;
  const totalPoints = homeScore + awayScore + drawScore;

  if (totalPoints === 0) {
    return { home: 33, draw: 34, away: 33 };
  }

  let homePercent = Math.round((homeScore / totalPoints) * 100);
  let awayPercent = Math.round((awayScore / totalPoints) * 100);
  let drawPercent = 100 - homePercent - awayPercent;

  if (drawPercent < 0) {
    drawPercent = 0;
    const remainder = 100 - (homePercent + awayPercent);
    if (homePercent > awayPercent) homePercent += remainder;
    else awayPercent += remainder;
  }

  return {
    home: homePercent,
    draw: drawPercent,
    away: awayPercent,
  };
};

// --- The main data fetching function ---
const fetchAllDataForFixture = async (fixtureId: string | number) => {
  const options = (endpoint: string, params: object) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  const fixtureResponse = await axios.request(
    options("fixtures", { id: fixtureId })
  );
  const fixtureData = fixtureResponse.data.response[0];

  if (!fixtureData) {
    throw new Error(`Fixture not found with ID: ${fixtureId}`);
  }

  const { league, teams } = fixtureData;
  const { home: homeTeam, away: awayTeam } = teams;

  const [
    eventsResponse,
    statsResponse,
    h2hResponse,
    predictionResponse,
    homeStatsResponse,
    awayStatsResponse,
    oddsResponse,
    standingsResponse,
  ] = await Promise.all([
    axios.request(options("fixtures/events", { fixture: fixtureId })),
    axios.request(options("fixtures/statistics", { fixture: fixtureId })),
    axios.request(
      options("fixtures/headtohead", { h2h: `${homeTeam.id}-${awayTeam.id}` })
    ),
    axios.request(options("predictions", { fixture: fixtureId })),
    axios.request(
      options("teams/statistics", {
        league: league.id,
        season: league.season,
        team: homeTeam.id,
      })
    ),
    axios.request(
      options("teams/statistics", {
        league: league.id,
        season: league.season,
        team: awayTeam.id,
      })
    ),
    axios.request(options("odds", { fixture: fixtureId, bet: "1" })),
    axios.request(
      options("standings", { league: league.id, season: league.season })
    ),
  ]);

  const standings =
    standingsResponse.data.response[0]?.league?.standings[0] || [];
  const homeTeamRank = standings.find(
    (s: any) => s.team.id === homeTeam.id
  )?.rank;
  const awayTeamRank = standings.find(
    (s: any) => s.team.id === awayTeam.id
  )?.rank;

  const customPrediction = calculateCustomPrediction(
    h2hResponse.data.response,
    homeStatsResponse.data.response,
    awayStatsResponse.data.response,
    homeTeam.id,
    homeTeamRank,
    awayTeamRank
  );

  return {
    fixture: fixtureData,
    events: eventsResponse.data.response,
    statistics: statsResponse.data.response,
    h2h: h2hResponse.data.response,
    analytics: {
      prediction: predictionResponse.data.response[0] ?? null,
      homeTeamStats: homeStatsResponse.data.response ?? null,
      awayTeamStats: awayStatsResponse.data.response ?? null,
      customPrediction: customPrediction,
      bookmakerOdds: oddsResponse.data.response[0]?.bookmakers ?? [],
    },
  };
};

// --- The GET handler that the frontend calls ---
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get("fixture");

  if (!fixtureId) {
    return NextResponse.json(
      { error: "Fixture ID is required" },
      { status: 400 }
    );
  }

  try {
    const matchDetails = await fetchAllDataForFixture(fixtureId);
    return NextResponse.json(matchDetails);
  } catch (error: any) {
    console.error(
      `[API /match-details] Error for fixture ${fixtureId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Failed to fetch match details." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\odds\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';

/**
 * API route to fetch pre-match odds for a specific fixture.
 * It is optimized to only request the "Match Winner" bet from a single, major bookmaker
 * to ensure a fast response and minimal data transfer.
 */
export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);
    const fixtureId = searchParams.get('fixture');

    // 1. Validate input: Ensure a fixture ID was provided.
    if (!fixtureId) {
        return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
    }

    // 2. Configure the optimized request to the external API.
    const options = {
        method: 'GET',
        url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds`,
        params: { 
            fixture: fixtureId, 
            bookmaker: '8', // A major, commonly available bookmaker (e.g., Bet365)
            bet: '1'        // The ID for the "Match Winner" bet (1X2)
        },
        headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    };

    try {
        // 3. Make the external API call.
        const response = await axios.request(options);
        
        // 4. Handle the "No Data" case gracefully.
        // If the external API has no odds, it's not an error. We successfully found that there's no data.
        // We return a 200 OK status with a null body to signal this to the frontend.
        if (!response.data.response || response.data.response.length === 0) {
            console.log(`No odds found for fixture ${fixtureId}. Returning null.`);
            return NextResponse.json(null, { status: 200 }); 
        }
        
        const bookmaker = response.data.response[0].bookmakers[0];
        
        const matchWinnerBet = bookmaker.bets.find((bet: any) => bet.id === 1);

        // Also handle the case where the bookmaker doesn't offer this specific bet type.
        if (!matchWinnerBet || !matchWinnerBet.values) {
            console.log(`"Match Winner" odds not available for fixture ${fixtureId}. Returning null.`);
            return NextResponse.json(null, { status: 200 });
        }

        // 5. Transform the data into a clean, simple object for the frontend.
        // The API returns an array, but the frontend just needs a { home, draw, away } object.
        const odds = matchWinnerBet.values.reduce((acc: any, curr: any) => {
            if (curr.value === 'Home') acc.home = curr.odd;
            if (curr.value === 'Draw') acc.draw = curr.odd;
            if (curr.value === 'Away') acc.away = curr.odd;
            return acc;
        }, {});
        
        // 6. Return the successfully transformed odds.
        return NextResponse.json(odds, { status: 200 });

    } catch (error) {
        // 7. Handle actual server or network errors.
        console.error(`[API/ODDS] Error fetching odds for fixture ${fixtureId}:`, error);
        return NextResponse.json(
            { error: 'Failed to fetch odds data from the provider.' }, 
            { status: 500 }
        );
    }
}

// ===== src\app\api\posts\route.ts =====
// src/app/api/posts/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post, { IPost } from "@/models/Post";
import slugify from "slugify";

// --- GET All Posts ---
// Publicly accessible, but can be filtered by status (e.g., for the public site)
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const status = searchParams.get("status");
  const limit = searchParams.get("limit");

  const query: { status?: string } = {};
  if (status) {
    query.status = status;
  }

  try {
    await dbConnect();
    let postsQuery = Post.find(query).sort({ createdAt: -1 });

    if (limit) {
      postsQuery = postsQuery.limit(parseInt(limit)); // <-- Apply the limit
    }

    const posts = await postsQuery;
    return NextResponse.json(posts);
  } catch (error) {
    console.error("Failed to fetch posts:", error);
    return NextResponse.json(
      { error: "Server error fetching posts" },
      { status: 500 }
    );
  }
}

// --- POST a New Post ---
// Protected: Only admins can create posts.
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body: Partial<IPost> = await request.json();
    const {
      title,
      content,
      status,
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle,
      featuredImageAltText,
    } = body;

    if (!title || !content) {
      return NextResponse.json(
        { error: "Title and content are required" },
        { status: 400 }
      );
    }

    await dbConnect();

    // Create a unique slug from the title
    const slug = slugify(title, { lower: true, strict: true });
    const slugExists = await Post.findOne({ slug });
    if (slugExists) {
      return NextResponse.json(
        {
          error: `A post with the slug '${slug}' already exists. Please use a different title.`,
        },
        { status: 409 }
      );
    }

    const newPost = new Post({
      title,
      content,
      status,
      slug,
      author: session.user.name || "Admin",
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle,
      featuredImageAltText,
    });

    await newPost.save();
    return NextResponse.json(newPost, { status: 201 });
  } catch (error) {
    console.error("Failed to create post:", error);
    return NextResponse.json(
      { error: "Server error creating post" },
      { status: 500 }
    );
  }
}


// ===== src\app\api\posts\[postId]\route.ts =====
// src/app/api/posts/[postId]/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import dbConnect from '@/lib/dbConnect';
import Post, { IPost } from '@/models/Post';

interface Params {
  params: { postId: string };
}

// --- GET a Single Post (by ID) ---
// Publicly accessible for the edit page pre-fill and potentially public view.
export async function GET(request: Request, { params }: Params) {
  const { postId } = params;
  try {
    await dbConnect();
    const post = await Post.findById(postId);
    if (!post) {
      return NextResponse.json({ error: 'Post not found' }, { status: 404 });
    }
    return NextResponse.json(post);
  } catch (error) {
    return NextResponse.json({ error: 'Server error' }, { status: 500 });
  }
}

// --- PUT (Update) a Post ---
// Protected: Only admins can update.
export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== 'admin') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const { postId } = params;
  try {
    const body: Partial<IPost> = await request.json();
    const { title, content, status, featuredImage, metaTitle, metaDescription, featuredImageTitle, featuredImageAltText } = body;
    
    await dbConnect();
    
    const updatedPost = await Post.findByIdAndUpdate(
        postId,
        { title, content, status },
        { new: true, runValidators: true }
    );
    
    if (!updatedPost) {
        return NextResponse.json({ error: 'Post not found' }, { status: 404 });
    }
    
    return NextResponse.json(updatedPost);
  } catch (error) {
    return NextResponse.json({ error: 'Server error updating post' }, { status: 500 });
  }
}

// --- DELETE a Post ---
// Protected: Only admins can delete.
export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== 'admin') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const { postId } = params;
  try {
    await dbConnect();
    const deletedPost = await Post.findByIdAndDelete(postId);
    if (!deletedPost) {
      return NextResponse.json({ error: 'Post not found' }, { status: 404 });
    }
    return NextResponse.json({ message: 'Post deleted successfully' });
  } catch (error) {
    return NextResponse.json({ error: 'Server error' }, { status: 500 });
  }
}

// ===== src\app\api\predictions\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get('fixture');

  if (!fixtureId) {
    return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/predictions`,
    params: { fixture: fixtureId },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    if (!response.data.response || response.data.response.length === 0) {
      return NextResponse.json({ error: 'No prediction available.' }, { status: 404 });
    }

    const predictionData = response.data.response[0];

    // --- THE FIX ---
    // We now extract and return the entire `teams` object from the prediction,
    // along with the percentages.
    const transformedPrediction = {
      teams: {
        home: {
          id: predictionData.teams.home.id,
          name: predictionData.teams.home.name,
          logo: predictionData.teams.home.logo, // <-- Pass the logo URL
        },
        away: {
          id: predictionData.teams.away.id,
          name: predictionData.teams.away.name,
          logo: predictionData.teams.away.logo, // <-- Pass the logo URL
        }
      },
      percent: {
        home: parseInt(predictionData.predictions.percent.home.replace('%', '')),
        draw: parseInt(predictionData.predictions.percent.draw.replace('%', '')),
        away: parseInt(predictionData.predictions.percent.away.replace('%', '')),
      }
    };

    return NextResponse.json(transformedPrediction);

  } catch (error) {
    console.error("Error fetching prediction:", error);
    return NextResponse.json({ error: 'Failed to fetch prediction data.' }, { status: 500 });
  }
}

// ===== src\app\api\sports\[sport]\fixtures\route.ts =====
import { NextResponse } from 'next/server';
import { getSportService } from '@/services/sports';

export async function GET(
  request: Request,
  { params }: { params: { sport: string } }
) {
  const { searchParams } = new URL(request.url);
  const sport = params.sport;
  
  // Convert searchParams to a plain object
  const queryParams: { [key: string]: any } = {};
  searchParams.forEach((value, key) => {
    queryParams[key] = value;
  });

  try {
    // 1. Get the correct service for the requested sport
    const sportService = getSportService(sport);
    
    // 2. Call the generic method
    const fixtures = await sportService.getFixtures(queryParams);

    // 3. Return the data
    return NextResponse.json(fixtures);

  } catch (error: any) {
    console.error(`[API /${sport}/fixtures] Error:`, error.message);
    return NextResponse.json(
      { error: `Failed to fetch fixture data for ${sport}.` },
      { status: 500 }
    );
  }
}

// ===== src\app\api\standings\route.ts =====
// src/app/api/standings/route.ts

import { NextResponse } from "next/server";
import axios from "axios";
import { generateLeagueSlug } from "@/lib/generate-league-slug"; // <-- IMPORT

// TeamStanding type definition remains the same
type TeamStanding = {
  rank: number;
  team: { id: number; name: string; logo: string };
  points: number;
  goalsDiff: number;
  all: { played: number; win: number; draw: number; lose: number };
  description: string | null;
  group: string; // <-- Make sure group is part of the type
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get("league");
  const season =
    searchParams.get("season") || new Date().getFullYear().toString();

  if (!leagueId) {
    return NextResponse.json(
      { error: "League ID is required" },
      { status: 400 }
    );
  }

  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/standings`,
    params: { league: leagueId, season: season },
    headers: {
      "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    if (!response.data.response || response.data.response.length === 0) {
      return NextResponse.json({ league: null, standings: [] });
    }

    const data = response.data.response[0];

    // --- ENHANCED TRANSFORMATION ---
    // We now add the href to the league info object
    const leagueInfo = {
      id: data.league.id,
      name: data.league.name,
      logo: data.league.logo,
      type: data.league.type, // Good to have for context
      href: generateLeagueSlug(data.league.name, data.league.id), // <-- ADD THE HREF
    };

    // Ensure we are selecting the correct standings array
    const standings: TeamStanding[][] = data.league.standings;

    return NextResponse.json({ league: leagueInfo, standings });
  } catch (error) {
    console.error("Error fetching standings:", error);
    return NextResponse.json(
      { error: "Failed to fetch standings data" },
      { status: 500 }
    );
  }
}


// ===== src\app\api\team-details\route.ts =====
// src/app/api/team-details/route.ts
import { NextResponse } from 'next/server';
import { fetchTeamDetails } from '@/lib/data/team'; // <-- IMPORT THE NEW FUNCTION

export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);
    const teamId = searchParams.get('team');

    if (!teamId) {
        return NextResponse.json({ error: 'Team ID is required' }, { status: 400 });
    }

    // Call the reusable function
    const teamData = await fetchTeamDetails(teamId);

    if (!teamData) {
        // This handles cases where the team isn't found or an error occurred in the lib function.
        return NextResponse.json({ error: 'Failed to fetch team details or team not found' }, { status: 500 });
    }

    return NextResponse.json(teamData);
}

// ===== src\app\api\team-trophies\route.ts =====
// src/app/api/team-trophies/route.ts
import { NextResponse } from "next/server";
import axios from "axios";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const teamId = searchParams.get("team");

  if (!teamId) {
    return NextResponse.json({ error: "Team ID is required" }, { status: 400 });
  }

  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/trophies`,
    params: { team: teamId },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };

  try {
    const response = await axios.request(options);
    // Sort trophies by season, newest first
    const sortedTrophies = response.data.response.sort((a: any, b: any) => {
      const seasonB = parseInt(b.season.split("-")[0]);
      const seasonA = parseInt(a.season.split("-")[0]);
      return seasonB - seasonA;
    });
    return NextResponse.json(sortedTrophies);
  } catch (error) {
    console.error("Error fetching team trophies:", error);
    return NextResponse.json(
      { error: "Failed to fetch trophies" },
      { status: 500 }
    );
  }
}


// ===== src\app\api\teams\route.ts =====
// src/app/api/teams/route.ts
import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');
  const season = searchParams.get('season');

  if (!leagueId || !season) {
    return NextResponse.json(
      { error: 'League ID and season are required' },
      { status: 400 }
    );
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
    params: {
      league: leagueId,
      season: season,
    },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    
    // The response is an array of objects, each containing a `team` and `venue` object.
    // We can pass it directly to the frontend.
    return NextResponse.json(response.data.response);

  } catch (error) {
    console.error("Error fetching teams:", error);
    return NextResponse.json(
      { error: 'Failed to fetch teams data.' },
      { status: 500 }
    );
  }
}

// ===== src\app\api\teams-by-country\route.ts =====
// src/app/api/teams-by-country/route.ts
import { NextResponse } from "next/server";
import axios from "axios";

const season = new Date().getFullYear();

// This is a reusable helper for making requests to the external API
const apiRequest = async (endpoint: string, params: object) => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };
  const response = await axios.request(options);
  return response.data.response;
};

// This function now returns both the list of teams AND the count
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const country = searchParams.get("country");

  if (!country) {
    return NextResponse.json(
      { error: "Country parameter is required" },
      { status: 400 }
    );
  }

  try {
    // 1. First, find all leagues for the specified country.
    const leagues = await apiRequest("leagues", { country: country });
    if (!leagues || leagues.length === 0) {
      // Return a structured response even if there are no teams
      return NextResponse.json({ teams: [], count: 0 });
    }

    const leagueIds = leagues.map((l: any) => l.league.id);

    // 2. Fetch all teams from all found leagues in parallel.
    const teamPromises = leagueIds.map((id: any) =>
      apiRequest("teams", { league: id, season: season })
    );
    const responses = await Promise.allSettled(teamPromises);

    // 3. Aggregate all teams from successful requests.
    const allTeamsResponses = responses
      .filter((result) => result.status === "fulfilled" && result.value)
      .flatMap((result) => (result as PromiseFulfilledResult<any>).value);

    // 4. De-duplicate the teams using a Map (very important).
    const uniqueTeams = Array.from(
      new Map(allTeamsResponses.map((item) => [item.team.id, item])).values()
    );

    // 5. Sort the final list alphabetically.
    uniqueTeams.sort((a, b) => a.team.name.localeCompare(b.team.name));

    // 6. Return the enhanced response object
    return NextResponse.json({
      teams: uniqueTeams,
      count: uniqueTeams.length, // The accurate count of unique teams
    });
  } catch (error) {
    console.error(`Error fetching teams for country "${country}":`, error);
    return NextResponse.json(
      { error: "Failed to fetch teams data for this country." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\top-scorers\route.ts =====
// src/app/api/top-scorers/route.ts

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');
  const season = searchParams.get('season');

  if (!leagueId || !season) {
    return NextResponse.json(
      { error: 'League ID and season are required' },
      { status: 400 }
    );
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/players/topscorers`,
    params: {
      league: leagueId,
      season: season,
    },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    
    // The API returns an array of players with their stats. We can pass it directly.
    return NextResponse.json(response.data.response);

  } catch (error) {
    console.error("Error fetching top scorers:", error);
    return NextResponse.json(
      { error: 'Failed to fetch top scorers data.' },
      { status: 500 }
    );
  }
}

// ===== src\app\api\upcoming-matches\route.ts =====
// src/app/api/upcoming-matches/route.ts
import { NextResponse } from 'next/server';
import axios from 'axios';
import { format, subDays, addDays } from 'date-fns';

// This is your existing API route for upcoming matches. Let's rename it
// to something more generic as it will now handle more than just "upcoming".
// The file path remains the same for backward compatibility.
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');

  if (!leagueId) {
    // If no leagueId, this route should do nothing or return an error.
    // Your global fetching is handled by the /api/fixtures route.
    return NextResponse.json({ error: 'League ID is required' }, { status: 400 });
  }

  const season = new Date().getFullYear().toString();
  const today = format(new Date(), 'yyyy-MM-dd');
  const nextSevenDays = format(addDays(new Date(), 7), 'yyyy-MM-dd');

  const options = (params: object) => ({
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params,
    headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    // --- 1. First, try to fetch UPCOMING matches ---
    const upcomingResponse = await axios.request(options({
      league: leagueId,
      season: season,
      from: today,
      to: nextSevenDays,
    }));
    
    let matches = upcomingResponse.data.response;

    // --- 2. If NO upcoming matches are found, fetch RECENT finished matches ---
    if (matches.length === 0) {
      console.log(`No upcoming matches for league ${leagueId}. Fetching recent results...`);
      const finishedResponse = await axios.request(options({
        league: leagueId,
        season: season,
        last: 5, // Get the last 5 finished fixtures
        status: 'FT', // Only get matches with a status of "Finished"
      }));
      matches = finishedResponse.data.response;
    }
    
    return NextResponse.json(matches);

  } catch (error) {
    console.error(`Error fetching matches for league ${leagueId}:`, error);
    return NextResponse.json({ error: 'Failed to fetch match data' }, { status: 500 });
  }
}

// ===== src\app\api\upload\route.ts =====
// src/app/api/upload/route.ts

import { NextResponse } from "next/server";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import sharp from "sharp";
import crypto from "crypto";

// --- S3 Client configuration remains the same ---
const s3Client = new S3Client({
  region: process.env.NEXT_PUBLIC_AWS_S3_REGION as string,
  credentials: {
    accessKeyId: process.env.NEXT_PUBLIC_AWS_ACCESS_KEY_ID as string,
    secretAccessKey: process.env.NEXT_PUBLIC_AWS_SECRET_ACCESS_KEY as string,
  },
});

const generateFileName = (bytes = 32) =>
  crypto.randomBytes(bytes).toString("hex");

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const formData = await request.formData();
    const file = formData.get("file") as File;
    const uploadType = formData.get("uploadType") as string | null;

    if (!file) {
      return NextResponse.json({ error: "No file provided." }, { status: 400 });
    }

    // --- NEW, MORE ROBUST LOGIC ---
    let finalBuffer: Buffer;
    let finalContentType: string = file.type; // Default to original file type
    const fileName = generateFileName();

    // Check if the file is a GIF and is intended for a banner slot.
    if (uploadType === "banner" && file.type === "image/gif") {
      // --- 1. GIF BANNER PATH ---
      // It's a GIF for a banner, so we bypass Sharp completely to preserve animation.
      console.log("GIF Banner detected. Bypassing image processing.");
      finalBuffer = Buffer.from(await file.arrayBuffer());
      // The contentType is already correctly set to 'image/gif'.
    } else {
      // --- 2. STANDARD IMAGE PROCESSING PATH ---
      // For all other images (JPG, PNG, or post images), we process them with Sharp.
      console.log("Standard image detected. Processing with Sharp.");
      const inputBuffer = Buffer.from(await file.arrayBuffer());
      let sharpInstance = sharp(inputBuffer);

      if (uploadType === "banner") {
        // For non-GIF banners, resize without cropping.
        sharpInstance = sharpInstance.resize(1200, 1200, {
          fit: "inside",
          withoutEnlargement: true,
        });
      } else {
        // For posts (default), resize with cropping.
        sharpInstance = sharpInstance.resize(1200, 630, { fit: "cover" });
      }

      // Convert the final processed image to WebP.
      finalBuffer = await sharpInstance.webp({ quality: 80 }).toBuffer();
      finalContentType = "image/webp"; // Update the content type for S3.
    }

    // --- UNIFIED UPLOAD TO S3 ---
    // This part now uses the dynamically determined buffer and content type.
    const bucketName = process.env.NEXT_PUBLIC_AWS_S3_BUCKET_NAME as string;

    const putObjectCommand = new PutObjectCommand({
      Bucket: bucketName,
      Key: fileName,
      Body: finalBuffer,
      ContentType: finalContentType, // Use the correct final content type
    });

    await s3Client.send(putObjectCommand);

    const publicUrl = `https://${bucketName}.s3.${process.env.NEXT_PUBLIC_AWS_S3_REGION}.amazonaws.com/${fileName}`;

    return NextResponse.json({
      message: "Image uploaded successfully",
      url: publicUrl,
    });
  } catch (error) {
    console.error("Error uploading to S3:", error);
    return NextResponse.json(
      { error: "Failed to upload image." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\votes\route.ts =====
import { NextResponse } from 'next/server';
import dbConnect from '@/lib/dbConnect';
import Vote from '@/models/Vote';

// --- GET Handler: Fetches vote counts for a fixture ---
export async function GET(request: Request) {
    console.log("requested here");
    
    const { searchParams } = new URL(request.url);
    const fixtureId = searchParams.get('fixture');

    if (!fixtureId) {
        return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
    }

    try {
        await dbConnect();
        const votes = await Vote.findOne({ fixtureId: Number(fixtureId) });
        console.log(votes);
        

        if (!votes) {
            // If no votes yet, return a default object
            return NextResponse.json({ homeVotes: 0, drawVotes: 0, awayVotes: 0 });
        }

        return NextResponse.json(votes);
    } catch (error) {
        console.log(error);
        
        return NextResponse.json({ error: 'Server error fetching votes' }, { status: 500 });
    }
}


// --- POST Handler: Submits a new vote ---
export async function POST(request: Request) {
    const { fixtureId, vote } = await request.json(); // vote should be 'home', 'draw', or 'away'

    if (!fixtureId || !['home', 'draw', 'away'].includes(vote)) {
        return NextResponse.json({ error: 'Valid fixtureId and vote type are required' }, { status: 400 });
    }
    
    try {
        await dbConnect();
        
        // Atomically find and update the document, or create it if it doesn't exist.
        // The $inc operator is crucial for preventing race conditions.
        const updatedVote = await Vote.findOneAndUpdate(
            { fixtureId: Number(fixtureId) },
            { $inc: { [`${vote}Votes`]: 1 } },
            { 
                upsert: true, // Create the document if it doesn't exist
                new: true     // Return the updated document
            }
        );

        return NextResponse.json(updatedVote);
    } catch (error) {
        return NextResponse.json({ error: 'Server error submitting vote' }, { status: 500 });
    }
}

// ===== src\app\football\league\[...slug]\page.tsx =====
// src/app/football/league/[...slug]/page.tsx
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import LeagueDetailView from "@/components/league-detail-view";
import axios from "axios";
import { notFound } from "next/navigation";

// Helper to extract the ID from the slug (e.g., "premier-league-39" -> "39")
const getLeagueIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

// The data fetching functions remain unchanged
async function getLeagueData(leagueId: string): Promise<any | null> {
  try {
    const { data } = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/leagues?id=${leagueId}`,
      {
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );

    if (!data.response || data.response.length === 0) {
      return null;
    }

    const leagueData = data.response[0];

    const standingsResponse = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/standings`,
      {
        params: { league: leagueId, season: new Date().getFullYear() },
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );

    leagueData.league.standings =
      standingsResponse.data.response[0]?.league?.standings || [];
    return leagueData;
  } catch (error) {
    console.error("Failed to fetch single league data:", error);
    return null;
  }
}

export async function generateMetadata({
  params,
}: {
  params: { slug: string[] };
}) {
  const slug = params.slug.join("/");
  const leagueId = getLeagueIdFromSlug(slug);
  if (!leagueId) return { title: "League Not Found" };

  const leagueData = await getLeagueData(leagueId);
  if (!leagueData) return { title: "League Not Found" };

  return {
    title: `${leagueData.league.name} - Info, Fixtures & Standings`,
    description: `All information about the ${leagueData.league.name}, including available seasons, fixtures, and full standings.`,
  };
}

// --- THE MAIN PAGE COMPONENT ---
export default async function LeaguePage({
  params,
}: {
  params: { slug: string[] };
}) {
  const slug = params.slug.join("/");
  const leagueId = getLeagueIdFromSlug(slug);

  if (!leagueId) {
    notFound();
  }

  const leagueData = await getLeagueData(leagueId);

  if (!leagueData) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <LeagueDetailView leagueData={leagueData} />
        </main>
      </div>
    </div>
  );
}


// ===== src\app\football\leagues\page.tsx =====
// src/app/football/leagues/page.tsx
"use client";

import { useState, useMemo, useEffect } from "react";
import { useQueries } from "@tanstack/react-query";
import axios from "axios";
import { League } from "@/types/api-football";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import DirectoryCard, {
  DirectoryCardSkeleton,
} from "@/components/DirectoryCard";
import Pagination from "@/components/Pagination";

export const dynamic = "force-dynamic";

const ITEMS_PER_PAGE = 15;

// Fetcher function for all leagues
const fetchAllLeagues = async (): Promise<League[]> => {
  const { data } = await axios.get("/api/leagues?fetchAll=true");
  return data;
};

// Fetcher function for the IDs of currently active leagues
const fetchActiveLeagueIds = async (): Promise<number[]> => {
  const { data } = await axios.get("/api/active-leagues");
  return data;
};

export default function LeaguesPage() {
  const [searchTerm, setSearchTerm] = useState("");
  const [filter, setFilter] = useState<"all" | "league" | "cup">("all");
  const [currentPage, setCurrentPage] = useState(1);

  // useQueries fetches both datasets in parallel for optimal performance
  const [
    { data: allLeagues, isLoading: isLoadingLeagues },
    { data: activeLeagueIds, isLoading: isLoadingActive },
  ] = useQueries({
    queries: [
      {
        queryKey: ["allLeaguesDirectory"],
        queryFn: fetchAllLeagues,
        staleTime: 1000 * 60 * 60, // Cache all leagues for 1 hour
      },
      {
        queryKey: ["activeLeagueIds"],
        queryFn: fetchActiveLeagueIds,
        staleTime: 1000 * 60 * 10, // Re-check for active leagues every 10 minutes
      },
    ],
  });

  const isLoading = isLoadingLeagues || isLoadingActive;

  // The main logic for filtering and sorting the leagues
  const { paginatedData, totalPages } = useMemo(() => {
    // Wait until both API calls are complete before processing data
    if (!allLeagues || !activeLeagueIds) {
      return { paginatedData: [], totalPages: 0 };
    }

    const activeIdsSet = new Set(activeLeagueIds);

    // First, apply the user's search and type filters
    const filtered = allLeagues.filter((league) => {
      const matchesSearch = league.name
        .toLowerCase()
        .includes(searchTerm.toLowerCase());
      const matchesFilter =
        filter === "all" || league.type.toLowerCase() === filter;
      return matchesSearch && matchesFilter;
    });

    // Separate the filtered list into active and inactive leagues
    const activeLeagues = filtered.filter((l) => activeIdsSet.has(l.id));
    const inactiveLeagues = filtered.filter((l) => !activeIdsSet.has(l.id));

    // Sort each sub-list alphabetically for consistent ordering
    activeLeagues.sort((a, b) => a.name.localeCompare(b.name));
    inactiveLeagues.sort((a, b) => a.name.localeCompare(b.name));

    // Combine the lists, with active leagues appearing first
    const sortedAndFiltered = [...activeLeagues, ...inactiveLeagues];

    // Apply pagination to the final, sorted list
    const totalPages = Math.ceil(sortedAndFiltered.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    const paginatedData = sortedAndFiltered.slice(startIndex, endIndex);

    return { paginatedData, totalPages };
  }, [allLeagues, activeLeagueIds, searchTerm, filter, currentPage]);

  // Reset to the first page whenever the filters change
  useEffect(() => {
    setCurrentPage(1);
  }, [searchTerm, filter]);

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <h1 className="text-4xl font-extrabold text-white mb-6">
            Leagues & Cups
          </h1>

          <div className="flex flex-col md:flex-row gap-4 mb-8">
            <input
              type="text"
              placeholder="Search by name..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full md:w-1/3 p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
            <div className="flex items-center gap-2 p-1 rounded-lg bg-brand-secondary">
              <button
                onClick={() => setFilter("all")}
                className={`px-4 py-1.5 rounded-md text-sm font-semibold transition-colors ${
                  filter === "all"
                    ? "bg-brand-purple text-white"
                    : "text-brand-muted hover:bg-gray-700/50"
                }`}
              >
                All
              </button>
              <button
                onClick={() => setFilter("league")}
                className={`px-4 py-1.5 rounded-md text-sm font-semibold transition-colors ${
                  filter === "league"
                    ? "bg-brand-purple text-white"
                    : "text-brand-muted hover:bg-gray-700/50"
                }`}
              >
                Leagues
              </button>
              <button
                onClick={() => setFilter("cup")}
                className={`px-3 py-1.5 rounded-md text-sm font-semibold transition-colors ${
                  filter === "cup"
                    ? "bg-brand-purple text-white"
                    : "text-brand-muted hover:bg-gray-700/50"
                }`}
              >
                Cups
              </button>
            </div>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
            {isLoading
              ? Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
                  <DirectoryCardSkeleton key={i} />
                ))
              : paginatedData.map((league) => (
                  <DirectoryCard
                    key={league.id}
                    {...league}
                    // The 'isPopular' prop is now used to signify 'isActive'
                    isPopular={activeLeagueIds?.includes(league.id)}
                  />
                ))}
          </div>

          {!isLoading && paginatedData.length > 0 && (
            <Pagination
              currentPage={currentPage}
              totalPages={totalPages}
              onPageChange={setCurrentPage}
            />
          )}

          {!isLoading && paginatedData.length === 0 && (
            <div className="text-center py-20 bg-brand-secondary rounded-lg">
              <p className="text-xl font-bold text-white">No Results Found</p>
              <p className="text-brand-muted mt-2">
                Try adjusting your search or filter.
              </p>
            </div>
          )}
        </main>
      </div>
    </div>
  );
}


// ===== src\app\football\match\[...slug]\page.tsx =====
// src/app/football/match/[...slug]/page.tsx
"use client";

import { useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import { useParams } from "next/navigation";
import axios from "axios";
import Header from "@/components/Header";

// Import all the components used on this page
import MatchHeader from "@/components/match/MatchHeader";
import MatchStatusBanner from "@/components/match/MatchStatusBanner";
import MatchH2HWidget from "@/components/match/MatchH2HWidget";
import MatchLineupsWidget from "@/components/match/MatchLineupsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import MatchPredictionWidget from "@/components/match/MatchPredictionWidget";
import TeamFormWidget from "@/components/match/TeamFormWidget";
import WeatherWidget from "@/components/match/WeatherWidget";
import LiveOddsWidget from "@/components/match/LiveOddsWidget";

// --- Data fetching functions and helpers ---
const getFixtureIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

const fetchMatchDetails = async (fixtureId: string) => {
  const { data } = await axios.get(`/api/match-details?fixture=${fixtureId}`);
  return data;
};

// --- Skeleton Component for Initial Loading ---
const PageSkeleton = () => (
  <div className="animate-pulse container mx-auto p-4 md:p-8">
    <div className="h-48 w-full bg-brand-secondary rounded-lg mb-2"></div>
    <div className="h-10 w-full bg-brand-secondary rounded-b-lg mb-8"></div>
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mt-8">
      {/* Main Column Skeleton */}
      <div className="lg:col-span-2 space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div className="h-96 w-full bg-brand-secondary rounded-lg"></div>
          <div className="h-96 w-full bg-brand-secondary rounded-lg"></div>
        </div>
        <div className="h-64 w-full bg-brand-secondary rounded-lg"></div>
      </div>
      {/* Sidebar Column Skeleton */}
      <div className="lg:col-span-1 space-y-6">
        <div className="h-48 w-full bg-brand-secondary rounded-lg"></div>
        <div className="h-28 w-full bg-brand-secondary rounded-lg"></div>
        <div className="h-80 w-full bg-brand-secondary rounded-lg"></div>
      </div>
    </div>
  </div>
);

// --- Main Page Component ---
export default function MatchDetailPage() {
  const params = useParams();
  const slug = Array.isArray(params.slug)
    ? params.slug.join("/")
    : (params.slug as string);
  const fixtureId = useMemo(() => getFixtureIdFromSlug(slug), [slug]);

  const { data, isLoading, error } = useQuery({
    queryKey: ["matchDetails", fixtureId],
    queryFn: () => fetchMatchDetails(fixtureId!),
    enabled: !!fixtureId,
    staleTime: 1000 * 30, // Refetch data every 30 seconds
    refetchOnWindowFocus: true,
  });

  const isLive = useMemo(() => {
    if (!data?.fixture) return false;
    const status = data.fixture.status?.short;
    return ["1H", "HT", "2H", "ET", "BT", "P", "LIVE"].includes(status);
  }, [data]);

  if (isLoading) {
    return (
      <div className="bg-brand-dark min-h-screen">
        <Header />
        <PageSkeleton />
      </div>
    );
  }

  if (error || !data || !data.fixture) {
    return (
      <div className="bg-brand-dark min-h-screen">
        <Header />
        <div className="container mx-auto p-8 text-center">
          <h1 className="text-2xl font-bold text-red-400">Match Not Found</h1>
          <p className="text-brand-muted mt-2">
            Could not load the details for this match. It may have been removed
            or the ID is incorrect.
          </p>
        </div>
      </div>
    );
  }

  const { fixture, h2h, analytics } = data;
  const { home: homeTeam, away: awayTeam } = fixture.teams;

  return (
    <div className="bg-brand-dark min-h-screen">
      <Header />
      <div className="container mx-auto p-2 md:p-4 lg:p-6 text-brand-light">
        <MatchHeader fixture={fixture} />
        <MatchStatusBanner fixture={fixture} />

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mt-8">
          {/* Main Content Column */}
          <main className="lg:col-span-2 space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <TeamFormWidget
                teamStats={analytics.homeTeamStats}
                team={homeTeam}
                location="Home"
              />
              <TeamFormWidget
                teamStats={analytics.awayTeamStats}
                team={awayTeam}
                location="Away"
              />
            </div>
            <MatchH2HWidget
              h2h={h2h}
              teams={fixture.teams}
              currentFixtureId={fixtureId!}
            />
          </main>

          {/* Sidebar Column */}
          <aside className="lg:col-span-1 space-y-6 sticky top-6">
            {isLive && <LiveOddsWidget fixtureId={fixtureId!} />}

            <MatchPredictionWidget
              apiPrediction={analytics.prediction}
              customPrediction={analytics.customPrediction}
              bookmakerOdds={analytics.bookmakerOdds}
              teams={fixture.teams}
            />

            <WeatherWidget fixture={fixture} />

            <MatchLineupsWidget lineups={fixture.lineups} />

            <AdSlotWidget location="match_sidebar" />
          </aside>
        </div>
      </div>
    </div>
  );
}


// ===== src\app\football\news\page.tsx =====
// src/app/football/news/page.tsx
"use client";

import { useState, useMemo, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { IPost } from "@/models/Post";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import Pagination from "@/components/Pagination";
import NewsListItem, { NewsListItemSkeleton } from "@/components/NewsListItem";
import { Info, Newspaper } from "lucide-react";
import Script from "next/script"; // Import the Script component for JSON-LD
import PostCategories, { NewsCategory } from "@/components/PostCategories"; // Import the new component

export const dynamic = "force-dynamic";

const ITEMS_PER_PAGE = 8;

const fetchNews = async (): Promise<IPost[]> => {
  const { data } = await axios.get("/api/posts?status=published");
  return data;
};

export default function NewsPage() {
  const [currentPage, setCurrentPage] = useState(1);
  const [activeCategory, setActiveCategory] = useState<NewsCategory>("all");

  const { data: allNews, isLoading } = useQuery<IPost[]>({
    queryKey: ["allNewsArticles"],
    queryFn: fetchNews,
    staleTime: 1000 * 60 * 5,
  });

  // --- ENHANCED: Filtering and Pagination Logic ---
  const { paginatedData, totalPages } = useMemo(() => {
    if (!allNews) return { paginatedData: [], totalPages: 0 };

    // 1. Filter by the active category first
    const filteredNews =
      activeCategory === "all"
        ? allNews
        : allNews.filter((post) => post.sport === activeCategory);

    // 2. Paginate the filtered results
    const totalPages = Math.ceil(filteredNews.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    const paginatedData = filteredNews.slice(startIndex, endIndex);

    return { paginatedData, totalPages };
  }, [allNews, currentPage, activeCategory]);

  // Reset page to 1 when category changes
  useEffect(() => {
    setCurrentPage(1);
  }, [activeCategory]);

  // --- SEO: JSON-LD Structured Data ---
  const generateJsonLd = () => {
    if (!paginatedData || paginatedData.length === 0) return null;

    const items = paginatedData.map((post) => ({
      "@type": "NewsArticle",
      headline: post.title,
      image: [post.featuredImage || ""],
      datePublished: post.createdAt,
      dateModified: post.updatedAt,
      author: [
        {
          "@type": "Person",
          name: post.author,
        },
      ],
    }));

    return {
      "@context": "https://schema.org",
      "@type": "ItemList",
      itemListElement: items.map((item, index) => ({
        "@type": "ListItem",
        position: (currentPage - 1) * ITEMS_PER_PAGE + index + 1,
        item: item,
      })),
    };
  };

  return (
    <>
      {/* Add the JSON-LD Script to the head of the page */}
      <Script
        id="news-list-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(generateJsonLd()) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
          <Sidebar />
          <main className="min-w-0 p-4 lg:p-0 lg:py-6">
            {/* --- ENHANCED UI: Page Header --- */}
            <div className="flex items-center gap-4 mb-8">
              <div className="p-3 bg-brand-purple/10 rounded-lg">
                <Newspaper className="w-8 h-8 text-brand-purple" />
              </div>
              <div>
                <h1 className="text-4xl font-extrabold text-white">
                  Latest News
                </h1>
                <p className="text-brand-muted">
                  Stay updated with the latest stories and analysis.
                </p>
              </div>
            </div>

            {/* --- ENHANCED UI: Category Filters --- */}
            <PostCategories
              activeCategory={activeCategory}
              onCategoryChange={setActiveCategory}
            />

            {isLoading ? (
              <div className="space-y-4">
                {Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
                  <NewsListItemSkeleton key={i} />
                ))}
              </div>
            ) : paginatedData.length > 0 ? (
              <div className="space-y-4">
                {paginatedData.map((post) => (
                  <NewsListItem key={post._id} post={post} />
                ))}
                {totalPages > 1 && (
                  <Pagination
                    currentPage={currentPage}
                    totalPages={totalPages}
                    onPageChange={setCurrentPage}
                  />
                )}
              </div>
            ) : (
              <div className="text-center py-20 bg-brand-secondary rounded-lg">
                <Info size={32} className="mx-auto text-brand-muted mb-3" />
                <p className="text-xl font-bold text-white">No News Found</p>
                <p className="text-brand-muted mt-2">
                  There are no articles available in the "{activeCategory}"
                  category.
                </p>
              </div>
            )}
          </main>
        </div>
      </div>
    </>
  );
}


// ===== src\app\football\news\[slug]\page.tsx =====
import { notFound } from 'next/navigation';
import dbConnect from '@/lib/dbConnect';
import Post from '@/models/Post';
import { format } from 'date-fns';
import Header from '@/components/Header';
import Image from 'next/image'; // <-- Import next/image
import SocialShareButtons from '@/components/SocialShareButtons'; // We will create this next
import NewsSidebar from '@/components/NewsSidebar';

// This function fetches the data on the server
async function getPost(slug: string) {
  await dbConnect();
  const post = await Post.findOne({ slug: slug, status: 'published' }).lean();
  if (!post) {
    return null;
  }
  return post;
}

// Update generateMetadata to use the new meta fields if they exist
export async function generateMetadata({ params }: { params: { slug: string } }) {
    const post = await getPost(params.slug);
    if (!post) {
      return { title: 'Not Found' };
    }
    return {
      // Use specific meta title if available, otherwise fall back to post title
      title: post.metaTitle || `${post.title} | Fulltime News`,
      // Use specific meta description if available
      description: post.metaDescription || post.content.replace(/<[^>]*>?/gm, '').substring(0, 160),
    };
}


// --- The Main Page Component ---
export default async function NewsArticlePage({ params }: { params: { slug: string } }) {
  const post = await getPost(params.slug);

  if (!post) {
    notFound();
  }

  // We need to construct the full URL for sharing
  const postUrl = `${process.env.NEXTAUTH_URL}/news/${post.slug}`;

  return (
     <div className="bg-brand-dark min-h-screen">
      <Header />
      {/* --- UPDATED LAYOUT --- */}
      <main className="container mx-auto p-4 md:p-8 grid grid-cols-1 lg:grid-cols-3 gap-12">
        
        {/* Main Content (Article) - Spans 2 columns on large screens */}
        <div className="lg:col-span-2">
          <article className="bg-brand-secondary rounded-lg overflow-hidden">
            {post.featuredImage && (
              <div className="relative w-full h-64 md:h-96">
                <Image
                  src={post.featuredImage}
                  alt={post.featuredImageAltText || post.title}
                  title={post.featuredImageTitle || post.title}
                  layout="fill"
                  objectFit="cover"
                  priority
                />
              </div>
            )}
            
            <div className="p-8">
              <div className="mb-8 text-center border-b border-gray-700/50 pb-8">
                <h1 className="text-4xl md:text-5xl font-extrabold text-white leading-tight mb-4">
                  {post.title}
                </h1>
                <p className="text-brand-muted">
                  Published by {post.author} on {format(new Date(), 'MMMM dd, yyyy')}
                </p>
              </div>
              
              <div 
                className="prose prose-invert lg:prose-xl max-w-none"
                dangerouslySetInnerHTML={{ __html: post.content }} 
              />

              <div className="mt-12 pt-8 border-t border-gray-700/50">
                  <h3 className="text-lg font-bold text-center text-brand-muted mb-4">Share this article</h3>
                  <SocialShareButtons url={postUrl} title={post.title} />
              </div>
            </div>
          </article>
        </div>

        {/* Sidebar - Spans 1 column on large screens */}
        <div className="lg:col-span-1">
          <NewsSidebar />
        </div>

      </main>
    </div>
  );
}
// Optional: For better performance in production, generate static pages for each post at build time.
export async function generateStaticParams() {
  await dbConnect();
  const posts = await Post.find({ status: 'published' }).select('slug').lean();
  return posts.map(post => ({
    slug: post.slug,
  }));
}

// ===== src\app\football\team\[...slug]\page.tsx =====
// src/app/football/team/[...slug]/page.tsx
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import TeamDetailView from "@/components/TeamDetailView";
import { notFound } from "next/navigation";
import axios from "axios";

// Helper to extract the ID from the slug (unchanged)
const getTeamIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

// --- THIS IS THE CORRECTED DATA FETCHING FUNCTION ---
async function getTeamData(teamId: string) {
  const season = new Date().getFullYear();

  // Reusable options object for axios requests
  const options = (endpoint: string, params: object) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    const [teamInfoRes, squadRes, fixturesRes] = await Promise.all([
      // This call is correct
      axios.request(options("teams", { id: teamId })),
      // This call is correct
      axios.request(options("players/squads", { team: teamId })),

      // --- THIS IS THE FIX ---
      // This API call now correctly queries the 'fixtures' endpoint
      // with a 'team' parameter, ensuring we only get matches for this specific team.
      // We fetch the last 50 to get a good mix of recent results and upcoming games.
      axios.request(
        options("fixtures", { team: teamId, season: season, last: 50 })
      ),
    ]);

    if (!teamInfoRes.data.response[0]) {
      return null;
    }

    return {
      teamInfo: teamInfoRes.data.response[0],
      squad: squadRes.data.response[0]?.players || [],
      // This now contains only the fixtures for the specified team
      fixtures: fixturesRes.data.response || [],
    };
  } catch (error) {
    console.error(`Failed to fetch team details for teamId ${teamId}:`, error);
    return null;
  }
}

// generateMetadata function (unchanged)
export async function generateMetadata({
  params,
}: {
  params: { slug: string[] };
}) {
  const slug = params.slug.join("/");
  const teamId = getTeamIdFromSlug(slug);
  if (!teamId) return { title: "Team Not Found" };

  try {
    const { data } = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams?id=${teamId}`,
      {
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );
    const teamInfo = data.response[0];
    if (!teamInfo) return { title: "Team Not Found" };

    return {
      title: `${teamInfo.team.name} - Squad, Fixtures & Standings`,
      description: `View the full squad, recent fixtures, and current standings for ${teamInfo.team.name}.`,
    };
  } catch {
    return { title: "Team Not Found" };
  }
}

// THE MAIN PAGE COMPONENT (Unchanged)
export default async function TeamPage({
  params,
}: {
  params: { slug: string[] };
}) {
  const slug = params.slug.join("/");
  const teamId = getTeamIdFromSlug(slug);

  if (!teamId) {
    notFound();
  }

  const teamData = await getTeamData(teamId);

  if (!teamData) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <TeamDetailView teamData={teamData} />
        </main>
      </div>
    </div>
  );
}


// ===== src\app\football\teams\page.tsx =====
// src/app/football/teams/page.tsx
"use client";

import { useState, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import StyledLink from "@/components/StyledLink";
import { ChevronRight, Globe, Search, Users } from "lucide-react";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";

export const dynamic = "force-dynamic";

// --- TYPE DEFINITION ---
interface EnrichedCountry {
  name: string;
  code: string | null;
  flagUrl: string;
  leagueCount: number;
}

// --- CARD AND SKELETON COMPONENTS (Unchanged) ---
const EnhancedCountryCard = ({ country }: { country: EnrichedCountry }) => (
  <StyledLink
    href={`/football/teams/${country.name}`}
    className="block group h-full"
  >
    <div className="bg-brand-secondary rounded-lg flex flex-col h-full transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20">
      <div className="p-4 flex items-center gap-4">
        <Image
          src={country.flagUrl}
          alt={country.name}
          width={40}
          height={40}
          className="rounded-full flex-shrink-0"
        />
        <div className="flex-1 min-w-0">
          <h3 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
            {country.name}
          </h3>
          <div className="flex items-center gap-1.5 text-xs text-brand-muted mt-1">
            <Globe size={12} />
            <span>View Teams</span>
          </div>
        </div>
        <ChevronRight className="text-brand-muted group-hover:text-brand-purple transition-colors flex-shrink-0" />
      </div>
      <div className="mt-auto border-t border-gray-700/50 p-3 text-xs text-brand-light flex items-center justify-center gap-2">
        <Users size={14} className="text-brand-muted" />
        <span className="font-semibold">{country.leagueCount}</span>
        <span>Professional Leagues</span>
      </div>
    </div>
  </StyledLink>
);

const CountryCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg flex flex-col h-full animate-pulse">
    <div className="p-4 flex items-center gap-4">
      <div className="w-10 h-10 rounded-full bg-gray-700"></div>
      <div className="space-y-2 flex-1">
        <div className="h-4 w-3/4 rounded bg-gray-600"></div>
        <div className="h-3 w-1/2 rounded bg-gray-600/50"></div>
      </div>
    </div>
    <div className="mt-auto border-t border-gray-700/50 p-3 flex items-center justify-center gap-2">
      <div className="h-4 w-2/3 bg-gray-700 rounded-md"></div>
    </div>
  </div>
);

export default function BrowseTeamsByCountryPage() {
  const [searchTerm, setSearchTerm] = useState("");

  // --- THIS IS THE FIX ---
  // Removed the external fetcher function and defined the query function directly and simply.
  // This is the most reliable pattern and avoids potential stale closure issues.
  const { data: countries, isLoading } = useQuery<EnrichedCountry[]>({
    queryKey: ["countryDirectory"],
    queryFn: async () => {
      const { data } = await axios.get("/api/directory/countries");
      return data;
    },
    staleTime: 1000 * 60 * 60 * 24, // Cache for a day
  });

  const filteredCountries = useMemo(() => {
    if (!countries) return [];
    return countries.filter((country) =>
      country.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [countries, searchTerm]);

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <h1 className="text-4xl font-extrabold text-white mb-2">
            Browse Teams by Country
          </h1>
          <p className="text-brand-muted mb-8">
            Select a country to view all associated professional teams.
          </p>

          <div className="relative mb-8 max-w-lg">
            <Search
              className="absolute left-3.5 top-1/2 -translate-y-1/2 text-brand-muted"
              size={20}
            />
            <input
              type="text"
              placeholder="Search for a country..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-3 pl-12 text-white focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
          </div>

          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-2 xl:grid-cols-3 gap-4">
            {isLoading ? (
              Array.from({ length: 18 }).map((_, i) => (
                <CountryCardSkeleton key={i} />
              ))
            ) : filteredCountries && filteredCountries.length > 0 ? (
              filteredCountries.map((country) => (
                <EnhancedCountryCard
                  key={country.code || country.name}
                  country={country}
                />
              ))
            ) : (
              <div className="text-center py-20 bg-brand-secondary rounded-lg col-span-full">
                <p className="text-xl font-bold text-white">
                  No Countries Found
                </p>
                <p className="text-brand-muted mt-2">
                  We couldn't find any countries with active leagues. Please
                  check back later.
                </p>
              </div>
            )}
          </div>
        </main>
      </div>
    </div>
  );
}


// ===== src\app\football\teams\[countryName]\page.tsx =====
// src/app/football/teams/[countryName]/page.tsx
"use client";

import { useState, useMemo, useEffect } from "react";
import { useParams } from "next/navigation";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import Pagination from "@/components/Pagination";
import StyledLink from "@/components/StyledLink";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import { Calendar, Info, MapPin, Search } from "lucide-react";

const ITEMS_PER_PAGE = 18;

// --- TYPE DEFINITION for the API response object ---
interface TeamsByCountryResponse {
  teams: any[];
  count: number;
}

// --- DATA FETCHER ---
const fetchTeamsByCountry = async (
  countryName: string
): Promise<TeamsByCountryResponse> => {
  const { data } = await axios.get(
    `/api/teams-by-country?country=${encodeURIComponent(countryName)}`
  );
  return data;
};

// EnhancedTeamCard and TeamCardSkeleton components remain the same
const EnhancedTeamCard = ({ team, venue }: { team: any; venue: any }) => (
  <StyledLink
    href={generateTeamSlug(team.name, team.id)}
    className="block group h-full"
  >
    <div className="bg-brand-secondary rounded-lg flex flex-col h-full transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20">
      <div className="p-4 flex items-center gap-4">
        <Image
          src={proxyImageUrl(team.logo)}
          alt={team.name}
          width={48}
          height={48}
          className="flex-shrink-0"
        />
        <div className="flex-1 min-w-0">
          <h3 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
            {team.name}
          </h3>
        </div>
      </div>
      <div className="px-4 pb-3 mt-auto border-t border-gray-700/50 pt-3 space-y-1.5 text-xs text-brand-muted">
        {team.founded && (
          <div className="flex items-center gap-2">
            <Calendar size={12} />
            <span>Founded: {team.founded}</span>
          </div>
        )}
        {venue?.name && (
          <div className="flex items-center gap-2 truncate">
            <MapPin size={12} />
            <span className="truncate" title={venue.name}>
              {venue.name}
            </span>
          </div>
        )}
      </div>
    </div>
  </StyledLink>
);

const TeamCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg p-4 h-36 animate-pulse">
    <div className="flex items-center gap-4">
      <div className="w-12 h-12 rounded-full bg-gray-700"></div>
      <div className="h-5 w-3/4 bg-gray-600 rounded"></div>
    </div>
    <div className="mt-6 space-y-2 border-t border-gray-700/50 pt-3">
      <div className="h-3 w-1/2 bg-gray-600/50 rounded"></div>
      <div className="h-3 w-full bg-gray-600/50 rounded"></div>
    </div>
  </div>
);

export default function TeamsByCountryPage() {
  const params = useParams();
  const countryName = decodeURIComponent(params.countryName as string);

  const [searchTerm, setSearchTerm] = useState("");
  const [currentPage, setCurrentPage] = useState(1);

  // --- FIX 1: Rename `data: teams` to `data: response` for clarity ---
  const { data: response, isLoading } = useQuery({
    queryKey: ["teamsByCountry", countryName],
    queryFn: () => fetchTeamsByCountry(countryName),
    staleTime: 1000 * 60 * 60,
  });

  const { paginatedData, totalPages } = useMemo(() => {
    // --- FIX 2: Access the `teams` array *from* the response object ---
    const teamsArray = response?.teams || []; // Use the actual array, or an empty one if data is not ready
    if (teamsArray.length === 0) return { paginatedData: [], totalPages: 0 };

    // --- FIX 3: Filter the `teamsArray`, not the response object ---
    const filtered = teamsArray.filter((teamData) =>
      teamData.team.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    const totalPages = Math.ceil(filtered.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    const paginatedData = filtered.slice(startIndex, endIndex);

    return { paginatedData, totalPages };
  }, [response, searchTerm, currentPage]);

  useEffect(() => {
    setCurrentPage(1);
  }, [searchTerm]);

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <h1 className="text-4xl font-extrabold text-white mb-6">
            Teams in {countryName}
          </h1>

          <div className="flex flex-col md:flex-row gap-4 mb-8">
            <div className="relative flex-grow">
              <Search
                className="absolute left-3.5 top-1/2 -translate-y-1/2 text-brand-muted"
                size={20}
              />
              <input
                type="text"
                placeholder="Search by team name..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-3 pl-12 text-white focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
            </div>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
            {isLoading ? (
              Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
                <TeamCardSkeleton key={i} />
              ))
            ) : paginatedData.length > 0 ? (
              paginatedData.map((teamData) => (
                <EnhancedTeamCard
                  key={teamData.team.id}
                  team={teamData.team}
                  venue={teamData.venue}
                />
              ))
            ) : (
              <div className="col-span-full text-center py-20 bg-brand-secondary rounded-lg">
                <Info size={32} className="mx-auto text-brand-muted mb-3" />
                <p className="text-xl font-bold text-white">No Results Found</p>
                <p className="text-brand-muted mt-2">
                  Try adjusting your search term or check back later.
                </p>
              </div>
            )}
          </div>

          {!isLoading && paginatedData.length > 0 && (
            <Pagination
              currentPage={currentPage}
              totalPages={totalPages}
              onPageChange={setCurrentPage}
            />
          )}
        </main>
      </div>
    </div>
  );
}


// ===== src\app\layout.tsx =====
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import Providers from "./providers";
import { LeagueProvider } from "@/context/LeagueContext";
import "slick-carousel/slick/slick.css";
import "slick-carousel/slick/slick-theme.css";
import { LanguageProvider } from "@/context/LanguageContext";
import NextAuthProvider from "./NextAuthProvider";
import { Suspense } from "react";
import StickyFooterAd from "@/components/StickyFooterAd";
import Loading from "./loading";
import Footer from "@/components/Footer";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Fan Skor | Türkiye'nin 1 numaralı Canlı Skor sitesi",
  description:
    "Oyuntaktik.com, Türkiye'nin bir numaralı inceleme sitesi, en iyi oyun rehberleri, taktikler ve güncel değerlendirmelerle oyuncuların yanında!",
  icons: {
    icon: [
      { url: "/favicon.ico", type: "image/png" }, // For modern browsers
    ],
    apple: [
      { url: "/favicon.ico" }, // For iOS
    ],
  },
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body
        className={`${inter.className} bg-background text-text-primary`}
        suppressHydrationWarning={true}
      >
        <Suspense fallback={<Loading />}>
          <NextAuthProvider>
            <Providers>
              <LanguageProvider>
                <LeagueProvider>
                  <main>{children}</main>
                  <StickyFooterAd />
                  <Footer />
                </LeagueProvider>
              </LanguageProvider>
            </Providers>
          </NextAuthProvider>
        </Suspense>
      </body>
    </html>
  );
}


// ===== src\app\loading.tsx =====
// src/app/loading.tsx
// This file acts as the server-side container for our client-side preloader.

import LottiePreloader from "@/components/LottiePreloader"; // Import the new component

export default function Loading() {
  return (
    <div className="fixed inset-0 z-[100] flex items-center justify-center bg-brand-dark">
      {/* 
        We render the LottiePreloader component here. 
        Next.js will handle rendering the client component within this server component shell.
      */}
      <LottiePreloader />
    </div>
  );
}


// ===== src\app\login\page.tsx =====
"use client";

import { useState } from 'react';
import { signIn } from 'next-auth/react';
import { useRouter, useSearchParams } from 'next/navigation';
import { useTranslation } from '@/hooks/useTranslation';


export const dynamic = 'force-dynamic';

export default function LoginPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { t } = useTranslation();
  
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState(searchParams.get('error') || '');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    const result = await signIn('credentials', {
      redirect: false,
      email,
      password,
    });

    if (result?.error) {
      setError(t('invalid_credentials'));
    } else if (result?.ok) {
      router.push('/admin/dashboard');
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-brand-dark">
      <form onSubmit={handleSubmit} className="p-8 rounded-lg shadow-lg bg-brand-secondary w-full max-w-sm">
        <h1 className="text-2xl font-bold mb-6 text-center text-white">{t('admin_login')}</h1>
        {error && <p className="bg-red-500/20 text-red-400 p-3 rounded mb-4 text-sm">{error}</p>}
        <div className="space-y-4">
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder={t('email')}
            required
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder={t('password')}
            required
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
        </div>
        <button type="submit" className="w-full mt-6 bg-brand-purple text-white font-bold py-3 rounded-lg hover:opacity-90 transition-opacity">
          {t('sign_in')}
        </button>
      </form>
    </div>
  );
}

// ===== src\app\NextAuthProvider.tsx =====
// src/app/NextAuthProvider.tsx
"use client";

import { SessionProvider } from "next-auth/react";

// This is a new wrapper component
export default function NextAuthProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  return <SessionProvider>{children}</SessionProvider>;
}

// ===== src\app\not-found.tsx =====
"use client";

import { Suspense } from 'react'; // <-- IMPORT Suspense
import Link from 'next/link';
import Header from '@/components/Header';
import { HeaderSkeleton } from '@/components/LayoutSkeletons'; // <-- IMPORT Skeleton
import { Frown } from 'lucide-react';

export default function NotFound() {
  return (
    <div className="min-h-screen flex flex-col">
      <Suspense fallback={<HeaderSkeleton />}>
        <Header />
      </Suspense>

      <main className="flex-1 flex flex-col items-center justify-center text-center p-4">
        <Frown className="w-16 h-16 text-text-muted mb-4" />
        <h1 className="text-4xl font-extrabold text-white">404 - Page Not Found</h1>
        <p className="text-lg text-text-secondary mt-2 mb-6">
          The page you are looking for does not exist or has been moved.
        </p>
        <Link 
            href="/"
            className="px-6 py-3 bg-brand-purple text-white font-bold rounded-lg hover:opacity-90 transition-opacity"
        >
          Go back to Homepage
        </Link>
      </main>
    </div>
  )
}

// ===== src\app\page.tsx =====
// src/app/page.tsx
import { Suspense } from "react";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import MainContent from "@/components/MainContent";
import { HeaderSkeleton, SidebarSkeleton } from "@/components/LayoutSkeletons";

export default async function HomePage() {
  return (
    <div className="min-h-screen flex flex-col">
      <Suspense fallback={<HeaderSkeleton />}>
        <Header />
      </Suspense>
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:items-start lg:py-8">
        <Suspense fallback={<SidebarSkeleton />}>
          <Sidebar />
        </Suspense>

        <main className="min-w-0">
          <MainContent />
        </main>
      </div>
    </div>
  );
}


// ===== src\app\providers.tsx =====
"use client";

import ProgressBar from "@/components/ProgressBar";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { useState } from "react";
import { Toaster } from "react-hot-toast";

export default function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
          },
        },
      })
  );

 return (
    <QueryClientProvider client={queryClient}>
      {/* Add Toaster here. You can customize its position and style. */}
      <Toaster 
        position="top-right"
        toastOptions={{
          style: {
            background: '#333',
            color: '#fff',
          },
        }}
      />
      <ProgressBar />
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}

