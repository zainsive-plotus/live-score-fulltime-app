// ===== src\app\admin\ai-journalists\page.tsx =====
// src/app/admin/ai-journalists/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  PlusCircle,
  Edit,
  Trash2,
  User,
  CheckCircle,
  XCircle,
  Loader2,
} from "lucide-react";

// Assuming IAIJournalist interface is defined, otherwise define it here
interface IAIJournalist {
  _id: string;
  name: string;
  description?: string;
  tonePrompt: string;
  isActive: boolean;
  createdAt: string; // ISO date string
  updatedAt: string; // ISO date string
}

// Reusable form modal for creating/editing AI Journalists
interface AIJournalistFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  journalist?: IAIJournalist | null; // Optional: for editing
}

const AIJournalistFormModal: React.FC<AIJournalistFormModalProps> = ({
  isOpen,
  onClose,
  journalist,
}) => {
  const queryClient = useQueryClient();
  const [name, setName] = useState(journalist?.name || "");
  const [description, setDescription] = useState(journalist?.description || "");
  const [tonePrompt, setTonePrompt] = useState(journalist?.tonePrompt || "");
  const [isActive, setIsActive] = useState(journalist?.isActive ?? true); // Default to true for new

  useEffect(() => {
    // Reset form fields when journalist prop changes (for editing)
    if (journalist) {
      setName(journalist.name);
      setDescription(journalist.description || "");
      setTonePrompt(journalist.tonePrompt);
      setIsActive(journalist.isActive);
    } else {
      // Clear form for new creation
      setName("");
      setDescription("");
      setTonePrompt("");
      setIsActive(true);
    }
  }, [journalist]);

  const createMutation = useMutation({
    mutationFn: (newJournalist: Partial<IAIJournalist>) =>
      axios.post("/api/admin/ai-journalists", newJournalist),
    onSuccess: () => {
      toast.success("AI Journalist created successfully!");
      queryClient.invalidateQueries({ queryKey: ["aiJournalists"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to create journalist.");
    },
  });

  const updateMutation = useMutation({
    mutationFn: (updatedJournalist: Partial<IAIJournalist>) =>
      axios.put(
        `/api/admin/ai-journalists/${journalist?._id}`,
        updatedJournalist
      ),
    onSuccess: () => {
      toast.success("AI Journalist updated successfully!");
      queryClient.invalidateQueries({ queryKey: ["aiJournalists"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to update journalist.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !tonePrompt.trim()) {
      toast.error("Name and Tone Prompt are required.");
      return;
    }

    const payload = { name, description, tonePrompt, isActive };

    if (journalist) {
      updateMutation.mutate(payload);
    } else {
      createMutation.mutate(payload);
    }
  };

  const isPending = createMutation.isPending || updateMutation.isPending;

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl overflow-hidden">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {journalist ? "Edit AI Journalist" : "Create New AI Journalist"}
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label
              htmlFor="name"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Journalist Name
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
          </div>
          <div>
            <label
              htmlFor="description"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Description (Optional)
            </label>
            <input
              id="description"
              type="text"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              disabled={isPending}
            />
          </div>
          <div>
            <label
              htmlFor="tonePrompt"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Tone Prompt Segment
            </label>
            <textarea
              id="tonePrompt"
              value={tonePrompt}
              onChange={(e) => setTonePrompt(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
              rows={6}
              required
              disabled={isPending}
              placeholder="e.g., 'Always use a sarcastic tone with witty remarks.', 'Provide deeply analytical and technical commentary.'"
            />
            <p className="text-xs text-brand-muted mt-1">
              This prompt segment will be injected into the main article
              generation prompt to define the journalist's style.
            </p>
          </div>
          <div className="flex items-center">
            <input
              id="isActive"
              type="checkbox"
              checked={isActive}
              onChange={(e) => setIsActive(e.target.checked)}
              className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
              disabled={isPending}
            />
            <label
              htmlFor="isActive"
              className="ml-2 text-sm font-medium text-brand-light"
            >
              Active (Can be used for generation)
            </label>
          </div>
          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
              disabled={isPending}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={isPending}
            >
              {isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {isPending
                ? journalist
                  ? "Updating..."
                  : "Creating..."
                : journalist
                ? "Save Changes"
                : "Create Journalist"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

// --- Main AI Journalists Page Component ---
export default function AdminAIJournalistsPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingJournalist, setEditingJournalist] =
    useState<IAIJournalist | null>(null);

  const {
    data: journalists,
    isLoading,
    error,
  } = useQuery<IAIJournalist[]>({
    queryKey: ["aiJournalists"],
    queryFn: async () => {
      const { data } = await axios.get("/api/admin/ai-journalists");
      return data;
    },
    staleTime: 1000 * 60 * 5, // Cache for 5 minutes
  });

  const deleteMutation = useMutation({
    mutationFn: (journalistId: string) =>
      axios.delete(`/api/admin/ai-journalists/${journalistId}`),
    onSuccess: () => {
      toast.success("AI Journalist deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["aiJournalists"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete journalist.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingJournalist(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (journalist: IAIJournalist) => {
    setEditingJournalist(journalist);
    setIsModalOpen(true);
  };

  const handleDelete = (journalistId: string, journalistName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete AI Journalist "${journalistName}"? This action cannot be undone.`
      )
    ) {
      deleteMutation.mutate(journalistId);
    }
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading AI Journalists...</p>;
  if (error)
    return <p className="text-red-400">Failed to load AI Journalists.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <User size={28} /> Manage AI Journalists
        </h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Journalist</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Name</th>
              <th className="p-4">Description</th>
              <th className="p-4">Tone Prompt Preview</th>
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {journalists?.map((journalist) => (
              <tr key={journalist._id} className="border-t border-gray-700/50">
                <td className="p-4 font-medium">{journalist.name}</td>
                <td
                  className="p-4 text-brand-muted text-sm max-w-[200px] truncate"
                  title={journalist.description}
                >
                  {journalist.description || "N/A"}
                </td>
                <td
                  className="p-4 text-brand-muted text-sm max-w-[300px] truncate"
                  title={journalist.tonePrompt}
                >
                  {journalist.tonePrompt}
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      journalist.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {journalist.isActive ? "Active" : "Inactive"}
                  </span>
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <button
                    onClick={() => handleOpenEditModal(journalist)}
                    className="text-blue-400 hover:text-blue-300"
                    title="Edit Journalist"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() =>
                      handleDelete(journalist._id, journalist.name)
                    }
                    className="text-red-400 hover:text-red-300"
                    title="Delete Journalist"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {journalists?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No AI Journalists found. Click "New Journalist" to create one.
          </p>
        )}
      </div>

      <AIJournalistFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        journalist={editingJournalist}
      />
    </div>
  );
}


// ===== src\app\admin\auto-news\page.tsx =====
// src/app/admin/auto-news/page.tsx
"use client";

import { useState, useMemo, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  Newspaper,
  Settings,
  DownloadCloud,
  Sparkles,
  AlertCircle,
  RefreshCw,
  Trash2,
  ExternalLink,
  Copy,
  Loader2,
  Hourglass,
  CheckCircle,
  XCircle,
  User, // Added User icon for dropdown
} from "lucide-react";
import { format, parseISO } from "date-fns";
import Image from "next/image";
import Link from "next/link";
import Pagination from "@/components/Pagination";

// Define interfaces for API responses (ensure these match your models/API)
interface IExternalNewsArticle {
  _id: string; // MongoDB's _id
  articleId: string; // ID from newsdata.io
  title: string;
  link: string;
  pubDate: string; // Will be ISO string, convert to Date
  imageUrl?: string | null;
  status: "fetched" | "processing" | "processed" | "skipped" | "error";
  processedPostId?: string; // MongoDB ObjectId as string
  createdAt: string;
  updatedAt: string;
}

interface ExternalNewsResponse {
  articles: IExternalNewsArticle[];
  totalCount: number;
  currentPage: number;
  perPage: number;
}

// --- Modified IAIPrompt for type field ---
interface IAIPrompt {
  _id: string;
  name: string;
  prompt: string;
  description?: string;
  type: "title" | "content" | "general"; // <-- Added type
}

// Assuming IAIJournalist interface is defined
interface IAIJournalist {
  _id: string;
  name: string;
  description?: string;
  tonePrompt: string;
  isActive: boolean;
  createdAt: string; // ISO date string
  updatedAt: string; // ISO date string
}

// --- Fetcher functions ---
const fetchExternalNews = async (
  page: number,
  limit: number,
  statusFilter: string
): Promise<ExternalNewsResponse> => {
  const { data } = await axios.get(
    `/api/admin/external-news?limit=${limit}&skip=${
      (page - 1) * limit
    }&status=${statusFilter}`
  );
  return data;
};

// --- Updated fetchAIPrompt to optionally fetch by type ---
const fetchAIPrompt = async (
  name: string,
  type: "title" | "content" | "general"
): Promise<IAIPrompt> => {
  const { data } = await axios.get(
    `/api/admin/ai-prompt?name=${encodeURIComponent(name)}&type=${type}`
  );
  return data;
};

// Fetcher for AI Journalists
const fetchAIJournalists = async (): Promise<IAIJournalist[]> => {
  const { data } = await axios.get("/api/admin/ai-journalists");
  return data;
};

// --- Define the fixed names for prompts ---
const TITLE_PROMPT_NAME = "AI Title Generation";
const CONTENT_PROMPT_NAME = "AI Content Generation";

export default function AdminAutoNewsPage() {
  const queryClient = useQueryClient();

  // --- State for News Fetching Form ---
  const [newsQuery, setNewsQuery] = useState("football OR soccer");
  const [newsLanguage, setNewsLanguage] = useState("en");
  const [newsCountry, setNewsCountry] = useState<string[]>(["gb", "us"]); // Default to UK and US
  const [newsCategory, setNewsCategory] = useState<string[]>(["sports"]); // Default to sports

  // --- State for AI Prompt Management ---
  const [titlePromptContent, setTitlePromptContent] = useState("");
  const [titlePromptDescription, setTitlePromptDescription] = useState("");
  const [isEditingTitlePrompt, setIsEditingTitlePrompt] = useState(false);

  const [contentPromptContent, setContentPromptContent] = useState("");
  const [contentPromptDescription, setContentPromptDescription] = useState("");
  const [isEditingContentPrompt, setIsEditingContentPrompt] = useState(false);

  // --- State for External News List Pagination/Filters ---
  const [currentPage, setCurrentPage] = useState(1);
  const [articlesPerPage, setArticlesPerPage] = useState(10);
  const [statusFilter, setStatusFilter] = useState("fetched");

  // --- New State for AI Journalist Selection ---
  const [selectedJournalistId, setSelectedJournalistId] = useState<
    string | null
  >(null);

  // --- Track pending mutations for UI feedback ---
  const [processingArticleId, setProcessingArticleId] = useState<string | null>(
    null
  );
  const [deletingArticleId, setDeletingArticleId] = useState<string | null>(
    null
  );

  // --- API Calls using TanStack Query ---

  // Query for external news articles
  const {
    data: externalNewsData,
    isLoading: isLoadingNews,
    error: newsError,
    refetch: refetchExternalNews,
  } = useQuery<ExternalNewsResponse>({
    queryKey: ["externalNews", currentPage, articlesPerPage, statusFilter],
    queryFn: () =>
      fetchExternalNews(currentPage, articlesPerPage, statusFilter),
    staleTime: 1000 * 60,
    placeholderData: (previousData) => previousData,
  });

  // Query for AI Title Prompt
  const {
    data: titlePromptData,
    isLoading: isLoadingTitlePrompt,
    error: titlePromptError,
  } = useQuery<IAIPrompt>({
    queryKey: ["aiPrompt", TITLE_PROMPT_NAME, "title"],
    queryFn: () => fetchAIPrompt(TITLE_PROMPT_NAME, "title"),
    staleTime: 1000 * 60 * 5,
  });

  // Query for AI Content Prompt
  const {
    data: contentPromptData,
    isLoading: isLoadingContentPrompt,
    error: contentPromptError,
  } = useQuery<IAIPrompt>({
    queryKey: ["aiPrompt", CONTENT_PROMPT_NAME, "content"],
    queryFn: () => fetchAIPrompt(CONTENT_PROMPT_NAME, "content"),
    staleTime: 1000 * 60 * 5,
  });

  // Query for AI Journalists
  const {
    data: journalists,
    isLoading: isLoadingJournalists,
    error: journalistsError,
  } = useQuery<IAIJournalist[]>({
    queryKey: ["aiJournalists"],
    queryFn: fetchAIJournalists,
    staleTime: 1000 * 60 * 5,
  });

  // Set initial selected journalist to the first active one, or null
  useEffect(() => {
    if (journalists && selectedJournalistId === null) {
      const firstActive = journalists.find((j) => j.isActive);
      if (firstActive) {
        setSelectedJournalistId(firstActive._id);
      }
    }
  }, [journalists, selectedJournalistId]);

  // Sync title prompt data to state
  useEffect(() => {
    if (titlePromptData) {
      setTitlePromptContent(titlePromptData.prompt);
      setTitlePromptDescription(titlePromptData.description || "");
    }
  }, [titlePromptData]);

  // Sync content prompt data to state
  useEffect(() => {
    if (contentPromptData) {
      setContentPromptContent(contentPromptData.prompt);
      setContentPromptDescription(contentPromptData.description || "");
    }
  }, [contentPromptData]);

  // --- Mutations ---

  // Mutation to fetch news from newsdata.io
  const fetchNewsMutation = useMutation({
    mutationFn: (payload: {
      query: string;
      language: string;
      country: string[];
      category: string[];
    }) => axios.post("/api/admin/fetch-external-news", payload),
    onSuccess: (data) => {
      toast.success(`Fetched ${data.data.newArticlesCount} new articles.`);
      queryClient.invalidateQueries({ queryKey: ["externalNews"] });
      setCurrentPage(1);
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to fetch news.");
    },
  });

  // --- Mutations for separate prompts ---
  const updateTitlePromptMutation = useMutation({
    mutationFn: (payload: { prompt: string; description?: string }) =>
      axios.put(
        `/api/admin/ai-prompt?name=${encodeURIComponent(
          TITLE_PROMPT_NAME
        )}&type=title`,
        payload
      ),
    onSuccess: (data) => {
      toast.success("AI Title Prompt updated successfully!");
      setTitlePromptContent(data.data.prompt);
      setTitlePromptDescription(data.data.description || "");
      setIsEditingTitlePrompt(false);
      queryClient.invalidateQueries({
        queryKey: ["aiPrompt", TITLE_PROMPT_NAME, "title"],
      });
    },
    onError: (err: any) => {
      toast.error(
        err.response?.data?.error || "Failed to update title prompt."
      );
    },
  });

  const updateContentPromptMutation = useMutation({
    mutationFn: (payload: { prompt: string; description?: string }) =>
      axios.put(
        `/api/admin/ai-prompt?name=${encodeURIComponent(
          CONTENT_PROMPT_NAME
        )}&type=content`,
        payload
      ),
    onSuccess: (data) => {
      toast.success("AI Content Prompt updated successfully!");
      setContentPromptContent(data.data.prompt);
      setContentPromptDescription(data.data.description || "");
      setIsEditingContentPrompt(false);
      queryClient.invalidateQueries({
        queryKey: ["aiPrompt", CONTENT_PROMPT_NAME, "content"],
      });
    },
    onError: (err: any) => {
      toast.error(
        err.response?.data?.error || "Failed to update content prompt."
      );
    },
  });

  // Mutation to process an external news article with AI
  const processArticleMutation = useMutation({
    mutationFn: (payload: {
      articleId: string;
      sportCategory: string;
      journalistId?: string | null;
    }) => {
      setProcessingArticleId(payload.articleId);
      return axios.post("/api/admin/process-external-news", payload);
    },
    onSuccess: (data) => {
      toast.success(data.data.message || "Article processed successfully!");
      queryClient.invalidateQueries({ queryKey: ["externalNews"] });
      queryClient.invalidateQueries({ queryKey: ["adminPosts"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to process article.");
    },
    onSettled: () => {
      setProcessingArticleId(null);
    },
  });

  // Mutation to delete an external news article
  const deleteArticleMutation = useMutation({
    mutationFn: (articleId: string) => {
      setDeletingArticleId(articleId);
      return axios.delete(`/api/admin/external-news?articleId=${articleId}`);
    },
    onSuccess: () => {
      toast.success("Article deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["externalNews"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete article.");
    },
    onSettled: () => {
      setDeletingArticleId(null);
    },
  });

  // --- Handlers ---
  const handleFetchNews = (e: React.FormEvent) => {
    e.preventDefault();
    fetchNewsMutation.mutate({
      query: newsQuery,
      language: newsLanguage,
      country: newsCountry,
      category: newsCategory,
    });
  };

  const handleUpdateTitlePrompt = (e: React.FormEvent) => {
    e.preventDefault();
    if (titlePromptContent.trim() === "") {
      toast.error("Title Prompt cannot be empty.");
      return;
    }
    updateTitlePromptMutation.mutate({
      prompt: titlePromptContent,
      description: titlePromptDescription,
    });
  };

  const handleUpdateContentPrompt = (e: React.FormEvent) => {
    e.preventDefault();
    if (contentPromptContent.trim() === "") {
      toast.error("Content Prompt cannot be empty.");
      return;
    }
    updateContentPromptMutation.mutate({
      prompt: contentPromptContent,
      description: contentPromptDescription,
    });
  };

  const handleProcessArticle = (articleId: string) => {
    if (!selectedJournalistId) {
      toast.error("Please select an AI Journalist before processing.");
      return;
    }
    processArticleMutation.mutate({
      articleId,
      sportCategory: "football",
      journalistId: selectedJournalistId,
    });
  };

  const handleDeleteArticle = (articleId: string) => {
    if (
      window.confirm(
        "Are you sure you want to delete this external article? This cannot be undone."
      )
    ) {
      deleteArticleMutation.mutate(articleId);
    }
  };

  const copyPromptToClipboard = (promptText: string) => {
    if (promptText) {
      navigator.clipboard.writeText(promptText);
      toast.success("Prompt copied to clipboard!");
    }
  };

  const totalPages = externalNewsData
    ? Math.ceil(externalNewsData.totalCount / articlesPerPage)
    : 0;

  // Country and Category options (simplified for now, could be dynamic from an API)
  const availableCountries = [
    { code: "us", name: "United States" },
    { code: "gb", name: "United Kingdom" },
    { code: "tr", name: "Turkey" },
    { code: "fr", name: "France" },
    { code: "de", name: "Germany" },
    { code: "es", name: "Spain" },
    { code: "it", name: "Italy" },
    { code: "br", name: "Brazil" },
    { code: "ar", name: "Argentina" },
    { code: "mx", name: "Mexico" },
    { code: "ca", name: "Canada" },
  ];
  const availableCategories = [
    { code: "sports", name: "Sports" },
    { code: "business", name: "Business" },
    { code: "health", name: "Health" },
    { code: "technology", name: "Technology" },
    { code: "entertainment", name: "Entertainment" },
    { code: "science", name: "Science" },
    { code: "politics", name: "Politics" },
    { code: "world", name: "World" },
  ];

  const handleCountryChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const options = Array.from(
      e.target.selectedOptions,
      (option) => option.value
    );
    setNewsCountry(options);
  };

  const handleCategoryChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const options = Array.from(
      e.target.selectedOptions,
      (option) => option.value
    );
    setNewsCategory(options);
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Newspaper size={28} /> Automated News Engine
        </h1>
      </div>

      {/* --- AI PROMPT MANAGEMENT SECTION --- */}
      <div className="bg-brand-secondary p-6 rounded-lg mb-8 shadow-xl">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
          <Settings size={24} /> AI Prompts Configuration
        </h2>

        {/* Title Prompt Subsection */}
        <div className="mb-8 border border-gray-700 rounded-lg p-4">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-xl font-semibold text-white">
              Title Generation Prompt
            </h3>
            <div className="flex gap-2">
              <button
                onClick={() => copyPromptToClipboard(titlePromptContent)}
                className="text-brand-light hover:text-white flex items-center gap-1 bg-gray-700 py-1.5 px-3 rounded-md text-sm"
                disabled={
                  !titlePromptContent ||
                  updateTitlePromptMutation.isPending ||
                  isLoadingTitlePrompt
                }
              >
                <Copy size={16} /> Copy
              </button>
              <button
                onClick={() => setIsEditingTitlePrompt(!isEditingTitlePrompt)}
                className="text-brand-purple hover:text-brand-purple/80 flex items-center gap-1 bg-gray-700 py-1.5 px-3 rounded-md text-sm"
                disabled={
                  isLoadingTitlePrompt || updateTitlePromptMutation.isPending
                }
              >
                {isEditingTitlePrompt ? "Cancel" : "Edit"}
              </button>
            </div>
          </div>
          {isLoadingTitlePrompt ? (
            <p className="text-brand-muted">Loading title prompt...</p>
          ) : titlePromptError ? (
            <p className="text-red-400">Error loading title prompt.</p>
          ) : (
            <form onSubmit={handleUpdateTitlePrompt} className="space-y-4">
              <div>
                <label
                  htmlFor="titlePromptContent"
                  className="block text-sm font-medium text-brand-light mb-1"
                >
                  Prompt Content:
                </label>
                <textarea
                  id="titlePromptContent"
                  value={titlePromptContent}
                  onChange={(e) => setTitlePromptContent(e.target.value)}
                  className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
                  rows={8}
                  disabled={
                    !isEditingTitlePrompt || updateTitlePromptMutation.isPending
                  }
                  placeholder="Enter the AI title generation prompt. Explain how to create a unique, plain-text title."
                />
                <p className="text-xs text-brand-muted mt-1">
                  This prompt guides the AI in generating a unique, plain-text
                  article title.
                </p>
              </div>
              <div>
                <label
                  htmlFor="titlePromptDescription"
                  className="block text-sm font-medium text-brand-light mb-1"
                >
                  Description (Optional):
                </label>
                <input
                  id="titlePromptDescription"
                  type="text"
                  value={titlePromptDescription}
                  onChange={(e) => setTitlePromptDescription(e.target.value)}
                  className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                  disabled={
                    !isEditingTitlePrompt || updateTitlePromptMutation.isPending
                  }
                  placeholder="Describe the purpose of this title prompt (e.g., 'Aggressive SEO titles')"
                />
              </div>
              {isEditingTitlePrompt && (
                <div className="flex justify-end">
                  <button
                    type="submit"
                    className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                    disabled={updateTitlePromptMutation.isPending}
                  >
                    {updateTitlePromptMutation.isPending ? (
                      <Loader2 size={18} className="animate-spin" />
                    ) : (
                      <CheckCircle size={18} />
                    )}
                    {updateTitlePromptMutation.isPending
                      ? "Saving..."
                      : "Save Title Prompt"}
                  </button>
                </div>
              )}
            </form>
          )}
        </div>

        {/* Content Prompt Subsection */}
        <div className="border border-gray-700 rounded-lg p-4">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-xl font-semibold text-white">
              Content Generation Prompt
            </h3>
            <div className="flex gap-2">
              <button
                onClick={() => copyPromptToClipboard(contentPromptContent)}
                className="text-brand-light hover:text-white flex items-center gap-1 bg-gray-700 py-1.5 px-3 rounded-md text-sm"
                disabled={
                  !contentPromptContent ||
                  updateContentPromptMutation.isPending ||
                  isLoadingContentPrompt
                }
              >
                <Copy size={16} /> Copy
              </button>
              <button
                onClick={() =>
                  setIsEditingContentPrompt(!isEditingContentPrompt)
                }
                className="text-brand-purple hover:text-brand-purple/80 flex items-center gap-1 bg-gray-700 py-1.5 px-3 rounded-md text-sm"
                disabled={
                  isLoadingContentPrompt ||
                  updateContentPromptMutation.isPending
                }
              >
                {isEditingContentPrompt ? "Cancel" : "Edit"}
              </button>
            </div>
          </div>
          {isLoadingContentPrompt ? (
            <p className="text-brand-muted">Loading content prompt...</p>
          ) : contentPromptError ? (
            <p className="text-red-400">Error loading content prompt.</p>
          ) : (
            <form onSubmit={handleUpdateContentPrompt} className="space-y-4">
              <div>
                <label
                  htmlFor="contentPromptContent"
                  className="block text-sm font-medium text-brand-light mb-1"
                >
                  Prompt Content:
                </label>
                <textarea
                  id="contentPromptContent"
                  value={contentPromptContent}
                  onChange={(e) => setContentPromptContent(e.target.value)}
                  className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
                  rows={8}
                  disabled={
                    !isEditingContentPrompt ||
                    updateContentPromptMutation.isPending
                  }
                  placeholder="Enter the AI content generation prompt. Explain how to create expanded, humanized HTML content."
                />
                <p className="text-xs text-brand-muted mt-1">
                  This prompt guides the AI in generating humanized HTML article
                  content.
                </p>
              </div>
              <div>
                <label
                  htmlFor="contentPromptDescription"
                  className="block text-sm font-medium text-brand-light mb-1"
                >
                  Description (Optional):
                </label>
                <input
                  id="contentPromptDescription"
                  type="text"
                  value={contentPromptDescription}
                  onChange={(e) => setContentPromptDescription(e.target.value)}
                  className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                  disabled={
                    !isEditingContentPrompt ||
                    updateContentPromptMutation.isPending
                  }
                  placeholder="Describe the purpose of this content prompt (e.g., 'Detailed analysis with examples')"
                />
              </div>
              {isEditingContentPrompt && (
                <div className="flex justify-end">
                  <button
                    type="submit"
                    className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                    disabled={updateContentPromptMutation.isPending}
                  >
                    {updateContentPromptMutation.isPending ? (
                      <Loader2 size={18} className="animate-spin" />
                    ) : (
                      <CheckCircle size={18} />
                    )}
                    {updateContentPromptMutation.isPending
                      ? "Saving..."
                      : "Save Content Prompt"}
                  </button>
                </div>
              )}
            </form>
          )}
        </div>
      </div>

      {/* --- FETCH EXTERNAL NEWS SECTION --- */}
      <div className="bg-brand-secondary p-6 rounded-lg mb-8 shadow-xl">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
          <DownloadCloud size={24} /> Fetch News from Newsdata.io
        </h2>
        <form
          onSubmit={handleFetchNews}
          className="grid grid-cols-1 md:grid-cols-2 gap-4"
        >
          <div>
            <label
              htmlFor="newsQuery"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Keywords (qInTitle):
            </label>
            <input
              type="text"
              id="newsQuery"
              value={newsQuery}
              onChange={(e) => setNewsQuery(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              placeholder="e.g., 'football OR soccer' (searches in title)"
            />
            <p className="text-xs text-brand-muted mt-1">
              Keywords to search for in article titles. Use OR for multiple
              terms.
            </p>
          </div>
          <div>
            <label
              htmlFor="newsLanguage"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Language:
            </label>
            <select
              id="newsLanguage"
              value={newsLanguage}
              onChange={(e) => setNewsLanguage(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            >
              <option value="en">English</option>
              <option value="tr">Turkish</option>
              {/* Add more languages as supported by newsdata.io */}
            </select>
          </div>
          <div>
            <label
              htmlFor="newsCountry"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Countries (Multi-select):
            </label>
            <select
              id="newsCountry"
              multiple
              value={newsCountry}
              onChange={handleCountryChange}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple h-28"
            >
              {availableCountries.map((c) => (
                <option key={c.code} value={c.code}>
                  {c.name}
                </option>
              ))}
            </select>
            <p className="text-xs text-brand-muted mt-1">
              Select one or more countries for news sources.
            </p>
          </div>
          <div>
            <label
              htmlFor="newsCategory"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Categories (Multi-select):
            </label>
            <select
              id="newsCategory"
              multiple
              value={newsCategory}
              onChange={handleCategoryChange}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple h-28"
            >
              {availableCategories.map((c) => (
                <option key={c.code} value={c.code}>
                  {c.name}
                </option>
              ))}
            </select>
            <p className="text-xs text-brand-muted mt-1">
              Select one or more categories for news sources.
            </p>
          </div>
          <div className="md:col-span-2 flex justify-end gap-3">
            <button
              type="button"
              onClick={() => refetchExternalNews()}
              className="flex items-center gap-2 bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed"
              disabled={
                isLoadingNews ||
                fetchNewsMutation.isPending ||
                processArticleMutation.isPending
              }
            >
              <RefreshCw
                size={18}
                className={isLoadingNews ? "animate-spin" : ""}
              />
              Refresh List
            </button>
            <button
              type="submit"
              className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed"
              disabled={fetchNewsMutation.isPending}
            >
              {fetchNewsMutation.isPending ? (
                <Loader2 size={20} className="animate-spin" />
              ) : (
                <DownloadCloud size={20} />
              )}
              {fetchNewsMutation.isPending
                ? "Fetching..."
                : "Fetch New Articles"}
            </button>
          </div>
        </form>
      </div>

      {/* --- EXTERNAL NEWS ARTICLES LIST --- */}
      <div className="bg-brand-secondary rounded-lg overflow-hidden shadow-xl">
        <div className="p-6">
          <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
            <Newspaper size={24} /> External News Articles
          </h2>
          <div className="flex items-center justify-between gap-4 mb-4">
            <div className="flex items-center gap-4">
              <span className="text-brand-light text-sm">
                Filter by Status:
              </span>
              <select
                value={statusFilter}
                onChange={(e) => {
                  setStatusFilter(e.target.value);
                  setCurrentPage(1);
                }}
                className="p-2 rounded bg-gray-700 text-white border border-gray-600 text-sm"
              >
                <option value="fetched">Fetched (Ready to Process)</option>
                <option value="processed">Processed</option>
                <option value="skipped">Skipped</option>
                <option value="error">Error</option>
                <option value="">All</option>
              </select>
            </div>
            {/* --- AI Journalist Dropdown --- */}
            <div className="flex items-center gap-2">
              <User size={18} className="text-brand-muted" />
              <select
                value={selectedJournalistId || ""}
                onChange={(e) =>
                  setSelectedJournalistId(e.target.value || null)
                }
                className="p-2 rounded bg-gray-700 text-white border border-gray-600 text-sm"
                disabled={isLoadingJournalists}
              >
                <option value="">
                  {isLoadingJournalists
                    ? "Loading Journalists..."
                    : "Select AI Journalist"}
                </option>
                {journalists
                  ?.filter((j) => j.isActive)
                  .map((j) => (
                    <option key={j._id} value={j._id}>
                      {j.name}
                    </option>
                  ))}
              </select>
            </div>
            {/* End AI Journalist Dropdown */}
            <span className="text-brand-muted text-sm ml-auto">
              Total Articles: {externalNewsData?.totalCount ?? 0}
            </span>
          </div>
        </div>

        <div className="overflow-x-auto">
          <table className="w-full text-left text-brand-light">
            <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
              <tr>
                <th className="p-4">Preview</th>
                <th className="p-4">Title</th>
                <th className="p-4">Source</th>
                <th className="p-4">Published Date</th>
                <th className="p-4">Status</th>
                <th className="p-4">Actions</th>
              </tr>
            </thead>
            <tbody>
              {isLoadingNews ? (
                Array.from({ length: articlesPerPage }).map((_, i) => (
                  <tr
                    key={i}
                    className="border-t border-gray-700/50 animate-pulse"
                  >
                    <td className="p-4">
                      <div className="w-20 h-10 bg-gray-700 rounded"></div>
                    </td>
                    <td className="p-4">
                      <div className="h-4 bg-gray-700 rounded w-4/5"></div>
                    </td>
                    <td className="p-4">
                      <div className="h-4 bg-gray-700 rounded w-1/2"></div>
                    </td>
                    <td className="p-4">
                      <div className="h-4 bg-gray-700 rounded w-1/3"></div>
                    </td>
                    <td className="p-4 flex gap-2">
                      <div className="w-8 h-8 bg-gray-700 rounded-full"></div>
                      <div className="w-8 h-8 bg-gray-700 rounded-full"></div>
                    </td>
                  </tr>
                ))
              ) : externalNewsData?.articles?.length === 0 ? (
                <tr>
                  <td colSpan={6} className="p-8 text-center text-brand-muted">
                    No external articles found with the current filter. Try
                    fetching new ones!
                  </td>
                </tr>
              ) : (
                externalNewsData?.articles?.map((article) => (
                  <tr
                    key={article._id}
                    className={`border-t border-gray-700/50 transition-colors 
                                ${
                                  processingArticleId === article.articleId ||
                                  deletingArticleId === article.articleId
                                    ? "bg-brand-dark/50 animate-pulse"
                                    : "hover:bg-gray-800"
                                }`}
                  >
                    <td className="p-4">
                      {article.imageUrl ? (
                        <Image
                          src={article.imageUrl}
                          alt={article.title}
                          width={80}
                          height={45}
                          objectFit="cover"
                          className="rounded-md"
                        />
                      ) : (
                        <div className="w-20 h-10 bg-gray-700 flex items-center justify-center text-xs text-brand-muted rounded-md">
                          No Image
                        </div>
                      )}
                    </td>
                    <td
                      className="p-4 font-medium max-w-xs overflow-hidden text-ellipsis whitespace-nowrap"
                      title={article.title}
                    >
                      {article.title}
                    </td>
                    <td className="p-4 text-brand-muted">
                      {article.link ? (
                        <a
                          href={article.link}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="hover:text-white flex items-center gap-1 text-sm"
                        >
                          {article.link.split("/")[2].replace("www.", "")}{" "}
                          <ExternalLink size={14} />
                        </a>
                      ) : (
                        "N/A"
                      )}
                    </td>
                    <td className="p-4 text-brand-muted text-sm">
                      {format(parseISO(article.pubDate), "dd MMM yyyy HH:mm")}
                    </td>
                    <td className="p-4">
                      <span
                        className={`px-2 py-1 text-xs font-semibold rounded-full min-w-[75px] inline-flex justify-center items-center gap-1
                          ${
                            article.status === "processed"
                              ? "bg-green-500/20 text-green-400"
                              : article.status === "fetched"
                              ? "bg-blue-500/20 text-blue-400"
                              : article.status === "skipped"
                              ? "bg-yellow-500/20 text-yellow-400"
                              : "bg-red-500/20 text-red-400"
                          }`}
                      >
                        {processingArticleId === article.articleId ? (
                          <Loader2 size={12} className="animate-spin" />
                        ) : deletingArticleId === article.articleId ? (
                          <Hourglass size={12} className="animate-spin" />
                        ) : article.status === "processed" ? (
                          <CheckCircle size={12} />
                        ) : article.status === "error" ? (
                          <XCircle size={12} />
                        ) : null}
                        {article.status.charAt(0).toUpperCase() +
                          article.status.slice(1)}
                      </span>
                    </td>
                    <td className="p-4 flex gap-2 items-center h-full">
                      <a
                        href={article.link}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-brand-muted hover:text-white p-1 rounded-full bg-brand-dark"
                        title="View Original Article"
                      >
                        <ExternalLink size={18} />
                      </a>
                      {article.status === "fetched" && (
                        <button
                          onClick={() =>
                            handleProcessArticle(article.articleId)
                          }
                          className="text-brand-purple hover:text-brand-purple/80 p-1 rounded-full bg-brand-dark"
                          title="Process with AI"
                          disabled={
                            processArticleMutation.isPending ||
                            deletingArticleId === article.articleId ||
                            !selectedJournalistId
                          } // Disable if no journalist selected
                        >
                          {processingArticleId === article.articleId ? (
                            <Loader2 size={18} className="animate-spin" />
                          ) : (
                            <Sparkles size={18} />
                          )}
                        </button>
                      )}
                      {article.status === "processed" &&
                        article.processedPostId && (
                          <Link
                            href={`/admin/news/edit/${article.processedPostId}`}
                            className="text-blue-400 hover:text-blue-300 p-1 rounded-full bg-brand-dark"
                            title="View Processed Post"
                          >
                            <ExternalLink size={18} />
                          </Link>
                        )}
                      {(article.status === "error" ||
                        article.status === "skipped") && (
                        <button
                          onClick={() =>
                            handleProcessArticle(article.articleId)
                          } // Allow reprocessing
                          className="text-yellow-400 hover:text-yellow-300 p-1 rounded-full bg-brand-dark"
                          title="Retry Processing"
                          disabled={
                            processArticleMutation.isPending ||
                            deletingArticleId === article.articleId ||
                            !selectedJournalistId
                          } // Disable if no journalist selected
                        >
                          {processingArticleId === article.articleId ? (
                            <Loader2 size={18} className="animate-spin" />
                          ) : (
                            <RefreshCw size={18} />
                          )}
                        </button>
                      )}
                      <button
                        onClick={() => handleDeleteArticle(article.articleId)}
                        className="text-red-400 hover:text-red-300 p-1 rounded-full bg-brand-dark"
                        title="Delete External Article"
                        disabled={
                          deleteArticleMutation.isPending ||
                          processingArticleId === article.articleId
                        }
                      >
                        {deletingArticleId === article.articleId ? (
                          <Loader2 size={18} className="animate-spin" />
                        ) : (
                          <Trash2 size={18} />
                        )}
                      </button>
                    </td>
                  </tr>
                ))
              )}
            </tbody>
          </table>
        </div>

        {externalNewsData && externalNewsData.articles.length > 0 && (
          <div className="p-6">
            <Pagination
              currentPage={currentPage}
              totalPages={totalPages}
              onPageChange={setCurrentPage}
            />
          </div>
        )}
      </div>
    </div>
  );
}


// ===== src\app\admin\banners\page.tsx =====
// src/app/admin/banners/page.tsx
"use client";

import { useMemo, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { PlusCircle, Edit, Trash2 } from "lucide-react";
import Image from "next/image";
import { IBanner } from "@/models/Banner";
import BannerFormModal from "@/components/admin/BannerFormModal";
import { AD_SLOTS } from "@/config/adSlots";
import { proxyImageUrl } from "@/lib/image-proxy";

const fetchBanners = async (): Promise<IBanner[]> => {
  const { data } = await axios.get("/api/banners");
  return data;
};

export default function AdminBannersPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingBanner, setEditingBanner] = useState<IBanner | null>(null);

  // Create a lookup map for user-friendly location names
  const locationNameMap = useMemo(
    () => new Map(AD_SLOTS.map((s) => [s.id, s.name])),
    []
  );

  const {
    data: banners,
    isLoading,
    error,
  } = useQuery<IBanner[]>({
    queryKey: ["adminBanners"],
    queryFn: fetchBanners,
  });

  const deleteMutation = useMutation({
    mutationFn: (bannerId: string) => axios.delete(`/api/banners/${bannerId}`),
    onSuccess: () => {
      toast.success("Banner deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["adminBanners"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete banner.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingBanner(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (banner: IBanner) => {
    setEditingBanner(banner);
    setIsModalOpen(true);
  };

  const handleDelete = (bannerId: string) => {
    if (
      window.confirm(
        "Are you sure you want to delete this banner? This action cannot be undone."
      )
    ) {
      deleteMutation.mutate(bannerId);
    }
  };

  if (isLoading) return <p className="text-brand-muted">Loading banners...</p>;
  if (error) return <p className="text-red-400">Failed to load banners.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Manage Ad Banners</h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Banner</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Preview</th>
              <th className="p-4">Title</th>
              <th className="p-4">Location</th> {/* <-- NEW COLUMN */}
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {banners?.map((banner) => (
              <tr
                key={banner._id as string}
                className="border-t border-gray-700/50"
              >
                <td className="p-4">
                  {/* --- THE FIX IS HERE --- */}
                  <Image
                    src={banner.imageUrl}
                    alt={banner.title}
                    width={120}
                    height={60}
                    // Add the objectFit="contain" property here as well.
                    // This was the missing piece from my previous implementation.
                    objectFit="contain"
                    className="rounded-md bg-gray-700"
                  />
                </td>
                <td className="p-4 font-medium">{banner.title}</td>
                <td className="p-4 font-semibold text-brand-light">
                  {locationNameMap.get(banner.location) || banner.location}
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      banner.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {banner.isActive ? "Active" : "Inactive"}
                  </span>
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <button
                    onClick={() => handleOpenEditModal(banner)}
                    className="text-blue-400 hover:text-blue-300"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() => handleDelete(banner._id as string)}
                    className="text-red-400 hover:text-red-300"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {banners?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No banners found. Click "New Banner" to create one.
          </p>
        )}
      </div>

      <BannerFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        banner={editingBanner}
      />
    </div>
  );
}


// ===== src\app\admin\casino-partners\page.tsx =====
// ===== src\app\admin\casino-partners\page.tsx (CORRECTED) =====
"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  PlusCircle,
  Edit,
  Trash2,
  Crown,
  Link as LinkIcon,
  ExternalLink,
  Loader2,
  CheckCircle,
  XCircle,
} from "lucide-react";
import Image from "next/image";

interface ICasinoPartner {
  _id: string;
  name: string;
  logoUrl: string;
  redirectUrl: string;
  description?: string;
  isFeatured: boolean;
  isActive: boolean;
  order: number;
  createdAt: string;
  updatedAt: string;
}

interface CasinoPartnerFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  partner?: ICasinoPartner | null;
}

const CasinoPartnerFormModal: React.FC<CasinoPartnerFormModalProps> = ({
  isOpen,
  onClose,
  partner,
}) => {
  const queryClient = useQueryClient();
  const [name, setName] = useState(partner?.name || "");
  const [logoUrl, setLogoUrl] = useState(partner?.logoUrl || "");
  const [redirectUrl, setRedirectUrl] = useState(partner?.redirectUrl || "");
  const [description, setDescription] = useState(partner?.description || "");
  const [isFeatured, setIsFeatured] = useState(partner?.isFeatured ?? false);
  const [isActive, setIsActive] = useState(partner?.isActive ?? true);
  const [order, setOrder] = useState(partner?.order ?? 0);

  useEffect(() => {
    if (partner) {
      setName(partner.name);
      setLogoUrl(partner.logoUrl);
      setRedirectUrl(partner.redirectUrl);
      setDescription(partner.description || "");
      setIsFeatured(partner.isFeatured);
      setIsActive(partner.isActive);
      setOrder(partner.order);
    } else {
      setName("");
      setLogoUrl("");
      setRedirectUrl("");
      setDescription("");
      setIsFeatured(false);
      setIsActive(true);
      setOrder(0);
    }
  }, [partner]);

  const createMutation = useMutation({
    mutationFn: (newPartner: Partial<ICasinoPartner>) =>
      axios.post("/api/admin/casino-partners", newPartner),
    onSuccess: () => {
      toast.success("Casino Partner created successfully!");
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersAdmin"] });
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersPublic"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to create partner.");
    },
  });

  const updateMutation = useMutation({
    mutationFn: (updatedPartner: Partial<ICasinoPartner>) =>
      axios.put(`/api/admin/casino-partners/${partner?._id}`, updatedPartner),
    onSuccess: () => {
      toast.success("Casino Partner updated successfully!");
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersAdmin"] });
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersPublic"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to update partner.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !logoUrl.trim() || !redirectUrl.trim()) {
      toast.error("Name, Logo URL, and Redirect URL are required.");
      return;
    }

    const payload = {
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured,
      isActive,
      order: Number(order),
    };

    if (partner) {
      updateMutation.mutate(payload);
    } else {
      createMutation.mutate(payload);
    }
  };

  const isPending = createMutation.isPending || updateMutation.isPending;

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl overflow-hidden">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {partner ? "Edit Casino Partner" : "Create New Casino Partner"}
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label
              htmlFor="name"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Partner Name
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
          </div>
          <div>
            <label
              htmlFor="logoUrl"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Logo URL
            </label>
            {/* ===== THE FIX IS HERE ===== */}
            <input
              id="logoUrl"
              type="url" // Changed from "url" to "text" to allow relative paths
              value={logoUrl}
              onChange={(e) => setLogoUrl(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
            {logoUrl && (
              <div className="mt-2 text-center">
                <Image
                  src={logoUrl}
                  alt="Logo Preview"
                  width={80}
                  height={40}
                  objectFit="contain"
                  className="rounded-md bg-gray-800 p-1"
                  // Next/Image handles both relative and absolute URLs correctly
                />
              </div>
            )}
          </div>
          <div>
            <label
              htmlFor="redirectUrl"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Redirect URL (Affiliate Link)
            </label>
            <input
              id="redirectUrl"
              type="url"
              value={redirectUrl}
              onChange={(e) => setRedirectUrl(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
            <p className="text-xs text-brand-muted mt-1">
              This is the link users will be redirected to.
            </p>
          </div>
          <div>
            <label
              htmlFor="description"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Description (Optional)
            </label>
            <textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
              rows={3}
              disabled={isPending}
              placeholder="A short internal description of the partner."
            />
          </div>
          <div className="flex flex-col sm:flex-row sm:items-center sm:gap-4 space-y-3 sm:space-y-0">
            <div className="flex items-center">
              <input
                id="isFeatured"
                type="checkbox"
                checked={isFeatured}
                onChange={(e) => setIsFeatured(e.target.checked)}
                className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
                disabled={isPending}
              />
              <label
                htmlFor="isFeatured"
                className="ml-2 text-sm font-medium text-brand-light"
              >
                Featured (Prominent Styling)
              </label>
            </div>
            <div className="flex items-center">
              <input
                id="isActive"
                type="checkbox"
                checked={isActive}
                onChange={(e) => setIsActive(e.target.checked)}
                className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
                disabled={isPending}
              />
              <label
                htmlFor="isActive"
                className="ml-2 text-sm font-medium text-brand-light"
              >
                Active (Display on site)
              </label>
            </div>
            <div className="flex-grow">
              <label
                htmlFor="order"
                className="block text-sm font-medium text-brand-light mb-1 sm:mb-0"
              >
                Order
              </label>
              <input
                id="order"
                type="number"
                value={order}
                onChange={(e) => setOrder(Number(e.target.value))}
                className="w-20 p-2 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                disabled={isPending}
                min="0"
              />
              <p className="text-xs text-brand-muted mt-1">
                Lower number = higher priority.
              </p>
            </div>
          </div>

          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
              disabled={isPending}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={isPending}
            >
              {isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {isPending
                ? partner
                  ? "Updating..."
                  : "Creating..."
                : partner
                ? "Save Changes"
                : "Create Partner"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

// --- Main Casino Partners Page Component ---
export default function AdminCasinoPartnersPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingPartner, setEditingPartner] = useState<ICasinoPartner | null>(
    null
  );

  const {
    data: partners,
    isLoading,
    error,
  } = useQuery<ICasinoPartner[]>({
    queryKey: ["casinoPartnersAdmin"],
    queryFn: async () => {
      const { data } = await axios.get("/api/admin/casino-partners");
      return data;
    },
    staleTime: 1000 * 60 * 5,
  });

  const deleteMutation = useMutation({
    mutationFn: (partnerId: string) =>
      axios.delete(`/api/admin/casino-partners/${partnerId}`),
    onSuccess: () => {
      toast.success("Casino Partner deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersAdmin"] });
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersPublic"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete partner.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingPartner(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (partner: ICasinoPartner) => {
    setEditingPartner(partner);
    setIsModalOpen(true);
  };

  const handleDelete = (partnerId: string, partnerName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete Casino Partner "${partnerName}"? This action cannot be undone.`
      )
    ) {
      deleteMutation.mutate(partnerId);
    }
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading Casino Partners...</p>;
  if (error)
    return <p className="text-red-400">Failed to load Casino Partners.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Crown size={28} /> Manage Casino Partners
        </h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Partner</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Logo</th>
              <th className="p-4">Name</th>
              <th className="p-4">Featured</th>
              <th className="p-4">Active</th>
              <th className="p-4">Order</th>
              <th className="p-4">Description</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {partners?.map((partner) => (
              <tr key={partner._id} className="border-t border-gray-700/50">
                <td className="p-4">
                  {partner.logoUrl && (
                    <Image
                      src={partner.logoUrl}
                      alt={partner.name}
                      width={60}
                      height={30}
                      objectFit="contain"
                      className="rounded-md bg-gray-700 p-1"
                    />
                  )}
                </td>
                <td className="p-4 font-medium">{partner.name}</td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      partner.isFeatured
                        ? "bg-yellow-500/20 text-yellow-400"
                        : "bg-gray-600/20 text-gray-400"
                    }`}
                  >
                    {partner.isFeatured ? "Yes" : "No"}
                  </span>
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      partner.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {partner.isActive ? "Yes" : "No"}
                  </span>
                </td>
                <td className="p-4 text-brand-muted">{partner.order}</td>
                <td
                  className="p-4 text-brand-muted text-sm max-w-[200px] truncate"
                  title={partner.description}
                >
                  {partner.description || "N/A"}
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <a
                    href={partner.redirectUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-brand-muted hover:text-white"
                    title="Go to Partner Site"
                  >
                    <ExternalLink size={18} />
                  </a>
                  <button
                    onClick={() => handleOpenEditModal(partner)}
                    className="text-blue-400 hover:text-blue-300"
                    title="Edit Partner"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() => handleDelete(partner._id, partner.name)}
                    className="text-red-400 hover:text-red-300"
                    title="Delete Partner"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {partners?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No Casino Partners found. Click "New Partner" to create one.
          </p>
        )}
      </div>

      <CasinoPartnerFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        partner={editingPartner}
      />
    </div>
  );
}


// ===== src\app\admin\dashboard\page.tsx =====
"use client"
import { useTranslation } from '@/hooks/useTranslation';

// This can be a simple server component for now
export default function AdminDashboardPage() {
  const { t } = useTranslation();

  return (
    <div>
      <h1 className="text-3xl font-bold text-white mb-4">{t('admin_dashboard')}</h1>
      <p className="text-brand-muted">{t('welcome_to_admin_area')}</p>
      <div className="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6">
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t('manage_users')}</h3>
          <p className="text-sm text-brand-muted mt-2">{t('view_and_edit_user_roles')}</p>
        </div>
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t('manage_matches')}</h3>
          <p className="text-sm text-brand-muted mt-2">{t('update_match_details')}</p>
        </div>
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t('view_analytics')}</h3>
          <p className="text-sm text-brand-muted mt-2">{t('check_site_traffic')}</p>
        </div>
      </div>
    </div>
  );
}

// ===== src\app\admin\file-manager\page.tsx =====
// src/app/admin/file-manager/page.tsx
"use client";

import { useState, useRef, useEffect } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  UploadCloud,
  CheckCircle,
  XCircle,
  Loader2,
  Link as LinkIcon,
  FileText,
  Download,
  Copy,
  Trash2,
  RefreshCw,
} from "lucide-react"; // Add Trash2
import Image from "next/image";

// Type for a simplified uploaded file representation
interface UploadedFile {
  name: string; // Original file name (or name used on S3) - this is the S3 Key
  url: string; // Public URL
  type: string; // Mime type
  size: number; // Size in bytes
}

// Fetcher function for listing files from S3
const fetchUploadedFiles = async (): Promise<UploadedFile[]> => {
  const { data } = await axios.get("/api/upload"); // Call the new GET endpoint
  return data;
};

export default function AdminFileManagerPage() {
  const queryClient = useQueryClient();
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const [downloadUrl, setDownloadUrl] = useState("");
  const [downloadFileName, setDownloadFileName] = useState("");

  console.log("process.env.NEXT_PUBLIC_R2_PUBLIC_BUCKET_URL");

  console.log(process.env.NEXT_PUBLIC_R2_PUBLIC_BUCKET_URL);

  const {
    data: existingFiles,
    isLoading: isLoadingFiles,
    error: filesError,
    refetch: refetchFiles,
  } = useQuery<UploadedFile[]>({
    queryKey: ["uploadedFiles"],
    queryFn: fetchUploadedFiles,
    staleTime: 1000 * 60 * 5,
  });

  const [currentUploadedFiles, setCurrentUploadedFiles] = useState<
    UploadedFile[]
  >([]);

  useEffect(() => {
    if (existingFiles) {
      setCurrentUploadedFiles(existingFiles);
    }
  }, [existingFiles]);

  const uploadMutation = useMutation({
    mutationFn: (formData: FormData) => axios.post("/api/upload", formData),
    onSuccess: (data) => {
      toast.success("File uploaded successfully!");
      setCurrentUploadedFiles((prev) => [
        {
          name: data.data.name || selectedFile?.name || "Unknown File",
          url: data.data.url,
          type:
            data.data.type || selectedFile?.type || "application/octet-stream",
          size: data.data.size || selectedFile?.size || 0,
        },
        ...prev.filter((f) => f.url !== data.data.url),
      ]);
      setSelectedFile(null);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
      queryClient.invalidateQueries({ queryKey: ["uploadedFiles"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to upload file.");
      setSelectedFile(null);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    },
  });

  const downloadFromUrlMutation = useMutation({
    mutationFn: (payload: { url: string; fileName?: string }) =>
      axios.post("/api/admin/file-manager/download-from-url", payload),
    onSuccess: (data) => {
      toast.success("File downloaded from URL and uploaded!");
      setCurrentUploadedFiles((prev) => [
        {
          name: data.data.name,
          url: data.data.url,
          type: data.data.type,
          size: data.data.size,
        },
        ...prev.filter((f) => f.url !== data.data.url),
      ]);
      setDownloadUrl("");
      setDownloadFileName("");
      queryClient.invalidateQueries({ queryKey: ["uploadedFiles"] });
    },
    onError: (err: any) => {
      toast.error(
        err.response?.data?.error || "Failed to download file from URL."
      );
    },
  });

  // --- NEW: Delete mutation ---
  const deleteFileMutation = useMutation({
    mutationFn: (fileKey: string) => axios.delete(`/api/upload?key=${fileKey}`),
    onSuccess: (_, fileKey) => {
      toast.success("File deleted successfully!");
      // Optimistically update the list
      setCurrentUploadedFiles((prev) => prev.filter((f) => f.name !== fileKey));
      queryClient.invalidateQueries({ queryKey: ["uploadedFiles"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete file.");
    },
  });

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setSelectedFile(file);
    } else {
      setSelectedFile(null);
    }
  };

  const handleUpload = (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedFile) {
      toast.error("Please select a file to upload.");
      return;
    }
    const formData = new FormData();
    formData.append("file", selectedFile);
    uploadMutation.mutate(formData);
  };

  const handleDownloadFromUrl = (e: React.FormEvent) => {
    e.preventDefault();
    if (!downloadUrl.trim()) {
      toast.error("Please enter a URL.");
      return;
    }
    downloadFromUrlMutation.mutate({
      url: downloadUrl,
      fileName: downloadFileName.trim() || undefined,
    });
  };

  const handleDeleteFile = (fileKey: string, fileName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete "${fileName}"? This action cannot be undone.`
      )
    ) {
      deleteFileMutation.mutate(fileKey);
    }
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
    toast.success("URL copied to clipboard!");
  };

  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  };

  const isUploading =
    uploadMutation.isPending || downloadFromUrlMutation.isPending;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <FileText size={28} /> File Manager
        </h1>
      </div>

      {/* File Upload Section */}
      <div className="bg-brand-secondary p-6 rounded-lg mb-8 shadow-xl">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
          <UploadCloud size={24} /> Upload New File
        </h2>
        <form onSubmit={handleUpload} className="space-y-4">
          <div>
            <label
              htmlFor="file-upload"
              className="block text-sm font-medium text-brand-light mb-2"
            >
              Select File
            </label>
            <input
              id="file-upload"
              type="file"
              ref={fileInputRef}
              onChange={handleFileChange}
              className="w-full text-brand-light bg-gray-700 border border-gray-600 rounded-lg p-3 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-brand-purple file:text-white hover:file:opacity-90 cursor-pointer"
              disabled={isUploading}
            />
            {selectedFile && (
              <p className="mt-2 text-sm text-brand-muted">
                Selected: {selectedFile.name} (
                {formatFileSize(selectedFile.size)})
              </p>
            )}
          </div>
          <div className="flex justify-end">
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={!selectedFile || isUploading}
            >
              {uploadMutation.isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {uploadMutation.isPending ? "Uploading..." : "Upload File"}
            </button>
          </div>
        </form>
      </div>

      {/* Download from URL Section */}
      <div className="bg-brand-secondary p-6 rounded-lg mb-8 shadow-xl">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
          <Download size={24} /> Download from URL
        </h2>
        <form onSubmit={handleDownloadFromUrl} className="space-y-4">
          <div>
            <label
              htmlFor="download-url"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              File URL
            </label>
            <input
              id="download-url"
              type="url"
              value={downloadUrl}
              onChange={(e) => setDownloadUrl(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              placeholder="e.g., https://example.com/image.jpg"
              required
              disabled={isUploading}
            />
          </div>
          <div>
            <label
              htmlFor="download-filename"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Optional File Name (on S3)
            </label>
            <input
              id="download-filename"
              type="text"
              value={downloadFileName}
              onChange={(e) => setDownloadFileName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              placeholder="e.g., my-custom-image (extension will be added automatically)"
              disabled={isUploading}
            />
          </div>
          <div className="flex justify-end">
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={!downloadUrl.trim() || isUploading}
            >
              {downloadFromUrlMutation.isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <Download size={18} />
              )}
              {downloadFromUrlMutation.isPending
                ? "Downloading..."
                : "Download & Upload"}
            </button>
          </div>
        </form>
      </div>

      {/* Uploaded Files List */}
      <div className="bg-brand-secondary rounded-lg overflow-hidden shadow-xl">
        <div className="p-6">
          <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
            <LinkIcon size={24} /> Uploaded Files
            <button
              onClick={() => refetchFiles()}
              className="ml-auto text-brand-muted hover:text-white flex items-center gap-1 text-sm"
              disabled={isLoadingFiles || deleteFileMutation.isPending}
            >
              <RefreshCw
                size={16}
                className={isLoadingFiles ? "animate-spin" : ""}
              />{" "}
              Refresh
            </button>
          </h2>
        </div>

        {isLoadingFiles ? (
          <p className="text-center p-8 text-brand-muted">
            Loading files from S3...
          </p>
        ) : filesError ? (
          <p className="text-center p-8 text-red-400">
            Failed to load files from S3: {filesError.message}
          </p>
        ) : currentUploadedFiles.length === 0 ? (
          <p className="text-center p-8 text-brand-muted">
            No files uploaded yet.
          </p>
        ) : (
          <div className="overflow-x-auto">
            <table className="w-full text-left text-brand-light">
              <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
                <tr>
                  <th className="p-4">Preview</th>
                  <th className="p-4">File Name</th>
                  <th className="p-4">Type</th>
                  <th className="p-4">Size</th>
                  <th className="p-4">Public URL</th>
                  <th className="p-4">Actions</th>
                </tr>
              </thead>
              <tbody>
                {currentUploadedFiles.map(
                  (
                    file // Removed 'index' as key, using file.url
                  ) => (
                    <tr key={file.url} className="border-t border-gray-700/50">
                      <td className="p-4">
                        {file.type.startsWith("image/") ? (
                          <Image
                            src={file.url}
                            alt={file.name}
                            width={80}
                            height={45}
                            objectFit="contain"
                            className="rounded-md bg-gray-700"
                          />
                        ) : (
                          <div className="w-20 h-10 bg-gray-700 flex items-center justify-center text-xs text-brand-muted rounded-md">
                            File
                          </div>
                        )}
                      </td>
                      <td
                        className="p-4 font-medium max-w-xs truncate"
                        title={file.name}
                      >
                        {file.name}
                      </td>
                      <td className="p-4 text-brand-muted text-sm">
                        {file.type.split("/")[1] || file.type}
                      </td>
                      <td className="p-4 text-brand-muted text-sm">
                        {formatFileSize(file.size)}
                      </td>
                      <td className="p-4 max-w-sm truncate">
                        <a
                          href={file.url}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="text-blue-400 hover:underline text-sm"
                          title={file.url}
                        >
                          {file.url}
                        </a>
                      </td>
                      <td className="p-4 flex gap-2 items-center">
                        <button
                          onClick={() => copyToClipboard(file.url)}
                          className="text-brand-purple hover:text-brand-purple/80 p-1 rounded-full bg-brand-dark"
                          title="Copy URL"
                        >
                          <Copy size={18} />
                        </button>
                        <button
                          onClick={() => handleDeleteFile(file.name, file.name)} // Pass file.name (which is the S3 Key) for deletion
                          className="text-red-400 hover:text-red-300 p-1 rounded-full bg-brand-dark"
                          title="Delete File"
                          disabled={
                            deleteFileMutation.isPending &&
                            deleteFileMutation.variables === file.name
                          } // Disable if this specific file is pending deletion
                        >
                          {deleteFileMutation.isPending &&
                          deleteFileMutation.variables === file.name ? (
                            <Loader2 size={18} className="animate-spin" />
                          ) : (
                            <Trash2 size={18} />
                          )}
                        </button>
                      </td>
                    </tr>
                  )
                )}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}


// ===== src\app\admin\layout.tsx =====
// src/app/admin/layout.tsx

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { redirect } from "next/navigation";
import AdminSidebar from "@/components/admin/AdminSidebar";
import { LanguageProvider } from "@/context/LanguageContext";

export default async function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await getServerSession(authOptions);

  // 1. UNCOMMENT THIS BLOCK
  if (!session) {
    // Redirect to the login page with an error message indicating forbidden access
    redirect("/login?error=Forbidden");
  }

  // 2. If user is an admin, render the layout...
  return (
     <LanguageProvider>
    <div className="flex min-h-screen">
      <AdminSidebar />
      <main className="flex-1 p-8 bg-brand-dark">
        {children}
      </main>
    </div>
    </LanguageProvider>
  );
}

// ===== src\app\admin\news\create\page.tsx =====
// src/app/admin/news/create/page.tsx
"use client";

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useMutation } from '@tanstack/react-query';
import axios from 'axios';
import toast from 'react-hot-toast';
import Link from '@/components/StyledLink'; 
import Image from 'next/image';
import { UploadCloud, XCircle } from 'lucide-react';

import RichTextEditor from '@/components/admin/RichTextEditor';

export default function CreateNewsPostPage() {
  const router = useRouter();
  // --- STATE FOR NEW FIELDS ---
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [status, setStatus] = useState<'draft' | 'published'>('draft');
  const [metaTitle, setMetaTitle] = useState('');
  const [metaDescription, setMetaDescription] = useState('');
  const [featuredImage, setFeaturedImage] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [imageTitle, setImageTitle] = useState('');
  const [imageAltText, setImageAltText] = useState('');
  const [sport, setSport] = useState('football');

  // --- IMAGE UPLOAD HANDLER ---
  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setIsUploading(true);
    const formData = new FormData();
    formData.append('file', file);

    try {
      const { data } = await axios.post('/api/upload', formData);
      setFeaturedImage(data.url);
      toast.success('Image uploaded!');
    } catch (error) {
      toast.error('Image upload failed.');
    } finally {
      setIsUploading(false);
    }
  };

  // --- MUTATION TO CREATE POST (NOW INCLUDES NEW FIELDS) ---
  const createPostMutation = useMutation({
    mutationFn: (newPost: {
      title: string;
      content: string;
      status: string;
      metaTitle?: string;
      metaDescription?: string;
      featuredImage?: string | null;
      featuredImageTitle?: string;
      featuredImageAltText?: string;
      sport: string,

    }) => {
      return axios.post('/api/posts', newPost);
    },
    onSuccess: () => {
      toast.success('Post created successfully!');
      router.push('/admin/news');
      router.refresh();
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.error || 'Failed to create post.');
    }
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!title.trim() || !content.trim()) {
        toast.error('Title and content cannot be empty.');
        return;
    }
    createPostMutation.mutate({
      title,
      content,
      status,
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle: imageTitle,
      featuredImageAltText: imageAltText,
      sport,
    });
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Create New Post</h1>
      </div>

      <form onSubmit={handleSubmit} className="bg-brand-secondary p-6 rounded-lg space-y-6">
        
        {/* --- ENHANCED: FEATURED IMAGE SECTION --- */}
        <div className="p-4 border border-gray-600 rounded-lg">
          <label className="block text-sm font-medium text-brand-light mb-2">Featured Image</label>
          <div className="mt-2 flex justify-center rounded-lg border border-dashed border-gray-600 px-6 py-10">
            {featuredImage ? (
              <div className="relative group w-full h-64">
                <Image src={featuredImage} alt={imageAltText || 'Featured preview'} layout="fill" objectFit="contain" />
                <button
                  type="button"
                  onClick={() => setFeaturedImage(null)}
                  className="absolute top-2 right-2 bg-red-600 rounded-full p-1 text-white opacity-0 group-hover:opacity-100 transition-opacity"
                >
                  <XCircle size={20} />
                </button>
              </div>
            ) : (
              <div className="text-center">
                <UploadCloud className="mx-auto h-12 w-12 text-gray-500" />
                <div className="mt-4 flex text-sm leading-6 text-gray-400">
                  <label htmlFor="file-upload" className="relative cursor-pointer rounded-md font-semibold text-brand-purple focus-within:outline-none focus-within:ring-2 focus-within:ring-brand-purple focus-within:ring-offset-2 focus-within:ring-offset-brand-dark hover:text-brand-purple/80">
                    <span>{isUploading ? 'Uploading...' : 'Upload a file'}</span>
                    <input id="file-upload" name="file-upload" type="file" className="sr-only" onChange={handleImageUpload} disabled={isUploading} accept="image/*" />
                  </label>
                  <p className="pl-1">or drag and drop</p>
                </div>
                <p className="text-xs leading-5 text-gray-500">PNG, JPG, GIF up to 10MB</p>
              </div>
            )}
          </div>
        </div>

        {featuredImage && (
            <div className="mt-4 space-y-4">
              <div>
                <label htmlFor="imageTitle" className="block text-sm font-medium text-brand-light mb-2">Image Title (Tooltip)</label>
                <input id="imageTitle" type="text" value={imageTitle} onChange={(e) => setImageTitle(e.target.value)} placeholder="e.g., Team celebrating a goal" className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple" />
              </div>
              <div>
                <label htmlFor="imageAltText" className="block text-sm font-medium text-brand-light mb-2">Image Alt Text (Accessibility & SEO)</label>
                <input id="imageAltText" type="text" value={imageAltText} onChange={(e) => setImageAltText(e.target.value)} placeholder="e.g., Player in red jersey kicking a football" className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple" />
                 <p className="text-xs text-brand-muted mt-1">Describe the image for screen readers and search engines.</p>
              </div>
            </div>
          )}

        {/* Title Field (No change) */}
        <div>
          <label htmlFor="title" className="block text-sm font-medium text-brand-light mb-2">Title</label>
          <input id="title" type="text" value={title} onChange={(e) => setTitle(e.target.value)} required className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple" />
        </div>

        {/* Content Field (No change) */}
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">Content</label>
          <RichTextEditor value={content} onChange={setContent} />
        </div>

        {/* --- SEO & META FIELDS SECTION --- */}
        <div className="space-y-4 p-4 border border-gray-600 rounded-lg">
            <h3 className="text-lg font-semibold text-white">SEO Settings</h3>
            <div>
              <label htmlFor="metaTitle" className="block text-sm font-medium text-brand-light mb-2">Meta Title</label>
              <input id="metaTitle" type="text" value={metaTitle} onChange={(e) => setMetaTitle(e.target.value)} placeholder="e.g., Ultimate Guide to Sunday's Match" className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple" />
              <p className="text-xs text-brand-muted mt-1">Recommended: 50-60 characters.</p>
            </div>
            <div>
              <label htmlFor="metaDescription" className="block text-sm font-medium text-brand-light mb-2">Meta Description</label>
              <textarea id="metaDescription" rows={3} value={metaDescription} onChange={(e) => setMetaDescription(e.target.value)} placeholder="A brief summary for search engines..." className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple" />
              <p className="text-xs text-brand-muted mt-1">Recommended: 150-160 characters.</p>
            </div>
        </div>

        {/* Status Field (No change) */}
        <div>
          <label htmlFor="status" className="block text-sm font-medium text-brand-light mb-2">Status</label>
          <select id="status" value={status} onChange={(e) => setStatus(e.target.value as 'draft' | 'published')} className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple">
            <option value="draft">Draft</option>
            <option value="published">Published</option>
          </select>
        </div>

                  <div>
            <label htmlFor="sport" className="block text-sm font-medium text-brand-light mb-2">Sport Category</label>
            <select 
              id="sport" 
              value={sport} 
              onChange={(e) => setSport(e.target.value)} 
              className="w-full p-3 rounded bg-gray-700 text-white ..."
            >
              <option value="football">Football</option>
              <option value="basketball">Basketball</option>
              <option value="tennis">Tennis</option>
              <option value="general">General</option>
            </select>
          </div>

        {/* Action Buttons (No change) */}
        <div className="flex justify-end gap-4 pt-4 border-t border-gray-600">
          <Link href="/admin/news" className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90">Cancel</Link>
          <button type="submit" disabled={createPostMutation.isPending || isUploading} className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed">
            {createPostMutation.isPending ? 'Saving...' : 'Save Post'}
          </button>
        </div>
      </form>
    </div>
  );
}

// ===== src\app\admin\news\edit\[postId]\page.tsx =====
// src/app/admin/news/edit/[postId]/page.tsx
"use client";

import { useState, useEffect } from 'react';
import { useRouter, useParams } from 'next/navigation';
import { useQuery, useMutation } from '@tanstack/react-query';
import axios from 'axios';
import toast from 'react-hot-toast';
import Link from '@/components/StyledLink'; 
import RichTextEditor from '@/components/admin/RichTextEditor';
import { IPost } from '@/models/Post';

// Fetcher function for a single post
const fetchPost = async (postId: string): Promise<IPost> => {
    const { data } = await axios.get(`/api/posts/${postId}`);
    return data;
};

export default function EditNewsPostPage() {
  const router = useRouter();
  const params = useParams();
  const postId = params.postId as string;

  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [status, setStatus] = useState<'draft' | 'published'>('draft');

  // 1. Fetch the existing post data
  const { data: postData, isLoading, isError } = useQuery<IPost>({
    queryKey: ['post', postId],
    queryFn: () => fetchPost(postId),
    enabled: !!postId, // Only run query if postId exists
  });

  // 2. Pre-fill the form once data is fetched
  useEffect(() => {
    if (postData) {
      setTitle(postData.title);
      setContent(postData.content);
      setStatus(postData.status);
    }
  }, [postData]);

  // 3. Mutation to update the post
  const updatePostMutation = useMutation({
    mutationFn: (updatedPost: { title: string; content: string; status: string; }) => {
      return axios.put(`/api/posts/${postId}`, updatedPost);
    },
    onSuccess: () => {
      toast.success('Post updated successfully!');
      router.push('/admin/news');
      router.refresh();
    },
    onError: (error: any) => {
      const errorMessage = error.response?.data?.error || 'Failed to update post.';
      toast.error(errorMessage);
    }
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!title.trim() || !content.trim()) {
        toast.error('Title and content cannot be empty.');
        return;
    }
    updatePostMutation.mutate({ title, content, status });
  };
  
  if (isLoading) return <p className="text-brand-muted">Loading post data...</p>;
  if (isError) return <p className="text-red-400">Failed to load post data.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Edit Post</h1>
        <Link href="/admin/news" className="text-sm text-brand-muted hover:text-white">
           Back to News List
        </Link>
      </div>

      <form onSubmit={handleSubmit} className="bg-brand-secondary p-6 rounded-lg space-y-6">
        {/* Title Field */}
        <div>
          <label htmlFor="title" className="block text-sm font-medium text-brand-light mb-2">Title</label>
          <input id="title" type="text" value={title} onChange={(e) => setTitle(e.target.value)} className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple" required/>
        </div>
        
        {/* Content Field (Rich Text Editor) */}
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">Content</label>
          {/* We must wait for content to be loaded before rendering the editor */}
          {content && <RichTextEditor value={content} onChange={setContent} />}
        </div>

        {/* Status Field */}
        <div>
          <label htmlFor="status" className="block text-sm font-medium text-brand-light mb-2">Status</label>
          <select id="status" value={status} onChange={(e) => setStatus(e.target.value as 'draft' | 'published')} className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple">
            <option value="draft">Draft</option>
            <option value="published">Published</option>
          </select>
        </div>

        {/* Action Buttons */}
        <div className="flex justify-end gap-4">
          <Link href="/admin/news" className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 transition-opacity">Cancel</Link>
          <button type="submit" disabled={updatePostMutation.isPending} className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 transition-opacity disabled:opacity-50 disabled:cursor-not-allowed">
            {updatePostMutation.isPending ? 'Saving...' : 'Save Changes'}
          </button>
        </div>
      </form>
    </div>
  );
}

// ===== src\app\admin\news\page.tsx =====
"use client";

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import Link from "@/components/StyledLink";
import { PlusCircle, Edit, Trash2, Lightbulb } from "lucide-react";
import { format } from "date-fns";
import { IPost } from "@/models/Post";
import toast from "react-hot-toast";
import Image from "next/image"; // <-- NEW IMPORT

// Fetcher function
const fetchPosts = async (): Promise<IPost[]> => {
  const { data } = await axios.get("/api/posts");
  return data;
};

export default function AdminNewsPage() {
  const queryClient = useQueryClient();

  const {
    data: posts,
    isLoading,
    error,
  } = useQuery<IPost[]>({
    queryKey: ["adminPosts"],
    queryFn: fetchPosts,
  });

  const deleteMutation = useMutation({
    mutationFn: (postId: string) => axios.delete(`/api/posts/${postId}`),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["adminPosts"] });
      // BEFORE: alert('Post deleted!');
      toast.success("Post deleted successfully!"); //
    },
    onError: (error: any) => {
      // BEFORE: alert('Error deleting post.');
      const message = error.response?.data?.message || "Error deleting post.";
      toast.error(message); //
    },
  });

  const handleDelete = (postId: string) => {
    if (window.confirm("Are you sure you want to delete this post?")) {
      deleteMutation.mutate(postId);
    }
  };

  if (isLoading) return <p className="text-brand-muted">Loading posts...</p>;
  if (error) return <p className="text-red-400">Failed to load posts.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Manage News</h1>
        <Link
          href="/admin/news/create"
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 transition-opacity"
        >
          <PlusCircle size={20} />
          <span>New Post</span>
        </Link>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-hidden">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Preview</th> {/* <-- NEW COLUMN HEADER */}
              <th className="p-4">Title</th>
              <th className="p-4">Status</th>
              <th className="p-4">Type</th>
              <th className="p-4">Created At</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {posts?.map((post) => (
              <tr
                key={post._id as string}
                className="border-t border-gray-700/50"
              >
                {/* --- NEW COLUMN CONTENT --- */}
                <td className="p-4">
                  {post.featuredImage ? (
                    <Image
                      src={post.featuredImage}
                      alt={post.title}
                      width={100} // Adjust width as needed for preview
                      height={56} // Maintain aspect ratio for common image sizes (16:9)
                      objectFit="cover" // Cover the area, cropping if necessary
                      className="rounded-md bg-gray-700"
                    />
                  ) : (
                    <div className="w-[100px] h-[56px] bg-gray-700 rounded-md flex items-center justify-center text-xs text-brand-muted">
                      No Image
                    </div>
                  )}
                </td>
                <td className="p-4 font-medium">{post.title}</td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      post.status === "published"
                        ? "bg-green-500/20 text-green-400"
                        : "bg-yellow-500/20 text-yellow-400"
                    }`}
                  >
                    {post.status}
                  </span>
                </td>
                <td className="p-4">
                  {post.isAIGenerated && (
                    <span className="flex items-center gap-1 px-2 py-1 text-xs font-semibold rounded-full bg-blue-500/20 text-blue-400">
                      <Lightbulb size={12} /> AI
                    </span>
                  )}
                  {!post.isAIGenerated && (
                    <span className="px-2 py-1 text-xs font-semibold rounded-full bg-gray-600/20 text-gray-400">
                      Manual
                    </span>
                  )}
                </td>
                <td className="p-4 text-brand-muted">
                  {format(new Date(post.createdAt), "dd MMM yyyy")}
                </td>
                <td className="p-4 flex gap-3">
                  <Link
                    href={`/admin/news/edit/${post._id}`}
                    className="text-blue-400 hover:text-blue-300"
                  >
                    <Edit size={18} />
                  </Link>
                  <button
                    onClick={() => handleDelete(post._id as string)}
                    className="text-red-400 hover:text-red-300"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {/* Optional: Message if no posts found */}
        {posts?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No news posts found. Create one manually or process an external
            article using the Automated News Engine.
          </p>
        )}
      </div>
    </div>
  );
}


// ===== src\app\api\active-leagues\route.ts =====
// src/app/api/active-leagues/route.ts
import { NextResponse } from "next/server";
import axios from "axios";
import { format, addDays } from "date-fns";

// A curated list of leagues to check for activity.
// Checking EVERY single league would be too slow and hit API rate limits.
// This list should contain leagues you generally expect to be active.
const LEAGUES_TO_CHECK = [
  39,
  140,
  135,
  78,
  61,
  2,
  3,
  88,
  94,
  253,
  45,
  48,
  71,
  62,
  144,
  203,
  197,
  218, // Premier League, La Liga, Serie A, Bundesliga, Ligue 1, UCL, UEL, Eredivisie, etc.
];

export async function GET() {
  const today = format(new Date(), "yyyy-MM-dd");
  const nextSevenDays = format(addDays(new Date(), 7), "yyyy-MM-dd");

  const options = (leagueId: number) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: {
      league: leagueId,
      season: new Date().getFullYear().toString(),
      from: today,
      to: nextSevenDays,
    },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    // Create an array of promises, one for each league check
    const fixtureChecks = LEAGUES_TO_CHECK.map((id) =>
      axios.request(options(id)).then((response) => ({
        leagueId: id,
        hasFixtures: response.data.results > 0,
      }))
    );

    // Execute all checks in parallel
    const results = await Promise.allSettled(fixtureChecks);

    // Filter out failed requests and leagues with no fixtures
    const activeLeagueIds = results
      .filter(
        (result) => result.status === "fulfilled" && result.value.hasFixtures
      )
      .map(
        (result) =>
          (result as PromiseFulfilledResult<{ leagueId: number }>).value
            .leagueId
      );

    return NextResponse.json(activeLeagueIds);
  } catch (error) {
    console.error("Error fetching active leagues:", error);
    return NextResponse.json(
      { error: "Failed to determine active leagues." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\admin\ai-journalists\route.ts =====
// src/app/api/admin/ai-journalists/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import AIJournalist, { IAIJournalist } from "@/models/AIJournalist";

// GET handler to retrieve a list of all AI Journalists
export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const journalists = await AIJournalist.find({}).sort({ name: 1 }).lean();
    return NextResponse.json(journalists, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching AI Journalists:", error.message);
    return NextResponse.json(
      { error: "Server error fetching AI Journalists." },
      { status: 500 }
    );
  }
}

// POST handler to create a new AI Journalist
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body: Partial<IAIJournalist> = await request.json();
    const { name, description, tonePrompt, isActive } = body;

    if (!name || !tonePrompt) {
      return NextResponse.json(
        { error: "Name and Tone Prompt are required." },
        { status: 400 }
      );
    }

    const newJournalist = new AIJournalist({
      name,
      description,
      tonePrompt,
      isActive: isActive !== undefined ? isActive : true, // Default to active
    });

    await newJournalist.save();
    return NextResponse.json(newJournalist, { status: 201 });
  } catch (error: any) {
    console.error("Error creating AI Journalist:", error.message);
    if (error.code === 11000) {
      // Duplicate key error
      return NextResponse.json(
        { error: "Journalist with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error creating AI Journalist." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\admin\ai-journalists\[journalistId]\route.ts =====
// src/app/api/admin/ai-journalists/[journalistId]/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import AIJournalist, { IAIJournalist } from "@/models/AIJournalist";

interface Params {
  params: { journalistId: string };
}

// GET handler to retrieve a single AI Journalist (optional, but good for editing)
export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { journalistId } = params;
    const journalist = await AIJournalist.findById(journalistId).lean();

    if (!journalist) {
      return NextResponse.json(
        { error: "AI Journalist not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(journalist, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error fetching AI Journalist ${params.journalistId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching AI Journalist." },
      { status: 500 }
    );
  }
}

// PUT handler to update an existing AI Journalist
export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { journalistId } = params;
    const body: Partial<IAIJournalist> = await request.json();
    const { name, description, tonePrompt, isActive } = body;

    // Optional: Basic validation if all fields are sent in PUT
    // If only partial updates are expected, this validation might be too strict.
    // Assuming a full form submission for update.
    if (!name || !tonePrompt) {
      return NextResponse.json(
        { error: "Name and Tone Prompt are required." },
        { status: 400 }
      );
    }

    const updatedJournalist = await AIJournalist.findByIdAndUpdate(
      journalistId,
      { name, description, tonePrompt, isActive },
      { new: true, runValidators: true } // Return the updated document, run schema validators
    );

    if (!updatedJournalist) {
      return NextResponse.json(
        { error: "AI Journalist not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(updatedJournalist, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error updating AI Journalist ${params.journalistId}:`,
      error.message
    );
    if (error.code === 11000) {
      // Duplicate key error
      return NextResponse.json(
        { error: "Journalist with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error updating AI Journalist." },
      { status: 500 }
    );
  }
}

// DELETE handler to delete an AI Journalist
export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { journalistId } = params;
    const deletedJournalist = await AIJournalist.findByIdAndDelete(
      journalistId
    );

    if (!deletedJournalist) {
      return NextResponse.json(
        { error: "AI Journalist not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { message: "AI Journalist deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      `Error deleting AI Journalist ${params.journalistId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error deleting AI Journalist." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\admin\ai-prompt\route.ts =====
// src/app/api/admin/ai-prompt/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import AIPrompt, { IAIPrompt } from "@/models/AIPrompt";

const PROMPT_NAME = "News Rewriting"; // A fixed name for the prompt we will manage

// GET handler to retrieve the AI prompt
export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    // Find the prompt by its predefined name
    const promptDoc = await AIPrompt.findOne({ name: PROMPT_NAME });

    if (!promptDoc) {
      // If no prompt exists, return a default one and it will be saved on first PUT
      // This default prompt is critical as it instructs the AI on overall article structure and formatting.
      return NextResponse.json(
        {
          name: PROMPT_NAME,
          prompt:
            "You are an expert sports journalist and content creator with a keen eye for engaging narratives and high humanized accuracy. Your task is to analyze the core information and context from the following sports news content. Based on this, **generate a completely new, original, and expanded article**, approximately 700 words long, suitable for a leading sports news website. Your goal is to make the article feel like it was written by a human expert, not an AI, focusing on deep insights, storytelling, and compelling analysis.\n\n**PRIORITY 1: NEW ORIGINAL TITLE (Single Line)**\nYour **absolute first instruction** is to generate a compelling, highly SEO-friendly, and **BRAND NEW, ORIGINAL TITLE** for this article. This title **MUST be unique** and distinct from the original, but accurately reflect the new article's core topic. The title should be on a single line, and **MUST NOT** include any HTML tags, Markdown formatting (e.g., no bolding, italics, headings like # or ##), or introductory phrases like 'Title: ' or 'New Title: '.\n\n**PRIORITY 2: EXACT SEPARATOR (On its own line)**\nImmediately after the title line, on its own line, you **MUST** place the exact unique separator: `---ARTICLE_CONTENT_STARTS_HERE---`\n\n**PRIORITY 3: HUMANIZED HTML ARTICLE CONTENT**\nThe rest of your response **MUST be the complete humanized article content, written entirely using valid HTML tags.** Avoid any Markdown syntax. Specifically, use `<h2>` for major section headings, `<p>` for paragraphs, `<strong>` for bold text, `<em>` for italic text, `<ul>` and `<li>` for lists, and `<a>` for links. **Ensure the content is well-structured, flows naturally, provides rich detail, and sounds genuinely human-written. Do NOT simply rephrase sentences; genuinely expand and add value.** Include an engaging introduction, several distinct body paragraphs that elaborate on key facts, implications, and broader context, and a strong, forward-looking conclusion. Do NOT use placeholder text for images.\n\n**HTML Example Structure (Strictly follow this style, without preamble or extra text):**\n<h2>Introduction Heading</h2>\n<p>This is the engaging introduction paragraph. It sets the scene for the article content, drawing the reader in with compelling language...</p>\n<h2>Key Development Heading</h2>\n<p>Here's a detailed paragraph on a specific aspect of the news, expanding on the original information with <strong>important facts</strong> and <em>key insights</em>. Consider historical context or future implications. Link to <a href=\"https://example.com/relevant-source\">relevant external sources</a> if appropriate, ensuring the links are valid HTML.</p>\n<ul>\n<li>Detailed point one expanding on the topic.</li>\n<li>Detailed point two with further analysis.</li>\n</ul>\n<p>Another paragraph providing deeper analysis and commentary, making the article feel unique and insightful.</p>\n<h2>Conclusion Heading</h2>\n<p>The concluding paragraph summarizes the article's main points and offers a compelling forward-looking perspective, encouraging discussion or future anticipation.</p>\n\n**IMPORTANT CONSIDERATION:** If the provided original content is too short or lacks sufficient detail for a 700-word expansion with humanized quality, respond only with 'CONTENT INSUFFICIENT FOR EXPANSION: [brief reason]' and no other text. Otherwise, produce the full article following the exact HTML structure and word count.\n\nHere is the original news content (may include raw article text, description, or webpage snippets):\n{article_content}",
        },
        { status: 200 }
      );
    }

    return NextResponse.json(promptDoc, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching AI prompt:", error.message);
    return NextResponse.json(
      { error: "Server error fetching AI prompt." },
      { status: 500 }
    );
  }
}

// PUT handler to update the AI prompt
export async function PUT(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { prompt, description }: { prompt: string; description?: string } =
      await request.json();

    if (!prompt) {
      return NextResponse.json(
        { error: "Prompt content is required." },
        { status: 400 }
      );
    }

    // Find and update the prompt, or create it if it doesn't exist
    const updatedPrompt = await AIPrompt.findOneAndUpdate(
      { name: PROMPT_NAME }, // Find by the fixed name
      { prompt, description, name: PROMPT_NAME }, // Ensure name is set for new creation
      { upsert: true, new: true, runValidators: true } // Create if not found, return new doc, run schema validators
    );

    return NextResponse.json(updatedPrompt, { status: 200 });
  } catch (error: any) {
    console.error("Error updating AI prompt:", error.message);
    return NextResponse.json(
      { error: "Server error updating AI prompt." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\admin\casino-partners\route.ts =====
// src/app/api/admin/casino-partners/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import CasinoPartner, { ICasinoPartner } from "@/models/CasinoPartner";

// GET handler to retrieve a list of all Casino Partners for admin
export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    // Sort by 'order' ascending, then by 'createdAt' descending (newest first for same order)
    const partners = await CasinoPartner.find({})
      .sort({ order: 1, createdAt: -1 })
      .lean();
    return NextResponse.json(partners, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching Casino Partners (Admin):", error.message);
    return NextResponse.json(
      { error: "Server error fetching Casino Partners." },
      { status: 500 }
    );
  }
}

// POST handler to create a new Casino Partner
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body: Partial<ICasinoPartner> = await request.json();
    const {
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured,
      isActive,
      order,
    } = body;

    if (!name || !logoUrl || !redirectUrl) {
      return NextResponse.json(
        { error: "Name, Logo URL, and Redirect URL are required." },
        { status: 400 }
      );
    }

    const newPartner = new CasinoPartner({
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured: isFeatured !== undefined ? isFeatured : false,
      isActive: isActive !== undefined ? isActive : true, // Default to active
      order: order !== undefined ? order : 0, // Default order
    });

    await newPartner.save();
    return NextResponse.json(newPartner, { status: 201 });
  } catch (error: any) {
    console.error("Error creating Casino Partner:", error.message);
    if (error.code === 11000) {
      // Duplicate key error
      return NextResponse.json(
        { error: "Partner with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error creating Casino Partner." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\admin\casino-partners\[partnerId]\route.ts =====
// src/app/api/admin/casino-partners/[partnerId]/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import CasinoPartner, { ICasinoPartner } from "@/models/CasinoPartner";

interface Params {
  params: { partnerId: string };
}

// GET handler to retrieve a single Casino Partner (optional, but good for editing)
export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { partnerId } = params;
    const partner = await CasinoPartner.findById(partnerId).lean();

    if (!partner) {
      return NextResponse.json(
        { error: "Casino Partner not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(partner, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error fetching Casino Partner ${params.partnerId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching Casino Partner." },
      { status: 500 }
    );
  }
}

// PUT handler to update an existing Casino Partner
export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { partnerId } = params;
    const body: Partial<ICasinoPartner> = await request.json();
    const {
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured,
      isActive,
      order,
    } = body;

    // Basic validation
    if (!name || !logoUrl || !redirectUrl) {
      return NextResponse.json(
        { error: "Name, Logo URL, and Redirect URL are required." },
        { status: 400 }
      );
    }

    const updatedPartner = await CasinoPartner.findByIdAndUpdate(
      partnerId,
      { name, logoUrl, redirectUrl, description, isFeatured, isActive, order },
      { new: true, runValidators: true } // Return the updated document, run schema validators
    );

    if (!updatedPartner) {
      return NextResponse.json(
        { error: "Casino Partner not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(updatedPartner, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error updating Casino Partner ${params.partnerId}:`,
      error.message
    );
    if (error.code === 11000) {
      // Duplicate key error
      return NextResponse.json(
        { error: "Partner with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error updating Casino Partner." },
      { status: 500 }
    );
  }
}

// DELETE handler to delete a Casino Partner
export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { partnerId } = params;
    const deletedPartner = await CasinoPartner.findByIdAndDelete(partnerId);

    if (!deletedPartner) {
      return NextResponse.json(
        { error: "Casino Partner not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { message: "Casino Partner deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      `Error deleting Casino Partner ${params.partnerId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error deleting Casino Partner." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\admin\external-news\route.ts =====
// ===== src\app\api\admin\process-external-news\route.ts =====
// This file now orchestrates the entire AI news generation process directly.

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle, {
  IExternalNewsArticle,
} from "@/models/ExternalNewsArticle";
import Post from "@/models/Post";
import AIPrompt from "@/models/AIPrompt";
import AIJournalist from "@/models/AIJournalist";
import { GoogleGenerativeAI } from "@google/generative-ai";
import axios from "axios";
import sharp from "sharp";
import crypto from "crypto";
import slugify from "slugify";
import * as cheerio from "cheerio";
import MarkdownIt from "markdown-it";
// NEW IMPORTS FOR LOCAL FILESYSTEM
import path from "path";
import { promises as fs } from "fs";

// Initialize markdown-it for HTML conversion
const md = new MarkdownIt({
  html: true,
  linkify: true,
  typographer: true,
});

// --- NEW LOCAL FILESYSTEM DEFINITIONS ---
const UPLOAD_DIR = path.join(process.cwd(), "public/uploads");
const ensureUploadDirExists = async () => {
  try {
    await fs.mkdir(UPLOAD_DIR, { recursive: true });
  } catch (e) {
    console.error(
      "Critical: Could not create upload directory for news engine.",
      e
    );
    throw new Error(
      "Server configuration error: cannot create storage directory."
    );
  }
};

const generateFileName = (bytes = 32) =>
  crypto.randomBytes(bytes).toString("hex");

// --- REWRITTEN: proxyAndUploadOriginalImage function ---
/**
 * Generates an image by proxying the original external article's image and saving it locally.
 * This is a standalone helper that can be called if AI image generation is not enabled or fails.
 * @param imageUrl The URL of the image to proxy.
 * @param newPostTitle The title of the new post for alt/title text.
 * @returns The local public URL of the processed image, or null if failed.
 */
async function proxyAndUploadOriginalImage(
  imageUrl: string,
  newPostTitle: string
): Promise<string | null> {
  try {
    console.log(
      `[Image Processing] Attempting to proxy original image: ${imageUrl}`
    );
    const imageResponse = await axios.get(imageUrl, {
      responseType: "arraybuffer",
      timeout: 15000,
      maxRedirects: 5,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });
    console.log(
      `[Image Processing] Original image download successful for ${imageUrl}. Size: ${imageResponse.data.length} bytes. Content-Type: ${imageResponse.headers["content-type"]}`
    );

    const inputBuffer = Buffer.from(imageResponse.data, "binary");
    const originalContentType =
      imageResponse.headers["content-type"] || "image/jpeg";

    let finalBuffer: Buffer;
    let fileExtension = ".webp"; // Default to webp after sharp processing

    if (originalContentType.includes("image/gif")) {
      finalBuffer = inputBuffer;
      fileExtension = ".gif";
      console.log(
        `[Image Processing] GIF detected, bypassing Sharp for ${imageUrl}.`
      );
    } else {
      try {
        finalBuffer = await sharp(inputBuffer)
          .resize(1200, 630, { fit: "cover" })
          .webp({ quality: 80 })
          .toBuffer();
        console.log(
          `[Image Processing] Resized and converted original image to WebP for ${imageUrl}.`
        );
      } catch (sharpError: any) {
        console.error(
          `[Image Processing] Sharp processing failed for original image ${imageUrl}:`,
          sharpError.message
        );
        finalBuffer = inputBuffer; // Fallback to original buffer
        fileExtension = path.extname(new URL(imageUrl).pathname) || ".jpg"; // Fallback extension
        console.warn(
          `[Image Processing] Using original image buffer as fallback (without sharp processing) for ${imageUrl}.`
        );
      }
    }

    const newFileName = generateFileName() + fileExtension;

    // Save to local filesystem
    const filePath = path.join(UPLOAD_DIR, newFileName);
    await ensureUploadDirExists();
    await fs.writeFile(filePath, finalBuffer);

    // Return the public relative URL
    const localUrl = `/uploads/${newFileName}`;
    console.log(
      `[Image Processing] Original image successfully saved locally: ${localUrl}`
    );
    return localUrl;
  } catch (imageError: any) {
    console.error(
      `[Image Processing] Failed to process/upload original image (URL: ${imageUrl}):`,
      imageError.message
    );
    if (axios.isAxiosError(imageError) && imageError.response) {
      console.error(
        `[Image Processing] Axios HTTP Error - Status: ${imageError.response.status}, Data:`,
        imageError.response.data
      );
    }
    return null;
  }
}

// --- Initialize Google Generative AI ---
// IMPORTANT: Ensure GEMINI_API_KEY is correctly set in .env.local (no NEXT_PUBLIC_ prefix for server-side)
const genAI = new GoogleGenerativeAI(
  process.env.NEXT_PUBLIC_GEMINI_API_KEY as string
); // Assuming GEMINI_API_KEY is server-side only
const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash-latest" });

// Fixed names for the AI prompts (must match names used in AIPrompt DB)
const TITLE_PROMPT_NAME = "AI Title Generation";
const CONTENT_PROMPT_NAME = "AI Content Generation";

/**
 * Helper for Jaccard Similarity.
 * Used for title uniqueness validation.
 * @param str1 First string.
 * @param str2 Second string.
 * @returns Jaccard similarity score (0.0 to 1.0).
 */
function calculateJaccardSimilarity(str1: string, str2: string): number {
  const words1 = new Set(str1.toLowerCase().split(/\s+/).filter(Boolean));
  const words2 = new Set(str2.toLowerCase().split(/\s+/).filter(Boolean));

  if (words1.size === 0 && words2.size === 0) return 1.0;
  if (words1.size === 0 || words2.size === 0) return 0.0;

  const intersection = new Set([...words1].filter((word) => words2.has(word)));
  const union = new Set([...words1, ...words2]);
  return intersection.size / union.size;
}

/**
 * Fetches content from a given URL and attempts to extract main article text.
 * @param url The URL to fetch.
 * @returns Extracted text content or null if failed.
 */
async function fetchAndExtractWebpageContent(
  url: string
): Promise<string | null> {
  try {
    console.log(
      `[Content Extraction Helper] Attempting to fetch content from: ${url}`
    );
    const response = await axios.get(url, {
      timeout: 10000,
      maxRedirects: 5,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });

    if (response.status !== 200) {
      console.warn(
        `[Content Extraction Helper] Failed to fetch content from ${url}: Status ${response.status}`
      );
      return null;
    }

    const $ = cheerio.load(response.data);

    const contentSelectors = [
      "article",
      "main",
      ".article-content",
      ".post-content",
      ".entry-content",
      ".story-content",
      ".body-content",
      "#article-body",
      "#main-content",
      "#content",
      "p",
    ];

    let extractedText = "";
    for (const selector of contentSelectors) {
      const element = $(selector);
      if (element.length > 0) {
        element
          .find(
            "script, style, header, footer, nav, aside, form, iframe, .ad-unit"
          )
          .remove();
        extractedText = element.text();
        if (extractedText.length > 200) {
          console.log(
            `[Content Extraction Helper] Found substantial content using selector: ${selector}`
          );
          break;
        }
      }
    }

    extractedText = extractedText.replace(/\s\s+/g, " ").trim();
    console.log(
      `[Content Extraction Helper] Extracted text length: ${extractedText.length}`
    );

    return extractedText.length > 0 ? extractedText : null;
  } catch (error: any) {
    console.error(
      `[Content Extraction Helper] Error fetching or extracting content from ${url}:`,
      error.message
    );
    return null;
  }
}

/**
 * Generates an AI-driven article title.
 * @param originalTitle The original news title.
 * @param originalDescription The original news description.
 * @param journalistId Optional ID of the AI Journalist to use.
 * @returns The AI-generated new title.
 * @throws Error if title generation fails or output is invalid.
 */
async function generateTitle(
  originalTitle: string,
  originalDescription: string,
  journalistId?: string
): Promise<string> {
  const titlePromptDoc = await AIPrompt.findOne({
    name: TITLE_PROMPT_NAME,
    type: "title",
  });
  if (!titlePromptDoc) {
    console.warn(
      `[AI Generate Title - Func] Title prompt "${TITLE_PROMPT_NAME}" (type 'title') not found. Using default internal prompt.`
    );
  }

  const defaultTitlePrompt =
    "YOUR ONLY TASK IS TO GENERATE A NEWS ARTICLE TITLE. Output MUST be plain text only, on a single line. NO HTML, NO Markdown. NO preambles. NO prefixes like 'Title: '.\n\n" +
    "You are an expert sports journalist. Generate a **new, original, SEO-friendly title** for a news article based on the following original title and description. The new title MUST be highly distinct from the original, capture a fresh angle, and avoid simply rephrasing original keywords.\n\n" +
    "Original Title: {original_title}\nOriginal Description: {original_description}\n\n" +
    "Generated Title:";

  let finalTitlePrompt = titlePromptDoc?.prompt || defaultTitlePrompt;

  let journalistTonePrompt = "";
  if (journalistId) {
    const journalist = await AIJournalist.findById(journalistId);
    if (journalist && journalist.isActive) {
      journalistTonePrompt = `As "${journalist.name}", your unique journalistic voice and tone should be: ${journalist.tonePrompt}\n\n`;
      console.log(
        `[AI Generate Title - Func] Using AI Journalist: ${journalist.name}`
      );
    }
  }

  const fullPrompt = `${journalistTonePrompt}${finalTitlePrompt}`
    .replace("{original_title}", originalTitle)
    .replace("{original_description}", originalDescription);

  // AI Call
  let aiResponseText: string = "";
  const MAX_RETRIES = 3;
  const RETRY_DELAY_MS = 2000;
  const AI_CALL_TIMEOUT_MS = 20000; // 20 seconds for title generation

  for (let i = 0; i < MAX_RETRIES; i++) {
    try {
      console.log(
        `[AI Generate Title - Func] Calling Gemini for title (Attempt ${
          i + 1
        })...`
      );
      const result: any = await Promise.race([
        model.generateContent(fullPrompt),
        new Promise((_, reject) =>
          setTimeout(
            () => reject(new Error("AI title generation timed out.")),
            AI_CALL_TIMEOUT_MS
          )
        ),
      ]);
      aiResponseText = (await result.response).text();
      console.log(
        `[AI Generate Title - Func] Received raw AI response. Length: ${aiResponseText.length}.`
      );
      break;
    } catch (aiError: any) {
      console.error(
        `[AI Generate Title - Func] Error in Gemini API call for title (Attempt ${
          i + 1
        }/${MAX_RETRIES}):`,
        aiError.message
      );
      if (
        i < MAX_RETRIES - 1 &&
        (aiError.message.includes("timed out.") ||
          aiError.status === 429 ||
          (aiError.status >= 500 && aiError.status < 600))
      ) {
        console.warn(
          `[AI Generate Title - Func] Retrying AI title generation in ${
            RETRY_DELAY_MS / 1000
          } seconds...`
        );
        await new Promise((res) => setTimeout(res, RETRY_DELAY_MS));
      } else {
        throw new Error(
          `AI title generation failed after ${MAX_RETRIES} retries: ${aiError.message}`
        );
      }
    }
  }

  if (!aiResponseText) {
    throw new Error("AI title generation failed to produce a response.");
  }

  // --- Aggressive Title Cleanup and Validation ---
  let generatedTitle = aiResponseText.trim();
  generatedTitle = generatedTitle
    .replace(/^```(?:html|text|json)?\n?|```$/g, "")
    .trim();
  generatedTitle = generatedTitle
    .replace(
      /<!DOCTYPE html>[\s\S]*?<body[^>]*>|(?<=<\/body>)[\s\S]*$|<\/body>|<\/html>|<\/head>|<\/title>|<\/meta>|<\/link>|<\/style>|<style[^>]*>[\s\S]*?<\/style>|<script[^>]*>[\s\S]*?<\/script>/g,
      ""
    )
    .trim();
  generatedTitle = generatedTitle
    .replace(/<html[^>]*>|<body[^>]*>/g, "")
    .trim();
  generatedTitle = generatedTitle.replace(/^\s*\n/gm, "").trim();
  generatedTitle = generatedTitle
    .replace(/^(AI JOURNALIST TONE & STYLE:[\s\S]*?\n\n)?/i, "")
    .trim();
  generatedTitle = generatedTitle
    .replace(
      /^(Here's the (title|article|rewritten title|news article|requested article|response)|Article Title|Generated Title|Title):?\s*\n*/i,
      ""
    )
    .trim();
  generatedTitle = generatedTitle.replace(/<[^>]*>?/gm, "");
  generatedTitle = generatedTitle.replace(/[\*_`#\[\]\n]/g, "");
  generatedTitle = generatedTitle.trim();

  console.log(
    `[AI Generate Title - Func] Cleaned generated title: "${generatedTitle}"`
  );

  // Strict validation
  const originalTitleLower = originalTitle.toLowerCase();
  const generatedTitleLower = generatedTitle.toLowerCase();
  const jaccardSimilarity = calculateJaccardSimilarity(
    originalTitleLower,
    generatedTitleLower
  );
  const SIMILARITY_THRESHOLD = 0.4;

  if (
    generatedTitle.length < 10 ||
    jaccardSimilarity > SIMILARITY_THRESHOLD ||
    generatedTitleLower === originalTitleLower
  ) {
    console.error(
      `[AI Generate Title - Func] Generated Title: "${generatedTitle}" (Original: "${originalTitle}")`
    );
    console.error(
      `[AI Generate Title - Func] Jaccard Similarity: ${jaccardSimilarity.toFixed(
        2
      )} (Threshold: ${SIMILARITY_THRESHOLD})`
    );
    throw new Error(
      `Generated title failed strict validation (too short, not unique, or too similar).`
    );
  }

  return generatedTitle;
}

/**
 * Generates an AI-driven article content.
 * @param originalTitle The original news title.
 * @param originalDescription The original news description.
 * @param originalContent The external article's content field.
 * @param articleLink The external article's link for scraping.
 * @param generatedTitle The title already generated by AI.
 * @param journalistId Optional ID of the AI Journalist to use.
 * @returns The AI-generated HTML content.
 * @throws Error if content generation fails or output is invalid.
 */
async function generateContent(
  originalTitle: string,
  originalDescription: string,
  originalContent: string | null,
  articleLink: string,
  generatedTitle: string,
  journalistId?: string
): Promise<string> {
  const contentPromptDoc = await AIPrompt.findOne({
    name: CONTENT_PROMPT_NAME,
    type: "content",
  });
  if (!contentPromptDoc) {
    console.warn(
      `[AI Generate Content - Func] Content prompt "${CONTENT_PROMPT_NAME}" (type 'content') not found. Using default internal prompt.`
    );
  }

  const defaultContentPrompt =
    "Your ONLY task is to generate a news article content in HTML. NO Markdown, NO preambles, NO extra text, NO code block wrappers (```html). DO NOT INCLUDE `<!DOCTYPE html>`, `<html>`, `<head>`, `<body>`, `<h1>`, or any other full document tags. \n\n" +
    "You are an expert sports journalist. Analyze the following news title, description, and provided context. Your goal is to generate a comprehensive, human-like, SEO-optimized HTML article, approximately 700 words long. Focus on deep insights, storytelling, and compelling analysis.\n\n" +
    "**GUIDELINES:**\n" +
    "1.  **HTML CONTENT:** Provide valid HTML. Use `<h2>` for main headings (optimized for keywords), `<p>` for paragraphs, `<strong>`, `<em>`, `<ul>`, `<li>`, `<a>`. Ensure natural flow, rich detail, and human tone. Integrate relevant keywords naturally throughout the article for SEO, but avoid stuffing.\n\n" +
    "**HTML Example Structure:**\n" +
    "<h2>Introduction Heading</h2><p>This is the engaging introduction paragraph...</p>\n" +
    "<h2>Key Developments</h2><p>Here's a detailed paragraph...</p><ul><li>...</li></ul><p>...</p><h2>Conclusion</h2><p>The concluding paragraph summarizes...</p>\n\n" +
    "**IMPORTANT:** If the provided content is too short or lacks sufficient detail for a 700-word SEO-optimized expansion, respond ONLY with 'CONTENT INSUFFICIENT FOR EXPANSION: [brief reason]'. No other text.\n\n" +
    "Generated Article Title: {generated_title}\nOriginal News Title: {original_title}\nOriginal News Description: {original_description}\nAdditional Context: {additional_context}";

  let finalContentPrompt = contentPromptDoc?.prompt || defaultContentPrompt;

  let journalistTonePrompt = "";
  if (journalistId) {
    const journalist = await AIJournalist.findById(journalistId);
    if (journalist && journalist.isActive) {
      journalistTonePrompt = `As "${journalist.name}", your unique journalistic voice and tone should be: ${journalist.tonePrompt}\n\n`;
      console.log(
        `[AI Generate Content - Func] Using AI Journalist: ${journalist.name}`
      );
    }
  }

  // --- Content Gathering for AI Input ---
  let combinedArticleContext = "";
  const MIN_TOTAL_CONTEXT_FOR_GENERATION = 100;

  if (originalTitle) combinedArticleContext += `Title: ${originalTitle}\n`;
  if (originalDescription)
    combinedArticleContext += `Description: ${originalDescription}\n`;
  if (originalContent && originalContent.length > 50) {
    combinedArticleContext += `\nFull Content: ${originalContent}\n`;
  }

  if (
    articleLink &&
    combinedArticleContext.length < MIN_TOTAL_CONTEXT_FOR_GENERATION
  ) {
    console.log(
      `[Content Gathering - Func] Combined context too short (${combinedArticleContext.length}), attempting to fetch from link: ${articleLink}`
    );
    const fetchedWebContent = await fetchAndExtractWebpageContent(articleLink);
    if (fetchedWebContent && fetchedWebContent.length > 50) {
      combinedArticleContext += `\nWebpage Context: ${fetchedWebContent}\n`;
      console.log(
        `[Content Gathering - Func] Successfully fetched and appended web content (total context length: ${combinedArticleContext.length})`
      );
    } else {
      console.log(
        "[Content Gathering - Func] No substantial web content extracted from link."
      );
    }
  }

  if (
    !combinedArticleContext ||
    combinedArticleContext.length < MIN_TOTAL_CONTEXT_FOR_GENERATION
  ) {
    throw new Error(
      "Article content (title, description, or external content) too short or missing to generate content."
    );
  }

  const MAX_CONTENT_LENGTH_TO_SEND = 8000;
  if (combinedArticleContext.length > MAX_CONTENT_LENGTH_TO_SEND) {
    combinedArticleContext =
      combinedArticleContext.substring(0, MAX_CONTENT_LENGTH_TO_SEND) +
      "... (truncated for AI processing)";
    console.warn(
      `[Content Gathering - Func] Article context truncated to ${MAX_CONTENT_LENGTH_TO_SEND} characters for AI.`
    );
  }

  const fullPrompt = `${journalistTonePrompt}${finalContentPrompt}`
    .replace("{generated_title}", generatedTitle)
    .replace("{original_title}", originalTitle)
    .replace("{original_description}", originalDescription)
    .replace("{additional_context}", combinedArticleContext);

  // AI Call
  let aiResponseText: string = "";
  const MAX_RETRIES = 3;
  const RETRY_DELAY_MS = 3000;
  const AI_CALL_TIMEOUT_MS = 90000; // 90 seconds for content generation

  for (let i = 0; i < MAX_RETRIES; i++) {
    try {
      console.log(
        `[AI Generate Content - Func] Calling Gemini for content (Attempt ${
          i + 1
        })...`
      );
      const result: any = await Promise.race([
        model.generateContent(fullPrompt),
        new Promise((_, reject) =>
          setTimeout(
            () => reject(new Error("AI content generation timed out.")),
            AI_CALL_TIMEOUT_MS
          )
        ),
      ]);
      aiResponseText = (await result.response).text();
      console.log(
        `[AI Generate Content - Func] Received raw AI response. Length: ${aiResponseText.length}.`
      );
      break;
    } catch (aiError: any) {
      console.error(
        `[AI Generate Content - Func] Error in Gemini API call for content (Attempt ${
          i + 1
        }/${MAX_RETRIES}):`,
        aiError.message
      );
      if (
        i < MAX_RETRIES - 1 &&
        (aiError.message.includes("timed out.") ||
          aiError.status === 429 ||
          (aiError.status >= 500 && aiError.status < 600))
      ) {
        console.warn(
          `[AI Generate Content - Func] Retrying AI content generation in ${
            RETRY_DELAY_MS / 1000
          } seconds...`
        );
        await new Promise((res) => setTimeout(res, RETRY_DELAY_MS));
      } else {
        throw new Error(
          `AI content generation failed after ${MAX_RETRIES} retries: ${aiError.message}`
        );
      }
    }
  }

  if (!aiResponseText) {
    throw new Error("AI content generation failed to produce a response.");
  }

  // --- Aggressive Content Cleanup and Validation ---
  let generatedContent = aiResponseText.trim();
  generatedContent = generatedContent
    .replace(/^```(?:html|text|json)?\n?|```$/g, "")
    .trim();
  generatedContent = generatedContent
    .replace(
      /<!DOCTYPE html>[\s\S]*?<body[^>]*>|(?<=<\/body>)[\s\S]*$|<\/body>|<\/html>|<\/head>|<\/title>|<\/meta>|<\/link>|<\/style>|<style[^>]*>[\s\S]*?<\/style>|<script[^>]*>[\s\S]*?<\/script>/g,
      ""
    )
    .trim();
  generatedContent = generatedContent
    .replace(/<html[^>]*>|<body[^>]*>/g, "")
    .trim();
  generatedContent = generatedContent.replace(/^\s*\n/gm, "").trim();
  generatedContent = generatedContent
    .replace(/^(AI JOURNALIST TONE & STYLE:[\s\S]*?\n\n)?/i, "")
    .trim();
  generatedContent = generatedContent
    .replace(
      /^(Here's the (article|rewritten article|news article|requested article|response)|Article|News Article|Your Article|Generated Article|Title):?\s*\n*/i,
      ""
    )
    .trim();
  if (generatedContent.includes("---START_CONTENT---")) {
    // Remove separator if AI accidentally includes it
    generatedContent =
      generatedContent.split("---START_CONTENT---")[1] || generatedContent;
    console.warn(
      "[AI Generate Content - Func] Stripped unexpected title separator from content."
    );
  }

  // Check for AI's own "insufficient content" flag (case-insensitive and partial match)
  if (
    generatedContent
      .toUpperCase()
      .includes("CONTENT INSUFFICIENT FOR EXPANSION")
  ) {
    throw new Error("AI determined content insufficient for expansion.");
  }

  // --- HTML Post-processing (markdown-it) and Validation ---
  let finalContent = md.render(generatedContent);

  const hasHtmlTags = /<[a-z][\s\S]*>/i.test(finalContent);
  const hasMarkdownChars = /[*_`#\[\]]/.test(finalContent);

  if (!hasHtmlTags || hasMarkdownChars) {
    throw new Error(
      `AI output format error: Content is not valid HTML after post-processing or still contains Markdown.`
    );
  }
  if (finalContent.includes("<h1")) {
    throw new Error(
      `AI output format error: Content unexpectedly contains <h1> tags.`
    );
  }

  return finalContent;
}

// POST handler to orchestrate the AI processing pipeline
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  let externalArticle: IExternalNewsArticle | null = null;
  let journalistName = "AI Auto-Generator";

  try {
    const {
      articleId,
      sportCategory,
      journalistId,
    }: { articleId: string; sportCategory?: string; journalistId?: string } =
      await request.json();

    if (!articleId) {
      console.error("[Process Article Orchestrator] Missing Article ID.");
      return NextResponse.json(
        { error: "Article ID is required." },
        { status: 400 }
      );
    }

    externalArticle = await ExternalNewsArticle.findOne({ articleId });

    if (!externalArticle) {
      console.error(
        `[Process Article Orchestrator] External news article not found: ${articleId}`
      );
      return NextResponse.json(
        { error: "External news article not found." },
        { status: 404 }
      );
    }

    if (externalArticle.status === "processed") {
      console.log(
        `[Process Article Orchestrator] Article ${articleId} already processed. Skipping.`
      );
      return NextResponse.json(
        { message: "Article already processed." },
        { status: 200 }
      );
    }
    if (externalArticle.status === "processing") {
      console.warn(
        `[Process Article Orchestrator] Article ${articleId} is already in 'processing' state. Aborting duplicate request.`
      );
      return NextResponse.json(
        { error: "Article is already being processed. Please wait." },
        { status: 409 }
      );
    }

    externalArticle.status = "processing";
    await externalArticle.save();
    console.log(
      `[Process Article Orchestrator] Starting processing for article: ${externalArticle.articleId}, current status updated to 'processing'.`
    );

    // --- Fetch Journalist Name (for author field later) ---
    if (journalistId) {
      const journalist = await AIJournalist.findById(journalistId);
      if (journalist && journalist.isActive) {
        journalistName = journalist.name;
      }
    }

    // 1. Generate Title via dedicated function call
    let newPostTitle: string = "";
    try {
      console.log(
        `[Orchestrator] Calling local generateTitle function for article ${externalArticle.articleId}...`
      );
      newPostTitle = await generateTitle(
        externalArticle.title,
        externalArticle.description || "",
        journalistId
      );
      console.log(
        `[Orchestrator] Successfully generated title: "${newPostTitle}"`
      );
      if (!newPostTitle)
        throw new Error("AI Title Generation returned no title.");
    } catch (titleError: any) {
      console.error(
        `[Orchestrator] Title generation failed for article ${externalArticle.articleId}:`,
        titleError.message
      );
      throw new Error(`Title generation failed: ${titleError.message}`);
    }

    // 2. Generate Content via dedicated function call
    let rewrittenContent: string = "";
    try {
      console.log(
        `[Orchestrator] Calling local generateContent function for article ${externalArticle.articleId}...`
      );
      rewrittenContent = await generateContent(
        externalArticle.title,
        externalArticle.description || "",
        externalArticle.content,
        externalArticle.link,
        newPostTitle,
        journalistId
      );
      console.log(
        `[Orchestrator] Successfully generated content. Length: ${rewrittenContent.length}`
      );
      if (!rewrittenContent)
        throw new Error("AI Content Generation returned no content.");
    } catch (contentError: any) {
      console.error(
        `[Orchestrator] Content generation failed for article ${externalArticle.articleId}:`,
        contentError.message
      );
      throw new Error(`Content generation failed: ${contentError.message}`);
    }

    // 3. Process/Generate Featured Image (Existing logic)
    let featuredImageUrl: string | null = null;
    let featuredImageTitle: string | undefined = undefined;
    let featuredImageAltText: string | undefined = undefined;

    // Fallback: Use the original external article's image and proxy it to S3.
    if (externalArticle.imageUrl) {
      try {
        console.log(
          `[Orchestrator] Proxying original image for article ${externalArticle.articleId}...`
        );
        featuredImageUrl = await proxyAndUploadOriginalImage(
          externalArticle.imageUrl,
          newPostTitle
        );
        if (featuredImageUrl) {
          console.log(
            `[Orchestrator] Original image proxied successfully: ${featuredImageUrl}`
          );
        } else {
          console.warn(
            `[Orchestrator] Failed to proxy original image for article ${externalArticle.articleId}. No featured image will be set.`
          );
        }
      } catch (proxyError: any) {
        console.error(
          `[Orchestrator] Error proxying original image for article ${externalArticle.articleId}:`,
          proxyError.message
        );
      }
    } else {
      console.log(
        `[Orchestrator] No image URL found in external article ${externalArticle.articleId}. Skipping image processing.`
      );
    }

    featuredImageTitle = newPostTitle;
    featuredImageAltText = `${newPostTitle} image`;

    // 4. Save the rewritten article as a new Post
    const postSlug = slugify(newPostTitle, { lower: true, strict: true });

    const existingPostWithSlug = await Post.findOne({ slug: postSlug });
    let finalSlug = postSlug;
    if (existingPostWithSlug) {
      finalSlug = `${postSlug}-${Date.now().toString().slice(-5)}`;
      console.warn(
        `[Orchestrator - Post Save] Post with slug '${postSlug}' already exists, new slug: '${finalSlug}'`
      );
    }

    const plainTextContent = rewrittenContent.replace(/<[^>]*>?/gm, "");

    const newPost = new Post({
      title: newPostTitle,
      content: rewrittenContent,
      status: "draft",
      slug: finalSlug,
      author: journalistName,
      featuredImage: featuredImageUrl,
      featuredImageTitle: featuredImageTitle,
      featuredImageAltText: featuredImageAltText,
      sport: sportCategory || externalArticle.category?.[0] || "general",
      metaTitle: `${newPostTitle} - Sports News`,
      metaDescription: plainTextContent.substring(0, 150) + "...",
      isAIGenerated: true,
      originalExternalArticleId: externalArticle._id,
    });

    console.log(
      `[Orchestrator - Post Save] Attempting to save new Post with title: "${
        newPost.title
      }", slug: "${newPost.slug}", image: ${!!newPost.featuredImage}`
    );
    await newPost.save();
    console.log(
      `[Orchestrator - Post Save] Post saved successfully. New Post ID: ${newPost._id}`
    );

    // 5. Final Status Update and Success Response
    externalArticle.status = "processed";
    externalArticle.processedPostId = newPost._id;
    await externalArticle.save();
    console.log(
      `[Orchestrator - Status Update] ExternalNewsArticle ${externalArticle.articleId} status updated to 'processed'.`
    );

    return NextResponse.json(
      {
        message: "Article processed and new post created successfully.",
        postId: newPost._id,
        postSlug: newPost.slug,
      },
      { status: 201 }
    );
  } catch (error: any) {
    // --- Centralized Error Handling and Status Update ---
    let errorMessage = "Server error processing external news.";
    let clientStatus = 500;

    const isCustomError = error instanceof Error;
    let finalArticleStatus: "skipped" | "error" = "error";

    if (isCustomError) {
      errorMessage = error.message;
      if (errorMessage.includes("AI determined content insufficient")) {
        clientStatus = 200;
        finalArticleStatus = "skipped";
      } else if (
        errorMessage.includes("AI output format error") ||
        errorMessage.includes("AI-generated title failed strict validation") ||
        errorMessage.includes("Content generation failed") ||
        errorMessage.includes("Title generation failed")
      ) {
        clientStatus = 422;
      } else if (errorMessage.includes("AI generation timed out")) {
        clientStatus = 504;
      } else if (
        errorMessage.includes("Article has no content") ||
        errorMessage.includes("content too short")
      ) {
        clientStatus = 400;
        finalArticleStatus = "skipped";
      } else if (errorMessage.includes("AI generation failed after")) {
        clientStatus = 500;
      } else if (errorMessage.includes("quota")) {
        errorMessage =
          "Gemini API Quota Exceeded. Please check your usage in Google AI Studio.";
        clientStatus = 429;
      } else if (
        errorMessage.includes("not found") ||
        errorMessage.includes("Network Error") ||
        errorMessage.includes("Failed to fetch content")
      ) {
        clientStatus = 404;
      } else if (axios.isAxiosError(error) && error.response) {
        errorMessage = `External API error: ${
          error.response.data?.error ||
          error.response?.data?.results?.message ||
          error.message
        }`;
        clientStatus = error.response.status || 500;
      } else if (
        error.message.includes("MongooseError") ||
        error.message.includes("MongoNetworkError")
      ) {
        errorMessage = `Database error: ${error.message}`;
        clientStatus = 500;
      }
    } else {
      errorMessage = `An unexpected error occurred: ${JSON.stringify(error)}`;
    }

    console.error(
      `[Process Article Orchestrator] Critical error processing external news article ${
        externalArticle?.articleId || "unknown"
      }: ${errorMessage}`,
      "\nFull Error Object:",
      error
    );

    if (externalArticle && externalArticle.status === "processing") {
      console.error(
        `[Process Article Orchestrator] Marking external article ${externalArticle.articleId} as '${finalArticleStatus}' due to critical failure.`
      );
      externalArticle.status = finalArticleStatus;
      try {
        await externalArticle.save();
      } catch (dbSaveError) {
        console.error(
          `[Process Article Orchestrator] Failed to save final external article status to '${finalArticleStatus}':`,
          dbSaveError
        );
      }
    } else if (externalArticle && externalArticle.status !== "processed") {
      console.error(
        `[Process Article Orchestrator] Marking external article ${externalArticle.articleId} as 'error' due to unhandled failure (status was ${externalArticle.status}).`
      );
      externalArticle.status = "error";
      try {
        await externalArticle.save();
      } catch (dbSaveError) {
        console.error(
          `[Orchestrator] Failed to save external article status to 'error':`,
          dbSaveError
        );
      }
    }

    return NextResponse.json({ error: errorMessage }, { status: clientStatus });
  }
}


// ===== src\app\api\admin\fetch-external-news\route.ts =====
// src/app/api/admin/fetch-external-news/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle from "@/models/ExternalNewsArticle";
import axios from "axios";

// Define the expected structure of a newsdata.io article
interface NewsDataItem {
  article_id: string;
  title: string;
  link: string;
  keywords?: string[] | null;
  creator?: string | null;
  video_url?: string | null;
  description?: string | null;
  content?: string | null;
  pubDate: string; // ISO 8601 string
  image_url?: string | null;
  source_id?: string;
  source_priority?: number;
  source_url?: string;
  source_icon?: string | null;
  language?: string;
  country?: string[];
  category?: string[];
  sentiment?: string;
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { query, language, country, category, count } = await request.json(); // Allow client to specify filters and count

    const newsDataApiKey = process.env.NEXT_PUBLIC_NEWSDATA_IO_API_KEY;
    if (!newsDataApiKey) {
      console.error("NEWSDATA_IO_API_KEY is not set in environment variables.");
      return NextResponse.json(
        { error: "Server configuration error: News API key missing." },
        { status: 500 }
      );
    }

    const apiUrl = "https://newsdata.io/api/1/news";
    const params: Record<string, string | number> = {
      apikey: newsDataApiKey,
      // We are only using qInTitle to avoid the 'TooManyQueryFilter' error.
      qInTitle: query || "football OR soccer", // Use qInTitle as the primary query filter
      language: language || "en", // Default language
    };

    if (country && country.length > 0) {
      params.country = country.join(",");
    }
    if (category && category.length > 0) {
      params.category = category.join(",");
    }

    console.log(
      `[Fetch External News] Fetching news from newsdata.io with params: ${JSON.stringify(
        params
      )}`
    );
    const response = await axios.get(apiUrl, { params });
    const newsItems: NewsDataItem[] = response.data.results || [];
    console.log(
      `[Fetch External News] Received ${newsItems.length} articles from newsdata.io`
    );

    let newArticlesCount = 0;
    let skippedArticlesCount = 0;

    for (const item of newsItems) {
      try {
        // Only save if the article_id is unique
        const existingArticle = await ExternalNewsArticle.findOne({
          articleId: item.article_id,
        });
        if (existingArticle) {
          skippedArticlesCount++;
          console.warn(
            `[Fetch External News] Duplicate article ID found, skipping: ${item.article_id}`
          );
          continue; // Skip if article already exists
        }

        const newArticle = new ExternalNewsArticle({
          articleId: item.article_id,
          title: item.title,
          link: item.link,
          keywords: item.keywords || undefined,
          creator: item.creator,
          video_url: item.video_url,
          description: item.description,
          content: item.content,
          pubDate: new Date(item.pubDate), // Convert to Date object
          imageUrl: item.image_url,
          source_id: item.source_id,
          source_priority: item.source_priority,
          source_url: item.source_url,
          source_icon: item.source_icon,
          language: item.language,
          country: item.country || undefined,
          category: item.category || undefined,
          sentiment: item.sentiment,
          status: "fetched", // Initial status
        });

        await newArticle.save();
        newArticlesCount++;
        console.log(`[Fetch External News] Saved new article: ${item.title}`);
      } catch (saveError: any) {
        // Handle duplicate key errors or other save errors gracefully
        if (saveError.code === 11000) {
          // MongoDB duplicate key error
          skippedArticlesCount++;
          console.warn(
            `[Fetch External News] Duplicate article ID found during save, skipping: ${item.article_id}`
          );
        } else {
          console.error(
            `[Fetch External News] Error saving article ${item.article_id}:`,
            saveError
          );
        }
      }
    }

    return NextResponse.json(
      {
        message: `Successfully fetched and saved ${newArticlesCount} new articles. Skipped ${skippedArticlesCount} existing articles.`,
        newArticlesCount,
        skippedArticlesCount,
      },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      "[Fetch External News] Error fetching external news:",
      error.message
    );
    if (axios.isAxiosError(error)) {
      console.error("newsdata.io API error response:", error.response?.data);
      return NextResponse.json(
        {
          error: `Failed to fetch news from external API: ${
            error.response?.data?.results?.message || error.message
          }`,
        },
        { status: error.response?.status || 500 }
      );
    }
    return NextResponse.json(
      { error: "Server error fetching external news." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\admin\file-manager\download-from-url\route.ts =====
// ===== src\app\api\admin\file-manager\download-from-url\route.ts =====
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import axios from "axios";
import crypto from "crypto";
import path from "path";
import slugify from "slugify";
import { promises as fs } from "fs";

// Re-use the UPLOAD_DIR definition and helper function
const UPLOAD_DIR = path.join(process.cwd(), "public/uploads");

const ensureUploadDirExists = async () => {
  try {
    await fs.mkdir(UPLOAD_DIR, { recursive: true });
  } catch (error) {
    console.error("Error creating upload directory:", error);
    throw new Error("Could not create upload directory on the server.");
  }
};

const generateFileName = (bytes = 32) =>
  crypto.randomBytes(bytes).toString("hex");

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const {
      url,
      fileName: providedFileName,
    }: { url: string; fileName?: string } = await request.json();

    if (!url) {
      return NextResponse.json({ error: "URL is required." }, { status: 400 });
    }

    console.log(
      `[File Manager - Download URL] Attempting to download from URL: ${url}`
    );

    // 1. Download the file from the external URL
    const response = await axios.get(url, {
      responseType: "arraybuffer", // Get as binary data
      timeout: 30000, // 30-second timeout for download
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });

    const fileBuffer = Buffer.from(response.data, "binary");
    const contentType =
      response.headers["content-type"] || "application/octet-stream"; // Get content type from response
    const contentLength = response.headers["content-length"]
      ? parseInt(response.headers["content-length"])
      : fileBuffer.length;

    if (contentLength === 0) {
      throw new Error("Downloaded file is empty.");
    }
    if (contentLength > 20 * 1024 * 1024) {
      // Max 20MB limit for direct download, adjust as needed
      throw new Error("File size exceeds 20MB limit for direct download.");
    }

    // Determine file extension and final file name
    let fileExtension = "";
    const mimeMap: { [key: string]: string } = {
      "image/jpeg": ".jpg",
      "image/png": ".png",
      "image/gif": ".gif",
      "image/webp": ".webp",
      "application/pdf": ".pdf",
      // Add more as needed
    };
    fileExtension =
      mimeMap[contentType.toLowerCase()] ||
      path.extname(new URL(url).pathname) ||
      ""; // Try mime type then URL path extension

    const uniqueBaseName = generateFileName();
    const finalFileName = providedFileName
      ? `${slugify(providedFileName, {
          lower: true,
          strict: true,
        })}${fileExtension}`
      : `${uniqueBaseName}${fileExtension}`;

    // 2. Save the file to the local filesystem
    const filePath = path.join(UPLOAD_DIR, finalFileName);
    await ensureUploadDirExists();
    await fs.writeFile(filePath, fileBuffer);

    // 3. Return the relative public URL
    const publicUrl = `/uploads/${finalFileName}`;
    console.log(
      `[File Manager - Download URL] File successfully saved locally: ${publicUrl}`
    );

    return NextResponse.json({
      message: "File downloaded and saved successfully",
      url: publicUrl,
      name: finalFileName,
      type: contentType,
      size: contentLength,
    });
  } catch (error: any) {
    console.error(
      `[File Manager - Download URL] Failed to download or save from URL: ${error.message}`,
      "\nFull Error:",
      error
    );
    let errorMessage = "Failed to download and upload file from URL.";
    let clientStatus = 500;

    if (axios.isAxiosError(error)) {
      if (error.response) {
        errorMessage = `External URL error: Status ${error.response.status} - ${error.response.statusText}`;
        clientStatus = error.response.status;
      } else if (error.request) {
        errorMessage = `Network error: Could not reach external URL.`;
        clientStatus = 502; // Bad Gateway
      } else {
        errorMessage = `Request setup error: ${error.message}`;
      }
    } else if (error instanceof Error) {
      errorMessage = error.message;
      if (errorMessage.includes("File size exceeds")) clientStatus = 413; // Payload Too Large
      if (errorMessage.includes("Downloaded file is empty")) clientStatus = 400; // Bad Request
    }

    return NextResponse.json({ error: errorMessage }, { status: clientStatus });
  }
}


// ===== src\app\api\admin\process-external-news\route.ts =====
// ===== src/app/api/admin/process-external-news/route.ts (REVISED FOR GIFS AND NO CROPPING) =====
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle, {
  IExternalNewsArticle,
} from "@/models/ExternalNewsArticle";
import Post from "@/models/Post";
import AIPrompt from "@/models/AIPrompt";
import AIJournalist from "@/models/AIJournalist";
import { GoogleGenerativeAI } from "@google/generative-ai";
import axios from "axios";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import sharp from "sharp";
import crypto from "crypto";
import slugify from "slugify";
import * as cheerio from "cheerio";
import MarkdownIt from "markdown-it";
import path from "path";

// Initialize markdown-it for HTML conversion
const md = new MarkdownIt({
  html: true,
  linkify: true,
  typographer: true,
});

// --- R2/S3 Client Configuration ---
const s3Client = new S3Client({
  region: "auto", // R2's region is 'auto'
  endpoint: process.env.NEXT_PUBLIC_R2_ENDPOINT as string,
  credentials: {
    accessKeyId: process.env.NEXT_PUBLIC_R2_ACCESS_KEY_ID as string,
    secretAccessKey: process.env.NEXT_PUBLIC_R2_SECRET_ACCESS_KEY as string,
  },
});

const R2_BUCKET_NAME = process.env.NEXT_PUBLIC_R2_BUCKET_NAME as string;
const R2_PUBLIC_URL = process.env.NEXT_PUBLIC_R2_PUBLIC_BUCKET_URL as string;

const generateFileName = (bytes = 32) =>
  crypto.randomBytes(bytes).toString("hex");

// --- REWRITTEN: proxyAndUploadOriginalImage function for R2 (UPDATED) ---
async function proxyAndUploadOriginalImage(
  imageUrl: string,
  newPostTitle: string
): Promise<string | null> {
  try {
    console.log(
      `[Image Processing] Attempting to proxy original image: ${imageUrl}`
    );
    const imageResponse = await axios.get(imageUrl, {
      responseType: "arraybuffer",
      timeout: 15000,
      maxRedirects: 5,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });

    const inputBuffer = Buffer.from(imageResponse.data, "binary");
    const originalContentType =
      imageResponse.headers["content-type"] || "image/jpeg";

    let finalBuffer: Buffer;
    let finalContentType: string = originalContentType;
    let fileExtension: string; // Will be set based on processing

    // ===== NEW GIF HANDLING AND NO-CROPPING LOGIC =====
    if (originalContentType.includes("image/gif")) {
      finalBuffer = inputBuffer;
      finalContentType = "image/gif";
      fileExtension = ".gif";
      console.log(
        `[Image Processing] GIF detected, bypassing Sharp for ${imageUrl}.`
      );
    } else {
      try {
        finalBuffer = await sharp(inputBuffer)
          .resize(1200, 630, {
            fit: "inside", // Changed from "cover" to "inside" to prevent cropping
            withoutEnlargement: true, // Prevents upscaling
          })
          .webp({ quality: 80 })
          .toBuffer();
        finalContentType = "image/webp";
        fileExtension = ".webp";
        console.log(
          `[Image Processing] Resized and converted original image to WebP (fit:inside) for ${imageUrl}.`
        );
      } catch (sharpError: any) {
        // Fallback if Sharp processing fails for non-GIFs (e.g., corrupted image, unsupported format)
        console.error(
          `[Image Processing] Sharp processing failed for image ${imageUrl} (non-GIF):`,
          sharpError.message
        );
        finalBuffer = inputBuffer; // Use original buffer as fallback
        finalContentType = originalContentType; // Keep original content type
        fileExtension = path.extname(new URL(imageUrl).pathname) || ".jpg"; // Try to get original extension or default
        console.warn(
          `[Image Processing] Using original image buffer as fallback (without sharp processing) for ${imageUrl}.`
        );
      }
    }

    const slug = slugify(newPostTitle, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });
    const uniqueSuffix = Date.now().toString().slice(-6);
    const newFileName = `fanskor-${slug}-${uniqueSuffix}${fileExtension}`;

    const putObjectCommand = new PutObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: newFileName,
      Body: finalBuffer,
      ContentType: finalContentType,
    });

    await s3Client.send(putObjectCommand);
    const r2Url = `${R2_PUBLIC_URL}/${newFileName}`;
    console.log(
      `[Image Processing] Original image successfully uploaded to R2: ${r2Url}`
    );

    return r2Url;
  } catch (imageError: any) {
    console.error(
      `[Image Processing] Failed to process/upload original image (URL: ${imageUrl}):`,
      imageError.message
    );
    return null;
  }
}

// --- Initialize Google Generative AI (unchanged) ---
const genAI = new GoogleGenerativeAI(
  process.env.NEXT_PUBLIC_GEMINI_API_KEY as string
);
const model = genAI.getGenerativeModel({ model: "gemini-2.5-pro" });

// Fixed names for the AI prompts (unchanged)
const TITLE_PROMPT_NAME = "AI Title Generation";
const CONTENT_PROMPT_NAME = "AI Content Generation";

// --- Helper Functions (calculateJaccardSimilarity, fetchAndExtractWebpageContent, generateTitle, generateContent) (unchanged) ---
function calculateJaccardSimilarity(str1: string, str2: string): number {
  const words1 = new Set(str1.toLowerCase().split(/\s+/).filter(Boolean));
  const words2 = new Set(str2.toLowerCase().split(/\s+/).filter(Boolean));
  if (words1.size === 0 && words2.size === 0) return 1.0;
  if (words1.size === 0 || words2.size === 0) return 0.0;
  const intersection = new Set([...words1].filter((word) => words2.has(word)));
  const union = new Set([...words1, ...words2]);
  return intersection.size / union.size;
}

async function fetchAndExtractWebpageContent(
  url: string
): Promise<string | null> {
  try {
    const response = await axios.get(url, {
      timeout: 10000,
      maxRedirects: 5,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });
    if (response.status !== 200) {
      return null;
    }
    const $ = cheerio.load(response.data);
    const contentSelectors = [
      "article",
      "main",
      ".article-content",
      ".post-content",
      ".entry-content",
      ".story-content",
      ".body-content",
      "#article-body",
      "#main-content",
      "#content",
      "p",
    ];
    let extractedText = "";
    for (const selector of contentSelectors) {
      const element = $(selector);
      if (element.length > 0) {
        element
          .find(
            "script, style, header, footer, nav, aside, form, iframe, .ad-unit"
          )
          .remove();
        extractedText = element.text();
        if (extractedText.length > 200) break;
      }
    }
    extractedText = extractedText.replace(/\s\s+/g, " ").trim();
    return extractedText.length > 0 ? extractedText : null;
  } catch (error: any) {
    console.error(
      `[Content Extraction Helper] Error fetching or extracting content from ${url}:`,
      error.message
    );
    return null;
  }
}

async function generateTitle(
  originalTitle: string,
  originalDescription: string,
  journalistId?: string
): Promise<string> {
  const titlePromptDoc = await AIPrompt.findOne({
    name: TITLE_PROMPT_NAME,
    type: "title",
  });
  const defaultTitlePrompt =
    "YOUR ONLY TASK IS TO GENERATE A NEWS ARTICLE TITLE. Output MUST be plain text only, on a single line. NO HTML, NO Markdown. NO preambles. NO prefixes like 'Title: '.\n\n" +
    "You are an expert sports journalist. Generate a **new, original, SEO-friendly title** for a news article based on the following original title and description. The new title MUST be highly distinct from the original, capture a fresh angle, and avoid simply rephrasing original keywords.\n\n" +
    "Original Title: {original_title}\nOriginal Description: {original_description}\n\n" +
    "Generated Title:";
  let finalTitlePrompt = titlePromptDoc?.prompt || defaultTitlePrompt;
  let journalistTonePrompt = "";
  if (journalistId) {
    const journalist = await AIJournalist.findById(journalistId);
    if (journalist && journalist.isActive) {
      journalistTonePrompt = `As "${journalist.name}", your unique journalistic voice and tone should be: ${journalist.tonePrompt}\n\n`;
    }
  }
  const fullPrompt = `${journalistTonePrompt}${finalTitlePrompt}`
    .replace("{original_title}", originalTitle)
    .replace("{original_description}", originalDescription);
  let aiResponseText: string = "";
  const MAX_RETRIES = 3,
    RETRY_DELAY_MS = 2000,
    AI_CALL_TIMEOUT_MS = 20000;
  for (let i = 0; i < MAX_RETRIES; i++) {
    try {
      const result: any = await Promise.race([
        model.generateContent(fullPrompt),
        new Promise((_, reject) =>
          setTimeout(
            () => reject(new Error("AI title generation timed out.")),
            AI_CALL_TIMEOUT_MS
          )
        ),
      ]);
      aiResponseText = (await result.response).text();
      break;
    } catch (aiError: any) {
      if (
        i < MAX_RETRIES - 1 &&
        (aiError.message.includes("timed out.") ||
          aiError.status === 429 ||
          (aiError.status >= 500 && aiError.status < 600))
      ) {
        await new Promise((res) => setTimeout(res, RETRY_DELAY_MS));
      } else {
        throw new Error(
          `AI title generation failed after ${MAX_RETRIES} retries: ${aiError.message}`
        );
      }
    }
  }
  if (!aiResponseText)
    throw new Error("AI title generation failed to produce a response.");
  let generatedTitle = aiResponseText
    .trim()
    .replace(/^```(?:html|text|json)?\n?|```$/g, "")
    .trim()
    .replace(
      /<!DOCTYPE html>[\s\S]*?<body[^>]*>|(?<=<\/body>)[\s\S]*$|<\/body>|<\/html>|<\/head>|<\/title>|<\/meta>|<\/link>|<\/style>|<style[^>]*>[\s\S]*?<\/style>|<script[^>]*>[\s\S]*?<\/script>/g,
      ""
    )
    .trim()
    .replace(/<html[^>]*>|<body[^>]*>/g, "")
    .trim()
    .replace(/^\s*\n/gm, "")
    .trim()
    .replace(/^(AI JOURNALIST TONE & STYLE:[\s\S]*?\n\n)?/i, "")
    .trim()
    .replace(
      /^(Here's the (title|article|rewritten title|news article|requested article|response)|Article Title|Generated Title|Title):?\s*\n*/i,
      ""
    )
    .trim()
    .replace(/<[^>]*>?/gm, "")
    .replace(/[\*_`#\[\]\n]/g, "")
    .trim();
  const jaccardSimilarity = calculateJaccardSimilarity(
    originalTitle.toLowerCase(),
    generatedTitle.toLowerCase()
  );
  if (
    generatedTitle.length < 10 ||
    jaccardSimilarity > 0.4 ||
    generatedTitle.toLowerCase() === originalTitle.toLowerCase()
  ) {
    throw new Error(
      `Generated title failed strict validation (too short, not unique, or too similar).`
    );
  }
  return generatedTitle;
}

async function generateContent(
  originalTitle: string,
  originalDescription: string,
  originalContent: string | null,
  articleLink: string,
  generatedTitle: string,
  journalistId?: string
): Promise<string> {
  const contentPromptDoc = await AIPrompt.findOne({
    name: CONTENT_PROMPT_NAME,
    type: "content",
  });
  const defaultContentPrompt =
    "Your ONLY TASK IS TO GENERATE A NEWS ARTICLE CONTENT in HTML. NO Markdown, NO preambles, NO extra text, NO code block wrappers (```html). DO NOT INCLUDE `<!DOCTYPE html>`, `<html>`, `<head>`, `<body>`, `<h1>`, or any other full document tags. \n\n" +
    "You are an expert sports journalist. Analyze the following news title, description, and provided context. Your goal is to generate a comprehensive, human-like, SEO-optimized HTML article, approximately 700 words long. Focus on deep insights, storytelling, and compelling analysis.\n\n" +
    "**GUIDELINES:**\n" +
    "1.  **HTML CONTENT:** Provide valid HTML. Use `<h2>` for main headings (optimized for keywords), `<p>` for paragraphs, `<strong>`, `<em>`, `<ul>`, `<li>`, `<a>`. Ensure natural flow, rich detail, and human tone. Integrate relevant keywords naturally throughout the article for SEO, but avoid stuffing.\n\n" +
    "**HTML Example Structure:**\n" +
    "<h2>Introduction Heading</h2><p>This is the engaging introduction paragraph...</p>\n" +
    "<h2>Key Developments</h2><p>Here's a detailed paragraph...</p><ul><li>...</li></ul><p>...</p><h2>Conclusion</h2><p>The concluding paragraph summarizes...</p>\n\n" +
    "**IMPORTANT:** If the provided content is too short or lacks sufficient detail for a 700-word SEO-optimized expansion, respond ONLY with 'CONTENT INSUFFICIENT FOR EXPANSION: [brief reason]'. No other text.\n\n" +
    "Generated Article Title: {generated_title}\nOriginal News Title: {original_title}\nOriginal News Description: {original_description}\nAdditional Context: {additional_context}";
  let finalContentPrompt = contentPromptDoc?.prompt || defaultContentPrompt;
  let journalistTonePrompt = "";
  if (journalistId) {
    const journalist = await AIJournalist.findById(journalistId);
    if (journalist && journalist.isActive) {
      journalistTonePrompt = `As "${journalist.name}", your unique journalistic voice and tone should be: ${journalist.tonePrompt}\n\n`;
    }
  }
  let combinedArticleContext = "";
  const MIN_TOTAL_CONTEXT_FOR_GENERATION = 100;
  if (originalTitle) combinedArticleContext += `Title: ${originalTitle}\n`;
  if (originalDescription)
    combinedArticleContext += `Description: ${originalDescription}\n`;
  if (originalContent && originalContent.length > 50) {
    combinedArticleContext += `\nFull Content: ${originalContent}\n`;
  }
  if (
    articleLink &&
    combinedArticleContext.length < MIN_TOTAL_CONTEXT_FOR_GENERATION
  ) {
    const fetchedWebContent = await fetchAndExtractWebpageContent(articleLink);
    if (fetchedWebContent && fetchedWebContent.length > 50) {
      combinedArticleContext += `\nWebpage Context: ${fetchedWebContent}\n`;
    }
  }
  if (
    !combinedArticleContext ||
    combinedArticleContext.length < MIN_TOTAL_CONTEXT_FOR_GENERATION
  ) {
    throw new Error(
      "Article content (title, description, or external content) too short or missing to generate content."
    );
  }
  const MAX_CONTENT_LENGTH_TO_SEND = 8000;
  if (combinedArticleContext.length > MAX_CONTENT_LENGTH_TO_SEND) {
    combinedArticleContext =
      combinedArticleContext.substring(0, MAX_CONTENT_LENGTH_TO_SEND) +
      "... (truncated for AI processing)";
  }
  const fullPrompt = `${journalistTonePrompt}${finalContentPrompt}`
    .replace("{generated_title}", generatedTitle)
    .replace("{original_title}", originalTitle)
    .replace("{original_description}", originalDescription)
    .replace("{additional_context}", combinedArticleContext);
  let aiResponseText: string = "";
  const MAX_RETRIES = 3,
    RETRY_DELAY_MS = 3000,
    AI_CALL_TIMEOUT_MS = 90000;
  for (let i = 0; i < MAX_RETRIES; i++) {
    try {
      const result: any = await Promise.race([
        model.generateContent(fullPrompt),
        new Promise((_, reject) =>
          setTimeout(
            () => reject(new Error("AI content generation timed out.")),
            AI_CALL_TIMEOUT_MS
          )
        ),
      ]);
      aiResponseText = (await result.response).text();
      break;
    } catch (aiError: any) {
      if (
        i < MAX_RETRIES - 1 &&
        (aiError.message.includes("timed out.") ||
          aiError.status === 429 ||
          (aiError.status >= 500 && aiError.status < 600))
      ) {
        await new Promise((res) => setTimeout(res, RETRY_DELAY_MS));
      } else {
        throw new Error(
          `AI content generation failed after ${MAX_RETRIES} retries: ${aiError.message}`
        );
      }
    }
  }
  if (!aiResponseText)
    throw new Error("AI content generation failed to produce a response.");
  let generatedContent = aiResponseText
    .trim()
    .replace(/^```(?:html|text|json)?\n?|```$/g, "")
    .trim()
    .replace(
      /<!DOCTYPE html>[\s\S]*?<body[^>]*>|(?<=<\/body>)[\s\S]*$|<\/body>|<\/html>|<\/head>|<\/title>|<\/meta>|<\/link>|<\/style>|<style[^>]*>[\s\S]*?<\/style>|<script[^>]*>[\s\S]*?<\/script>/g,
      ""
    )
    .trim()
    .replace(/<html[^>]*>|<body[^>]*>/g, "")
    .trim()
    .replace(/^\s*\n/gm, "")
    .trim()
    .replace(/^(AI JOURNALIST TONE & STYLE:[\s\S]*?\n\n)?/i, "")
    .trim()
    .replace(
      /^(Here's the (article|rewritten article|news article|requested article|response)|Article|News Article|Your Article|Generated Article|Title):?\s*\n*/i,
      ""
    )
    .trim();
  if (generatedContent.includes("---START_CONTENT---")) {
    generatedContent =
      generatedContent.split("---START_CONTENT---")[1] || generatedContent;
  }
  if (
    generatedContent
      .toUpperCase()
      .includes("CONTENT INSUFFICIENT FOR EXPANSION")
  ) {
    throw new Error("AI determined content insufficient for expansion.");
  }
  let finalContent = md.render(generatedContent);
  const hasHtmlTags = /<[a-z][\s\S]*>/i.test(finalContent);
  const hasMarkdownChars = /[*_`#\[\]]/.test(finalContent);
  if (!hasHtmlTags || hasMarkdownChars) {
    throw new Error(
      `AI output format error: Content is not valid HTML after post-processing or still contains Markdown.`
    );
  }
  if (finalContent.includes("<h1")) {
    throw new Error(
      `AI output format error: Content unexpectedly contains <h1> tags.`
    );
  }
  return finalContent;
}

// POST handler to orchestrate the AI processing pipeline (unchanged)
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  let externalArticle: IExternalNewsArticle | null = null;
  let journalistName = "AI Auto-Generator";

  try {
    const {
      articleId,
      sportCategory,
      journalistId,
    }: { articleId: string; sportCategory?: string; journalistId?: string } =
      await request.json();

    if (!articleId) {
      console.error("[Process Article Orchestrator] Missing Article ID.");
      return NextResponse.json(
        { error: "Article ID is required." },
        { status: 400 }
      );
    }

    externalArticle = await ExternalNewsArticle.findOne({ articleId });

    if (!externalArticle) {
      console.error(
        `[Process Article Orchestrator] External news article not found: ${articleId}`
      );
      return NextResponse.json(
        { error: "External news article not found." },
        { status: 404 }
      );
    }

    if (externalArticle.status === "processed") {
      console.log(
        `[Process Article Orchestrator] Article ${articleId} already processed. Skipping.`
      );
      return NextResponse.json(
        { message: "Article already processed." },
        { status: 200 }
      );
    }
    if (externalArticle.status === "processing") {
      console.warn(
        `[Process Article Orchestrator] Article ${articleId} is already in 'processing' state. Aborting duplicate request.`
      );
      return NextResponse.json(
        { error: "Article is already being processed. Please wait." },
        { status: 409 }
      );
    }

    externalArticle.status = "processing";
    await externalArticle.save();
    console.log(
      `[Process Article Orchestrator] Starting processing for article: ${externalArticle.articleId}, current status updated to 'processing'.`
    );

    // --- Fetch Journalist Name (for author field later) ---
    if (journalistId) {
      const journalist = await AIJournalist.findById(journalistId);
      if (journalist && journalist.isActive) {
        journalistName = journalist.name;
      }
    }

    // 1. Generate Title via dedicated function call
    let newPostTitle: string = "";
    try {
      console.log(
        `[Orchestrator] Calling local generateTitle function for article ${externalArticle.articleId}...`
      );
      newPostTitle = await generateTitle(
        externalArticle.title,
        externalArticle.description || "",
        journalistId
      );
      console.log(
        `[Orchestrator] Successfully generated title: "${newPostTitle}"`
      );
      if (!newPostTitle)
        throw new Error("AI Title Generation returned no title.");
    } catch (titleError: any) {
      console.error(
        `[Orchestrator] Title generation failed for article ${externalArticle.articleId}:`,
        titleError.message
      );
      throw new Error(`Title generation failed: ${titleError.message}`);
    }

    // 2. Generate Content via dedicated function call
    let rewrittenContent: string = "";
    try {
      console.log(
        `[Orchestrator] Calling local generateContent function for article ${externalArticle.articleId}...`
      );
      rewrittenContent = await generateContent(
        externalArticle.title,
        externalArticle.description || "",
        externalArticle.content,
        externalArticle.link,
        newPostTitle,
        journalistId
      );
      console.log(
        `[Orchestrator] Successfully generated content. Length: ${rewrittenContent.length}`
      );
      if (!rewrittenContent)
        throw new Error("AI Content Generation returned no content.");
    } catch (contentError: any) {
      console.error(
        `[Orchestrator] Content generation failed for article ${externalArticle.articleId}:`,
        contentError.message
      );
      throw new Error(`Content generation failed: ${contentError.message}`);
    }

    // 3. Process/Generate Featured Image (Existing logic)
    let featuredImageUrl: string | null = null;
    let featuredImageTitle: string | undefined = undefined;
    let featuredImageAltText: string | undefined = undefined;

    // Fallback: Use the original external article's image and proxy it to R2.
    if (externalArticle.imageUrl) {
      try {
        console.log(
          `[Orchestrator] Proxying original image for article ${externalArticle.articleId}...`
        );
        featuredImageUrl = await proxyAndUploadOriginalImage(
          externalArticle.imageUrl,
          newPostTitle
        );
        if (featuredImageUrl) {
          console.log(
            `[Orchestrator] Original image proxied successfully: ${featuredImageUrl}`
          );
        } else {
          console.warn(
            `[Orchestrator] Failed to proxy original image for article ${externalArticle.articleId}. No featured image will be set.`
          );
        }
      } catch (proxyError: any) {
        console.error(
          `[Orchestrator] Error proxying original image for article ${externalArticle.articleId}:`,
          proxyError.message
        );
      }
    } else {
      console.log(
        `[Orchestrator] No image URL found in external article ${externalArticle.articleId}. Skipping image processing.`
      );
    }

    featuredImageTitle = newPostTitle;
    featuredImageAltText = `${newPostTitle} image`;

    // 4. Save the rewritten article as a new Post
    const postSlug = slugify(newPostTitle, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });

    const existingPostWithSlug = await Post.findOne({ slug: postSlug });
    let finalSlug = postSlug;
    if (existingPostWithSlug) {
      finalSlug = `${postSlug}-${Date.now().toString().slice(-5)}`;
      console.warn(
        `[Orchestrator - Post Save] Post with slug '${postSlug}' already exists, new slug: '${finalSlug}'`
      );
    }

    const plainTextContent = rewrittenContent.replace(/<[^>]*>?/gm, "");

    const newPost = new Post({
      title: newPostTitle,
      content: rewrittenContent,
      status: "draft",
      slug: finalSlug,
      author: journalistName,
      featuredImage: featuredImageUrl,
      featuredImageTitle: featuredImageTitle,
      featuredImageAltText: featuredImageAltText,
      sport: sportCategory || externalArticle.category?.[0] || "general",
      metaTitle: `${newPostTitle} - Sports News`,
      metaDescription: plainTextContent.substring(0, 150) + "...",
      isAIGenerated: true,
      originalExternalArticleId: externalArticle._id,
    });

    console.log(
      `[Orchestrator - Post Save] Attempting to save new Post with title: "${
        newPost.title
      }", slug: "${newPost.slug}", image: ${!!newPost.featuredImage}`
    );
    await newPost.save();
    console.log(
      `[Orchestrator - Post Save] Post saved successfully. New Post ID: ${newPost._id}`
    );

    // 5. Final Status Update and Success Response
    externalArticle.status = "processed";
    externalArticle.processedPostId = newPost._id;
    await externalArticle.save();
    console.log(
      `[Orchestrator - Status Update] ExternalNewsArticle ${externalArticle.articleId} status updated to 'processed'.`
    );

    return NextResponse.json(
      {
        message: "Article processed and new post created successfully.",
        postId: newPost._id,
        postSlug: newPost.slug,
      },
      { status: 201 }
    );
  } catch (error: any) {
    // --- Centralized Error Handling and Status Update ---
    let errorMessage = "Server error processing external news.";
    let clientStatus = 500;

    const isCustomError = error instanceof Error;
    let finalArticleStatus: "skipped" | "error" = "error";

    if (isCustomError) {
      errorMessage = error.message;
      if (errorMessage.includes("AI determined content insufficient")) {
        clientStatus = 200;
        finalArticleStatus = "skipped";
      } else if (
        errorMessage.includes("AI output format error") ||
        errorMessage.includes("AI-generated title failed strict validation") ||
        errorMessage.includes("Content generation failed") ||
        errorMessage.includes("Title generation failed")
      ) {
        clientStatus = 422;
      } else if (errorMessage.includes("AI generation timed out")) {
        clientStatus = 504;
      } else if (
        errorMessage.includes("Article has no content") ||
        errorMessage.includes("content too short")
      ) {
        clientStatus = 400;
        finalArticleStatus = "skipped";
      } else if (errorMessage.includes("AI generation failed after")) {
        clientStatus = 500;
      } else if (errorMessage.includes("quota")) {
        errorMessage =
          "Gemini API Quota Exceeded. Please check your usage in Google AI Studio.";
        clientStatus = 429;
      } else if (
        errorMessage.includes("not found") ||
        errorMessage.includes("Network Error") ||
        errorMessage.includes("Failed to fetch content")
      ) {
        clientStatus = 404;
      } else if (axios.isAxiosError(error) && error.response) {
        errorMessage = `External API error: ${
          error.response.data?.error ||
          error.response?.data?.results?.message ||
          error.message
        }`;
        clientStatus = error.response.status || 500;
      } else if (
        error.message.includes("MongooseError") ||
        error.message.includes("MongoNetworkError")
      ) {
        errorMessage = `Database error: ${error.message}`;
        clientStatus = 500;
      }
    } else {
      errorMessage = `An unexpected error occurred: ${JSON.stringify(error)}`;
    }

    console.error(
      `[Process Article Orchestrator] Critical error processing external news article ${
        externalArticle?.articleId || "unknown"
      }: ${errorMessage}`,
      "\nFull Error Object:",
      error
    );

    if (externalArticle && externalArticle.status === "processing") {
      console.error(
        `[Process Article Orchestrator] Marking external article ${externalArticle.articleId} as '${finalArticleStatus}' due to critical failure.`
      );
      externalArticle.status = finalArticleStatus;
      try {
        await externalArticle.save();
      } catch (dbSaveError) {
        console.error(
          `[Process Article Orchestrator] Failed to save final external article status to '${finalArticleStatus}':`,
          dbSaveError
        );
      }
    } else if (externalArticle && externalArticle.status !== "processed") {
      console.error(
        `[Process Article Orchestrator] Marking external article ${externalArticle.articleId} as 'error' due to unhandled failure (status was ${externalArticle.status}).`
      );
      externalArticle.status = "error";
      try {
        await externalArticle.save();
      } catch (dbSaveError) {
        console.error(
          `[Orchestrator] Failed to save external article status to 'error':`,
          dbSaveError
        );
      }
    }

    return NextResponse.json({ error: errorMessage }, { status: clientStatus });
  }
}


// ===== src\app\api\auth\[...nextauth]\route.ts =====
// src/app/api/auth/[...nextauth]/route.ts

import NextAuth, { NextAuthOptions } from "next-auth";
// --- Adapter Imports ---
import { MongoDBAdapter } from "@auth/mongodb-adapter";
import clientPromise from "@/lib/mongoClient";

// --- Provider Imports ---
import GoogleProvider from "next-auth/providers/google";
import CredentialsProvider from "next-auth/providers/credentials";

// --- Mongoose Imports (for Credentials Provider) ---
import dbConnect from "@/lib/dbConnect";
import User, { IUser } from "@/models/User"; // <-- Import IUser
import bcrypt from "bcrypt";

export const authOptions: NextAuthOptions = {
  adapter: MongoDBAdapter(clientPromise),

  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
    CredentialsProvider({
      name: 'Credentials',
      credentials: { },
      async authorize(credentials: any) {
        if (!credentials?.email || !credentials.password) {
          throw new Error('Please enter an email and password');
        }
        
        await dbConnect(); 
        
        const user = await User.findOne({ email: credentials.email }).select('+password');
        
        if (!user || !user.password) {
          throw new Error('Invalid credentials');
        }

        const isPasswordCorrect = await bcrypt.compare(
          credentials.password,
          user.password
        );

        if (!isPasswordCorrect) {
          throw new Error('Invalid credentials');
        }

        // Return the full user object on success
        return user;
      }
    })
  ],
  
  session: { strategy: "jwt" },

  // --- THIS IS THE NEW/UPDATED PART ---
  callbacks: {
    // This callback is called whenever a JWT is created or updated.
    // We want to add the user's role and ID to the token.
    jwt: async ({ token, user }) => {
      if (user) {
        const u = user as IUser; // Cast to our user type
        token.role = u.role;
        token.id = u.id;
      }
      return token;
    },

    // This callback is called whenever a session is checked.
    // We want to add the role and ID from the token to the session object.
    session: async ({ session, token }) => {
      if (session?.user) {
        session.user.role = token.role as 'user' | 'admin';
        session.user.id = token.id as string;
      }
      return session;
    },
  },
  // --- END OF NEW/UPDATED PART ---

  pages: { signIn: "/login" },
  secret: process.env.NEXT_PUBLIC_NEXTAUTH_SECRET,
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };

// ===== src\app\api\banners\route.ts =====
// src/app/api/banners/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Banner, { IBanner } from "@/models/Banner";

// GET handler remains the same...
export async function GET(request: Request) {
  // ... no changes here
  const { searchParams } = new URL(request.url);
  const activeOnly = searchParams.get("active") === "true";
  const location = searchParams.get("location");

  const query: { isActive?: boolean; location?: string } = {};
  if (activeOnly) {
    query.isActive = true;
  }
  if (location) {
    query.location = location;
  }

  try {
    await dbConnect();
    const banners = await Banner.find(query).sort({ createdAt: -1 });
    return NextResponse.json(banners);
  } catch (error) {
    console.error("Failed to fetch banners:", error);
    return NextResponse.json(
      { error: "Server error fetching banners" },
      { status: 500 }
    );
  }
}

// --- POST a New Banner ---
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body: Partial<IBanner> = await request.json();

    console.log(
      "[API/Banners] Received POST request with body:",
      JSON.stringify(body, null, 2)
    );

    const { title, imageUrl, linkUrl, isActive, location } = body;

    if (!title || !imageUrl || !linkUrl || !location) {
      console.error(
        "[API/Banners] Validation failed. Missing required fields."
      );
      return NextResponse.json(
        { error: "Title, Image URL, Link URL, and Location are required" },
        { status: 400 }
      );
    }

    await dbConnect();

    // Mongoose will now correctly use the schema that includes 'location'
    const newBanner = new Banner({
      title,
      imageUrl,
      linkUrl,
      isActive,
      location,
    });

    await newBanner.save(); // This would throw an error if location was missing and the schema was loaded correctly
    console.log("[API/Banners] New banner created successfully:", newBanner);
    return NextResponse.json(newBanner, { status: 201 });
  } catch (error: any) {
    console.error("[API/Banners] Failed to create banner:", error.message);
    return NextResponse.json(
      { error: "Server error creating banner" },
      { status: 500 }
    );
  }
}


// ===== src\app\api\banners\[bannerId]\route.ts =====
// src/app/api/banners/[bannerId]/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Banner, { IBanner } from "@/models/Banner";

interface Params {
  params: { bannerId: string };
}

// --- PUT (Update) a Banner ---
// Protected: Only admins can update.
export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { bannerId } = params;
  try {
    const body: Partial<IBanner> = await request.json();
    // --- THE FIX IS HERE ---
    // Destructure ALL fields from the body that you intend to update.
    const { title, imageUrl, linkUrl, isActive, location } = body;

    await dbConnect();

    const updatedBanner = await Banner.findByIdAndUpdate(
      bannerId,
      {
        // Pass an explicit object with all the fields to Mongoose.
        // This ensures 'location' is included in the update.
        title,
        imageUrl,
        linkUrl,
        isActive,
        location,
      },
      { new: true, runValidators: true }
    );

    if (!updatedBanner) {
      return NextResponse.json({ error: "Banner not found" }, { status: 404 });
    }

    return NextResponse.json(updatedBanner);
  } catch (error) {
    console.error("Error updating banner:", error);
    return NextResponse.json(
      { error: "Server error updating banner" },
      { status: 500 }
    );
  }
}

// --- DELETE a Banner ---
// (No changes needed for the DELETE handler)
export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { bannerId } = params;
  try {
    await dbConnect();
    const deletedBanner = await Banner.findByIdAndDelete(bannerId);
    if (!deletedBanner) {
      return NextResponse.json({ error: "Banner not found" }, { status: 404 });
    }
    return NextResponse.json({ message: "Banner deleted successfully" });
  } catch (error) {
    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}


// ===== src\app\api\casino-partners\route.ts =====
// src/app/api/casino-partners/route.ts
import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import CasinoPartner from "@/models/CasinoPartner";

// GET handler to retrieve active Casino Partners for public display
export async function GET(request: Request) {
  await dbConnect();

  try {
    const { searchParams } = new URL(request.url);
    const featuredOnly = searchParams.get("featured") === "true";

    const query: { isActive: boolean; isFeatured?: boolean } = {
      isActive: true,
    };
    if (featuredOnly) {
      query.isFeatured = true;
    }

    // Sort by 'order' ascending (lower numbers first), then 'isFeatured' (true first), then random fallback
    // Random fallback helps if multiple partners have the same order/featured status, provides variety
    const partners = await CasinoPartner.aggregate([
      { $match: query }, // Filter by active and optionally featured
      { $addFields: { __rand: { $rand: {} } } }, // Add a random field for tie-breaking
      { $sort: { order: 1, isFeatured: -1, __rand: 1 } }, // Sort by order, then featured (desc), then random
      { $project: { __rand: 0 } }, // Remove the random field from output
      { $limit: 10 }, // Limit the number of partners returned to a reasonable amount
    ]);

    return NextResponse.json(partners, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching Casino Partners (Public):", error.message);
    return NextResponse.json(
      { error: "Server error fetching Casino Partners." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\contact\route.ts =====
// src/app/api/contact/route.ts
import { NextResponse } from "next/server";

interface ContactFormData {
  name: string;
  email: string;
  subject: string;
  message: string;
}

export async function POST(request: Request) {
  try {
    const { name, email, subject, message }: ContactFormData =
      await request.json();

    // Basic validation
    if (!name || !email || !subject || !message) {
      return NextResponse.json(
        { error: "All fields are required." },
        { status: 400 }
      );
    }
    if (!email.includes("@") || !email.includes(".")) {
      return NextResponse.json(
        { error: "Please enter a valid email address." },
        { status: 400 }
      );
    }

    console.log("[Contact API] New contact form submission:");
    console.log(`- Name: ${name}`);
    console.log(`- Email: ${email}`);
    console.log(`- Subject: ${subject}`);
    console.log(`- Message: ${message}`);

    // --- Placeholder for actual email sending logic ---
    // In a real application, you would integrate with an email sending service here, e.g.:
    // - Nodemailer (for SMTP)
    // - SendGrid, Mailgun, Resend, AWS SES (for transactional emails)
    // - Saving to a database for CRM integration
    // Example:
    /*
    const sendEmailResult = await sendEmailService.send({
      to: 'your-support-email@fanskor.com',
      from: 'noreply@fanskor.com',
      subject: `Fanskor Contact Form: ${subject}`,
      html: `
        <p><strong>Name:</strong> ${name}</p>
        <p><strong>Email:</strong> ${email}</p>
        <p><strong>Subject:</strong> ${subject}</p>
        <p><strong>Message:</strong></p>
        <p>${message}</p>
      `,
    });
    if (!sendEmailResult.success) {
        console.error('[Contact API] Failed to send email:', sendEmailResult.error);
        return NextResponse.json({ error: 'Failed to send message. Please try again later.' }, { status: 500 });
    }
    */
    // --- End Placeholder ---

    return NextResponse.json(
      { message: "Your message has been sent successfully!" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      "[Contact API] Error processing contact form submission:",
      error.message
    );
    return NextResponse.json(
      { error: "An unexpected error occurred." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\countries\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';
import { Country } from '@/types/api-football'; // We will define this type

// This function handles GET requests to /api/countries
export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/countries`,
    headers: {
      // Securely read API key and host from environment variables
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };


  try {
    const response = await axios.request(options);

    // --- Data Transformation ---
    // We will clean and simplify the data before sending it to the frontend.
    const transformedCountries: Country[] = response.data.response
      // 1. Filter out any countries that are missing essential data
      .filter((country: any) => country.name && country.code && country.flag)
      // 2. Map the raw data to our clean, simplified `Country` type
      .map((country: any) => ({
        name: country.name,
        code: country.code,
        flagUrl: country.flag,
      }));

    // 3. Sort the countries alphabetically for a better user experience
    transformedCountries.sort((a, b) => a.name.localeCompare(b.name));
    

    return NextResponse.json(transformedCountries);

  } catch (error) {
    console.error("Error fetching countries:", error);
    return NextResponse.json(
      { error: 'Failed to fetch country data.' },
      { status: 500 }
    );
  }
}

// ===== src\app\api\country-stats\route.ts =====
// src/app/api/country-stats/route.ts
import { NextResponse } from "next/server";
import axios from "axios";

// A curated list of popular league IDs to source teams from.
const POPULAR_LEAGUE_IDS = [
  39, 140, 135, 78, 61, 88, 94, 253, 2, 3, 45, 48, 71, 62, 144, 203, 197, 218,
];
const season = new Date().getFullYear();

export async function GET() {
  const options = (leagueId: number) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
    params: { league: leagueId, season: season },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    const teamPromises = POPULAR_LEAGUE_IDS.map((id) =>
      axios.request(options(id))
    );
    const responses = await Promise.allSettled(teamPromises);

    const allTeamsResponses = responses
      .filter(
        (result) => result.status === "fulfilled" && result.value.data.response
      )
      .flatMap(
        (result) => (result as PromiseFulfilledResult<any>).value.data.response
      );

    // --- THIS IS THE FIX ---
    // 1. De-duplicate the teams first using a Map based on the unique team ID.
    // This ensures that a team like "Manchester City" which is in both the Premier League (39)
    // and the Champions League (2) is only processed once.
    const uniqueTeams = Array.from(
      new Map(allTeamsResponses.map((item) => [item.team.id, item])).values()
    );

    // 2. Now, count the de-duplicated teams.
    const countryTeamCounts: { [key: string]: number } = {};
    uniqueTeams.forEach((item) => {
      const countryName = item.team.country;
      if (countryName) {
        if (!countryTeamCounts[countryName]) {
          countryTeamCounts[countryName] = 0;
        }
        countryTeamCounts[countryName]++;
      }
    });

    return NextResponse.json(countryTeamCounts);
  } catch (error) {
    console.error("Error fetching country stats:", error);
    return NextResponse.json(
      { error: "Failed to fetch country statistics." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\directory\countries\route.ts =====
// src/app/api/directory/countries/route.ts
import { NextResponse, NextRequest } from "next/server"; // Import NextRequest
import axios from "axios";

// The GET function now accepts the 'request' object
export async function GET(request: NextRequest) {
  try {
    // --- THIS IS THE FIX ---
    // 1. Get the protocol (http or https) and host (localhost:3000 or your domain)
    //    from the incoming request headers. This is the most reliable method.
    const protocol = request.headers.get("x-forwarded-proto") || "http";
    const host = request.headers.get("host");

    // 2. Construct the absolute URL for the internal API call.
    const internalApiUrl = `${protocol}://${host}/api/leagues?fetchAll=true`;

    // 3. Make the internal API call using the constructed URL.
    const leaguesResponse = await axios.get(internalApiUrl);
    const allLeagues = leaguesResponse.data;

    if (!allLeagues || allLeagues.length === 0) {
      return NextResponse.json([]);
    }

    const leagueCounts: { [key: string]: number } = {};
    allLeagues.forEach((league: any) => {
      if (league.countryName) {
        leagueCounts[league.countryName] =
          (leagueCounts[league.countryName] || 0) + 1;
      }
    });

    const countriesResponse = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/countries`,
      {
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );

    const allCountries = countriesResponse.data.response;

    let enrichedCountries = allCountries
      .map((country: any) => ({
        name: country.name,
        code: country.code,
        flagUrl: country.flag,
        leagueCount: leagueCounts[country.name] || 0,
      }))
      .filter(
        (country: any) =>
          country.leagueCount > 0 &&
          country.name &&
          country.code &&
          country.flagUrl
      );

    enrichedCountries.sort((a, b) => a.name.localeCompare(b.name));

    return NextResponse.json(enrichedCountries);
  } catch (error) {
    console.error("Error building country directory from all leagues:", error);
    if (axios.isAxiosError(error)) {
      console.error("Axios error details:", error.response?.data);
    }
    return NextResponse.json(
      { error: "Failed to build country directory." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\directory\teams\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';

// A curated list of popular league IDs to source teams from.
const POPULAR_LEAGUE_IDS = [
  39,  // England - Premier League
  140, // Spain - La Liga
  135, // Italy - Serie A
  78,  // Germany - Bundesliga
  61,  // France - Ligue 1
  88,  // Netherlands - Eredivisie
  94,  // Portugal - Primeira Liga
  253, // USA - MLS
  2,   // UEFA Champions League
];

const season = new Date().getFullYear();

// This function handles GET requests to /api/directory/teams
export async function GET() {
  const options = (leagueId: number) => ({
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
    params: { league: leagueId, season: season },
    headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    // 1. Fetch all teams from all popular leagues in parallel
    const teamPromises = POPULAR_LEAGUE_IDS.map(id => axios.request(options(id)));
    const responses = await Promise.allSettled(teamPromises);

    // 2. Aggregate all teams and filter out any failed requests
    const allTeamsResponses = responses
      .filter(result => result.status === 'fulfilled')
      .flatMap(result => (result as PromiseFulfilledResult<any>).value.data.response);

    // 3. De-duplicate the teams using a Map (a team can be in a league and a cup)
    const uniqueTeams = Array.from(new Map(allTeamsResponses.map(item => [item.team.id, item])).values());

    // 4. Sort the final list alphabetically for a better user experience
    uniqueTeams.sort((a, b) => a.team.name.localeCompare(b.team.name));
    
    return NextResponse.json(uniqueTeams);

  } catch (error) {
    console.error("Error fetching teams for directory:", error);
    return NextResponse.json(
      { error: 'Failed to fetch teams data.' },
      { status: 500 }
    );
  }
}

// ===== src\app\api\find-live-matches\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';

// This function handles GET requests to /api/live-matches
export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: { live: 'all' },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    // Directly return the array of live fixtures
    
    return NextResponse.json(response.data.response);
  } catch (error) {
    console.error("Error fetching live matches:", error);
    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src\app\api\fixtures\route.ts =====
import { NextResponse } from "next/server";
import axios from "axios";
import { format, addDays } from "date-fns";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get("league");
  const date = searchParams.get("date");
  const season = searchParams.get("season");

  // Base options for axios requests
  const axiosOptions = (params: object) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params,
    headers: {
      "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  });

  try {
    // --- PATTERN 1: Get all fixtures for a specific LEAGUE and SEASON ---
    // Used by the new "Season View" in the LeagueFixturesTab.
    if (leagueId && season) {
      console.log(
        `API: Fetching all fixtures for league ${leagueId}, season ${season}`
      );
      const response = await axios.request(
        axiosOptions({
          league: leagueId,
          season: season,
        })
      );
      // Sort matches by date, as the API might not return them in chronological order
      const sortedMatches = response.data.response.sort(
        (a: any, b: any) =>
          new Date(a.fixture.date).getTime() -
          new Date(b.fixture.date).getTime()
      );
      return NextResponse.json(sortedMatches);
    }

    // --- PATTERN 2: Get all fixtures for a specific LEAGUE and DATE ---
    // Used by the original day-by-day fixtures tab.
    if (leagueId && date) {
      console.log(
        `API: Fetching fixtures for league ${leagueId}, date ${date}`
      );
      const response = await axios.request(
        axiosOptions({
          league: leagueId,
          season: new Date(date).getFullYear().toString(), // Use the year from the date for the season
          date: date,
        })
      );
      return NextResponse.json(response.data.response);
    }

    // --- PATTERN 3: Get upcoming matches for a specific LEAGUE ---
    // Used by the homepage slider when a league is selected.
    if (leagueId) {
      console.log(`API: Fetching upcoming fixtures for league ${leagueId}`);
      const today = format(new Date(), "yyyy-MM-dd");
      const nextSevenDays = format(addDays(new Date(), 7), "yyyy-MM-dd");
      const response = await axios.request(
        axiosOptions({
          league: leagueId,
          season: new Date().getFullYear().toString(),
          from: today,
          to: nextSevenDays,
        })
      );
      return NextResponse.json(response.data.response);
    }

    // --- PATTERN 4: Get GLOBAL matches (live, today, tomorrow) if no league is specified ---
    // This is the default for the homepage.
    if (!leagueId) {
      // If a specific date is provided for the global view, use it.
      if (date) {
        console.log(`API: Fetching global fixtures for date ${date}`);
        const response = await axios.request(axiosOptions({ date: date }));
        return NextResponse.json(response.data.response);
      }

      // Fallback to the original "live, today, tomorrow" logic if no date is provided.
      console.log("API: Fetching global matches (live, today, tomorrow)");
      const todayStr = format(new Date(), "yyyy-MM-dd");
      const tomorrowStr = format(addDays(new Date(), 1), "yyyy-MM-dd");

      const [liveResponse, todayResponse, tomorrowResponse] = await Promise.all(
        [
          axios.request(axiosOptions({ live: "all" })),
          axios.request(axiosOptions({ date: todayStr })),
          axios.request(axiosOptions({ date: tomorrowStr })),
        ]
      );

      const allMatches = [
        ...liveResponse.data.response,
        ...todayResponse.data.response,
        ...tomorrowResponse.data.response,
      ];

      const uniqueMatches = Array.from(
        new Map(allMatches.map((m) => [m.fixture.id, m])).values()
      );
      return NextResponse.json(uniqueMatches);
    }

    return NextResponse.json([]);
  } catch (error) {
    console.error("Error in /api/fixtures:", error);
    return NextResponse.json(
      { error: "Failed to fetch fixture data." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\global-live\route.ts =====
// src/app/api/global-live/route.ts
import { NextResponse } from 'next/server';
import axios from 'axios';

// This function handles GET requests to /api/global-live
export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    // The key is to use the `live: 'all'` parameter
    params: { live: 'all' },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    // Directly return the array of live fixtures
    return NextResponse.json(response.data.response);
  } catch (error) {
    console.error("Error fetching global live matches:", error);
    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src\app\api\image-proxy\route.ts =====
// src/app/api/image-proxy/route.ts

import { NextRequest, NextResponse } from "next/server";
import axios from "axios";

// --- SECURITY: A whitelist of allowed domains to prevent abuse ---
// This ensures our proxy can only be used to fetch images from trusted sources.
const ALLOWED_DOMAINS = [
  "media.api-sports.io",
  // Add other trusted image source domains here if needed in the future
];

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const imageUrl = searchParams.get("url");

  // 1. Validate input
  if (!imageUrl) {
    return NextResponse.json(
      { error: "Image URL is required" },
      { status: 400 }
    );
  }

  // 2. Security Check: Ensure the requested URL is from an allowed domain
  try {
    const urlObject = new URL(imageUrl);
    if (!ALLOWED_DOMAINS.includes(urlObject.hostname)) {
      return NextResponse.json(
        { error: "Domain not allowed" },
        { status: 403 }
      );
    }
  } catch (error) {
    return NextResponse.json({ error: "Invalid URL format" }, { status: 400 });
  }

  try {
    // 3. Fetch the image from the external source
    const response = await axios.get(imageUrl, {
      responseType: "arraybuffer", // Fetch as raw data
    });

    const imageBuffer = Buffer.from(response.data, "binary");
    const contentType = response.headers["content-type"] || "image/png";

    // 4. Return the image with our custom, strong caching headers
    return new NextResponse(imageBuffer, {
      status: 200,
      headers: {
        "Content-Type": contentType,
        // Cache for 7 days, immutable means the browser won't even check for updates
        "Cache-Control": "public, max-age=604800, immutable",
      },
    });
  } catch (error) {
    console.error(`[Image Proxy] Failed to fetch ${imageUrl}:`, error);
    // You could return a placeholder image here if you wanted
    return NextResponse.json(
      { error: "Failed to fetch image" },
      { status: 502 }
    ); // 502 Bad Gateway
  }
}


// ===== src\app\api\leagues\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';
import { League } from '@/types/api-football';
import { generateLeagueSlug } from '@/lib/generate-league-slug';

// --- DEFINE CURATED LISTS OF POPULAR COMPETITIONS ---
// This is a list of well-known league IDs used for the sidebar's default view.
const POPULAR_LEAGUE_IDS = new Set([
  39,  // England - Premier League
  140, // Spain - La Liga
  135, // Italy - Serie A
  78,  // Germany - Bundesliga
  61,  // France - Ligue 1
  88,  // Netherlands - Eredivisie
  94,  // Portugal - Primeira Liga
  253, // USA - MLS
  203, // Turkey - Sper Lig
]);

const POPULAR_CUP_IDS = new Set([
  2,   // UEFA Champions League
  3,   // UEFA Europa League
  531, // UEFA Conference League
  45,  // England - FA Cup
  9,   // Copa Libertadores
  11,  // Copa Sudamericana
]);

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const country = searchParams.get('country');
  const type = searchParams.get('type'); // Can be 'league' or 'cup'
  const fetchAll = searchParams.get('fetchAll'); // <-- NEW PARAMETER

  const params: { current: string; country?: string, type?: string } = {
    current: 'true',
  };

  if (country) {
    params.country = country;
  }
  if (type) {
    params.type = type;
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/leagues`,
    params: params, 
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    let allLeagues = response.data.response;

    // --- UPDATED FILTERING LOGIC ---
    // If we are on the global view (no country selected) AND we are NOT fetching for a directory page,
    // then filter the results to only show popular competitions.
    if (!country && !fetchAll) {
      const popularIds = type === 'cup' ? POPULAR_CUP_IDS : POPULAR_LEAGUE_IDS;
      allLeagues = allLeagues.filter((item: any) => popularIds.has(item.league.id));
    }
    
    // Perform data transformation for all cases
    const transformedData: League[] = allLeagues
      .filter((item: any) => item.league.id && item.league.name && item.league.logo)
      .map((item: any) => ({
        id: item.league.id,
        name: item.league.name,
        logoUrl: item.league.logo,
        countryName: item.country.name,
        countryFlagUrl: item.country.flag,
        type: item.league.type,    
        href: generateLeagueSlug(item.league.name, item.league.id),
      }));
    
    // Sort the results alphabetically for a consistent order
    transformedData.sort((a, b) => a.name.localeCompare(b.name));

    return NextResponse.json(transformedData);

  } catch (error) {
    console.error("Error fetching leagues:", error);
    return NextResponse.json(
      { error: 'Failed to fetch league data.' },
      { status: 500 }
    );
  }
}

// ===== src\app\api\live-matches\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');

  if (!leagueId) {
    return NextResponse.json({ error: 'League ID is required' }, { status: 400 });
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: {
      league: leagueId,
      live: 'all',
    },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    // Directly return the response data, which is an array of live fixtures
    return NextResponse.json(response.data.response);
  } catch (error) {
    console.error("Error fetching live matches:", error);
    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src\app\api\live-odds\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';

/**
 * API route to fetch LIVE odds for all currently live matches.
 * This is a bulk fetch operation. It returns a map-like object
 * where keys are fixture IDs and values are the odds for that match.
 * This is far more efficient than fetching odds for each live match individually.
 */
export async function GET() {
    // Configure the request to the external API.
    // We are optimizing by only asking for the "Match Winner" bet type (id: 1).
    const options = {
        method: 'GET',
        url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds/live`,
        params: { bet: '1' }, 
        headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    };

    try {
        const response = await axios.request(options);

        // If the external API returns no live odds, we successfully found that out.
        // Return a 200 OK status with an empty object.
        if (!response.data.response || response.data.response.length === 0) {
            return NextResponse.json({}, { status: 200 });
        }

        // Transform the array response into a more efficient key-value object (a map).
        // This allows our frontend to look up odds by fixture ID in O(1) time.
        // The final object will look like: { "12345": { home: "1.50", ... }, "67890": { ... } }
        const liveOddsObject = response.data.response.reduce((acc: any, fixtureData: any) => {
            const fixtureId = fixtureData.fixture.id;
            const bookmaker = fixtureData.bookmakers?.[0]; // Get the first available bookmaker
            const matchWinnerBet = bookmaker?.bets.find((bet: any) => bet.id === 1);

            // Ensure we found a valid "Match Winner" bet
            if (matchWinnerBet) {
                const odds = matchWinnerBet.values.reduce((oddAcc: any, curr: any) => {
                    if (curr.value === 'Home') oddAcc.home = curr.odd;
                    if (curr.value === 'Draw') oddAcc.draw = curr.odd;
                    if (curr.value === 'Away') oddAcc.away = curr.odd;
                    return oddAcc;
                }, {});
                acc[fixtureId] = odds;
            }
            return acc;
        }, {});

        // Return the successfully transformed odds object.
        return NextResponse.json(liveOddsObject, { status: 200 });

    } catch (error) {
        console.error('[API/LIVE-ODDS] Error fetching live odds:', error);
        return NextResponse.json(
            { error: 'Failed to fetch live odds data from the provider.' },
            { status: 500 }
        );
    }
}

// ===== src\app\api\live-odds-by-fixture\route.ts =====
// src/app/api/live-odds-by-fixture/route.ts
import { NextResponse } from "next/server";
import axios from "axios";

// --- Data Transformation Helper ---
// This function finds a specific bet type by its ID and extracts the main odds.
const extractMainOdds = (odds: any[], betId: number, valueKeys: string[]) => {
  const betData = odds.find((o) => o.id === betId);
  if (!betData) return null;

  // Prefer the 'main' market if available, otherwise take the first valid one.
  let targetValues = betData.values.find((v: any) => v.main === true)
    ? betData.values.filter((v: any) => v.main === true)
    : betData.values;

  const result: { [key: string]: string | null } = {};
  valueKeys.forEach((key) => {
    result[key.toLowerCase()] =
      targetValues.find((v: any) => v.value === key)?.odd || null;
  });

  // Also extract the handicap if present
  result.handicap = targetValues[0]?.handicap || null;

  // Check if we found any valid odds
  const hasValues = Object.values(result).some(
    (v) => v !== null && v !== undefined
  );
  return hasValues ? result : null;
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get("fixture");

  if (!fixtureId) {
    return NextResponse.json(
      { error: "Fixture ID is required" },
      { status: 400 }
    );
  }

  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds/live`,
    params: { fixture: fixtureId },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };

  try {
    const response = await axios.request(options);
    const liveData = response.data.response[0];

    if (!liveData || !liveData.odds) {
      return NextResponse.json(null); // Return null if no live odds are available
    }

    const odds = liveData.odds;

    // Curate and simplify the data before sending to the frontend
    const curatedOdds = {
      asianHandicap: extractMainOdds(odds, 33, ["Home", "Away"]),
      overUnder: extractMainOdds(odds, 36, ["Over", "Under"]),
      matchCorners: extractMainOdds(odds, 20, ["Over", "Under"]),
      nextGoal: extractMainOdds(odds, 85, ["1", "No goal", "2"]),
    };

    return NextResponse.json(curatedOdds);
  } catch (error) {
    console.error(`Error fetching live odds for fixture ${fixtureId}:`, error);
    return NextResponse.json(
      { error: "Failed to fetch live odds" },
      { status: 500 }
    );
  }
}


// ===== src\app\api\match-details\route.ts =====
// src/app/api/match-details/route.ts

import { NextResponse } from "next/server";
import axios from "axios";

// ====================================================================
// --- FANSKOR PREDICTION ENGINE V3.0 (Weather Removed) ---
// ====================================================================
const calculateCustomPrediction = (
  h2h: any[],
  homeTeamStats: any,
  awayTeamStats: any,
  homeTeamId: number,
  homeTeamRank: number | undefined,
  awayTeamRank: number | undefined,
  // weatherData parameter removed
  matchEvents: any[],
  matchStatus: string
) => {
  const config = {
    weights: {
      homeAdvantage: 12,
      form: 1.5,
      h2h: 2.5,
      rankDifference: 0.8,
      goalDifference: 6,
      xGInfluence: 3,
      // weatherInfluence config removed
      matchActivity: 0.5,
      liveMatchBonus: 5,
    },
    h2hMaxGames: 5,
    drawWeight: 0.85,
  };

  let homeScore = 0;
  let awayScore = 0;

  // 1. Home Advantage
  homeScore += config.weights.homeAdvantage;

  // 2. Momentum (Recent Form)
  const calculateForm = (formString: string): number => {
    return (
      (formString.match(/W/g) || []).length * 3 +
      (formString.match(/D/g) || []).length * 1
    );
  };
  const homeFormString = homeTeamStats?.form || "";
  const awayFormString = awayTeamStats?.form || "";
  homeScore += calculateForm(homeFormString) * config.weights.form;
  awayScore += calculateForm(awayFormString) * config.weights.form;

  // 3. Goal Form (Average Goal Difference)
  const homeGoalsForAvg = homeTeamStats?.goals?.for?.average?.total ?? 0;
  const homeGoalsAgainstAvg =
    homeTeamStats?.goals?.against?.average?.total ?? 0;
  const awayGoalsForAvg = awayTeamStats?.goals?.for?.average?.total ?? 0;
  const awayGoalsAgainstAvg =
    awayTeamStats?.goals?.against?.average?.total ?? 0;

  const homeGoalDiff = homeGoalsForAvg - homeGoalsAgainstAvg;
  const awayGoalDiff = awayGoalsForAvg - awayGoalsAgainstAvg;
  homeScore += homeGoalDiff * config.weights.goalDifference;
  awayScore += awayGoalDiff * config.weights.goalDifference;

  // 4. Simulated Expected Goals (xG)
  const simulateXG = (avgGoals: number) => Math.min(avgGoals * 1.1, 3.0);
  const homeXG = simulateXG(homeGoalsForAvg);
  const awayXG = simulateXG(awayGoalsForAvg);

  const xgDiff = homeXG - awayXG;
  homeScore += xgDiff * config.weights.xGInfluence;
  awayScore -= xgDiff * config.weights.xGInfluence;

  // 5. Head-to-Head (H2H) Records
  if (h2h && h2h.length > 0) {
    h2h.slice(0, config.h2hMaxGames).forEach((match) => {
      if (match.teams.home.winner) {
        homeTeamId === match.teams.home.id
          ? (homeScore += config.weights.h2h)
          : (awayScore += config.weights.h2h);
      } else if (match.teams.away.winner) {
        homeTeamId === match.teams.away.id
          ? (homeScore += config.weights.h2h)
          : (awayScore += config.weights.h2h);
      } else {
        // It was a draw
        homeScore += config.weights.h2h / 2;
        awayScore += config.weights.h2h / 2;
      }
    });
  }

  // 6. League Rank Difference
  if (homeTeamRank != null && awayTeamRank != null) {
    const rankDiff = Math.abs(homeTeamRank - awayTeamRank);
    if (homeTeamRank < awayTeamRank) {
      homeScore += rankDiff * config.weights.rankDifference;
    } else if (awayTeamRank < homeTeamRank) {
      awayScore += rankDiff * config.weights.rankDifference;
    }
  }

  // 7. Weather Conditions (Logic removed)
  // The weather influence logic is entirely removed.

  // 8. Match Activity Analysis
  const isLiveMatch = ["1H", "HT", "2H", "ET", "BT", "P", "LIVE"].includes(
    matchStatus
  );
  if (isLiveMatch) {
    homeScore += config.weights.liveMatchBonus;
    awayScore += config.weights.liveMatchBonus;
    const recentEventsCount = matchEvents.filter(
      (event: any) =>
        (event.type === "Goal" || event.type === "Card") &&
        event.time.elapsed > (matchStatus === "1H" ? 1 : 45)
    ).length;
    homeScore += recentEventsCount * config.weights.matchActivity;
    awayScore += recentEventsCount * config.weights.matchActivity;
  }

  // --- Final Calculation & Normalization ---
  homeScore = Math.max(1, homeScore);
  awayScore = Math.max(1, awayScore);
  const drawScore =
    (homeScore + awayScore) *
    (1 - Math.abs(homeScore - awayScore) / (homeScore + awayScore)) *
    config.drawWeight;
  const totalPoints = homeScore + awayScore + drawScore;

  if (totalPoints <= 1) {
    return { home: 33, draw: 34, away: 33 };
  }

  let homePercent = Math.round((homeScore / totalPoints) * 100);
  let awayPercent = Math.round((awayScore / totalPoints) * 100);
  let drawPercent = 100 - homePercent - awayPercent;

  if (homePercent + awayPercent + drawPercent !== 100) {
    const diff = 100 - (homePercent + awayPercent + drawPercent);
    if (homePercent >= awayPercent && homePercent >= drawPercent) {
      homePercent += diff;
    } else if (awayPercent >= homePercent && awayPercent >= drawPercent) {
      awayPercent += diff;
    } else {
      drawPercent += diff;
    }
  }

  return {
    home: homePercent,
    draw: drawPercent,
    away: awayPercent,
  };
};

// --- Helper to convert percentages to decimal odds (Unchanged) ---
const convertPercentageToOdds = (percent: number): string => {
  if (percent <= 0) return "INF";
  return (100 / percent).toFixed(2);
};

// --- The main data fetching function ---
const fetchAllDataForFixture = async (fixtureId: string | number) => {
  const options = (endpoint: string, params: object) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  const fixtureResponse = await axios.request(
    options("fixtures", { id: fixtureId })
  );
  const fixtureData = fixtureResponse.data.response[0];

  if (!fixtureData) {
    throw new Error(`Fixture not found with ID: ${fixtureId}`);
  }

  const { league, teams } = fixtureData;
  const { home: homeTeam, away: awayTeam } = teams;
  // venueLat and venueLon extraction removed

  const [
    eventsResponse,
    statsResponse,
    h2hResponse,
    predictionResponse,
    homeStatsResponse,
    awayStatsResponse,
    oddsResponse,
    standingsResponse,
  ] = await Promise.all([
    axios.request(options("fixtures/events", { fixture: fixtureId })),
    axios.request(options("fixtures/statistics", { fixture: fixtureId })),
    axios.request(
      options("fixtures/headtohead", { h2h: `${homeTeam.id}-${awayTeam.id}` })
    ),
    axios.request(options("predictions", { fixture: fixtureId })),
    axios.request(
      options("teams/statistics", {
        league: league.id,
        season: league.season,
        team: homeTeam.id,
      })
    ),
    axios.request(
      options("teams/statistics", {
        league: league.id,
        season: league.season,
        team: awayTeam.id,
      })
    ),
    axios.request(options("odds", { fixture: fixtureId, bet: "1" })),
    axios.request(
      options("standings", { league: league.id, season: league.season })
    ),
    // Weather API request removed
  ]);

  const standings =
    standingsResponse.data.response[0]?.league?.standings[0] || [];
  const homeTeamRank = standings.find(
    (s: any) => s.team.id === homeTeam.id
  )?.rank;
  const awayTeamRank = standings.find(
    (s: any) => s.team.id === awayTeam.id
  )?.rank;

  const customPredictionPercentages = calculateCustomPrediction(
    h2hResponse.data.response,
    homeStatsResponse.data.response,
    awayStatsResponse.data.response,
    homeTeam.id,
    homeTeamRank,
    awayTeamRank,
    // null, // weatherData parameter removed
    eventsResponse.data.response,
    fixtureData.fixture.status.short
  );

  const customPredictionOdds = customPredictionPercentages
    ? {
        home: convertPercentageToOdds(customPredictionPercentages.home),
        draw: convertPercentageToOdds(customPredictionPercentages.draw),
        away: convertPercentageToOdds(customPredictionPercentages.away),
      }
    : null;

  return {
    fixture: fixtureData,
    events: eventsResponse.data.response,
    statistics: statsResponse.data.response,
    h2h: h2hResponse.data.response,
    analytics: {
      prediction: predictionResponse.data.response[0] ?? null,
      homeTeamStats: homeStatsResponse.data.response ?? null,
      awayTeamStats: awayStatsResponse.data.response ?? null,
      customPrediction: customPredictionPercentages,
      customOdds: customPredictionOdds,
      bookmakerOdds: oddsResponse.data.response[0]?.bookmakers ?? [],
    },
  };
};

// --- The GET handler that the frontend calls ---
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get("fixture");

  if (!fixtureId) {
    return NextResponse.json(
      { error: "Fixture ID is required" },
      { status: 400 }
    );
  }

  try {
    const matchDetails = await fetchAllDataForFixture(fixtureId);
    return NextResponse.json(matchDetails);
  } catch (error: any) {
    console.error(
      `[API /match-details] Error for fixture ${fixtureId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Failed to fetch match details." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\odds\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';

/**
 * API route to fetch pre-match odds for a specific fixture.
 * It is optimized to only request the "Match Winner" bet from a single, major bookmaker
 * to ensure a fast response and minimal data transfer.
 */
export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);
    const fixtureId = searchParams.get('fixture');

    // 1. Validate input: Ensure a fixture ID was provided.
    if (!fixtureId) {
        return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
    }

    // 2. Configure the optimized request to the external API.
    const options = {
        method: 'GET',
        url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds`,
        params: { 
            fixture: fixtureId, 
            bookmaker: '8', // A major, commonly available bookmaker (e.g., Bet365)
            bet: '1'        // The ID for the "Match Winner" bet (1X2)
        },
        headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    };

    try {
        // 3. Make the external API call.
        const response = await axios.request(options);
        
        // 4. Handle the "No Data" case gracefully.
        // If the external API has no odds, it's not an error. We successfully found that there's no data.
        // We return a 200 OK status with a null body to signal this to the frontend.
        if (!response.data.response || response.data.response.length === 0) {
            console.log(`No odds found for fixture ${fixtureId}. Returning null.`);
            return NextResponse.json(null, { status: 200 }); 
        }
        
        const bookmaker = response.data.response[0].bookmakers[0];
        
        const matchWinnerBet = bookmaker.bets.find((bet: any) => bet.id === 1);

        // Also handle the case where the bookmaker doesn't offer this specific bet type.
        if (!matchWinnerBet || !matchWinnerBet.values) {
            console.log(`"Match Winner" odds not available for fixture ${fixtureId}. Returning null.`);
            return NextResponse.json(null, { status: 200 });
        }

        // 5. Transform the data into a clean, simple object for the frontend.
        // The API returns an array, but the frontend just needs a { home, draw, away } object.
        const odds = matchWinnerBet.values.reduce((acc: any, curr: any) => {
            if (curr.value === 'Home') acc.home = curr.odd;
            if (curr.value === 'Draw') acc.draw = curr.odd;
            if (curr.value === 'Away') acc.away = curr.odd;
            return acc;
        }, {});
        
        // 6. Return the successfully transformed odds.
        return NextResponse.json(odds, { status: 200 });

    } catch (error) {
        // 7. Handle actual server or network errors.
        console.error(`[API/ODDS] Error fetching odds for fixture ${fixtureId}:`, error);
        return NextResponse.json(
            { error: 'Failed to fetch odds data from the provider.' }, 
            { status: 500 }
        );
    }
}

// ===== src\app\api\posts\route.ts =====
// src/app/api/posts/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post, { IPost } from "@/models/Post";
import slugify from "slugify";
// --- NEW: Import ExternalNewsArticle model directly into this file ---
import ExternalNewsArticle from "@/models/ExternalNewsArticle";

// --- GET All Posts ---
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const status = searchParams.get("status");
  const limit = searchParams.get("limit");

  const query: { status?: string } = {};
  if (status) {
    query.status = status;
  }

  try {
    await dbConnect(); // This still connects, and imports in dbConnect.ts register models
    // --- THE FIX IS HERE: Pass ExternalNewsArticle model object directly to populate ---
    let postsQuery = Post.find(query).sort({ createdAt: -1 }).populate({
      path: "originalExternalArticleId",
      model: ExternalNewsArticle, // <-- Pass the imported Model object here
      select: "title link",
    });

    const posts = await postsQuery;
    return NextResponse.json(posts);
  } catch (error) {
    console.error("Failed to fetch posts:", error);
    return NextResponse.json(
      { error: "Server error fetching posts" },
      { status: 500 }
    );
  }
}

// --- POST a New Post ---
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body: Partial<IPost> = await request.json();
    const {
      title,
      content,
      status,
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle,
      featuredImageAltText,
      sport,
    } = body;

    if (!title || !content) {
      return NextResponse.json(
        { error: "Title and content are required" },
        { status: 400 }
      );
    }

    await dbConnect();

    const slug = slugify(title, { lower: true, strict: true });
    const slugExists = await Post.findOne({ slug });
    if (slugExists) {
      return NextResponse.json(
        {
          error: `A post with the slug '${slug}' already exists. Please use a different title.`,
        },
        { status: 409 }
      );
    }

    const newPost = new Post({
      title,
      content,
      status,
      slug,
      author: session.user.name || "Admin",
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle,
      featuredImageAltText,
      sport,
    });

    await newPost.save();
    return NextResponse.json(newPost, { status: 201 });
  } catch (error) {
    console.error("Failed to create post:", error);
    return NextResponse.json(
      { error: "Server error creating post" },
      { status: 500 }
    );
  }
}


// ===== src\app\api\posts\[postId]\route.ts =====
// src/app/api/posts/[postId]/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import dbConnect from '@/lib/dbConnect';
import Post, { IPost } from '@/models/Post';

interface Params {
  params: { postId: string };
}

// --- GET a Single Post (by ID) ---
// Publicly accessible for the edit page pre-fill and potentially public view.
export async function GET(request: Request, { params }: Params) {
  const { postId } = params;
  try {
    await dbConnect();
    const post = await Post.findById(postId);
    if (!post) {
      return NextResponse.json({ error: 'Post not found' }, { status: 404 });
    }
    return NextResponse.json(post);
  } catch (error) {
    return NextResponse.json({ error: 'Server error' }, { status: 500 });
  }
}

// --- PUT (Update) a Post ---
// Protected: Only admins can update.
export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== 'admin') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const { postId } = params;
  try {
    const body: Partial<IPost> = await request.json();
    const { title, content, status, featuredImage, metaTitle, metaDescription, featuredImageTitle, featuredImageAltText } = body;
    
    await dbConnect();
    
    const updatedPost = await Post.findByIdAndUpdate(
        postId,
        { title, content, status },
        { new: true, runValidators: true }
    );
    
    if (!updatedPost) {
        return NextResponse.json({ error: 'Post not found' }, { status: 404 });
    }
    
    return NextResponse.json(updatedPost);
  } catch (error) {
    return NextResponse.json({ error: 'Server error updating post' }, { status: 500 });
  }
}

// --- DELETE a Post ---
// Protected: Only admins can delete.
export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== 'admin') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const { postId } = params;
  try {
    await dbConnect();
    const deletedPost = await Post.findByIdAndDelete(postId);
    if (!deletedPost) {
      return NextResponse.json({ error: 'Post not found' }, { status: 404 });
    }
    return NextResponse.json({ message: 'Post deleted successfully' });
  } catch (error) {
    return NextResponse.json({ error: 'Server error' }, { status: 500 });
  }
}

// ===== src\app\api\predictions\route.ts =====
import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get('fixture');

  if (!fixtureId) {
    return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/predictions`,
    params: { fixture: fixtureId },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    if (!response.data.response || response.data.response.length === 0) {
      return NextResponse.json({ error: 'No prediction available.' }, { status: 404 });
    }

    const predictionData = response.data.response[0];

    // --- THE FIX ---
    // We now extract and return the entire `teams` object from the prediction,
    // along with the percentages.
    const transformedPrediction = {
      teams: {
        home: {
          id: predictionData.teams.home.id,
          name: predictionData.teams.home.name,
          logo: predictionData.teams.home.logo, // <-- Pass the logo URL
        },
        away: {
          id: predictionData.teams.away.id,
          name: predictionData.teams.away.name,
          logo: predictionData.teams.away.logo, // <-- Pass the logo URL
        }
      },
      percent: {
        home: parseInt(predictionData.predictions.percent.home.replace('%', '')),
        draw: parseInt(predictionData.predictions.percent.draw.replace('%', '')),
        away: parseInt(predictionData.predictions.percent.away.replace('%', '')),
      }
    };

    return NextResponse.json(transformedPrediction);

  } catch (error) {
    console.error("Error fetching prediction:", error);
    return NextResponse.json({ error: 'Failed to fetch prediction data.' }, { status: 500 });
  }
}

// ===== src\app\api\sports\[sport]\fixtures\route.ts =====
import { NextResponse } from 'next/server';
import { getSportService } from '@/services/sports';

export async function GET(
  request: Request,
  { params }: { params: { sport: string } }
) {
  const { searchParams } = new URL(request.url);
  const sport = params.sport;
  
  // Convert searchParams to a plain object
  const queryParams: { [key: string]: any } = {};
  searchParams.forEach((value, key) => {
    queryParams[key] = value;
  });

  try {
    // 1. Get the correct service for the requested sport
    const sportService = getSportService(sport);
    
    // 2. Call the generic method
    const fixtures = await sportService.getFixtures(queryParams);

    // 3. Return the data
    return NextResponse.json(fixtures);

  } catch (error: any) {
    console.error(`[API /${sport}/fixtures] Error:`, error.message);
    return NextResponse.json(
      { error: `Failed to fetch fixture data for ${sport}.` },
      { status: 500 }
    );
  }
}

// ===== src\app\api\standings\route.ts =====
// src/app/api/standings/route.ts

import { NextResponse } from "next/server";
import axios from "axios";
import { generateLeagueSlug } from "@/lib/generate-league-slug"; // <-- IMPORT

// TeamStanding type definition remains the same
type TeamStanding = {
  rank: number;
  team: { id: number; name: string; logo: string };
  points: number;
  goalsDiff: number;
  all: { played: number; win: number; draw: number; lose: number };
  description: string | null;
  group: string; // <-- Make sure group is part of the type
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get("league");
  const season =
    searchParams.get("season") || new Date().getFullYear().toString();

  if (!leagueId) {
    return NextResponse.json(
      { error: "League ID is required" },
      { status: 400 }
    );
  }

  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/standings`,
    params: { league: leagueId, season: season },
    headers: {
      "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    if (!response.data.response || response.data.response.length === 0) {
      return NextResponse.json({ league: null, standings: [] });
    }

    const data = response.data.response[0];

    // --- ENHANCED TRANSFORMATION ---
    // We now add the href to the league info object
    const leagueInfo = {
      id: data.league.id,
      name: data.league.name,
      logo: data.league.logo,
      type: data.league.type, // Good to have for context
      href: generateLeagueSlug(data.league.name, data.league.id), // <-- ADD THE HREF
    };

    // Ensure we are selecting the correct standings array
    const standings: TeamStanding[][] = data.league.standings;

    return NextResponse.json({ league: leagueInfo, standings });
  } catch (error) {
    console.error("Error fetching standings:", error);
    return NextResponse.json(
      { error: "Failed to fetch standings data" },
      { status: 500 }
    );
  }
}


// ===== src\app\api\team-details\route.ts =====
// src/app/api/team-details/route.ts
import { NextResponse } from 'next/server';
import { fetchTeamDetails } from '@/lib/data/team'; // <-- IMPORT THE NEW FUNCTION

export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);
    const teamId = searchParams.get('team');

    if (!teamId) {
        return NextResponse.json({ error: 'Team ID is required' }, { status: 400 });
    }

    // Call the reusable function
    const teamData = await fetchTeamDetails(teamId);

    if (!teamData) {
        // This handles cases where the team isn't found or an error occurred in the lib function.
        return NextResponse.json({ error: 'Failed to fetch team details or team not found' }, { status: 500 });
    }

    return NextResponse.json(teamData);
}

// ===== src\app\api\team-trophies\route.ts =====
// src/app/api/team-trophies/route.ts
import { NextResponse } from "next/server";
import axios from "axios";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const teamId = searchParams.get("team");

  if (!teamId) {
    return NextResponse.json({ error: "Team ID is required" }, { status: 400 });
  }

  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/trophies`,
    params: { team: teamId },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };

  try {
    const response = await axios.request(options);
    // Sort trophies by season, newest first
    const sortedTrophies = response.data.response.sort((a: any, b: any) => {
      const seasonB = parseInt(b.season.split("-")[0]);
      const seasonA = parseInt(a.season.split("-")[0]);
      return seasonB - seasonA;
    });
    return NextResponse.json(sortedTrophies);
  } catch (error) {
    console.error("Error fetching team trophies:", error);
    return NextResponse.json(
      { error: "Failed to fetch trophies" },
      { status: 500 }
    );
  }
}


// ===== src\app\api\teams\route.ts =====
// src/app/api/teams/route.ts
import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');
  const season = searchParams.get('season');

  if (!leagueId || !season) {
    return NextResponse.json(
      { error: 'League ID and season are required' },
      { status: 400 }
    );
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
    params: {
      league: leagueId,
      season: season,
    },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    
    // The response is an array of objects, each containing a `team` and `venue` object.
    // We can pass it directly to the frontend.
    return NextResponse.json(response.data.response);

  } catch (error) {
    console.error("Error fetching teams:", error);
    return NextResponse.json(
      { error: 'Failed to fetch teams data.' },
      { status: 500 }
    );
  }
}

// ===== src\app\api\teams-by-country\route.ts =====
// src/app/api/teams-by-country/route.ts
import { NextResponse } from "next/server";
import axios from "axios";

const season = new Date().getFullYear();

// This is a reusable helper for making requests to the external API
const apiRequest = async (endpoint: string, params: object) => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };
  const response = await axios.request(options);
  return response.data.response;
};

// This function now returns both the list of teams AND the count
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const country = searchParams.get("country");

  if (!country) {
    return NextResponse.json(
      { error: "Country parameter is required" },
      { status: 400 }
    );
  }

  try {
    // 1. First, find all leagues for the specified country.
    const leagues = await apiRequest("leagues", { country: country });
    if (!leagues || leagues.length === 0) {
      // Return a structured response even if there are no teams
      return NextResponse.json({ teams: [], count: 0 });
    }

    const leagueIds = leagues.map((l: any) => l.league.id);

    // 2. Fetch all teams from all found leagues in parallel.
    const teamPromises = leagueIds.map((id: any) =>
      apiRequest("teams", { league: id, season: season })
    );
    const responses = await Promise.allSettled(teamPromises);

    // 3. Aggregate all teams from successful requests.
    const allTeamsResponses = responses
      .filter((result) => result.status === "fulfilled" && result.value)
      .flatMap((result) => (result as PromiseFulfilledResult<any>).value);

    // 4. De-duplicate the teams using a Map (very important).
    const uniqueTeams = Array.from(
      new Map(allTeamsResponses.map((item) => [item.team.id, item])).values()
    );

    // 5. Sort the final list alphabetically.
    uniqueTeams.sort((a, b) => a.team.name.localeCompare(b.team.name));

    // 6. Return the enhanced response object
    return NextResponse.json({
      teams: uniqueTeams,
      count: uniqueTeams.length, // The accurate count of unique teams
    });
  } catch (error) {
    console.error(`Error fetching teams for country "${country}":`, error);
    return NextResponse.json(
      { error: "Failed to fetch teams data for this country." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\top-scorers\route.ts =====
// src/app/api/top-scorers/route.ts

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');
  const season = searchParams.get('season');

  if (!leagueId || !season) {
    return NextResponse.json(
      { error: 'League ID and season are required' },
      { status: 400 }
    );
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/players/topscorers`,
    params: {
      league: leagueId,
      season: season,
    },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    
    // The API returns an array of players with their stats. We can pass it directly.
    return NextResponse.json(response.data.response);

  } catch (error) {
    console.error("Error fetching top scorers:", error);
    return NextResponse.json(
      { error: 'Failed to fetch top scorers data.' },
      { status: 500 }
    );
  }
}

// ===== src\app\api\upcoming-matches\route.ts =====
// src/app/api/upcoming-matches/route.ts
import { NextResponse } from 'next/server';
import axios from 'axios';
import { format, subDays, addDays } from 'date-fns';

// This is your existing API route for upcoming matches. Let's rename it
// to something more generic as it will now handle more than just "upcoming".
// The file path remains the same for backward compatibility.
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');

  if (!leagueId) {
    // If no leagueId, this route should do nothing or return an error.
    // Your global fetching is handled by the /api/fixtures route.
    return NextResponse.json({ error: 'League ID is required' }, { status: 400 });
  }

  const season = new Date().getFullYear().toString();
  const today = format(new Date(), 'yyyy-MM-dd');
  const nextSevenDays = format(addDays(new Date(), 7), 'yyyy-MM-dd');

  const options = (params: object) => ({
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params,
    headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    // --- 1. First, try to fetch UPCOMING matches ---
    const upcomingResponse = await axios.request(options({
      league: leagueId,
      season: season,
      from: today,
      to: nextSevenDays,
    }));
    
    let matches = upcomingResponse.data.response;

    // --- 2. If NO upcoming matches are found, fetch RECENT finished matches ---
    if (matches.length === 0) {
      console.log(`No upcoming matches for league ${leagueId}. Fetching recent results...`);
      const finishedResponse = await axios.request(options({
        league: leagueId,
        season: season,
        last: 5, // Get the last 5 finished fixtures
        status: 'FT', // Only get matches with a status of "Finished"
      }));
      matches = finishedResponse.data.response;
    }
    
    return NextResponse.json(matches);

  } catch (error) {
    console.error(`Error fetching matches for league ${leagueId}:`, error);
    return NextResponse.json({ error: 'Failed to fetch match data' }, { status: 500 });
  }
}

// ===== src\app\api\upload\route.ts =====
// ===== src/app/api/upload/route.ts (REVISED FOR GIFS AND NO CROPPING) =====
import { NextResponse } from "next/server";
import {
  S3Client,
  PutObjectCommand,
  ListObjectsV2Command,
  DeleteObjectCommand,
} from "@aws-sdk/client-s3";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import sharp from "sharp";
import path from "path";
import slugify from "slugify";

// --- R2/S3 Client Configuration ---
const s3Client = new S3Client({
  region: "auto",
  endpoint: process.env.NEXT_PUBLIC_R2_ENDPOINT as string,
  credentials: {
    accessKeyId: process.env.NEXT_PUBLIC_R2_ACCESS_KEY_ID as string,
    secretAccessKey: process.env.NEXT_PUBLIC_R2_SECRET_ACCESS_KEY as string,
  },
});

const R2_BUCKET_NAME = process.env.NEXT_PUBLIC_R2_BUCKET_NAME as string;
const R2_PUBLIC_URL = process.env.NEXT_PUBLIC_R2_PUBLIC_BUCKET_URL as string;

// --- GET handler to list uploaded files from R2 (unchanged) ---
export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const listObjectsCommand = new ListObjectsV2Command({
      Bucket: R2_BUCKET_NAME,
      MaxKeys: 100,
    });

    const { Contents } = await s3Client.send(listObjectsCommand);

    const files =
      Contents?.map((item) => {
        const key = item.Key || "unknown";
        const fileExtension = path.extname(key).toLowerCase();
        let mimeType = "application/octet-stream";

        if (fileExtension === ".png") mimeType = "image/png";
        else if (fileExtension === ".jpg" || fileExtension === ".jpeg")
          mimeType = "image/jpeg";
        else if (fileExtension === ".gif") mimeType = "image/gif";
        else if (fileExtension === ".webp") mimeType = "image/webp";

        return {
          name: key,
          url: `${R2_PUBLIC_URL}/${key}`,
          size: item.Size || 0,
          lastModified: item.LastModified,
          type: mimeType,
        };
      }) || [];

    files.sort(
      (a, b) =>
        (b.lastModified?.getTime() || 0) - (a.lastModified?.getTime() || 0)
    );

    return NextResponse.json(files, { status: 200 });
  } catch (error) {
    console.error("Error listing files from R2:", error);
    return NextResponse.json(
      { error: "Failed to list files from Cloudflare R2." },
      { status: 500 }
    );
  }
}

// --- POST handler to upload files to R2 (UPDATED) ---
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const formData = await request.formData();
    const file = formData.get("file") as File;
    const uploadType = formData.get("uploadType") as string | null;

    if (!file) {
      return NextResponse.json({ error: "No file provided." }, { status: 400 });
    }

    let finalBuffer: Buffer;
    let finalContentType: string = file.type;
    let finalFileExtension: string;

    // ===== NEW GIF HANDLING LOGIC =====
    if (file.type === "image/gif") {
      finalBuffer = Buffer.from(await file.arrayBuffer());
      finalContentType = "image/gif";
      finalFileExtension = ".gif";
    } else {
      // Process other image types (PNG, JPEG, WebP, etc.)
      const inputBuffer = Buffer.from(await file.arrayBuffer());
      let sharpInstance = sharp(inputBuffer);

      if (uploadType === "banner") {
        // Banners should be resized to fit inside without cropping
        sharpInstance = sharpInstance.resize(1200, 1200, {
          fit: "inside", // This prevents cropping
          withoutEnlargement: true,
        });
      } else {
        // Other images (e.g., news featured images) should also be resized to fit without cropping
        // Change from 'cover' to 'inside' to prevent cropping
        sharpInstance = sharpInstance.resize(1200, 630, {
          fit: "inside", // Changed from "cover" to "inside"
          withoutEnlargement: true,
        });
      }

      finalBuffer = await sharpInstance.webp({ quality: 80 }).toBuffer();
      finalContentType = "image/webp";
      finalFileExtension = ".webp";
    }

    // Generate the new filename with "fanskor-" prefix, slug, and unique suffix
    const originalFilename = file.name;
    const extension = path.extname(originalFilename);
    const basename = path.basename(originalFilename, extension);
    const slug = slugify(basename, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });
    const uniqueSuffix = Date.now().toString().slice(-6);

    const newFileName = `fanskor-${slug}-${uniqueSuffix}${finalFileExtension}`;

    const putObjectCommand = new PutObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: newFileName,
      Body: finalBuffer,
      ContentType: finalContentType,
    });

    await s3Client.send(putObjectCommand);

    const publicUrl = `${R2_PUBLIC_URL}/${newFileName}`;

    return NextResponse.json({
      message: "File uploaded successfully",
      url: publicUrl,
      name: newFileName,
      type: finalContentType,
      size: finalBuffer.length,
    });
  } catch (error) {
    console.error("Error uploading to R2:", error);
    return NextResponse.json(
      { error: "Failed to upload image to Cloudflare R2." },
      { status: 500 }
    );
  }
}

// --- DELETE handler to remove files from R2 (unchanged) ---
export async function DELETE(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { searchParams } = new URL(request.url);
  const fileKey = searchParams.get("key");

  if (!fileKey) {
    return NextResponse.json(
      { error: "File key is required for deletion." },
      { status: 400 }
    );
  }

  try {
    const deleteObjectCommand = new DeleteObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: fileKey,
    });

    await s3Client.send(deleteObjectCommand);
    console.log(`Successfully deleted R2 object: ${fileKey}`);

    return NextResponse.json(
      { message: "File deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(`Error deleting file ${fileKey} from R2:`, error);
    if (error.name === "NoSuchKey") {
      return NextResponse.json(
        { error: "File not found on Cloudflare R2." },
        { status: 404 }
      );
    }
    return NextResponse.json(
      { error: error.message || "Failed to delete file from Cloudflare R2." },
      { status: 500 }
    );
  }
}


// ===== src\app\api\votes\route.ts =====
import { NextResponse } from 'next/server';
import dbConnect from '@/lib/dbConnect';
import Vote from '@/models/Vote';

// --- GET Handler: Fetches vote counts for a fixture ---
export async function GET(request: Request) {
    console.log("requested here");
    
    const { searchParams } = new URL(request.url);
    const fixtureId = searchParams.get('fixture');

    if (!fixtureId) {
        return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
    }

    try {
        await dbConnect();
        const votes = await Vote.findOne({ fixtureId: Number(fixtureId) });
        console.log(votes);
        

        if (!votes) {
            // If no votes yet, return a default object
            return NextResponse.json({ homeVotes: 0, drawVotes: 0, awayVotes: 0 });
        }

        return NextResponse.json(votes);
    } catch (error) {
        console.log(error);
        
        return NextResponse.json({ error: 'Server error fetching votes' }, { status: 500 });
    }
}


// --- POST Handler: Submits a new vote ---
export async function POST(request: Request) {
    const { fixtureId, vote } = await request.json(); // vote should be 'home', 'draw', or 'away'

    if (!fixtureId || !['home', 'draw', 'away'].includes(vote)) {
        return NextResponse.json({ error: 'Valid fixtureId and vote type are required' }, { status: 400 });
    }
    
    try {
        await dbConnect();
        
        // Atomically find and update the document, or create it if it doesn't exist.
        // The $inc operator is crucial for preventing race conditions.
        const updatedVote = await Vote.findOneAndUpdate(
            { fixtureId: Number(fixtureId) },
            { $inc: { [`${vote}Votes`]: 1 } },
            { 
                upsert: true, // Create the document if it doesn't exist
                new: true     // Return the updated document
            }
        );

        return NextResponse.json(updatedVote);
    } catch (error) {
        return NextResponse.json({ error: 'Server error submitting vote' }, { status: 500 });
    }
}

// ===== src\app\contact-us\page.tsx =====
// src/app/contact-us/page.tsx
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import type { Metadata } from "next";
import { Mail, Phone, MapPin } from "lucide-react";
import axios from "axios"; // For server-side data fetching

import ContactFormClient from "@/components/ContactFormClient";
import NewsListItem from "@/components/NewsListItem"; // Reusing for news list (might need prop adjustments)
import AdSlotWidget from "@/components/AdSlotWidget";

const fetchSidebarNews = async (): Promise<any[]> => {
  const publicAppUrl = process.env.NEXT_PUBLIC_PUBLIC_APP_URL;
  if (!publicAppUrl) {
    console.error(
      "[Contact Us Page] NEXT_PUBLIC_PUBLIC_APP_URL is not defined! Cannot fetch news."
    );
    return [];
  }
  try {
    // Fetch latest 3 published posts for the sidebar
    const { data } = await axios.get(
      `${publicAppUrl}/api/posts?status=published&limit=3`,
      { timeout: 10000 }
    );
    console.log(
      `[Contact Us Page] Fetched ${data.length} news posts for sidebar.`
    );
    return data;
  } catch (error: any) {
    console.error(
      "[Contact Us Page] Failed to fetch news for sidebar:",
      error.message
    );
    return [];
  }
};

// --- Metadata for the Contact Us page (Server-side) ---
export const metadata: Metadata = {
  title: "Contact Us | Fan Skor Destek",
  description:
    "Get in touch with Fanskor support team. Send us your questions, feedback, or inquiries through our contact form or find our contact details here.",
  alternates: {
    canonical: `/contact-us`,
  },
  openGraph: {
    title: "Contact Us | Fan Skor Destek",
    description:
      "Get in touch with Fanskor support team. Send us your questions, feedback, or inquiries through our contact form or find our contact details here.",
    url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/contact-us`,
    siteName: "Fan Skor",
    type: "website",
  },
};

// --- Main Contact Us Page Component (Server-side) ---
export default async function ContactUsPage() {
  // Make async to await data fetching
  // --- SEO Description for the page content ---
  const contactPageSeoText =
    `Fanskor ekibine ulamak iin doru yerdesiniz! ` +
    `Sorularnz, geri bildirimleriniz, ortaklk talepleriniz veya herhangi bir konuda yardma ihtiyacnz olduunda bize ulamaktan ekinmeyin. ` +
    `Mteri memnuniyeti bizim iin nceliktir ve tm mesajlarnza en ksa srede yant vermeyi taahht ediyoruz. ` +
    `Aadaki formu kullanarak bize dorudan mesaj gnderebilir veya iletiim bilgilerimiz araclyla bize ulaabilirsiniz.`;

  // --- Fetch data for right sidebar in parallel ---
  const [sidebarNews] = await Promise.all([fetchSidebarNews()]);

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        {" "}
        {/* Changed grid: 288px sidebar, 1fr main, 288px right sidebar */}
        <Sidebar /> {/* Left sidebar */}
        <main className="min-w-0">
          {" "}
          {/* Main content area */}
          {/* Page Heading and Description for SEO */}
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl mb-8">
            <h1 className="text-3xl font-bold text-white mb-3">
              letiim Kurun
            </h1>
            <p className="text-brand-light text-base leading-relaxed">
              {contactPageSeoText}
            </p>
          </div>
          <div className="grid grid-cols-1 gap-8">
            {/* Contact Form (Client Component) */}
            <ContactFormClient />

            {/* Contact Details Section (Server-rendered) */}
            <div className="bg-brand-secondary p-8 rounded-lg shadow-xl">
              <h2 className="text-3xl font-bold text-white mb-6">
                letiim Bilgileri
              </h2>
              <div className="space-y-6 text-brand-light">
                <div className="flex items-center gap-4">
                  <Mail size={24} className="text-brand-purple" />
                  <div>
                    <h3 className="font-semibold text-white">E-posta</h3>
                    <p className="text-brand-muted">support@fanskor.com</p>
                  </div>
                </div>
                <div className="flex items-center gap-4">
                  <Phone size={24} className="text-brand-purple" />
                  <div>
                    <h3 className="font-semibold text-white">Telefon</h3>
                    <p className="text-brand-muted">+90 (555) 123 45 67</p>
                  </div>
                </div>
                <div className="flex items-center gap-4">
                  <MapPin size={24} className="text-brand-purple" />
                  <div>
                    <h3 className="font-semibold text-white">Adres</h3>
                    <p className="text-brand-muted">
                      Futbol Caddesi No: 10, Skor Mahallesi <br />
                      ampiyon ehir, Trkiye
                    </p>
                  </div>
                </div>
                <div className="text-sm pt-4 border-t border-gray-700 text-brand-muted">
                  Mesajnza 24 saat iinde yant vermeyi hedefliyoruz.
                </div>
              </div>
            </div>
          </div>
        </main>
        {/* --- NEW: Right Sidebar --- */}
        <aside className="lg:col-span-1 space-y-8 min-w-0">
          {/* News List Widget */}
          <section className="bg-brand-secondary rounded-lg shadow-lg p-6">
            <h2 className="text-2xl font-bold text-white mb-4">Son Haberler</h2>
            {sidebarNews && sidebarNews.length > 0 ? (
              <div className="space-y-4">
                {sidebarNews.map((post: any) => (
                  <NewsListItem key={post._id} post={post} />
                ))}
              </div>
            ) : (
              <p className="text-brand-muted text-center text-sm">
                Gncel haber bulunamad.
              </p>
            )}
          </section>
          {/* Ad Slot (Right Sidebar) */}
          <AdSlotWidget location="homepage_right_sidebar" />
        </aside>
      </div>
    </div>
  );
}


// ===== src\app\football\league\[...slug]\page.tsx =====
// src/app/football/league/[...slug]/page.tsx
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import LeagueDetailView from "@/components/league-detail-view";
import axios from "axios";
import { notFound } from "next/navigation";

// Helper to extract the ID from the slug (e.g., "premier-league-39" -> "39")
const getLeagueIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

// The data fetching functions remain unchanged
async function getLeagueData(leagueId: string): Promise<any | null> {
  try {
    const { data } = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/leagues?id=${leagueId}`,
      {
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );

    if (!data.response || data.response.length === 0) {
      return null;
    }

    const leagueData = data.response[0];

    const standingsResponse = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/standings`,
      {
        params: { league: leagueId, season: new Date().getFullYear() },
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );

    leagueData.league.standings =
      standingsResponse.data.response[0]?.league?.standings || [];
    return leagueData;
  } catch (error) {
    console.error("Failed to fetch single league data:", error);
    return null;
  }
}

export async function generateMetadata({
  params,
}: {
  params: { slug: string[] };
}) {
  const slug = params.slug.join("/");
  const leagueId = getLeagueIdFromSlug(slug);
  if (!leagueId) return { title: "League Not Found" };

  const leagueData = await getLeagueData(leagueId);
  if (!leagueData) return { title: "League Not Found" };

  return {
    title: `${leagueData.league.name} - Info, Fixtures & Standings`,
    description: `All information about the ${leagueData.league.name}, including available seasons, fixtures, and full standings.`,
    alternates: {
      canonical: `/football/league/${slug}`,
    },
  };
}

// --- THE MAIN PAGE COMPONENT ---
export default async function LeaguePage({
  params,
}: {
  params: { slug: string[] };
}) {
  const slug = params.slug.join("/");
  const leagueId = getLeagueIdFromSlug(slug);

  if (!leagueId) {
    notFound();
  }

  const leagueData = await getLeagueData(leagueId);

  if (!leagueData) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <LeagueDetailView leagueData={leagueData} />
        </main>
      </div>
    </div>
  );
}


// ===== src\app\football\leagues\page.tsx =====
// src/app/football/leagues/page.tsx
// This is now a Server Component. Removed "use client";
import { headers } from "next/headers"; // Used for locale detection on server if needed, though not directly for SEO text
import axios from "axios";
import type { Metadata } from "next"; // Import Metadata type

import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import LeagueListClient from "@/components/LeagueListClient"; // <-- NEW IMPORT: Client Component
import { League } from "@/types/api-football"; // Assuming League type is accessible

// This ensures dynamic rendering for this page if it uses headers, cookies, etc.
// For metadata, it's often implicit, but explicit for page content.
export const dynamic = "force-dynamic";

// --- Server-side Data Fetching for Initial Leagues List ---
const fetchAllLeaguesServer = async (): Promise<League[]> => {
  const publicAppUrl = process.env.NEXT_PUBLIC_PUBLIC_APP_URL;
  if (!publicAppUrl) {
    console.error(
      "[Leagues Page Server] NEXT_PUBLIC_PUBLIC_APP_URL is not defined! Cannot fetch all leagues."
    );
    return [];
  }
  const apiUrl = `${publicAppUrl}/api/leagues?fetchAll=true`;
  console.log(
    `[Leagues Page Server] Attempting to fetch all leagues from internal API: ${apiUrl}`
  );
  try {
    const { data } = await axios.get(apiUrl, { timeout: 15000 }); // Increased timeout
    console.log(
      `[Leagues Page Server] Successfully fetched ${data.length} leagues.`
    );
    return data;
  } catch (error: any) {
    console.error(
      `[Leagues Page Server] Failed to fetch all leagues (${apiUrl}):`,
      error.message
    );
    if (axios.isAxiosError(error) && error.response) {
      console.error(
        "[Leagues Page Server] API Response Error (Status, Data):",
        error.response.status,
        error.response.data
      );
    }
    return [];
  }
};

// --- DYNAMIC METADATA GENERATION FOR LEAGUES PAGE ---
export async function generateMetadata(): Promise<Metadata> {
  const pageTitle =
    "All Football Leagues & Cups | Find Your Favorite Competition";
  const pageDescription =
    "Explore a comprehensive list of football leagues and cups from around the world. Find detailed information, standings, fixtures, and more for top divisions and international competitions.";

  // Construct Canonical URL
  const canonicalUrl = `/football/leagues`;

  console.log(
    `[Leagues Metadata] Generating metadata. Canonical: ${canonicalUrl}`
  );

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: {
      canonical: canonicalUrl,
    },
    openGraph: {
      title: pageTitle,
      description: pageDescription,
      url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/football/leagues`,
      siteName: "Fan Skor",
      // images: [{ url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/og-image.jpg` }],
      type: "website",
    },
    twitter: {
      card: "summary_large_image",
      title: pageTitle,
      description: pageDescription,
      // images: [`${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/twitter-image.jpg`],
    },
  };
}

export default async function LeaguesPage() {
  console.log(
    "[Leagues Page Server] Rendering LeaguesPage (Server Component)."
  );

  // Fetch all leagues server-side
  const allLeagues = await fetchAllLeaguesServer();

  // --- Generate SEO Text for the page ---
  const leaguesPageSeoText = `Futbol dnyasnn kalbine ho geldiniz! Bu sayfada, en heyecan verici yerel liglerden prestijli uluslararas kupalara kadar, dnya genelindeki tm futbol liglerini ve kupalarn kefedebilirsiniz. Takmlarn gncel sralamalarn, yaklaan fikstrlerini ve tarihi istatistiklerini kolayca bulun. En sevdiiniz ligin detayl analizlerine daln ve futbolun nabzn tutun.`;

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <h1 className="text-4xl font-extrabold text-white mb-6">
            Leagues & Cups
          </h1>

          {/* Render the SEO text from the server */}
          <p className="italic text-[#a3a3a3] leading-relaxed mb-8">
            {leaguesPageSeoText}
          </p>

          {/* Render the Client Component, passing the initial server-fetched data */}
          <LeagueListClient initialAllLeagues={allLeagues} />
        </main>
      </div>
    </div>
  );
}


// ===== src\app\football\match\[...slug]\page.tsx =====
// src/app/football/match/[...slug]/page.tsx
// This is now a Server Component. No "use client" directive here.

import { notFound } from "next/navigation";
import axios from "axios";
import type { Metadata } from "next";

// Removed server-side i18n imports
// import { getDictionary } from '@/i18n.server';
// import { Locale } from '@/i18n.config';

// Import all the components used on this page
import Header from "@/components/Header";
import MatchHeader from "@/components/match/MatchHeader";
import MatchStatusBanner from "@/components/match/MatchStatusBanner";
import MatchH2HWidget from "@/components/match/MatchH2HWidget";
import MatchLineupsWidget from "@/components/match/MatchLineupsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import MatchPredictionWidget from "@/components/match/MatchPredictionWidget";
import TeamFormWidget from "@/components/match/TeamFormWidget";
import LiveOddsWidget from "@/components/match/LiveOddsWidget";
import MatchActivityWidget from "@/components/match/MatchActivityWidget";
import TeamStandingsWidget from "@/components/match/TeamStandingsWidget";
import CasinoPartner from "@/models/CasinoPartner";
import CasinoPartnerWidget from "@/components/CasinoPartnerWidget";

// --- Helper Functions (callable by server components) ---
const getFixtureIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

// Server-side data fetching for initial page render and metadata
const fetchMatchDetailsServer = async (fixtureId: string) => {
  const publicAppUrl = process.env.NEXT_PUBLIC_PUBLIC_APP_URL;
  if (!publicAppUrl) {
    console.error(
      "[Match Page Server] NEXT_PUBLIC_PUBLIC_APP_URL is not defined! Cannot fetch data."
    );
    return null;
  }
  const apiUrl = `${publicAppUrl}/api/match-details?fixture=${fixtureId}`;
  console.log(
    `[Match Page Server] Attempting to fetch initial match data from internal API: ${apiUrl}`
  );

  try {
    const { data } = await axios.get(apiUrl, { timeout: 10000 });
    console.log(
      `[Match Page Server] Successfully fetched initial match data for fixture ID ${fixtureId}.`
    );
    return data;
  } catch (error: any) {
    console.error(
      `[Match Page Server] Failed to fetch initial match details (${apiUrl}):`,
      error.message
    );
    if (axios.isAxiosError(error) && error.response) {
      console.error(
        "[Match Page Server] API Response Error (Status, Data):",
        error.response.status,
        error.response.data
      );
    }
    return null;
  }
};

// Skeleton Component (remains unchanged)
const PageSkeleton = () => (
  <div className="animate-pulse container mx-auto p-4 md:p-8">
    <div className="h-48 w-full bg-brand-secondary rounded-lg mb-2"></div>
    <div className="h-10 w-full bg-brand-secondary rounded-b-lg mb-8"></div>
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mt-8">
      <div className="lg:col-span-2 space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div className="h-96 w-full bg-brand-secondary rounded-lg"></div>
          <div className="h-96 w-full bg-brand-secondary rounded-lg"></div>
        </div>
        <div className="h-96 w-full bg-brand-secondary rounded-lg"></div>
        <div className="h-64 w-full bg-brand-secondary rounded-lg"></div>
      </div>
      <div className="lg:col-span-1 space-y-6">
        <div className="h-48 w-full bg-brand-secondary rounded-lg"></div>
        <div className="h-28 w-full bg-brand-secondary rounded-lg"></div>
        <div className="h-80 w-full bg-brand-secondary rounded-lg"></div>
        <div className="h-64 w-full bg-brand-secondary rounded-lg"></div>
        <div className="h-40 w-full bg-brand-secondary rounded-lg"></div>
      </div>
    </div>
  </div>
);

// --- DYNAMIC METADATA GENERATION ---
export async function generateMetadata({
  params,
}: {
  params: { slug: string[] }; // Removed locale from params
}): Promise<Metadata> {
  console.log(
    `[generateMetadata] Function called for params: ${JSON.stringify(
      params.slug
    )}`
  );

  const slug = params.slug.join("/");
  const fixtureId = getFixtureIdFromSlug(slug);

  if (!fixtureId) {
    console.warn(
      "[generateMetadata] No valid fixtureId obtained from slug. Returning default metadata."
    );
    return {
      title: "Match Not Found",
      description: "Details for this football match are not available.",
    };
  }

  const matchData = await fetchMatchDetailsServer(fixtureId);

  if (!matchData || !matchData.fixture) {
    console.warn(
      `[generateMetadata] Data for fixture ID ${fixtureId} is missing or incomplete. Returning default metadata.`
    );
    return {
      title: "Match Not Found",
      description: "Details for this football match are not available.",
    };
  }

  const homeTeamName = matchData.fixture.teams.home.name;
  const awayTeamName = matchData.fixture.teams.away.name;
  const leagueName = matchData.fixture.league.name;

  // Removed getDictionary call
  // const dict = await getDictionary(params.locale);

  const pageTitle = `${homeTeamName} vs ${awayTeamName} - Live Score, Prediction & Match Stats | ${leagueName}`;

  // Reverted to static description, or you can add client-side translation if desired.
  // For metadata, static is safer if not using server-side i18n directly.
  const pageDescription = `Get ready for an electrifying clash between ${homeTeamName} and ${awayTeamName}, promising intense competition and thrilling moments for football fans! As these two teams step onto the pitch, all eyes will be on their tactical setups, player performances, and the strategies they bring to secure vital points.`;

  // Construct Canonical URL: metadataBase from root layout + relative path
  const canonicalUrl = `/football/match/${slug}`;
  console.log(
    `[generateMetadata] Constructed Canonical URL (relative): ${canonicalUrl}`
  );

  const metadataResult: Metadata = {
    title: pageTitle,
    description: pageDescription,
    alternates: {
      canonical: canonicalUrl,
    },
    openGraph: {
      title: pageTitle,
      description: pageDescription,
    },
    twitter: {
      card: "summary_large_image",
      title: pageTitle,
      description: pageDescription,
    },
  };

  console.log(
    "[generateMetadata] Successfully generated metadata. Returning result."
  );
  return metadataResult;
}

// --- Main Page Component (Server Component) ---
export default async function MatchDetailPage({
  params,
}: {
  params: { slug: string[] }; // Removed locale from params
}) {
  console.log(
    `[Match Page Server] Rendering MatchDetailPage for slug: ${JSON.stringify(
      params.slug
    )}`
  );

  const slug = params.slug.join("/");
  const fixtureId = getFixtureIdFromSlug(slug);

  if (!fixtureId) {
    console.error(
      "[Match Page Server] No fixtureId available, calling notFound()."
    );
    notFound();
  }

  // Fetch initial data on the server
  const data = await fetchMatchDetailsServer(fixtureId);

  // Handle cases where data fetching fails or fixture is not found
  if (!data || !data.fixture) {
    console.error(
      `[Match Page Server] Initial data fetch failed or fixture not found for ID ${fixtureId}, calling notFound().`
    );
    notFound();
  }

  // Removed getDictionary call
  // const dict = await getDictionary(params.locale);

  // Determine if match is live (server-side, for initial render)
  const isLive = ["1H", "HT", "2H", "ET", "BT", "P", "LIVE"].includes(
    data.fixture.status?.short
  );

  const { fixture, h2h, analytics } = data;
  const { home: homeTeam, away: awayTeam } = fixture.teams;

  // --- Generate SEO Optimization Text for display on page ---
  // Pass team names for client-side translation in MatchHeader
  const matchSeoDescription = `${homeTeam.name}, son haftalarda dikkat ekici galibiyetler ve salam savunma performanslaryla bu maa gl bir formda geliyor. Saldr hatt keskin, birok frsat yaratarak rakip hatalarndan faydalanyor. Bu arada, ${awayTeam.name}  de direncini gsterdi, erken aksaklklardan geri dnd ve sralamada istikrarl bir ekilde ykselmeye balad. Taraftarlar, her iki takmdan da yksek enerji, agresif bask ve yaratc oyunlar bekleyebilirler.`;

  const h2hSeoDescription = `Tarihsel olarak, ${homeTeam.name} ve ${awayTeam.name} arasndaki karlamalar sk gemi, skor farklar dar ve son dakika dramalaryla dolu olmutur. Topa sahip olma yzdeleri, kaleye atlan utlar ve pas tamamlama oranlar gibi detayl istatistikler, her kritik an takip edebilmeniz iin gerek zamanl olarak gncellenecek.`;

  // --- Generate SEO Optimization Text for Standings widget ---
  const standingsSeoDescription =
    `${homeTeam.name}'nn gl orta saha motoruna ve yldz forvetine dikkat edin, her ikisi de savunmalar amak iin hayati neme sahip. ` +
    `Ancak, ${awayTeam.name} esas olarak gl stoper kombinasyonuna ve man seyrini her an deitirebilecek hzl kanat oyuncularna bamldr.`;

  const activitySeoDescription = `Fanskor, stadyumdan canl gncellemeler, gerek zamanl skorlar ve detayl ma istatistikleri sunar. Taktik analizlerden gerek zamanl gol bildirimlerine kadar, tek bir nemli an bile karmayacaksnz. Sohbete katln, tahminlerinizi paylan ve ${homeTeam.name} ile ${awayTeam.name} arasnda stnlk mcadelesinde heyecana kapln.`;

  return (
    <div className="bg-brand-dark min-h-screen">
      <Header />
      <div className="container mx-auto p-2 md:p-4 lg:p-6 text-brand-light">
        {/* Pass team names to MatchHeader for client-side translation */}
        <MatchHeader
          fixture={fixture}
          analytics={analytics}
          matchSeoDescription={matchSeoDescription} // Changed prop name
        />
        <MatchStatusBanner fixture={fixture} />

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mt-8">
          <main className="lg:col-span-2 space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <TeamFormWidget
                teamStats={analytics.homeTeamStats}
                team={homeTeam}
                location="Home"
              />
              <TeamFormWidget
                teamStats={analytics.awayTeamStats}
                team={awayTeam}
                location="Away"
              />
            </div>

            <MatchH2HWidget
              h2h={h2h}
              teams={fixture.teams}
              currentFixtureId={fixtureId!}
              h2hSeoDescription={h2hSeoDescription}
            />

            <MatchActivityWidget
              fixtureId={fixtureId!}
              homeTeamId={homeTeam.id}
              awayTeamId={awayTeam.id}
              homeTeamLogo={homeTeam.logo}
              awayTeamLogo={awayTeam.logo}
              isLive={isLive}
              activitySeoDescription={activitySeoDescription}
            />
          </main>

          <aside className="lg:col-span-1 space-y-6 sticky top-6">
            {isLive && <LiveOddsWidget fixtureId={fixtureId!} />}

            <CasinoPartnerWidget />

            <TeamStandingsWidget
              leagueId={fixture.league.id}
              season={fixture.league.season}
              homeTeamId={homeTeam.id}
              awayTeamId={awayTeam.id}
              standingsSeoDescription={standingsSeoDescription}
            />

            <MatchPredictionWidget
              apiPrediction={analytics.prediction}
              customPrediction={analytics.customPrediction}
              bookmakerOdds={analytics.bookmakerOdds}
              teams={fixture.teams}
            />

            <MatchLineupsWidget lineups={fixture.lineups} />

            <AdSlotWidget location="match_sidebar" />
          </aside>
        </div>
      </div>
    </div>
  );
}


// ===== src\app\football\news\page.tsx =====
// src/app/football/news/page.tsx
"use client";

import { useState, useMemo, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { IPost } from "@/models/Post";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import Pagination from "@/components/Pagination";
import NewsListItem, { NewsListItemSkeleton } from "@/components/NewsListItem";
import { Info, Newspaper } from "lucide-react";
import Script from "next/script"; // Import the Script component for JSON-LD
import PostCategories, { NewsCategory } from "@/components/PostCategories"; // Import the new component

export const dynamic = "force-dynamic";

const ITEMS_PER_PAGE = 8;

const fetchNews = async (): Promise<IPost[]> => {
  const { data } = await axios.get("/api/posts?status=published");
  return data;
};

export default function NewsPage() {
  const [currentPage, setCurrentPage] = useState(1);
  const [activeCategory, setActiveCategory] = useState<NewsCategory>("all");

  const { data: allNews, isLoading } = useQuery<IPost[]>({
    queryKey: ["allNewsArticles"],
    queryFn: fetchNews,
    staleTime: 1000 * 60 * 5,
  });

  // --- ENHANCED: Filtering and Pagination Logic ---
  const { paginatedData, totalPages } = useMemo(() => {
    if (!allNews) return { paginatedData: [], totalPages: 0 };

    // 1. Filter by the active category first
    const filteredNews =
      activeCategory === "all"
        ? allNews
        : allNews.filter((post) => post.sport === activeCategory);

    // 2. Paginate the filtered results
    const totalPages = Math.ceil(filteredNews.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    const paginatedData = filteredNews.slice(startIndex, endIndex);

    return { paginatedData, totalPages };
  }, [allNews, currentPage, activeCategory]);

  // Reset page to 1 when category changes
  useEffect(() => {
    setCurrentPage(1);
  }, [activeCategory]);

  // --- SEO: JSON-LD Structured Data ---
  const generateJsonLd = () => {
    if (!paginatedData || paginatedData.length === 0) return null;

    const items = paginatedData.map((post) => ({
      "@type": "NewsArticle",
      headline: post.title,
      image: [post.featuredImage || ""],
      datePublished: post.createdAt,
      dateModified: post.updatedAt,
      author: [
        {
          "@type": "Person",
          name: post.author,
        },
      ],
    }));

    return {
      "@context": "https://schema.org",
      "@type": "ItemList",
      itemListElement: items.map((item, index) => ({
        "@type": "ListItem",
        position: (currentPage - 1) * ITEMS_PER_PAGE + index + 1,
        item: item,
      })),
    };
  };

  return (
    <>
      {/* Add the JSON-LD Script to the head of the page */}
      <Script
        id="news-list-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(generateJsonLd()) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
          <Sidebar />
          <main className="min-w-0 p-4 lg:p-0 lg:py-6">
            {/* --- ENHANCED UI: Page Header --- */}
            <div className="flex items-center gap-4 mb-8">
              <div className="p-3 bg-brand-purple/10 rounded-lg">
                <Newspaper className="w-8 h-8 text-brand-purple" />
              </div>
              <div>
                <h1 className="text-4xl font-extrabold text-white">
                  Latest News
                </h1>
                <p className="text-brand-muted">
                  Stay updated with the latest stories and analysis.
                </p>
              </div>
            </div>

            {/* --- ENHANCED UI: Category Filters --- */}
            <PostCategories
              activeCategory={activeCategory}
              onCategoryChange={setActiveCategory}
            />

            {isLoading ? (
              <div className="space-y-4">
                {Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
                  <NewsListItemSkeleton key={i} />
                ))}
              </div>
            ) : paginatedData.length > 0 ? (
              <div className="space-y-4">
                {paginatedData.map((post) => (
                  <NewsListItem key={post._id} post={post} />
                ))}
                {totalPages > 1 && (
                  <Pagination
                    currentPage={currentPage}
                    totalPages={totalPages}
                    onPageChange={setCurrentPage}
                  />
                )}
              </div>
            ) : (
              <div className="text-center py-20 bg-brand-secondary rounded-lg">
                <Info size={32} className="mx-auto text-brand-muted mb-3" />
                <p className="text-xl font-bold text-white">No News Found</p>
                <p className="text-brand-muted mt-2">
                  There are no articles available in the "{activeCategory}"
                  category.
                </p>
              </div>
            )}
          </main>
        </div>
      </div>
    </>
  );
}


// ===== src\app\football\news\[slug]\page.tsx =====
import { notFound } from "next/navigation";
import dbConnect from "@/lib/dbConnect";
import Post from "@/models/Post";
import { format } from "date-fns";
import Header from "@/components/Header";
import Image from "next/image"; // <-- Import next/image
import SocialShareButtons from "@/components/SocialShareButtons"; // We will create this next
import NewsSidebar from "@/components/NewsSidebar";

// This function fetches the data on the server
async function getPost(slug: string) {
  await dbConnect();
  const post: any = await Post.findOne({
    slug: slug,
    status: "published",
  }).lean();
  if (!post) {
    return null;
  }
  return post;
}

// Update generateMetadata to use the new meta fields if they exist
export async function generateMetadata({
  params,
}: {
  params: { slug: string };
}) {
  const post = await getPost(params.slug);
  if (!post) {
    return { title: "Not Found" };
  }
  return {
    // Use specific meta title if available, otherwise fall back to post title
    title: post.metaTitle || `${post.title} | Fulltime News`,
    // Use specific meta description if available
    description:
      post.metaDescription ||
      post.content.replace(/<[^>]*>?/gm, "").substring(0, 160),
  };
}

// --- The Main Page Component ---
export default async function NewsArticlePage({
  params,
}: {
  params: { slug: string };
}) {
  const post = await getPost(params.slug);

  if (!post) {
    notFound();
  }

  // We need to construct the full URL for sharing
  const postUrl = `${process.env.NEXTAUTH_URL}/news/${post.slug}`;

  return (
    <div className="bg-brand-dark min-h-screen">
      <Header />
      {/* --- UPDATED LAYOUT --- */}
      <main className="container mx-auto p-4 md:p-8 grid grid-cols-1 lg:grid-cols-3 gap-12">
        {/* Main Content (Article) - Spans 2 columns on large screens */}
        <div className="lg:col-span-2">
          <article className="bg-brand-secondary rounded-lg overflow-hidden">
            {post.featuredImage && (
              <div className="relative w-full h-64 md:h-96">
                <Image
                  src={post.featuredImage}
                  alt={post.featuredImageAltText || post.title}
                  title={post.featuredImageTitle || post.title}
                  layout="fill"
                  objectFit="cover"
                  priority
                />
              </div>
            )}

            <div className="p-8">
              <div className="mb-8 text-center border-b border-gray-700/50 pb-8">
                <h1 className="text-4xl md:text-5xl font-extrabold text-white leading-tight mb-4">
                  {post.title}
                </h1>
                <p className="text-brand-muted">
                  Published by {post.author} on{" "}
                  {format(new Date(), "MMMM dd, yyyy")}
                </p>
              </div>

              <div
                className="prose prose-invert lg:prose-xl max-w-none"
                dangerouslySetInnerHTML={{ __html: post.content }}
              />

              <div className="mt-12 pt-8 border-t border-gray-700/50">
                <h3 className="text-lg font-bold text-center text-brand-muted mb-4">
                  Share this article
                </h3>
                <SocialShareButtons url={postUrl} title={post.title} />
              </div>
            </div>
          </article>
        </div>

        {/* Sidebar - Spans 1 column on large screens */}
        <div className="lg:col-span-1">
          <NewsSidebar />
        </div>
      </main>
    </div>
  );
}
// Optional: For better performance in production, generate static pages for each post at build time.
export async function generateStaticParams() {
  await dbConnect();
  const posts = await Post.find({ status: "published" }).select("slug").lean();
  return posts.map((post) => ({
    slug: post.slug,
  }));
}


// ===== src\app\football\team\[...slug]\page.tsx =====
// src/app/football/team/[...slug]/page.tsx
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import TeamDetailView from "@/components/TeamDetailView";
import { notFound } from "next/navigation";
import axios from "axios";
import type { Metadata } from "next"; // <-- NEW IMPORT for Metadata

// Helper to extract the ID from the slug (unchanged)
const getTeamIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

// --- THIS IS THE CORRECTED DATA FETCHING FUNCTION ---
async function getTeamData(teamId: string) {
  const season = new Date().getFullYear();

  // Reusable options object for axios requests
  const options = (endpoint: string, params: object) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    const [teamInfoRes, squadRes, fixturesRes] = await Promise.all([
      axios.request(options("teams", { id: teamId })),
      axios.request(options("players/squads", { team: teamId })),
      axios.request(
        options("fixtures", { team: teamId, season: season, last: 50 })
      ),
    ]);

    if (!teamInfoRes.data.response[0]) {
      return null;
    }

    return {
      teamInfo: teamInfoRes.data.response[0],
      squad: squadRes.data.response[0]?.players || [],
      fixtures: fixturesRes.data.response || [],
    };
  } catch (error) {
    console.error(`Failed to fetch team details for teamId ${teamId}:`, error);
    return null;
  }
}

// --- generateMetadata function ---
export async function generateMetadata({
  params,
}: {
  params: { slug: string[] };
}): Promise<Metadata> {
  // Specify Metadata return type
  // --- THE FIX IS HERE: AWAIT params ---
  const awaitedParams = await params; // Await the params object
  const slug = awaitedParams.slug.join("/");
  const teamId = getTeamIdFromSlug(slug);

  if (!teamId) {
    return { title: "Team Not Found" };
  }

  try {
    const { data } = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams?id=${teamId}`,
      {
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );
    const teamInfo = data.response[0];
    if (!teamInfo) return { title: "Team Not Found" };

    const pageTitle = `${teamInfo.team.name} - Squad, Fixtures & Standings`;
    const pageDescription = `View the full squad, recent fixtures, and current standings for ${teamInfo.team.name}.`;
    const canonicalUrl = `/football/team/${slug}`;

    return {
      title: pageTitle,
      description: pageDescription,
      alternates: {
        canonical: canonicalUrl,
      },
      openGraph: {
        title: pageTitle,
        description: pageDescription,
        // images: [`${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/api/image-proxy?url=${encodeURIComponent(teamInfo.team.logo)}`],
      },
      twitter: {
        card: "summary_large_image",
        title: pageTitle,
        description: pageDescription,
        // images: [`${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/api/image-proxy?url=${encodeURIComponent(teamInfo.team.logo)}`],
      },
    };
  } catch {
    return { title: "Team Not Found" };
  }
}

// THE MAIN PAGE COMPONENT
export default async function TeamPage({
  params,
}: {
  params: { slug: string[] };
}) {
  // --- THE FIX IS HERE: AWAIT params ---
  const awaitedParams = await params; // Await the params object
  const slug = awaitedParams.slug.join("/");
  const teamId = getTeamIdFromSlug(slug);

  if (!teamId) {
    notFound();
  }

  const teamData = await getTeamData(teamId);

  if (!teamData) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <TeamDetailView teamData={teamData} />
        </main>
      </div>
    </div>
  );
}


// ===== src\app\football\teams\page.tsx =====
// src/app/football/teams/page.tsx
"use client";

import { useState, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import StyledLink from "@/components/StyledLink";
import { ChevronRight, Globe, Search, Users } from "lucide-react";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";

export const dynamic = "force-dynamic";

// --- TYPE DEFINITION ---
interface EnrichedCountry {
  name: string;
  code: string | null;
  flagUrl: string;
  leagueCount: number;
}

// --- CARD AND SKELETON COMPONENTS (Unchanged) ---
const EnhancedCountryCard = ({ country }: { country: EnrichedCountry }) => (
  <StyledLink
    href={`/football/teams/${country.name}`}
    className="block group h-full"
  >
    <div className="bg-brand-secondary rounded-lg flex flex-col h-full transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20">
      <div className="p-4 flex items-center gap-4">
        <Image
          src={country.flagUrl}
          alt={country.name}
          width={40}
          height={40}
          className="rounded-full flex-shrink-0"
        />
        <div className="flex-1 min-w-0">
          <h3 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
            {country.name}
          </h3>
          <div className="flex items-center gap-1.5 text-xs text-brand-muted mt-1">
            <Globe size={12} />
            <span>View Teams</span>
          </div>
        </div>
        <ChevronRight className="text-brand-muted group-hover:text-brand-purple transition-colors flex-shrink-0" />
      </div>
      <div className="mt-auto border-t border-gray-700/50 p-3 text-xs text-brand-light flex items-center justify-center gap-2">
        <Users size={14} className="text-brand-muted" />
        <span className="font-semibold">{country.leagueCount}</span>
        <span>Professional Leagues</span>
      </div>
    </div>
  </StyledLink>
);

const CountryCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg flex flex-col h-full animate-pulse">
    <div className="p-4 flex items-center gap-4">
      <div className="w-10 h-10 rounded-full bg-gray-700"></div>
      <div className="space-y-2 flex-1">
        <div className="h-4 w-3/4 rounded bg-gray-600"></div>
        <div className="h-3 w-1/2 rounded bg-gray-600/50"></div>
      </div>
    </div>
    <div className="mt-auto border-t border-gray-700/50 p-3 flex items-center justify-center gap-2">
      <div className="h-4 w-2/3 bg-gray-700 rounded-md"></div>
    </div>
  </div>
);

export default function BrowseTeamsByCountryPage() {
  const [searchTerm, setSearchTerm] = useState("");

  // --- THIS IS THE FIX ---
  // Removed the external fetcher function and defined the query function directly and simply.
  // This is the most reliable pattern and avoids potential stale closure issues.
  const { data: countries, isLoading } = useQuery<EnrichedCountry[]>({
    queryKey: ["countryDirectory"],
    queryFn: async () => {
      const { data } = await axios.get("/api/directory/countries");
      return data;
    },
    staleTime: 1000 * 60 * 60 * 24, // Cache for a day
  });

  const filteredCountries = useMemo(() => {
    if (!countries) return [];
    return countries.filter((country) =>
      country.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [countries, searchTerm]);

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <h1 className="text-4xl font-extrabold text-white mb-2">
            Browse Teams by Country
          </h1>
          <p className="text-brand-muted mb-8">
            Select a country to view all associated professional teams.
          </p>

          <div className="relative mb-8 max-w-lg">
            <Search
              className="absolute left-3.5 top-1/2 -translate-y-1/2 text-brand-muted"
              size={20}
            />
            <input
              type="text"
              placeholder="Search for a country..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-3 pl-12 text-white focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
          </div>

          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-2 xl:grid-cols-3 gap-4">
            {isLoading ? (
              Array.from({ length: 18 }).map((_, i) => (
                <CountryCardSkeleton key={i} />
              ))
            ) : filteredCountries && filteredCountries.length > 0 ? (
              filteredCountries.map((country) => (
                <EnhancedCountryCard
                  key={country.code || country.name}
                  country={country}
                />
              ))
            ) : (
              <div className="text-center py-20 bg-brand-secondary rounded-lg col-span-full">
                <p className="text-xl font-bold text-white">
                  No Countries Found
                </p>
                <p className="text-brand-muted mt-2">
                  We couldn't find any countries with active leagues. Please
                  check back later.
                </p>
              </div>
            )}
          </div>
        </main>
      </div>
    </div>
  );
}


// ===== src\app\football\teams\[countryName]\page.tsx =====
// src/app/football/teams/[countryName]/page.tsx
"use client";

import { useState, useMemo, useEffect } from "react";
import { useParams } from "next/navigation";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import Pagination from "@/components/Pagination";
import StyledLink from "@/components/StyledLink";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import { Calendar, Info, MapPin, Search } from "lucide-react";

const ITEMS_PER_PAGE = 18;

// --- TYPE DEFINITION for the API response object ---
interface TeamsByCountryResponse {
  teams: any[];
  count: number;
}

// --- DATA FETCHER ---
const fetchTeamsByCountry = async (
  countryName: string
): Promise<TeamsByCountryResponse> => {
  const { data } = await axios.get(
    `/api/teams-by-country?country=${encodeURIComponent(countryName)}`
  );
  return data;
};

// EnhancedTeamCard and TeamCardSkeleton components remain the same
const EnhancedTeamCard = ({ team, venue }: { team: any; venue: any }) => (
  <StyledLink
    href={generateTeamSlug(team.name, team.id)}
    className="block group h-full"
  >
    <div className="bg-brand-secondary rounded-lg flex flex-col h-full transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20">
      <div className="p-4 flex items-center gap-4">
        <Image
          src={proxyImageUrl(team.logo)}
          alt={team.name}
          width={48}
          height={48}
          className="flex-shrink-0"
        />
        <div className="flex-1 min-w-0">
          <h3 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
            {team.name}
          </h3>
        </div>
      </div>
      <div className="px-4 pb-3 mt-auto border-t border-gray-700/50 pt-3 space-y-1.5 text-xs text-brand-muted">
        {team.founded && (
          <div className="flex items-center gap-2">
            <Calendar size={12} />
            <span>Founded: {team.founded}</span>
          </div>
        )}
        {venue?.name && (
          <div className="flex items-center gap-2 truncate">
            <MapPin size={12} />
            <span className="truncate" title={venue.name}>
              {venue.name}
            </span>
          </div>
        )}
      </div>
    </div>
  </StyledLink>
);

const TeamCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg p-4 h-36 animate-pulse">
    <div className="flex items-center gap-4">
      <div className="w-12 h-12 rounded-full bg-gray-700"></div>
      <div className="h-5 w-3/4 bg-gray-600 rounded"></div>
    </div>
    <div className="mt-6 space-y-2 border-t border-gray-700/50 pt-3">
      <div className="h-3 w-1/2 bg-gray-600/50 rounded"></div>
      <div className="h-3 w-full bg-gray-600/50 rounded"></div>
    </div>
  </div>
);

export default function TeamsByCountryPage() {
  const params = useParams();
  const countryName = decodeURIComponent(params.countryName as string);

  const [searchTerm, setSearchTerm] = useState("");
  const [currentPage, setCurrentPage] = useState(1);

  // --- FIX 1: Rename `data: teams` to `data: response` for clarity ---
  const { data: response, isLoading } = useQuery({
    queryKey: ["teamsByCountry", countryName],
    queryFn: () => fetchTeamsByCountry(countryName),
    staleTime: 1000 * 60 * 60,
  });

  const { paginatedData, totalPages } = useMemo(() => {
    // --- FIX 2: Access the `teams` array *from* the response object ---
    const teamsArray = response?.teams || []; // Use the actual array, or an empty one if data is not ready
    if (teamsArray.length === 0) return { paginatedData: [], totalPages: 0 };

    // --- FIX 3: Filter the `teamsArray`, not the response object ---
    const filtered = teamsArray.filter((teamData) =>
      teamData.team.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    const totalPages = Math.ceil(filtered.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    const paginatedData = filtered.slice(startIndex, endIndex);

    return { paginatedData, totalPages };
  }, [response, searchTerm, currentPage]);

  useEffect(() => {
    setCurrentPage(1);
  }, [searchTerm]);

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <h1 className="text-4xl font-extrabold text-white mb-6">
            Teams in {countryName}
          </h1>

          <div className="flex flex-col md:flex-row gap-4 mb-8">
            <div className="relative flex-grow">
              <Search
                className="absolute left-3.5 top-1/2 -translate-y-1/2 text-brand-muted"
                size={20}
              />
              <input
                type="text"
                placeholder="Search by team name..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-3 pl-12 text-white focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
            </div>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
            {isLoading ? (
              Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
                <TeamCardSkeleton key={i} />
              ))
            ) : paginatedData.length > 0 ? (
              paginatedData.map((teamData) => (
                <EnhancedTeamCard
                  key={teamData.team.id}
                  team={teamData.team}
                  venue={teamData.venue}
                />
              ))
            ) : (
              <div className="col-span-full text-center py-20 bg-brand-secondary rounded-lg">
                <Info size={32} className="mx-auto text-brand-muted mb-3" />
                <p className="text-xl font-bold text-white">No Results Found</p>
                <p className="text-brand-muted mt-2">
                  Try adjusting your search term or check back later.
                </p>
              </div>
            )}
          </div>

          {!isLoading && paginatedData.length > 0 && (
            <Pagination
              currentPage={currentPage}
              totalPages={totalPages}
              onPageChange={setCurrentPage}
            />
          )}
        </main>
      </div>
    </div>
  );
}


// ===== src\app\layout.tsx =====
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import Providers from "./providers";
import { LeagueProvider } from "@/context/LeagueContext";
import "slick-carousel/slick/slick.css";
import "slick-carousel/slick/slick-theme.css";
import { LanguageProvider } from "@/context/LanguageContext";
import NextAuthProvider from "./NextAuthProvider";
import { Suspense } from "react";
import StickyFooterAd from "@/components/StickyFooterAd";
import Loading from "./loading";
import Footer from "@/components/Footer";

const inter = Inter({ subsets: ["latin"] });

const METADATA_BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

export const metadata: Metadata = {
  metadataBase: new URL(METADATA_BASE_URL),
  alternates: {
    canonical: "/",
  },
  title: "Fan Skor | Trkiye'nin 1 numaral Canl Skor sitesi",
  description:
    "Oyuntaktik.com, Trkiye'nin bir numaral inceleme sitesi, en iyi oyun rehberleri, taktikler ve gncel deerlendirmelerle oyuncularn yannda!",
  icons: {
    icon: [{ url: "/favicon.ico", type: "image/png" }],
    apple: [{ url: "/favicon.ico" }],
  },
  robots: {
    index: true,
    follow: true,
    googleBot: {
      index: true,
      follow: true,
    },
  },
  // --- ADDED DEFAULT OPEN GRAPH TAGS ---
  openGraph: {
    title: "Fan Skor | Trkiye'nin 1 numaral Canl Skor sitesi",
    description:
      "Oyuntaktik.com, Trkiye'nin bir numaral inceleme sitesi, en iyi oyun rehberleri, taktikler ve gncel deerlendirmelerle oyuncularn yannda!",
    url: METADATA_BASE_URL, // Canonical URL for the site root
    siteName: "Fan Skor",
    images: [
      {
        url: `${METADATA_BASE_URL}/og-image.jpg`, // You should create this image in your public folder
        width: 1200,
        height: 630,
        alt: "Fan Skor - Trkiye Canl Skor Sitesi",
      },
    ],
    locale: "en_US", // Default locale, can be changed dynamically by pages if i18n is used
    type: "website",
  },
  // --- ADDED DEFAULT TWITTER CARD TAGS ---
  twitter: {
    card: "summary_large_image",
    title: "Fan Skor | Trkiye'nin 1 numaral Canl Skor sitesi",
    description:
      "Oyuntaktik.com, Trkiye'nin bir numaral inceleme sitesi, en iyi oyun rehberleri, taktikler ve gncel deerlendirmelerle oyuncularn yannda!",
    creator: "@fanskor_official", // Your Twitter handle
    images: [`${METADATA_BASE_URL}/twitter-image.jpg`], // You should create this image in your public folder
  },
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body
        className={`${inter.className} bg-background text-text-primary`}
        suppressHydrationWarning={true}
      >
        <Suspense fallback={<Loading />}>
          <NextAuthProvider>
            <Providers>
              <LanguageProvider>
                <LeagueProvider>
                  <main>{children}</main>
                  <StickyFooterAd />
                  <Footer />
                </LeagueProvider>
              </LanguageProvider>
            </Providers>
          </NextAuthProvider>
        </Suspense>
      </body>
    </html>
  );
}


// ===== src\app\loading.tsx =====
// src/app/loading.tsx
// This file acts as the server-side container for our client-side preloader.

import LottiePreloader from "@/components/LottiePreloader"; // Import the new component

export default function Loading() {
  return (
    <div className="fixed inset-0 z-[100] flex items-center justify-center bg-[#1F1D2B]">
      {/* 
        We render the LottiePreloader component here. 
        Next.js will handle rendering the client component within this server component shell.
      */}
      <LottiePreloader />
    </div>
  );
}


// ===== src\app\login\page.tsx =====
"use client";

import { useState } from 'react';
import { signIn } from 'next-auth/react';
import { useRouter, useSearchParams } from 'next/navigation';
import { useTranslation } from '@/hooks/useTranslation';


export const dynamic = 'force-dynamic';

export default function LoginPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { t } = useTranslation();
  
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState(searchParams.get('error') || '');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    const result = await signIn('credentials', {
      redirect: false,
      email,
      password,
    });

    if (result?.error) {
      setError(t('invalid_credentials'));
    } else if (result?.ok) {
      router.push('/admin/dashboard');
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-brand-dark">
      <form onSubmit={handleSubmit} className="p-8 rounded-lg shadow-lg bg-brand-secondary w-full max-w-sm">
        <h1 className="text-2xl font-bold mb-6 text-center text-white">{t('admin_login')}</h1>
        {error && <p className="bg-red-500/20 text-red-400 p-3 rounded mb-4 text-sm">{error}</p>}
        <div className="space-y-4">
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder={t('email')}
            required
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder={t('password')}
            required
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
        </div>
        <button type="submit" className="w-full mt-6 bg-brand-purple text-white font-bold py-3 rounded-lg hover:opacity-90 transition-opacity">
          {t('sign_in')}
        </button>
      </form>
    </div>
  );
}

// ===== src\app\NextAuthProvider.tsx =====
// src/app/NextAuthProvider.tsx
"use client";

import { SessionProvider } from "next-auth/react";

// This is a new wrapper component
export default function NextAuthProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  return <SessionProvider>{children}</SessionProvider>;
}

// ===== src\app\not-found.tsx =====
"use client";

import { Suspense } from 'react'; // <-- IMPORT Suspense
import Link from 'next/link';
import Header from '@/components/Header';
import { HeaderSkeleton } from '@/components/LayoutSkeletons'; // <-- IMPORT Skeleton
import { Frown } from 'lucide-react';

export default function NotFound() {
  return (
    <div className="min-h-screen flex flex-col">
      <Suspense fallback={<HeaderSkeleton />}>
        <Header />
      </Suspense>

      <main className="flex-1 flex flex-col items-center justify-center text-center p-4">
        <Frown className="w-16 h-16 text-text-muted mb-4" />
        <h1 className="text-4xl font-extrabold text-white">404 - Page Not Found</h1>
        <p className="text-lg text-text-secondary mt-2 mb-6">
          The page you are looking for does not exist or has been moved.
        </p>
        <Link 
            href="/"
            className="px-6 py-3 bg-brand-purple text-white font-bold rounded-lg hover:opacity-90 transition-opacity"
        >
          Go back to Homepage
        </Link>
      </main>
    </div>
  )
}

// ===== src\app\page.tsx =====
// src/app/page.tsx
import { Suspense } from "react";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { MainContent } from "@/components/MainContent"; // This is a Client Component
import { SidebarSkeleton } from "@/components/LayoutSkeletons";
import type { Metadata } from "next";

// --- DYNAMIC METADATA GENERATION FOR HOMEPAGE ---
export async function generateMetadata(): Promise<Metadata> {
  const pageTitle = "Fan Skor | Trkiye'nin 1 numaral Canl Skor sitesi";
  const pageDescription =
    "Oyuntaktik.com, Trkiye'nin bir numaral inceleme sitesi, en iyi oyun rehberleri, taktikler ve gncel deerlendirmelerle oyuncularn yannda!";

  const canonicalUrl = `/`;

  console.log(
    `[Homepage Metadata] Generating metadata for homepage. Canonical: ${canonicalUrl}`
  );

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: {
      canonical: canonicalUrl,
    },
    openGraph: {
      title: pageTitle,
      description: pageDescription,
      url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}`,
      siteName: "Fan Skor",
      images: [
        {
          url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/og-image.jpg`,
          width: 1200,
          height: 630,
          alt: "Fan Skor - Trkiye Canl Skor Sitesi",
        },
      ],
      type: "website",
    },
    twitter: {
      card: "summary_large_image",
      title: pageTitle,
      description: pageDescription,
      creator: "@fanskor_official",
      images: [`${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/twitter-image.jpg`],
    },
  };
}

export default async function HomePage() {
  // --- Generate Homepage About SEO Text ---
  const homepageAboutSeoText = `Fanskor'da, size sadece gerek zamanl olarak dzenli olarak gncellenen Trk Sper Ligi'nin sonular ve puan durumlarndan daha fazlasn sunuyoruz, ayrca ma balar balamaz size en kapsaml ma incelemesini ve canl skorlar veriyoruz, bylece Fanskor ile her zaman Trk Sper Ligi'nin nabzn tutuyorsunuz!
      Her bir gol veya dier nemli anlar kapsamak iin derinlemesine analiz ve takm istatistiklerinin yan sra canl gncellemeler vb. sunuyoruz. nceden mi planlyorsunuz? Hibir glk ekmeden gelecekteki malar renin ve bir daha asla nemli bir ma karmayn.
      ster favori takmnz takip edin, ister ligin tm malarn izleyin, Fanskor size gerek taraftarn tercihi zerine gerek Trk futbolunun mkemmel, eksiksiz, gvenilir ve dinamik bir resmini salayabilir.
      Bir oyun takipisi olmayn, Fanskor ile bir oyun takipisi olun. imdi en yeni, itibarl ve tek elden kapsam aln!
      `;
  const sidebarAboutSeoText = `Fanskor, heyecan verici derbileri veya beklenmedik alt kadro hikayelerini takip ediyor olsanz da, size en son haberleri ve analizleri sunar. Fanskor, Trk Sper Ligi haberleri iin bavurabileceiniz kaynanzdr. Ma programlarn kontrol edebilir, gncel puan durumunu grebilir, canl sonular takip edebilir ve tm takm istatistiklerine cebinizde ulaabilirsiniz.`;

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:items-start lg:py-8">
        <Suspense fallback={<SidebarSkeleton />}>
          <Sidebar />
        </Suspense>

        <main className="min-w-0">
          {/* Pass the homepageAboutSeoText as a prop to MainContent */}
          <MainContent
            sidebarAboutSeoText={sidebarAboutSeoText}
            homepageAboutSeoText={homepageAboutSeoText}
          />
        </main>
      </div>
    </div>
  );
}


// ===== src\app\providers.tsx =====
"use client";

import ProgressBar from "@/components/ProgressBar";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { useState } from "react";
import { Toaster } from "react-hot-toast";

export default function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
          },
        },
      })
  );

 return (
    <QueryClientProvider client={queryClient}>
      {/* Add Toaster here. You can customize its position and style. */}
      <Toaster 
        position="top-right"
        toastOptions={{
          style: {
            background: '#333',
            color: '#fff',
          },
        }}
      />
      <ProgressBar />
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}

// ===== src\app\sitemap.ts =====
// src/app/sitemap.ts
// This is the full, dynamic sitemap.ts file.

import { MetadataRoute } from "next";
import axios from "axios";
import { format, subDays, addDays } from "date-fns";
import slugify from "slugify";

// --- IMPORTANT: This is the critical part for production deployment ---
// Ensure NEXT_PUBLIC_PUBLIC_APP_URL is set in your production environment variables.
const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";
console.log(`[Sitemap Generation] BASE_URL is: ${BASE_URL}`);

// --- Helper Functions to build slugs (ensure they match your frontend) ---
const generateLeagueSlug = (leagueName: string, leagueId: number): string => {
  const slug = slugify(leagueName, {
    lower: true,
    strict: true,
    remove: /[*+~.()'"!:@]/g,
  });
  return `/football/league/${slug}-${leagueId}`;
};

const generateTeamSlug = (teamName: string, teamId: number): string => {
  const slug = slugify(teamName, {
    lower: true,
    strict: true,
    remove: /[*+~.()'"!:@]/g,
  });
  return `/football/team/${slug}-${teamId}`;
};

const generateMatchSlug = (
  homeName: string,
  awayName: string,
  fixtureId: number
): string => {
  const slugifyPart = (str: string) =>
    slugify(str, { lower: true, strict: true, remove: /[*+~.()'"!:@]/g });
  return `/football/match/${slugifyPart(homeName)}-vs-${slugifyPart(
    awayName
  )}-${fixtureId}`;
};

// --- Fetchers for each content type ---

async function getNewsUrls(): Promise<MetadataRoute.Sitemap> {
  console.log(
    `[Sitemap] Fetching news from: ${BASE_URL}/api/posts?status=published`
  );
  try {
    const { data: posts } = await axios.get(
      `${BASE_URL}/api/posts?status=published`
    );
    console.log(`[Sitemap] Fetched ${posts.length} news posts.`);
    return posts.map((post: any) => ({
      url: `${BASE_URL}/football/news/${post.slug}`,
      lastModified: post.updatedAt
        ? new Date(post.updatedAt)
        : new Date(post.createdAt),
      changeFrequency: "weekly",
      priority: 0.8,
    }));
  } catch (error) {
    console.error("[Sitemap] Error generating news sitemap:", error);
    return [];
  }
}

async function getLeagueUrls(): Promise<MetadataRoute.Sitemap> {
  console.log(
    `[Sitemap] Fetching leagues from: ${BASE_URL}/api/leagues?fetchAll=true`
  );
  try {
    const { data: leagues } = await axios.get(
      `${BASE_URL}/api/leagues?fetchAll=true`
    );
    console.log(`[Sitemap] Fetched ${leagues.length} leagues.`);
    return leagues.map((league: any) => ({
      url: `${BASE_URL}${generateLeagueSlug(league.name, league.id)}`,
      lastModified: new Date(),
      changeFrequency: "monthly",
      priority: 0.7,
    }));
  } catch (error) {
    console.error("[Sitemap] Error generating league sitemap:", error);
    return [];
  }
}

async function getTeamUrls(): Promise<MetadataRoute.Sitemap> {
  console.log(`[Sitemap] Fetching teams from: ${BASE_URL}/api/directory/teams`);
  try {
    const { data: teamsData } = await axios.get(
      `${BASE_URL}/api/directory/teams`
    );
    console.log(`[Sitemap] Fetched ${teamsData.length} teams.`);
    return teamsData.map((teamData: any) => ({
      url: `${BASE_URL}${generateTeamSlug(
        teamData.team.name,
        teamData.team.id
      )}`,
      lastModified: new Date(),
      changeFrequency: "weekly",
      priority: 0.6,
    }));
  } catch (error) {
    console.error("[Sitemap] Error generating team sitemap:", error);
    return [];
  }
}

async function getMatchUrls(): Promise<MetadataRoute.Sitemap> {
  const today = new Date();
  const fromDate = format(subDays(today, 60), "yyyy-MM-dd");
  const toDate = format(addDays(today, 60), "yyyy-MM-dd");
  console.log(
    `[Sitemap] Fetching matches from: ${BASE_URL}/api/fixtures?from=${fromDate}&to=${toDate}`
  );
  try {
    const { data: matches } = await axios.get(
      `${BASE_URL}/api/fixtures?from=${fromDate}&to=${toDate}`
    );
    console.log(`[Sitemap] Fetched ${matches.length} matches.`);
    return matches.map((match: any) => ({
      url: `${BASE_URL}${generateMatchSlug(
        match.teams.home.name,
        match.teams.away.name,
        match.fixture.id
      )}`,
      lastModified: new Date(match.fixture.date),
      changeFrequency: "daily",
      priority: 0.9,
    }));
  } catch (error) {
    console.error("[Sitemap] Error generating match sitemap:", error);
    return [];
  }
}

export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  console.log("[Sitemap] Starting sitemap generation...");
  const [newsUrls, leagueUrls, teamUrls, matchUrls] = await Promise.all([
    getNewsUrls(),
    getLeagueUrls(),
    getTeamUrls(),
    getMatchUrls(),
  ]);

  const allUrls = [
    {
      url: `${BASE_URL}/`,
      lastModified: new Date(),
      changeFrequency: "daily",
      priority: 1,
    },
    {
      url: `${BASE_URL}/football/news`,
      lastModified: new Date(),
      changeFrequency: "daily",
      priority: 0.9,
    },
    {
      url: `${BASE_URL}/football/leagues`,
      lastModified: new Date(),
      changeFrequency: "daily",
      priority: 0.9,
    },
    {
      url: `${BASE_URL}/football/teams`,
      lastModified: new Date(),
      changeFrequency: "daily",
      priority: 0.9,
    },
    {
      url: `${BASE_URL}/contact-us`,
      lastModified: new Date(),
      changeFrequency: "weekly",
      priority: 0.9,
    },
    ...newsUrls,
    ...leagueUrls,
    ...teamUrls,
    ...matchUrls,
  ];

  console.log(
    `[Sitemap] Finished sitemap generation. Total URLs: ${allUrls.length}`
  );
  return allUrls;
}


