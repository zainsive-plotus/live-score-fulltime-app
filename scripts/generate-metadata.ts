// ===== scripts/generate-metadata.ts =====

import fs from "fs/promises";
import path from "path";
import chalk from "chalk";
import mongoose from "mongoose";

import Post, { IPost } from "../src/models/Post";

// --- Configuration ---
const MONGODB_URI =
  "mongodb+srv://malikseo856:Djr9jOgdoMQ862xG@cluster0.pu5jzdv.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0";
const OUTPUT_FILE = path.join(process.cwd(), "public/data/metadata-cache.js");
const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

if (!MONGODB_URI) {
  console.error(
    chalk.red(
      "[ERROR] NEXT_PUBLIC_MONGODB_URI environment variable is not set."
    )
  );
  process.exit(1);
}

// --- Helper Functions ---
const log = (message: string): void =>
  console.log(chalk.blue(`[INFO] ${message}`));
const logSuccess = (message: string): void =>
  console.log(chalk.green(`[SUCCESS] ${message}`));
const logError = (message: string): void =>
  console.error(chalk.red(`[ERROR] ${message}`));

// --- Type Definition for our Cache ---
interface PostMetadata {
  title: string;
  description: string;
  imageUrl: string;
  imageAlt: string;
  publishedTime: string;
  modifiedTime: string;
  author: string;
}

// --- Main Execution Function ---
async function run(): Promise<void> {
  const startTime = Date.now();

  try {
    log("Connecting to the database...");
    await mongoose.connect(MONGODB_URI);
    logSuccess("Database connection established.");

    log("Fetching all published posts...");
    const allPosts: IPost[] = await Post.find({ status: "published" }).lean();
    logSuccess(`Found ${allPosts.length} posts to process.`);

    const metadataMap: Record<string, PostMetadata> = {};

    for (const post of allPosts) {
      const key = `${post.language}:${post.slug}`;

      const description =
        post.metaDescription ||
        post.content.replace(/<[^>]*>?/gm, "").substring(0, 160);
      const imageUrl = post.featuredImage || `${BASE_URL}/og-image.jpg`;

      metadataMap[key] = {
        title: post.metaTitle || post.title,
        description: description,
        imageUrl: imageUrl,
        imageAlt: post.featuredImageAltText || post.title,
        publishedTime: post.createdAt.toISOString(),
        modifiedTime: post.updatedAt.toISOString(),
        author: post.author,
      };
    }

    log(`Processed ${Object.keys(metadataMap).length} metadata entries.`);

    const fileContent = `
// This file is auto-generated by scripts/generate-metadata.ts
// Do not edit this file manually.
export const metadataCache = ${JSON.stringify(metadataMap, null, 2)};
`;

    await fs.mkdir(path.dirname(OUTPUT_FILE), { recursive: true });
    await fs.writeFile(OUTPUT_FILE, fileContent, "utf-8");
    logSuccess(
      `Metadata cache successfully written to ${OUTPUT_FILE.replace(
        process.cwd(),
        ""
      )}`
    );
  } catch (error: any) {
    logError(`An error occurred during metadata generation: ${error.message}`);
  } finally {
    if (mongoose.connection.readyState === 1) {
      log("Disconnecting from database...");
      await mongoose.disconnect();
      logSuccess("Database disconnected.");
    }
  }

  const duration = ((Date.now() - startTime) / 1000).toFixed(2);
  logSuccess(`Metadata generation complete in ${duration} seconds.`);
}

run();
