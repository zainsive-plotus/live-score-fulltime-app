// ===== src/app/NextAuthProvider.tsx =====

"use client";

import { SessionProvider } from "next-auth/react";

export default function NextAuthProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  return <SessionProvider>{children}</SessionProvider>;
}

// ===== src/app/[locale]/author/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import { notFound } from "next/navigation";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { UserCircle } from "lucide-react";
import AdSlotWidget from "@/components/AdSlotWidget";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import Script from "next/script";
import {
  WithContext,
  AboutPage,
  Organization,
  BreadcrumbList,
} from "schema-dts";

const PAGE_SLUG = "author";
const PAGE_PATH = "/author";
const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

async function getPageContent() {
  try {
    const response = await axios.get(`${BASE_URL}/api/pages/${PAGE_SLUG}`);
    return response.data;
  } catch (error) {
    return null;
  }
}

export async function generateMetadata({
  params: { locale },
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const t = await getI18n(locale);
  const title = t("author_default_page_title");
  const description = t("author_default_page_description");
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, locale);

  return {
    title: title,
    description: description,
    alternates: hreflangAlternates,
  };
}

export default async function AuthorPage({
  params: { locale },
}: {
  params: { locale: string };
}) {
  const t = await getI18n(locale);
  const pageContent = await getPageContent();

  if (!pageContent || !pageContent.content) {
    notFound();
  }

  const pageDescription = t("author_default_page_description");

  const jsonLd: WithContext<AboutPage | BreadcrumbList>[] = [
    {
      "@context": "https://schema.org",
      "@type": "AboutPage",
      mainEntity: {
        "@type": "Organization",
        name: "Fan Skor",
        url: BASE_URL,
        logo: `${BASE_URL}/fanskor-transparent.webp`,
      },
      name: pageContent.title,
      description: pageDescription,
      url: `${BASE_URL}/${locale}${PAGE_PATH}`,
    },
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: t("homepage"),
          item: `${BASE_URL}/${locale}`,
        },
        {
          "@type": "ListItem",
          position: 2,
          name: pageContent.title,
        },
      ],
    },
  ];

  return (
    <>
      <Script
        id="author-page-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
          <Sidebar />

          <main className="min-w-0">
            <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
              <div className="flex items-center gap-4 mb-4">
                <div className="p-3 bg-purple-500/10 rounded-lg">
                  <UserCircle className="w-8 h-8 text-purple-400" />
                </div>
                <h1 className="text-4xl font-extrabold text-white">
                  {pageContent.title}
                </h1>
              </div>

              <div
                className="prose prose-invert lg:prose-xl max-w-none text-text-secondary"
                dangerouslySetInnerHTML={{ __html: pageContent.content }}
              />
            </div>
          </main>

          <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
            <RecentNewsWidget />
            <AdSlotWidget location="homepage_right_sidebar" />
          </aside>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/contact-us/page.tsx =====

import type { Metadata } from "next";
import { Mail, Phone, MapPin } from "lucide-react";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import ContactFormClient from "@/components/ContactFormClient";
import AdSlotWidget from "@/components/AdSlotWidget";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import Script from "next/script";
import {
  WithContext,
  ContactPage,
  Organization,
  BreadcrumbList,
  PostalAddress,
} from "schema-dts";

const PAGE_PATH = "/contact-us";
const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

export async function generateMetadata({
  params: { locale },
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const t = await getI18n(locale);
  const pageTitle = t("contact_us_meta_title");
  const pageDescription = t("contact_us_meta_description");
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, locale);

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
    openGraph: {
      title: pageTitle,
      description: pageDescription,
      url: `${BASE_URL}${PAGE_PATH}`,
      siteName: "Fan Skor",
      type: "website",
    },
  };
}

export default async function ContactUsPage({
  params: { locale },
}: {
  params: { locale: string };
}) {
  const t = await getI18n(locale);
  const contactPageSeoText = t("contact_us_seo_text");

  const address: PostalAddress = {
    "@type": "PostalAddress",
    streetAddress: "123 Futbol Sokak, Spor Mahallesi",
    addressLocality: "Istanbul",
    postalCode: "34000",
    addressCountry: "TR",
  };

  const jsonLd: WithContext<ContactPage | BreadcrumbList>[] = [
    {
      "@context": "https://schema.org",
      "@type": "ContactPage",
      name: t("contact_us_meta_title"),
      description: t("contact_us_meta_description"),
      url: `${BASE_URL}/${locale}${PAGE_PATH}`,
      mainEntity: {
        "@type": "Organization",
        name: "Fan Skor",
        url: BASE_URL,
        logo: `${BASE_URL}/fanskor-transparent.webp`,
        contactPoint: [
          {
            "@type": "ContactPoint",
            telephone: "+90-555-123-4567",
            contactType: "customer support",
            email: "support@fanskor.com",
            areaServed: "TR",
            availableLanguage: [
              "English",
              "Turkish",
              "Africans",
              "Spanish",
              "French",
              "Italians",
            ],
          },
        ],
        address: address,
      },
    },
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: t("homepage"),
          item: `${BASE_URL}/${locale}`,
        },
        {
          "@type": "ListItem",
          position: 2,
          name: t("contact_us_form_title"),
        },
      ],
    },
  ];

  return (
    <>
      <Script
        id="contact-page-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
          <Sidebar />
          <main className="min-w-0">
            <div className="bg-brand-secondary p-6 rounded-lg shadow-xl mb-8">
              <h1 className="text-3xl font-bold text-white mb-3">
                {t("contact_us_form_title")}
              </h1>
              <p className="text-brand-light text-base leading-relaxed">
                {contactPageSeoText}
              </p>
            </div>
            <div className="grid grid-cols-1 gap-8">
              <ContactFormClient />
              <div className="bg-brand-secondary p-8 rounded-lg shadow-xl">
                <h2 className="text-3xl font-bold text-white mb-6">
                  {t("contact_information_title")}
                </h2>
                <div className="space-y-6 text-brand-light">
                  <div className="flex items-center gap-4">
                    <Mail size={24} className="text-brand-purple" />
                    <div>
                      <h3 className="font-semibold text-white">{t("email")}</h3>
                      <p className="text-brand-muted">support@fanskor.com</p>
                    </div>
                  </div>
                  <div className="flex items-center gap-4">
                    <Phone size={24} className="text-brand-purple" />
                    <div>
                      <h3 className="font-semibold text-white">{t("phone")}</h3>
                      <p className="text-brand-muted">+90 (555) 123 45 67</p>
                    </div>
                  </div>
                  <div className="flex items-center gap-4">
                    <MapPin size={24} className="text-brand-purple" />
                    <div>
                      <h3 className="font-semibold text-white">
                        {t("address")}
                      </h3>
                      <p
                        className="text-brand-muted"
                        dangerouslySetInnerHTML={{
                          __html: t("contact_address_html"),
                        }}
                      ></p>
                    </div>
                  </div>
                  <div className="text-sm pt-4 border-t border-gray-700 text-brand-muted">
                    {t("contact_response_time_info")}
                  </div>
                </div>
              </div>
            </div>
          </main>
          <aside className="lg:col-span-1 space-y-8 min-w-0 mt-8 lg:mt-0">
            <RecentNewsWidget />
            <AdSlotWidget location="homepage_right_sidebar" />
          </aside>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/faq/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { HelpCircle } from "lucide-react";
import AdSlotWidget from "@/components/AdSlotWidget";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import { getI18n } from "@/lib/i18n/server";
import { IFaq } from "@/models/Faq";
import FaqClient from "@/components/FaqClient";
import { generateHreflangTags } from "@/lib/hreflang";
import Script from "next/script";
import { WithContext, FAQPage } from "schema-dts";

const PAGE_PATH = "/faq";
const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

async function fetchFaqs(): Promise<IFaq[]> {
  try {
    const { data } = await axios.get(`${BASE_URL}/api/faqs`);
    return data;
  } catch (error) {

    return [];
  }
}

export async function generateMetadata({
  params: { locale },
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, locale);

  return {
    title: t("faq_meta_title"),
    description: t("faq_meta_description"),
    alternates: hreflangAlternates,
  };
}

export default async function FaqPage({
  params: { locale },
}: {
  params: { locale: string };
}) {
  const t = await getI18n(locale);
  const allFaqs = await fetchFaqs();

  const jsonLd: WithContext<FAQPage> = {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    mainEntity: allFaqs.map((faq) => ({
      "@type": "Question",
      name: faq.question,
      acceptedAnswer: {
        "@type": "Answer",
        text: faq.answer,
      },
    })),
  };

  return (
    <>
      <Script
        id="faq-page-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
          <Sidebar />

          <main className="min-w-0 space-y-8">
            <div className="bg-brand-secondary p-6 rounded-lg shadow-xl text-center">
              <HelpCircle className="w-12 h-12 text-[var(--brand-accent)] mx-auto mb-4" />
              <h1 className="text-4xl font-extrabold text-white">
                {t("faq_page_main_title")}
              </h1>
              <p className="text-text-muted mt-2 max-w-2xl mx-auto">
                {t("faq_page_subtitle")}
              </p>
            </div>

            <FaqClient initialFaqs={allFaqs} />
          </main>

          <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
            <RecentNewsWidget />
            <AdSlotWidget location="homepage_right_sidebar" />
          </aside>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/football/league/[...slug]/page.tsx =====

import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import LeagueDetailView from "@/components/league-detail-view";
import axios from "axios";
import { notFound } from "next/navigation";
import type { Metadata } from "next";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";

const getLeagueIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

async function getLeagueData(leagueId: string): Promise<any | null> {
  try {
    const { data } = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/leagues?id=${leagueId}`,
      {
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );
    if (!data.response || data.response.length === 0) return null;
    const leagueData = data.response[0];

    if (leagueData.league.type === "League") {
      const standingsResponse = await axios.get(
        `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/standings`,
        {
          params: { league: leagueId, season: new Date().getFullYear() },
          headers: {
            "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
          },
        }
      );
      leagueData.league.standings =
        standingsResponse.data.response[0]?.league?.standings || [];
    } else {
      leagueData.league.standings = [];
    }
    return leagueData;
  } catch (error) {
    return null;
  }
}

export async function generateMetadata({
  params,
}: {
  params: Promise<{ slug: string[]; locale: string }>;
}): Promise<Metadata> {
  const { slug, locale } = await params;
  const t = await getI18n(locale);
  const leagueId = getLeagueIdFromSlug(slug[0]);

  if (!leagueId) {
    return { title: t("not_found_title") };
  }

  const leagueData = await getLeagueData(leagueId);

  if (!leagueData) {
    return { title: t("not_found_title") };
  }

  const { league, country } = leagueData;
  const pagePath = `/football/league/${slug.join("/")}`;
  const hreflangAlternates = await generateHreflangTags(pagePath, locale);

  return {
    title: t("league_page_title", {
      leagueName: league.name,
      countryName: country.name,
    }),
    description: t("league_page_description", {
      leagueName: league.name,
      countryName: country.name,
    }),
    alternates: hreflangAlternates,
  };
}

export default async function LeaguePage({
  params,
}: {
  params: Promise<{ slug: string[]; locale: string }>;
}) {
  const { slug } = await params;
  const leagueId = getLeagueIdFromSlug(slug[0]);

  if (!leagueId) {
    notFound();
  }

  const leagueData = await getLeagueData(leagueId);

  if (!leagueData) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        <Sidebar />
        <main className="min-w-0">
          <LeagueDetailView leagueData={leagueData} />
        </main>
        <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
          <RecentNewsWidget />
          <AdSlotWidget location="homepage_right_sidebar" />
        </aside>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/football/leagues/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import LeagueListClient from "@/components/LeagueListClient";
import { League } from "@/types/api-football";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";

const PAGE_PATH = "/football/leagues";

export const dynamic = "force-dynamic";

const fetchAllLeaguesServer = async (): Promise<League[]> => {
  const publicAppUrl = process.env.NEXT_PUBLIC_PUBLIC_APP_URL;
  if (!publicAppUrl) {
    console.error(
      "[Leagues Page Server] NEXT_PUBLIC_PUBLIC_APP_URL is not defined! Cannot fetch all leagues."
    );
    return [];
  }
  const apiUrl = `${publicAppUrl}/api/leagues?fetchAll=true`;
  try {
    const { data } = await axios.get(apiUrl, { timeout: 15000 });
    return data;
  } catch (error: any) {
    console.error(
      `[Leagues Page Server] Failed to fetch all leagues (${apiUrl}):`,
      error.message
    );
    return [];
  }
};

export async function generateMetadata({
  params: { locale },
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, locale);

  const pageTitle = t("leagues_page_meta_title");
  const pageDescription = t("leagues_page_meta_description");

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
    openGraph: {
      title: pageTitle,
      description: pageDescription,
      url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/${locale}${PAGE_PATH}`,
      siteName: "Fan Skor",
      type: "website",
    },
    twitter: {
      card: "summary_large_image",
      title: pageTitle,
      description: pageDescription,
    },
  };
}

export default async function LeaguesPage({
  params: { locale },
}: {
  params: { locale: string };
}) {
  const allLeagues = await fetchAllLeaguesServer();
  const t = await getI18n(locale);

  const leaguesPageSeoText = t("leagues_page_seo_text");

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        <Sidebar />
        <main className="min-w-0">
          <h1 className="text-4xl font-extrabold text-white mb-6">
            {t("leagues_and_cups_title")}
          </h1>
          <p className="italic text-[#a3a3a3] leading-relaxed mb-8">
            {leaguesPageSeoText}
          </p>
          {}
          <LeagueListClient initialAllLeagues={allLeagues} />
        </main>
        <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
          <RecentNewsWidget />
          <AdSlotWidget location="homepage_right_sidebar" />
        </aside>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/football/match/[...slug]/page.tsx =====

import { notFound } from "next/navigation";
import axios from "axios";
import type { Metadata } from "next";

import { MatchHeader } from "@/components/match/MatchHeader";
import MatchStatusBanner from "@/components/match/MatchStatusBanner";
import MatchH2HWidget from "@/components/match/MatchH2HWidget";
import MatchLineupsWidget from "@/components/match/MatchLineupsWidget";
import MatchStatsWidget from "@/components/match/MatchStatsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import MatchPredictionWidget from "@/components/match/MatchPredictionWidget";
import TeamFormWidget from "@/components/match/TeamFormWidget";
import LiveOddsWidget from "@/components/match/LiveOddsWidget";
import MatchActivityWidget from "@/components/match/MatchActivityWidget";
import TeamStandingsWidget from "@/components/match/TeamStandingsWidget";
import Header from "@/components/Header";
import MatchHighlightsWidget from "@/components/match/MatchHighlightsWidget";
import LinkedNewsWidget from "@/components/match/LinkedNewsWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";

const getFixtureIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug?.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

const fetchMatchDetailsServer = async (fixtureId: string) => {
  const publicAppUrl = process.env.NEXT_PUBLIC_PUBLIC_APP_URL;
  if (!publicAppUrl) {
    console.error(
      "[Match Page Server] NEXT_PUBLIC_PUBLIC_APP_URL is not defined! Cannot fetch data."
    );
    return null;
  }
  const apiUrl = `${publicAppUrl}/api/match-details?fixture=${fixtureId}`;
  try {
    const { data } = await axios.get(apiUrl, { timeout: 15000 });
    return data;
  } catch (error: any) {
    console.error(
      `[Match Page Server] Failed to fetch initial match details (${apiUrl}):`,
      error.message
    );
    return null;
  }
};

export async function generateMetadata({
  params,
}: {
  params: Promise<{ slug: string[]; locale: string }>;
}): Promise<Metadata> {
  const { slug, locale } = await params;
  const t = await getI18n(locale);
  const fixtureId = getFixtureIdFromSlug(slug[0]);

  if (!fixtureId) {
    return { title: t("not_found_title") };
  }

  const matchData = await fetchMatchDetailsServer(fixtureId);
  if (!matchData || !matchData.fixture) {
    return { title: t("not_found_title") };
  }

  const { home: homeTeam, away: awayTeam } = matchData.fixture.teams;
  const pagePath = `/football/match/${slug.join("/")}`;
  const hreflangAlternates = await generateHreflangTags(pagePath, locale);

  const pageTitle = t("match_page_title", {
    homeTeam: homeTeam.name,
    awayTeam: awayTeam.name,
    leagueName: matchData.fixture.league.name,
  });
  const pageDescription = t("match_page_description", {
    homeTeam: homeTeam.name,
    awayTeam: awayTeam.name,
    leagueName: matchData.fixture.league.name,
  });

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
    openGraph: {
      title: pageTitle,
      description: pageDescription,
      url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}${pagePath}`,
    },
    twitter: {
      card: "summary_large_image",
      title: pageTitle,
      description: pageDescription,
    },
  };
}

export default async function MatchDetailPage({
  params,
}: {
  params: Promise<{ slug: string[]; locale: string }>;
}) {
  const { slug, locale } = await params;
  const fixtureId = getFixtureIdFromSlug(slug[0]);

  if (!fixtureId) {
    notFound();
  }

  const data = await fetchMatchDetailsServer(fixtureId);
  if (!data || !data.fixture) {
    notFound();
  }

  const t = await getI18n(locale);

  const isLive = ["1H", "HT", "2H", "ET", "BT", "P", "LIVE"].includes(
    data.fixture.fixture.status?.short
  );
  const isFinished = ["FT", "AET", "PEN"].includes(
    data.fixture.fixture.status?.short
  );

  const { fixture, h2h, analytics, statistics } = data;
  const { home: homeTeam, away: awayTeam } = fixture.teams;

  const h2hSeoDescription = t("match_page_h2h_seo_text", {
    homeTeam: homeTeam.name,
    awayTeam: awayTeam.name,
  });
  const standingsSeoDescription = t("match_page_standings_seo_text", {
    homeTeam: homeTeam.name,
    awayTeam: awayTeam.name,
  });
  const activitySeoDescription = t("match_page_activity_seo_text", {
    homeTeam: homeTeam.name,
    awayTeam: awayTeam.name,
  });

  return (
    <div className="bg-brand-dark min-h-screen">
      <Header />
      <div className="container mx-auto p-4 md:p-6 lg:grid lg:grid-cols-3 lg:gap-8 lg:items-start">
        <main className="lg:col-span-2 space-y-6">
          <MatchHeader fixture={fixture} analytics={analytics} />
          <MatchStatusBanner fixture={fixture} />
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <TeamFormWidget
              teamStats={analytics.homeTeamStats}
              team={homeTeam}
              location="Home"
              h2hData={h2h}
            />
            <TeamFormWidget
              teamStats={analytics.awayTeamStats}
              team={awayTeam}
              location="Away"
              h2hData={h2h}
            />
          </div>
          <MatchLineupsWidget lineups={fixture.lineups} />
          <MatchH2HWidget
            h2h={h2h}
            teams={fixture.teams}
            currentFixtureId={fixtureId}
            h2hSeoDescription={h2hSeoDescription}
          />
          {(isLive || isFinished) && (
            <MatchStatsWidget statistics={statistics} teams={fixture.teams} />
          )}
          <MatchActivityWidget
            fixtureId={fixtureId}
            homeTeamId={homeTeam.id}
            isLive={isLive}
            activitySeoDescription={activitySeoDescription}
          />
        </main>
        <aside className="lg:col-span-1 space-y-6 lg:sticky lg:top-6 mt-8 lg:mt-0">
          {isLive && <LiveOddsWidget fixtureId={fixtureId} />}
          <LinkedNewsWidget fixtureId={fixture.fixture.id} />
          <MatchHighlightsWidget fixtureId={fixtureId} />
          <TeamStandingsWidget
            leagueId={fixture.league.id}
            season={fixture.league.season}
            homeTeamId={homeTeam.id}
            awayTeamId={awayTeam.id}
            standingsSeoDescription={standingsSeoDescription}
          />
          <MatchPredictionWidget
            apiPrediction={null}
            customPrediction={analytics.customPrediction}
            bookmakerOdds={analytics.bookmakerOdds}
            teams={fixture.teams}
          />
          <AdSlotWidget location="match_sidebar" />
        </aside>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/football/news/NewsPageClient.tsx =====

"use client";

import { useState, useMemo } from "react";
import { usePathname } from "next/navigation";
import { IPost } from "@/models/Post";
import { useTranslation } from "@/hooks/useTranslation";
import { Info } from "lucide-react";
import Pagination from "@/components/Pagination";
import NewsListItemCompact, {
  NewsListItemCompactSkeleton,
} from "@/components/NewsListItemCompact";

const ITEMS_PER_PAGE = 10;

interface NewsPageClientProps {
  initialNews: IPost[];
}

export default function NewsPageClient({ initialNews }: NewsPageClientProps) {
  const { t } = useTranslation();
  const pathname = usePathname();
  const [currentPage, setCurrentPage] = useState(1);

  const { paginatedData, totalPages } = useMemo(() => {
    const newsArray = Array.isArray(initialNews) ? initialNews : [];
    const total = Math.ceil(newsArray.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    return {
      paginatedData: newsArray.slice(startIndex, endIndex),
      totalPages: total,
    };
  }, [initialNews, currentPage]);

  if (!initialNews || initialNews.length === 0) {
    return (
      <div className="text-center py-20 bg-brand-secondary rounded-lg">
        <Info size={32} className="mx-auto text-brand-muted mb-3" />
        <p className="text-xl font-bold text-white">
          {t("no_news_found_title")}
        </p>
        <p className="text-brand-muted mt-2">
          {t("no_football_news_found_subtitle")}
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {paginatedData.map((post) => (
        <NewsListItemCompact key={post._id as string} post={post} />
      ))}

      {totalPages > 1 && (
        <div className="pt-4">
          <Pagination
            currentPage={currentPage}
            totalPages={totalPages}
            basePath={pathname}
          />
        </div>
      )}
    </div>
  );
}

// ===== src/app/[locale]/football/news/page.tsx =====

import type { Metadata } from "next";
import { IPost } from "@/models/Post";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { Newspaper } from "lucide-react";
import Script from "next/script";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import { Suspense } from "react";
import { getNews } from "@/lib/data/news";
import NewsPageClient from "./NewsPageClient";
import { NewsListItemCompactSkeleton } from "@/components/NewsListItemCompact";

const PAGE_PATH = "/football/news";
const ITEMS_PER_PAGE = 10;

export async function generateMetadata({
  params,
}: {
  params: Promise<{ locale: string }>;
}): Promise<Metadata> {
  const { locale } = await params;

  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, locale);
  const pageTitle = t("news_page_meta_title");
  const pageDescription = t("news_page_meta_description");

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
  };
}

const generateInitialJsonLd = (posts: IPost[], t: Function) => {
  const paginatedPosts = posts.slice(0, ITEMS_PER_PAGE);
  if (paginatedPosts.length === 0) return null;

  const itemListElement = paginatedPosts.map((post, index) => {
    const postUrl = `/${post.language}/news/${post.slug}`;
    return {
      "@type": "ListItem",
      position: index + 1,
      item: {
        "@type": "NewsArticle",
        mainEntityOfPage: { "@type": "WebPage", "@id": postUrl },
        headline: post.title,
        image:
          post.featuredImage ||
          `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/og-image.jpg`,
        datePublished: post.createdAt,
        dateModified: post.updatedAt,
        author: { "@type": "Organization", name: "Fan Skor" },
        publisher: {
          "@type": "Organization",
          name: "Fan Skor",
          logo: {
            "@type": "ImageObject",
            url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/fanskor-transparent.webp`,
          },
        },
        description: post.metaDescription,
      },
    };
  });

  return {
    "@context": "https://schema.org",
    "@type": "ItemList",
    name: t("latest_football_news"),
    description: t("latest_football_news_subtitle"),
    itemListElement,
  };
};

export default async function FootballNewsPage({
  params,
}: {
  params: { locale: string };
}) {
  const { locale } = params;
  const t = await getI18n(locale);

  const allNews = (await getNews({ locale, sportsCategory: "football" })) ?? [];

  const jsonLdData = generateInitialJsonLd(allNews, t);

  return (
    <>
      {jsonLdData && (
        <Script
          id="news-list-jsonld"
          type="application/ld+json"
          dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLdData) }}
        />
      )}
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
          <Sidebar />
          <main className="min-w-0 p-4 lg:p-0 lg:py-6">
            <div className="flex items-center gap-4 mb-8">
              <div className="p-3 bg-brand-purple/10 rounded-lg">
                <Newspaper className="w-8 h-8 text-brand-purple" />
              </div>
              <div>
                <h1 className="text-4xl font-extrabold text-white">
                  {t("latest_football_news")}
                </h1>
                <p className="text-brand-muted">
                  {t("latest_football_news_subtitle")}
                </p>
              </div>
            </div>

            <Suspense
              fallback={
                <div className="space-y-4">
                  <NewsListItemCompactSkeleton />
                  <NewsListItemCompactSkeleton />
                  <NewsListItemCompactSkeleton />
                  <NewsListItemCompactSkeleton />
                </div>
              }
            >
              <NewsPageClient initialNews={allNews} />
            </Suspense>
          </main>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/football/team/[...slug]/page.tsx =====

import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import TeamDetailView from "@/components/TeamDetailView";
import { notFound } from "next/navigation";
import type { Metadata } from "next";
import { fetchTeamDetails } from "@/lib/data/team";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";

const getTeamIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

export async function generateMetadata({
  params,
}: {
  params: Promise<{ slug: string[]; locale: string }>;
}): Promise<Metadata> {
  const { slug, locale } = await params;
  const t = await getI18n(locale);
  const teamId = getTeamIdFromSlug(slug[0]);

  if (!teamId) {
    return { title: t("not_found_title") };
  }

  const teamData = await fetchTeamDetails(teamId);
  if (!teamData) {
    return { title: t("not_found_title") };
  }

  const { team } = teamData.teamInfo;
  const pagePath = `/football/team/${slug.join("/")}`;
  const hreflangAlternates = await generateHreflangTags(pagePath, locale);

  const pageTitle = t("team_page_meta_title", { teamName: team.name });
  const pageDescription = t("team_page_meta_description", {
    teamName: team.name,
  });

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
  };
}

export default async function TeamPage({
  params,
}: {
  params: Promise<{ slug: string[]; locale: string }>;
}) {
  const { locale, slug } = await params;

  const teamId = getTeamIdFromSlug(slug[0]);
  if (!teamId) {
    notFound();
  }

  const teamData = await fetchTeamDetails(teamId);
  if (!teamData) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        <Sidebar />
        <main className="min-w-0">
          <TeamDetailView teamData={teamData} />
        </main>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/football/teams/[countryName]/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { getI18n } from "@/lib/i18n/server";
import TeamsByCountryClient from "@/components/TeamsByCountryClient";

const apiRequest = async (endpoint: string, params: object) => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };
  try {
    const response = await axios.request(options);
    return response.data.response;
  } catch (error) {

    return [];
  }
};

const fetchTeamsByCountry = async (countryName: string) => {
  const season = new Date().getFullYear();
  const leagues = await apiRequest("leagues", { country: countryName });
  if (!leagues || leagues.length === 0) {
    return [];
  }

  const leagueIds = leagues.map((l: any) => l.league.id);
  const teamPromises = leagueIds.map((id: any) =>
    apiRequest("teams", { league: id, season: season })
  );
  const responses = await Promise.allSettled(teamPromises);

  const allTeamsResponses = responses
    .filter((result) => result.status === "fulfilled" && result.value)
    .flatMap((result) => (result as PromiseFulfilledResult<any>).value);

  const uniqueTeams = Array.from(
    new Map(allTeamsResponses.map((item) => [item.team.id, item])).values()
  );

  uniqueTeams.sort((a, b) => a.team.name.localeCompare(b.team.name));
  return uniqueTeams;
};

export async function generateMetadata({
  params,
}: {
  params: { countryName: string };
}): Promise<Metadata> {
  const countryName = decodeURIComponent(params.countryName);
  const t = await getI18n();
  return {
    title: t("teams_in_country_page_title", { country: countryName }),
    description: t("teams_in_country_page_description", {
      country: countryName,
    }),
  };
}

export default async function TeamsByCountryPage({
  params,
}: {
  params: { countryName: string };
}) {
  const countryName = decodeURIComponent(params.countryName);
  const t = await getI18n();
  const allTeams = await fetchTeamsByCountry(countryName);

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <h1 className="text-4xl font-extrabold text-white mb-6">
            {t("teams_in_country_title", { country: countryName })}
          </h1>

          <TeamsByCountryClient initialTeams={allTeams} />
        </main>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/football/teams/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import TeamListClient from "@/components/TeamListClient";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import { Users } from "lucide-react";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";

const PAGE_PATH = "/football/teams";

const fetchPopularTeams = async () => {
  const publicAppUrl = process.env.NEXT_PUBLIC_PUBLIC_APP_URL;
  if (!publicAppUrl) {
    console.error(
      "[Teams Page Server] NEXT_PUBLIC_PUBLIC_APP_URL is not defined."
    );
    return [];
  }
  const apiUrl = `${publicAppUrl}/api/directory/teams`;
  try {
    const { data } = await axios.get(apiUrl, { timeout: 15000 });

    return data;
  } catch (error: any) {
    console.error(
      `[Teams Page Server] Failed to fetch popular teams (${apiUrl}):`,
      error.message
    );
    return [];
  }
};

export async function generateMetadata({
  params,
}: {
  params: Promise<{ locale: string }>;
}): Promise<Metadata> {
  const { locale } = await params;

  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, locale);

  const pageTitle = t("teams_page_meta_title");
  const pageDescription = t("teams_page_meta_description");

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
  };
}

export default async function TeamsPage({
  params,
}: {
  params: Promise<{ locale: string }>;
}) {
  const { locale } = await params;

  const initialTeams = await fetchPopularTeams();
  const t = await getI18n(locale);

  const seoDescription = t("teams_page_seo_text");

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        <Sidebar />

        <main className="min-w-0">
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl mb-8">
            <div className="flex items-center gap-4 mb-3">
              <div className="p-3 bg-[var(--brand-accent)]/10 rounded-lg">
                <Users className="w-8 h-8 text-[var(--brand-accent)]" />
              </div>
              <div>
                <h1 className="text-4xl font-extrabold text-white">
                  {t("football_teams_title")}
                </h1>
                <p className="text-text-muted">
                  {t("football_teams_subtitle")}
                </p>
              </div>
            </div>
            <p className="italic text-[#a3a3a3] leading-relaxed text-sm mt-4">
              {seoDescription}
            </p>
          </div>

          <TeamListClient initialTeams={initialTeams} />
        </main>

        <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
          <RecentNewsWidget />
          <AdSlotWidget location="homepage_right_sidebar" />
        </aside>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/gdpr/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import { notFound } from "next/navigation";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { DatabaseZap } from "lucide-react";
import AdSlotWidget from "@/components/AdSlotWidget";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";

const PAGE_SLUG = "gdpr";
const PAGE_PATH = "/gdpr";

async function getPageContent() {
  try {
    const response = await axios.get(
      `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/api/pages/${PAGE_SLUG}`
    );
    return response.data;
  } catch (error) {
    return null;
  }
}

export async function generateMetadata({
  params,
}: {
  params: Promise<{ locale: string }>;
}): Promise<Metadata> {
  const { locale } = await params;

  const t = await getI18n(locale);
  const pageContent = await getPageContent();
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, locale);

  const title = t("gdpr_default_page_title");

  const description = t("gdpr_default_page_description");

  return {
    title: title,
    description: description,
    alternates: hreflangAlternates,
  };
}

export default async function GdprPage({
  params: { locale },
}: {
  params: { locale: string };
}) {
  const pageContent = await getPageContent();

  if (!pageContent || !pageContent.content) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        <Sidebar />

        <main className="min-w-0">
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
            <div className="flex items-center gap-4 mb-4">
              <div className="p-3 bg-indigo-500/10 rounded-lg">
                <DatabaseZap className="w-8 h-8 text-indigo-400" />
              </div>
              <h1 className="text-4xl font-extrabold text-white">
                {pageContent.title}
              </h1>
            </div>

            <div
              className="prose prose-invert lg:prose-xl max-w-none text-text-secondary"
              dangerouslySetInnerHTML={{ __html: pageContent.content }}
            />
          </div>
        </main>

        <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
          <RecentNewsWidget />
          <AdSlotWidget location="homepage_right_sidebar" />
        </aside>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/layout.tsx =====

import type { Metadata } from "next";
import "../globals.css";
import Providers from "../providers";
import { LeagueProvider } from "@/context/LeagueContext";
import "slick-carousel/slick/slick.css";
import "slick-carousel/slick/slick-theme.css";
import NextAuthProvider from "../NextAuthProvider";
import { Suspense } from "react";
import StickyFooterAd from "@/components/StickyFooterAd";
import Loading from "./loading";
import Footer from "@/components/Footer";
import Ticker from "@/components/Ticker";
import Header from "@/components/Header";

import { GoogleAnalytics } from "@next/third-parties/google";
import { getI18n } from "@/lib/i18n/server";
import { I18nProviderClient } from "@/lib/i18n/client";
import { TimeZoneProvider } from "@/context/TimeZoneContext";
import { i18nCache } from "@/lib/i18n/i18n.cache";
import { generateHreflangTags } from "@/lib/hreflang";

const METADATA_BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

export async function generateMetadata({
  params,
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const { locale } = await params;
  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags("/", locale);
  const title = t("homepage_meta_title");
  const description = t("homepage_meta_description");

  return {
    metadataBase: new URL(METADATA_BASE_URL),
    alternates: hreflangAlternates,
    title: title,
    description: description,
    icons: {
      icon: [{ url: "/favicon.ico", type: "image/png" }],
      apple: [{ url: "/favicon.ico" }],
    },
    robots: {
      index: true,
      follow: true,
      googleBot: {
        index: true,
        follow: true,
      },
    },
    openGraph: {
      title: title,
      description: description,
      url: `${METADATA_BASE_URL}/${locale === "tr" ? "" : locale}`,
      siteName: "Fan Skor",
      images: [
        {
          url: `${METADATA_BASE_URL}/og-image.jpg`,
          width: 1200,
          height: 630,
          alt: t("og_image_alt_text"),
        },
      ],
      locale: locale,
      type: "website",
    },
    twitter: {
      card: "summary_large_image",
      title: title,
      description: description,
      creator: "@fanskor_official",
      images: [`${METADATA_BASE_URL}/twitter-image.jpg`],
    },
  };
}

export default async function LocaleLayout({
  children,
  params,
}: {
  children: React.ReactNode;
  params: { locale: string };
}) {
  const { locale } = await params;
  const translations = (await i18nCache.getTranslations(locale)) || {};

  return (
    <>
      <Suspense fallback={<Loading />}>
        <NextAuthProvider>
          <Providers>
            <I18nProviderClient locale={locale} translations={translations}>
              <TimeZoneProvider>
                <LeagueProvider>
                  <main>{children}</main>
                  <StickyFooterAd />
                  <Footer />
                </LeagueProvider>
              </TimeZoneProvider>
            </I18nProviderClient>
          </Providers>
        </NextAuthProvider>
      </Suspense>
      {process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID && (
        <GoogleAnalytics gaId={process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID} />
      )}
    </>
  );
}

// ===== src/app/[locale]/loading.tsx =====

import LottiePreloader from "@/components/LottiePreloader";

export default function Loading() {
  return (
    <div className="fixed inset-0 z-[100] flex items-center justify-center bg-[#1F1D2B]">
      {}
      <LottiePreloader />
    </div>
  );
}

// ===== src/app/[locale]/news/GeneralNewsClient.tsx =====

"use client";

import { useState, useMemo } from "react";
import { usePathname } from "next/navigation";
import { IPost } from "@/models/Post";
import { useTranslation } from "@/hooks/useTranslation";
import { Info } from "lucide-react";
import Pagination from "@/components/Pagination";
import NewsCard, { NewsCardSkeleton } from "@/components/NewsCard";

const ITEMS_PER_PAGE = 12;

interface GeneralNewsClientProps {
  initialNews: IPost[];
}

export default function GeneralNewsClient({
  initialNews,
}: GeneralNewsClientProps) {
  const { t } = useTranslation();
  const pathname = usePathname();
  const [currentPage, setCurrentPage] = useState(1);

  const { paginatedData, totalPages } = useMemo(() => {
    const newsArray = Array.isArray(initialNews) ? initialNews : [];
    const total = Math.ceil(newsArray.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    return {
      paginatedData: newsArray.slice(startIndex, endIndex),
      totalPages: total,
    };
  }, [initialNews, currentPage]);

  if (!initialNews || initialNews.length === 0) {
    return (
      <div className="text-center py-20 bg-brand-secondary rounded-lg">
        <Info size={32} className="mx-auto text-brand-muted mb-3" />
        <p className="text-xl font-bold text-white">
          {t("no_news_found_title")}
        </p>
        <p className="text-brand-muted mt-2">{t("no_news_found_subtitle")}</p>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      {}
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
        {paginatedData.map((post) => (
          <NewsCard key={post._id as string} post={post} />
        ))}
      </div>

      {}
      {totalPages > 1 && (
        <div className="pt-8">
          <Pagination
            currentPage={currentPage}
            totalPages={totalPages}
            basePath={pathname}
          />
        </div>
      )}
    </div>
  );
}

// ===== src/app/[locale]/news/[slug]/page.tsx =====

import { notFound, redirect } from "next/navigation";
import dbConnect from "@/lib/dbConnect";
import Post, { IPost } from "@/models/Post";
import { format } from "date-fns";
import Header from "@/components/Header";
import Image from "next/image";
import SocialShareButtons from "@/components/SocialShareButtons";
import NewsSidebar from "@/components/NewsSidebar";
import type { Metadata } from "next";
import { getI18n } from "@/lib/i18n/server";
import { proxyImageUrl } from "@/lib/image-proxy";
import Script from "next/script";
import { generateHreflangTags } from "@/lib/hreflang";
import { generateTableOfContents } from "@/lib/toc";
import TableOfContents from "@/components/TableOfContents";
import { WithContext, NewsArticle, BreadcrumbList } from "schema-dts";

const DEFAULT_LOCALE = "tr";
const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

async function getPostAndTranslations(
  slug: string,
  locale: string
): Promise<{ postToRender: IPost; allTranslations: IPost[] } | null> {
  await dbConnect();

  let initialPost = await Post.findOne({
    slug,
    language: locale,
    status: "published",
  }).lean();

  if (!initialPost) {
    initialPost = await Post.findOne({ slug, status: "published" }).lean();
  }

  if (!initialPost) {
    return null;
  }

  const translationGroupId = initialPost.translationGroupId;

  const allTranslations = await Post.find({
    translationGroupId,
    status: "published",
  }).lean();

  if (allTranslations.length === 0) {
    return null;
  }

  let postToRender = allTranslations.find((p) => p.language === locale);
  if (!postToRender) {
    postToRender = allTranslations.find((p) => p.language === DEFAULT_LOCALE);
  }
  if (!postToRender) {
    postToRender = allTranslations[0];
  }

  return {
    postToRender: JSON.parse(JSON.stringify(postToRender)),
    allTranslations: JSON.parse(JSON.stringify(allTranslations)),
  };
}

export async function generateMetadata({
  params,
}: {
  params: { slug: string; locale: string };
}): Promise<Metadata> {
  const { slug, locale } = params;
  const data = await getPostAndTranslations(slug, locale);

  if (!data) {
    return { title: "Not Found" };
  }

  const { postToRender, allTranslations } = data;

  const pagePath = `/news/${postToRender.slug}`;
  const availableLocales = allTranslations.map((p) => p.language);
  const hreflangAlternates = generateHreflangTags(
    pagePath,
    locale,
    availableLocales
  );

  const description =
    postToRender.metaDescription ||
    postToRender.content.replace(/<[^>]*>?/gm, "").substring(0, 160);

  const imageUrl = postToRender.featuredImage
    ? proxyImageUrl(postToRender.featuredImage)
    : `${BASE_URL}/og-image.jpg`;

  return {
    title: postToRender.metaTitle || `${postToRender.title} | Fan Skor`,
    description: description,
    alternates: hreflangAlternates,
    openGraph: {
      title: postToRender.metaTitle || postToRender.title,
      description: description,
      url: `${BASE_URL}/${locale}${pagePath}`,
      type: "article",
      publishedTime: new Date(postToRender.createdAt).toISOString(),
      modifiedTime: new Date(postToRender.updatedAt).toISOString(),
      authors: [postToRender.author || "Fan Skor"],
      images: [
        {
          url: imageUrl,
          width: 1200,
          height: 630,
          alt: postToRender.title,
        },
      ],
    },
  };
}

export default async function GeneralNewsArticlePage({
  params,
}: {
  params: { slug: string; locale: string };
}) {
  const { slug, locale } = params;
  const data = await getPostAndTranslations(slug, locale);

  if (!data) {
    notFound();
  }

  const { postToRender } = data;

  if (postToRender.language !== locale) {
    const correctPath = `/${postToRender.language}/news/${postToRender.slug}`;
    redirect(correctPath);
  }

  const post = postToRender;
  const t = await getI18n(locale);

  const { processedHtml, toc } = generateTableOfContents(post.content);

  const pagePath = `/news/${post.slug}`;
  const postUrl = `${BASE_URL}/${locale}${pagePath}`;
  const description =
    post.metaDescription ||
    post.content.replace(/<[^>]*>?/gm, "").substring(0, 160);
  const imageUrl = post.featuredImage || `${BASE_URL}/og-image.jpg`;

  const jsonLd: WithContext<NewsArticle | BreadcrumbList>[] = [
    {
      "@context": "https://schema.org",
      "@type": "NewsArticle",
      mainEntityOfPage: {
        "@type": "WebPage",
        "@id": postUrl,
      },
      headline: post.title,
      image: [imageUrl],
      datePublished: new Date(post.createdAt).toISOString(),
      dateModified: new Date(post.updatedAt).toISOString(),
      author: {
        "@type": "Organization",
        name: "Fan Skor",
        url: BASE_URL,
      },
      publisher: {
        "@type": "Organization",
        name: "Fan Skor",
        logo: {
          "@type": "ImageObject",
          url: `${BASE_URL}/fanskor-transparent.webp`,
        },
      },
      description: description,
    },
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: t("homepage"),
          item: `${BASE_URL}/${locale}`,
        },
        {
          "@type": "ListItem",
          position: 2,
          name: t("news"),
          item: `${BASE_URL}/${locale}/news`,
        },
        {
          "@type": "ListItem",
          position: 3,
          name: post.title,
        },
      ],
    },
  ];

  return (
    <>
      <Script
        id="news-article-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <div className="bg-brand-dark min-h-screen">
        <Header />
        <main className="container mx-auto p-4 md:p-8 grid grid-cols-1 lg:grid-cols-3 gap-8 lg:gap-12 items-start">
          <div className="lg:col-span-2">
            <article className="bg-brand-secondary rounded-lg overflow-hidden">
              {post.featuredImage && (
                <div className="relative w-full aspect-video md:h-[500px]">
                  <Image
                    src={post.featuredImage}
                    alt={post.featuredImageAltText || post.title}
                    title={post.featuredImageTitle || post.title}
                    layout="fill"
                    objectFit="cover"
                    priority
                  />
                </div>
              )}

              <div className="p-4 sm:p-6 md:p-8">
                <h1 className="text-3xl md:text-5xl font-extrabold text-white leading-tight mb-4">
                  {post.title}
                </h1>
                <p className="text-brand-muted mb-6 pb-6 border-b border-gray-700/50">
                  {t("published_by_on", {
                    author: post.author,
                    date: format(new Date(post.createdAt), "MMMM dd, yyyy"),
                  })}
                </p>

                {toc.length > 0 && <TableOfContents toc={toc} />}

                <div
                  className="prose prose-invert prose-lg lg:prose-xl max-w-none mt-8"
                  dangerouslySetInnerHTML={{ __html: processedHtml }}
                />

                <div className="mt-12 pt-8 border-t border-gray-700/50">
                  <h3 className="text-lg font-bold text-center text-brand-muted mb-4">
                    {t("share_this_article")}
                  </h3>
                  <SocialShareButtons url={postUrl} title={post.title} />
                </div>
              </div>
            </article>
          </div>

          <div className="lg:col-span-1">
            <NewsSidebar />
          </div>
        </main>
      </div>
    </>
  );
}

export async function generateStaticParams() {
  await dbConnect();
  const posts = await Post.find({ status: "published" })
    .select("slug language")
    .lean();

  return posts.map((post) => ({
    slug: post.slug,
    locale: post.language,
  }));
}

// ===== src/app/[locale]/news/page.tsx =====

import type { Metadata } from "next";
import { IPost } from "@/models/Post";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { Newspaper } from "lucide-react";
import Script from "next/script";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import { Suspense } from "react";
import { getNews } from "@/lib/data/news";
import GeneralNewsClient from "./GeneralNewsClient";
import { NewsCardSkeleton } from "@/components/NewsCard";

const PAGE_PATH = "/news";
const ITEMS_PER_PAGE = 12;

export async function generateMetadata({
  params: { locale },
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, locale);
  const pageTitle = t("general_news_meta_title");
  const pageDescription = t("general_news_meta_description");

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
  };
}

const generateInitialJsonLd = (posts: IPost[], t: Function) => {
  const paginatedPosts = posts.slice(0, ITEMS_PER_PAGE);
  if (paginatedPosts.length === 0) return null;

  const itemListElement = paginatedPosts.map((post, index) => {
    const postUrl = `/${post.language}/news/${post.slug}`;
    return {
      "@type": "ListItem",
      position: index + 1,
      item: {
        "@type": "NewsArticle",
        mainEntityOfPage: { "@type": "WebPage", "@id": postUrl },
        headline: post.title,
        image:
          post.featuredImage ||
          `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/og-image.jpg`,
        datePublished: post.createdAt,
        dateModified: post.updatedAt,
        author: { "@type": "Organization", name: "Fan Skor" },
        publisher: {
          "@type": "Organization",
          name: "Fan Skor",
          logo: {
            "@type": "ImageObject",
            url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/fanskor-transparent.webp`,
          },
        },
        description: post.metaDescription,
      },
    };
  });

  return {
    "@context": "https://schema.org",
    "@type": "ItemList",
    name: t("latest_news"),
    description: t("latest_news_subtitle"),
    itemListElement,
  };
};

export default async function GeneralNewsPage({
  params,
}: {
  params: { locale: string };
}) {
  const { locale } = params;
  const t = await getI18n(locale);

  const allNews = (await getNews({ locale, sportsCategory: "general" })) ?? [];

  const jsonLdData = generateInitialJsonLd(allNews, t);

  return (
    <>
      {jsonLdData && (
        <Script
          id="news-list-jsonld"
          type="application/ld+json"
          dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLdData) }}
        />
      )}
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
          <Sidebar />
          <main className="min-w-0 p-4 lg:p-0 lg:py-6">
            <div className="flex items-center gap-4 mb-8">
              <div className="p-3 bg-brand-purple/10 rounded-lg">
                <Newspaper className="w-8 h-8 text-brand-purple" />
              </div>
              <div>
                <h1 className="text-4xl font-extrabold text-white">
                  {t("latest_news")}
                </h1>
                <p className="text-brand-muted">{t("latest_news_subtitle")}</p>
              </div>
            </div>

            <Suspense
              fallback={
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                  <NewsCardSkeleton />
                  <NewsCardSkeleton />
                  <NewsCardSkeleton />
                  <NewsCardSkeleton />
                  <NewsCardSkeleton />
                  <NewsCardSkeleton />
                </div>
              }
            >
              <GeneralNewsClient initialNews={allNews} />
            </Suspense>
          </main>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/not-found.tsx =====

"use client";

import { Suspense } from 'react';
import Link from 'next/link';
import Header from '@/components/Header';
import { HeaderSkeleton } from '@/components/LayoutSkeletons';
import { Frown } from 'lucide-react';

export default function NotFound() {
  return (
    <div className="min-h-screen flex flex-col">
      <Suspense fallback={<HeaderSkeleton />}>
        <Header />
      </Suspense>

      <main className="flex-1 flex flex-col items-center justify-center text-center p-4">
        <Frown className="w-16 h-16 text-text-muted mb-4" />
        <h1 className="text-4xl font-extrabold text-white">404 - Page Not Found</h1>
        <p className="text-lg text-text-secondary mt-2 mb-6">
          The page you are looking for does not exist or has been moved.
        </p>
        <Link
            href="/"
            className="px-6 py-3 bg-brand-purple text-white font-bold rounded-lg hover:opacity-90 transition-opacity"
        >
          Go back to Homepage
        </Link>
      </main>
    </div>
  )
}

// ===== src/app/[locale]/page.tsx =====

import { Suspense } from "react";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { MainContent } from "@/components/MainContent";
import { SidebarSkeleton } from "@/components/LayoutSkeletons";
import { getI18n } from "@/lib/i18n/server";

interface HomePageProps {
  params: Promise<{
    locale: string;
  }>;

  homepageAboutSeoText?: string;
  sidebarAboutSeoText?: string;
}

export default async function HomePage({
  params,
  homepageAboutSeoText: initialHomepageText,
  sidebarAboutSeoText: initialSidebarText,
}: HomePageProps) {
  const { locale } = await params;

  const t = await getI18n(locale);
  const homepageAboutSeoText =
    initialHomepageText || t("homepage_about_seo_text");
  const sidebarAboutSeoText = initialSidebarText || t("sidebar_about_seo_text");

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:items-start lg:py-8">
        <Suspense fallback={<SidebarSkeleton />}>
          <Sidebar />
        </Suspense>

        <main className="min-w-0">
          <MainContent
            sidebarAboutSeoText={sidebarAboutSeoText}
            homepageAboutSeoText={homepageAboutSeoText}
          />
        </main>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/privacy-policy/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import { notFound } from "next/navigation";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { Shield } from "lucide-react";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";

const PAGE_SLUG = "privacy-policy";
const PAGE_PATH = "/privacy-policy";

async function getPageContent() {
  try {
    const response = await axios.get(
      `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/api/pages/${PAGE_SLUG}`
    );
    return response.data;
  } catch (error) {
    return null;
  }
}

export async function generateMetadata({
  params,
}: {
  params: Promise<{ locale: string }>;
}): Promise<Metadata> {
  const { locale } = await params;

  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, locale);

  const title = t("privacy_policy_default_page_title");
  const description = t("privacy_policy_default_page_description");

  return {
    title: title,
    description: description,
    alternates: hreflangAlternates,
  };
}

export default async function PrivacyPolicyPage({
  params,
}: {
  params: Promise<{ locale: string }>;
}) {
  const pageContent = await getPageContent();

  if (!pageContent || !pageContent.content) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        <Sidebar />

        <main className="min-w-0">
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
            <div className="flex items-center gap-4 mb-4">
              <div className="p-3 bg-blue-500/10 rounded-lg">
                <Shield className="w-8 h-8 text-blue-400" />
              </div>
              <h1 className="text-4xl font-extrabold text-white">
                {pageContent.title}
              </h1>
            </div>

            <div
              className="prose prose-invert lg:prose-xl max-w-none text-text-secondary"
              dangerouslySetInnerHTML={{ __html: pageContent.content }}
            />
          </div>
        </main>

        <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
          <RecentNewsWidget />
          <AdSlotWidget location="homepage_right_sidebar" />
        </aside>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/report-abuse/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import { notFound } from "next/navigation";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { AlertTriangle } from "lucide-react";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";

const PAGE_SLUG = "report-abuse";
const PAGE_PATH = "/report-abuse";

async function getPageContent() {
  try {
    const response = await axios.get(
      `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/api/pages/${PAGE_SLUG}`
    );
    return response.data;
  } catch (error) {
    return null;
  }
}

export async function generateMetadata({
  params,
}: {
  params: Promise<{ locale: string }>;
}): Promise<Metadata> {
  const { locale } = await params;

  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, locale);

  const title = t("report_abuse_default_page_title");

  const description = t("report_abuse_default_page_description");

  return {
    title: title,
    description: description,
    alternates: hreflangAlternates,
  };
}

export default async function ReportAbusePage({
  params,
}: {
  params: Promise<{ locale: string }>;
}) {
  const pageContent = await getPageContent();

  if (!pageContent || !pageContent.content) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        <Sidebar />

        <main className="min-w-0">
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
            <div className="flex items-center gap-4 mb-4">
              <div className="p-3 bg-red-500/10 rounded-lg">
                <AlertTriangle className="w-8 h-8 text-red-400" />
              </div>
              <h1 className="text-4xl font-extrabold text-white">
                {pageContent.title}
              </h1>
            </div>

            <div
              className="prose prose-invert lg:prose-xl max-w-none text-text-secondary"
              dangerouslySetInnerHTML={{ __html: pageContent.content }}
            />
          </div>
        </main>

        <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
          <RecentNewsWidget />
          <AdSlotWidget location="homepage_right_sidebar" />
        </aside>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/terms-and-conditions/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import { notFound } from "next/navigation";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { FileText } from "lucide-react";
import CasinoPartnerWidget from "@/components/CasinoPartnerWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";

const PAGE_SLUG = "terms-and-conditions";
const PAGE_PATH = "/terms-and-conditions";

async function getPageContent() {
  try {
    const response = await axios.get(
      `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/api/pages/${PAGE_SLUG}`
    );
    return response.data;
  } catch (error) {
    return null;
  }
}

export async function generateMetadata({
  params,
}: {
  params: Promise<{ locale: string }>;
}): Promise<Metadata> {
  const { locale } = await params;

  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, locale);

  const title = t("terms_and_conditions_default_title");
  const description = t("terms_and_conditions_default_desc");

  return {
    title,
    description,
    alternates: hreflangAlternates,
  };
}

export default async function TermsAndConditionsPage({
  params,
}: {
  params: Promise<{ locale: string }>;
}) {
  const pageContent = await getPageContent();

  if (!pageContent || !pageContent.content) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        <Sidebar />

        <main className="min-w-0">
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
            <div className="flex items-center gap-4 mb-4">
              <div className="p-3 bg-gray-500/10 rounded-lg">
                <FileText className="w-8 h-8 text-gray-400" />
              </div>
              <h1 className="text-4xl font-extrabold text-white">
                {pageContent.title}
              </h1>
            </div>

            <div
              className="prose prose-invert lg:prose-xl max-w-none text-text-secondary"
              dangerouslySetInnerHTML={{ __html: pageContent.content }}
            />
          </div>
        </main>

        <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
          <RecentNewsWidget />
          <AdSlotWidget location="homepage_right_sidebar" />
        </aside>
      </div>
    </div>
  );
}

// ===== src/app/actions/language.ts =====

"use server";

import { cookies } from "next/headers";

const I18N_COOKIE_NAME = "NEXT_LOCALE";

export async function setLocaleCookie(locale: string) {
  cookies().set(I18N_COOKIE_NAME, locale, {
    path: "/",
    maxAge: 60 * 60 * 24 * 365,
    sameSite: "lax",
    secure: process.env.NODE_ENV === "production",
  });
}

// ===== src/app/admin/ai-journalists/page.tsx =====

"use client";

import { useEffect, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  PlusCircle,
  Edit,
  Trash2,
  User,
  CheckCircle,
  XCircle,
  Loader2,
} from "lucide-react";

interface IAIJournalist {
  _id: string;
  name: string;
  description?: string;
  tonePrompt: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

interface AIJournalistFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  journalist?: IAIJournalist | null;
}

const AIJournalistFormModal: React.FC<AIJournalistFormModalProps> = ({
  isOpen,
  onClose,
  journalist,
}) => {
  const queryClient = useQueryClient();
  const [name, setName] = useState(journalist?.name || "");
  const [description, setDescription] = useState(journalist?.description || "");

  const [tonePrompt, setTonePrompt] = useState(
    journalist?.tonePrompt ||
      "Daima Trke bir ton kullann, esprili yorumlarla ve derinlemesine analitik ve teknik yorumlarla makaleleri ekillendirin."
  );
  const [isActive, setIsActive] = useState(journalist?.isActive ?? true);

  useEffect(() => {

    if (journalist) {
      setName(journalist.name);
      setDescription(journalist.description || "");
      setTonePrompt(journalist.tonePrompt);
      setIsActive(journalist.isActive);
    } else {

      setName("");
      setDescription("");
      setTonePrompt(
        "Daima Trke bir ton kullann, esprili yorumlarla ve derinlemesine analitik ve teknik yorumlarla makaleleri ekillendirin."
      );
      setIsActive(true);
    }
  }, [journalist]);

  const createMutation = useMutation({
    mutationFn: (newJournalist: Partial<IAIJournalist>) =>
      axios.post("/api/admin/ai-journalists", newJournalist),
    onSuccess: () => {
      toast.success("AI Journalist created successfully!");
      queryClient.invalidateQueries({ queryKey: ["aiJournalists"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to create journalist.");
    },
  });

  const updateMutation = useMutation({
    mutationFn: (updatedJournalist: Partial<IAIJournalist>) =>
      axios.put(
        `/api/admin/ai-journalists/${journalist?._id}`,
        updatedJournalist
      ),
    onSuccess: () => {
      toast.success("AI Journalist updated successfully!");
      queryClient.invalidateQueries({ queryKey: ["aiJournalists"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to update journalist.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !tonePrompt.trim()) {
      toast.error("Name and Tone Prompt are required.");
      return;
    }

    const payload = { name, description, tonePrompt, isActive };

    if (journalist) {
      updateMutation.mutate(payload);
    } else {
      createMutation.mutate(payload);
    }
  };

  const isPending = createMutation.isPending || updateMutation.isPending;

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl overflow-hidden">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {journalist ? "Edit AI Journalist" : "Create New AI Journalist"}
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label
              htmlFor="name"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Journalist Name
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
          </div>
          <div>
            <label
              htmlFor="description"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Description (Optional)
            </label>
            <input
              id="description"
              type="text"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              disabled={isPending}
            />
          </div>
          <div>
            <label
              htmlFor="tonePrompt"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Tone Prompt Segment (Turkish Language)
            </label>
            <textarea
              id="tonePrompt"
              value={tonePrompt}
              onChange={(e) => setTonePrompt(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
              rows={6}
              required
              disabled={isPending}
              placeholder="e.g., 'Daima Trke bir ton kullann, esprili yorumlarla ve derinlemesine analitik ve teknik yorumlarla makaleleri ekillendirin.'"
            />
            <p className="text-xs text-brand-muted mt-1">
              Bu istem segmenti, gazetecinin stilini tanmlamak iin ana makale
              oluturma istemine eklenecektir. Makalelerin daima Trke
              oluturulduundan emin olun.
            </p>
          </div>
          <div className="flex items-center">
            <input
              id="isActive"
              type="checkbox"
              checked={isActive}
              onChange={(e) => setIsActive(e.target.checked)}
              className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
              disabled={isPending}
            />
            <label
              htmlFor="isActive"
              className="ml-2 text-sm font-medium text-brand-light"
            >
              Active (Can be used for generation)
            </label>
          </div>
          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
              disabled={isPending}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={isPending}
            >
              {isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {isPending
                ? journalist
                  ? "Updating..."
                  : "Creating..."
                : journalist
                ? "Save Changes"
                : "Create Journalist"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default function AdminAIJournalistsPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingJournalist, setEditingJournalist] =
    useState<IAIJournalist | null>(null);

  const {
    data: journalists,
    isLoading,
    error,
  } = useQuery<IAIJournalist[]>({
    queryKey: ["aiJournalists"],
    queryFn: async () => {
      const { data } = await axios.get("/api/admin/ai-journalists");
      return data;
    },
    staleTime: 1000 * 60 * 5,
  });

  const deleteMutation = useMutation({
    mutationFn: (journalistId: string) =>
      axios.delete(`/api/admin/ai-journalists/${journalistId}`),
    onSuccess: () => {
      toast.success("AI Journalist deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["aiJournalists"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete journalist.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingJournalist(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (journalist: IAIJournalist) => {
    setEditingJournalist(journalist);
    setIsModalOpen(true);
  };

  const handleDelete = (journalistId: string, journalistName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete AI Journalist "${journalistName}"? This action cannot be undone.`
      )
    ) {
      deleteMutation.mutate(journalistId);
    }
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading AI Journalists...</p>;
  if (error)
    return <p className="text-red-400">Failed to load AI Journalists.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <User size={28} /> Manage AI Journalists
        </h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Journalist</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Name</th>
              <th className="p-4">Description</th>
              <th className="p-4">Tone Prompt Preview</th>
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {journalists?.map((journalist) => (
              <tr key={journalist._id} className="border-t border-gray-700/50">
                <td className="p-4 font-medium">{journalist.name}</td>
                <td
                  className="p-4 text-brand-muted text-sm max-w-[200px] truncate"
                  title={journalist.description}
                >
                  {journalist.description || "N/A"}
                </td>
                <td
                  className="p-4 text-brand-muted text-sm max-w-[300px] truncate"
                  title={journalist.tonePrompt}
                >
                  {journalist.tonePrompt}
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      journalist.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {journalist.isActive ? "Active" : "Inactive"}
                  </span>
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <button
                    onClick={() => handleOpenEditModal(journalist)}
                    className="text-blue-400 hover:text-blue-300"
                    title="Edit Journalist"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() =>
                      handleDelete(journalist._id, journalist.name)
                    }
                    className="text-red-400 hover:text-red-300"
                    title="Delete Journalist"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {journalists?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No AI Journalists found. Click "New Journalist" to create one.
          </p>
        )}
      </div>

      <AIJournalistFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        journalist={editingJournalist}
      />
    </div>
  );
}

// ===== src/app/admin/auto-news/PredictionGenerationTab.tsx =====

"use client";

import { useEffect, useState, useMemo } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  Calendar,
  Sparkles,
  RefreshCw,
  Loader2,
  User,
  Info,
  CheckCircle,
  ExternalLink,
  Eye,
} from "lucide-react";
import { format, parseISO } from "date-fns";
import Pagination from "@/components/Pagination";

interface IAIJournalist {
  _id: string;
  name: string;
  description?: string;
  tonePrompt: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

interface UpcomingFixture {
  fixture: {
    id: number;
    date: string;
    timezone: string;
    status: {
      long: string;
      short: string;
      elapsed: number | null;
    };
  };
  league: {
    id: number;
    name: string;
    logo: string;
  };
  teams: {
    home: { id: number; name: string; logo: string };
    away: { id: number; name: string; logo: string };
  };

  processedPostId?: string;
}

interface UpcomingFixturesResponse {
  fixtures: UpcomingFixture[];
  totalCount: number;
  currentPage: number;
  perPage: number;
}

const fetchAIJournalists = async (): Promise<IAIJournalist[]> => {
  const { data } = await axios.get("/api/admin/ai-journalists");
  return data;
};

const fetchUpcomingFixturesForPrediction = async (
  page: number,
  limit: number
): Promise<UpcomingFixturesResponse> => {
  const { data } = await axios.get(
    `/api/admin/upcoming-fixtures-for-prediction?limit=${limit}&skip=${
      (page - 1) * limit
    }`
  );
  return data;
};

const ITEMS_PER_PAGE = 10;

export default function PredictionGenerationTab() {
  const queryClient = useQueryClient();
  const [currentPage, setCurrentPage] = useState(1);
  const [selectedJournalistId, setSelectedJournalistId] = useState<
    string | null
  >(null);

  const [processingFixtureId, setProcessingFixtureId] = useState<number | null>(
    null
  );

  const {
    data: journalists,
    isLoading: isLoadingJournalists,
    error: journalistsError,
  } = useQuery<IAIJournalist[]>({
    queryKey: ["aiJournalists"],
    queryFn: fetchAIJournalists,
    staleTime: 1000 * 60 * 5,
  });

  const {
    data: fixturesData,
    isLoading: isLoadingFixtures,
    error: fixturesError,
    refetch: refetchFixtures,
  } = useQuery<UpcomingFixturesResponse>({
    queryKey: ["upcomingFixturesForPrediction", currentPage, ITEMS_PER_PAGE],
    queryFn: () =>
      fetchUpcomingFixturesForPrediction(currentPage, ITEMS_PER_PAGE),
    staleTime: 1000 * 60,
    placeholderData: (previousData) => previousData,
  });

  useEffect(() => {
    if (journalists && selectedJournalistId === null) {
      const firstActive = journalists.find((j) => j.isActive);
      if (firstActive) {
        setSelectedJournalistId(firstActive._id);
      }
    }
  }, [journalists, selectedJournalistId]);

  const generatePredictionNewsMutation = useMutation({
    mutationFn: (payload: {
      fixtureId: number;
      journalistId: string;
      sportCategory: string;
    }) => axios.post("/api/admin/generate-prediction-news", payload),
    onSuccess: (data) => {
      toast.success(data.data.message || "Prediction news generated!");
      queryClient.invalidateQueries({
        queryKey: ["upcomingFixturesForPrediction"],
      });
      queryClient.invalidateQueries({ queryKey: ["adminPosts"] });
    },
    onError: (err: any) => {
      toast.error(
        err.response?.data?.error || "Failed to generate prediction news."
      );
    },
    onSettled: (data, error, variables) => {

      queryClient.setQueryData(
        ["upcomingFixturesForPrediction", currentPage, ITEMS_PER_PAGE],
        (oldData: UpcomingFixturesResponse | undefined) => {
          if (!oldData) return oldData;
          return {
            ...oldData,
            fixtures: oldData.fixtures.map((f) =>
              f.fixture.id === variables.fixtureId
                ? {
                    ...f,
                    processedPostId: data?.data.postId || f.processedPostId,
                  }
                : f
            ),
          };
        }
      );
      setProcessingFixtureId(null);
    },
  });

  const handleGeneratePrediction = (fixture: UpcomingFixture) => {
    if (!selectedJournalistId) {
      toast.error("Please select an AI Journalist before generating.");
      return;
    }
    setProcessingFixtureId(fixture.fixture.id);
    generatePredictionNewsMutation.mutate({
      fixtureId: fixture.fixture.id,
      journalistId: selectedJournalistId,
      sportCategory: "football",
    });
  };

  const totalPages = fixturesData
    ? Math.ceil(fixturesData.totalCount / ITEMS_PER_PAGE)
    : 0;

  return (
    <div className="bg-brand-secondary p-6 rounded-lg mb-8 shadow-xl">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2">
          <Sparkles size={24} /> Generate Prediction News
        </h2>
        <button
          onClick={() => refetchFixtures()}
          className="flex items-center gap-2 bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed"
          disabled={
            isLoadingFixtures || generatePredictionNewsMutation.isPending
          }
        >
          <RefreshCw
            size={18}
            className={isLoadingFixtures ? "animate-spin" : ""}
          />
          Refresh Matches
        </button>
      </div>

      <div className="flex items-center justify-between gap-4 mb-4">
        {}
        <div className="flex items-center gap-2">
          <User size={18} className="text-brand-muted" />
          <select
            value={selectedJournalistId || ""}
            onChange={(e) => setSelectedJournalistId(e.target.value || null)}
            className="p-2 rounded bg-gray-700 text-white border border-gray-600 text-sm"
            disabled={
              isLoadingJournalists || generatePredictionNewsMutation.isPending
            }
          >
            <option value="">
              {isLoadingJournalists
                ? "Loading Journalists..."
                : "Select AI Journalist"}
            </option>
            {journalists
              ?.filter((j) => j.isActive)
              .map((j) => (
                <option key={j._id} value={j._id}>
                  {j.name}
                </option>
              ))}
          </select>
        </div>
        {}
        <span className="text-brand-muted text-sm ml-auto">
          Total Upcoming Matches: {fixturesData?.totalCount ?? 0}
        </span>
      </div>

      <div className="overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Match</th>
              <th className="p-4">League</th>
              <th className="p-4">Date & Time</th>
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {isLoadingFixtures ? (
              Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
                <tr
                  key={i}
                  className="border-t border-gray-700/50 animate-pulse"
                >
                  <td className="p-4">
                    <div className="h-4 bg-gray-700 rounded w-full"></div>
                  </td>
                  <td className="p-4">
                    <div className="h-4 bg-gray-700 rounded w-3/4"></div>
                  </td>
                  <td className="p-4">
                    <div className="h-4 bg-gray-700 rounded w-1/2"></div>
                  </td>
                  <td className="p-4">
                    <div className="h-4 bg-gray-700 rounded w-1/3"></div>
                  </td>
                  <td className="p-4">
                    <div className="w-10 h-10 bg-gray-700 rounded-full"></div>
                  </td>
                </tr>
              ))
            ) : fixturesData?.fixtures?.length === 0 ? (
              <tr>
                <td colSpan={5} className="p-8 text-center text-brand-muted">
                  No upcoming matches found for prediction.
                </td>
              </tr>
            ) : (
              fixturesData?.fixtures?.map((fixture) => (
                <tr
                  key={fixture.fixture.id}
                  className={`border-t border-gray-700/50 transition-colors
                                ${
                                  processingFixtureId === fixture.fixture.id
                                    ? "bg-brand-dark/50 animate-pulse"
                                    : fixture.processedPostId
                                    ? "bg-green-900/20"
                                    : "hover:bg-gray-800"
                                }`}
                >
                  <td className="p-4 font-medium flex items-center gap-3">
                    <img
                      src={fixture.teams.home.logo}
                      alt={fixture.teams.home.name}
                      className="w-6 h-6"
                    />
                    {fixture.teams.home.name} vs {fixture.teams.away.name}
                    <img
                      src={fixture.teams.away.logo}
                      alt={fixture.teams.away.name}
                      className="w-6 h-6"
                    />
                  </td>
                  <td className="p-4 text-brand-muted text-sm flex items-center gap-2">
                    <img
                      src={fixture.league.logo}
                      alt={fixture.league.name}
                      className="w-4 h-4"
                    />
                    {fixture.league.name}
                  </td>
                  <td className="p-4 text-brand-muted text-sm">
                    {format(
                      parseISO(fixture.fixture.date),
                      "dd MMM yyyy HH:mm"
                    )}
                  </td>
                  <td className="p-4">
                    <span
                      className={`px-2 py-1 text-xs font-semibold rounded-full min-w-[75px] inline-flex justify-center items-center gap-1
                          ${
                            fixture.processedPostId
                              ? "bg-green-500/20 text-green-400"
                              : "bg-blue-500/20 text-blue-400"
                          }`}
                    >
                      {processingFixtureId === fixture.fixture.id ? (
                        <Loader2 size={12} className="animate-spin" />
                      ) : fixture.processedPostId ? (
                        <CheckCircle size={12} />
                      ) : (
                        <Info size={12} />
                      )}
                      {processingFixtureId === fixture.fixture.id
                        ? "Generating..."
                        : fixture.processedPostId
                        ? "Generated"
                        : "Not Generated"}
                    </span>
                  </td>
                  <td className="p-4 flex gap-2 items-center h-full">
                    {fixture.processedPostId ? (
                      <a
                        href={`/admin/news/edit/${fixture.processedPostId}`}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-blue-400 hover:text-blue-300 p-1 rounded-full bg-brand-dark"
                        title="View Generated Post"
                      >
                        <Eye size={18} />
                      </a>
                    ) : (
                      <button
                        onClick={() => handleGeneratePrediction(fixture)}
                        className="text-brand-purple hover:text-brand-purple/80 p-1 rounded-full bg-brand-dark"
                        title="Generate Prediction News"
                        disabled={
                          generatePredictionNewsMutation.isPending ||
                          !selectedJournalistId
                        }
                      >
                        <Sparkles size={18} />
                      </button>
                    )}
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>

      {fixturesData && fixturesData.fixtures.length > 0 && (
        <div className="p-6">
          <Pagination
            currentPage={currentPage}
            totalPages={totalPages}
            onPageChange={setCurrentPage}
          />
        </div>
      )}
    </div>
  );
}

// ===== src/app/admin/auto-news/page.tsx =====

"use client";

import { useState, useMemo, useEffect, useRef } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  Newspaper,
  Settings,
  DownloadCloud,
  Sparkles,
  AlertCircle,
  RefreshCw,
  Trash2,
  ExternalLink,
  Loader2,
  CheckCircle,
  XCircle,
  User,
  FileText,
  SkipForward,
  ChevronDown,
  Lightbulb,
  Tag,
  Type,
  Terminal,
} from "lucide-react";
import { format, parseISO } from "date-fns";
import Image from "next/image";
import Link from "next/link";
import Pagination from "@/components/Pagination";
import PredictionGenerationTab from "./PredictionGenerationTab";
import AIPromptDisplayCard from "@/components/admin/AIPromptDisplayCard";
import { proxyImageUrl } from "@/lib/image-proxy";
import { NewsType, SportsCategory } from "@/models/Post";
import { ITitleTemplate } from "@/models/TitleTemplate";

interface IExternalNewsArticle {
  articleId: string;
  title: string;
  link: string;
  pubDate: string;
  imageUrl?: string | null;
  source_icon?: string | null;
  status: "fetched" | "processing" | "processed" | "skipped" | "error";
  processedPostId?: string;
  _id: string;
}
interface ExternalNewsResponse {
  articles: IExternalNewsArticle[];
  totalCount: number;
  currentPage: number;
  perPage: number;
}
interface IAIJournalist {
  _id: string;
  name: string;
  isActive: boolean;
}

const fetchExternalNews = async (
  page: number,
  limit: number,
  statusFilter: string
): Promise<ExternalNewsResponse> => {
  const { data } = await axios.get(
    `/api/admin/external-news?limit=${limit}&skip=${
      (page - 1) * limit
    }&status=${statusFilter}`
  );
  return data;
};

const fetchAIJournalists = async (): Promise<IAIJournalist[]> => {
  const { data } = await axios.get("/api/admin/ai-journalists");
  return data;
};

const fetchTitleTemplates = async (): Promise<ITitleTemplate[]> => {
  const { data } = await axios.get("/api/admin/title-templates?active=true");
  return data;
};

const availableSportsCategories: { id: SportsCategory; label: string }[] = [
  { id: "football", label: "Football" },
  { id: "basketball", label: "Basketball" },
  { id: "tennis", label: "Tennis" },
  { id: "general", label: "General" },
];

const availableNewsTypes: { id: NewsType; label: string }[] = [
  { id: "news", label: "General News" },
  { id: "highlights", label: "Highlights" },
  { id: "reviews", label: "Match Review" },
  { id: "prediction", label: "Prediction/Analysis" },
];

const FetchSummaryModal = ({
  summary,
  onClose,
}: {
  summary: any;
  onClose: () => void;
}) => {
  if (!summary) return null;
  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-md text-center p-8">
        <CheckCircle size={48} className="text-green-400 mx-auto mb-4" />
        <h2 className="text-2xl font-bold text-white mb-2">Fetch Complete!</h2>
        <p className="text-brand-muted mb-6">{summary.message}</p>
        <div className="grid grid-cols-3 gap-4 text-white mb-8">
          <div className="bg-green-500/20 p-4 rounded-lg">
            <p className="text-3xl font-bold">{summary.newArticlesCount}</p>
            <p className="text-sm font-semibold">Saved</p>
          </div>
          <div className="bg-yellow-500/20 p-4 rounded-lg">
            <p className="text-3xl font-bold">{summary.skippedArticlesCount}</p>
            <p className="text-sm font-semibold">Skipped</p>
          </div>
          <div className="bg-red-500/20 p-4 rounded-lg">
            <p className="text-3xl font-bold">
              {summary.failedArticlesCount || 0}
            </p>
            <p className="text-sm font-semibold">Failed</p>
          </div>
        </div>
        <button
          onClick={onClose}
          className="bg-brand-purple text-white font-bold py-2 px-6 rounded-lg hover:opacity-90"
        >
          Close
        </button>
      </div>
    </div>
  );
};

interface ProcessArticleModalProps {
  isOpen: boolean;
  onClose: () => void;
  article: IExternalNewsArticle | null;
  journalists: IAIJournalist[] | undefined;
}
const ProcessArticleModal: React.FC<ProcessArticleModalProps> = ({
  isOpen,
  onClose,
  article,
  journalists,
}) => {
  const queryClient = useQueryClient();
  const [selectedJournalistId, setSelectedJournalistId] = useState<
    string | null
  >(null);
  const [selectedTitleTemplateId, setSelectedTitleTemplateId] =
    useState<string>("");
  const [selectedCategories, setSelectedCategories] = useState<
    SportsCategory[]
  >(["general"]);
  const [newsType, setNewsType] = useState<NewsType>("news");
  const [publishImmediately, setPublishImmediately] = useState(false);

  const [isProcessing, setIsProcessing] = useState(false);
  const [logs, setLogs] = useState<string[]>([]);
  const logContainerRef = useRef<HTMLDivElement>(null);

  const { data: titleTemplates, isLoading: isLoadingTemplates } = useQuery<
    ITitleTemplate[]
  >({
    queryKey: ["activeTitleTemplates"],
    queryFn: fetchTitleTemplates,
    staleTime: 1000 * 60 * 5,
    enabled: isOpen,
  });

  useEffect(() => {
    if (logContainerRef.current) {
      logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
    }
  }, [logs]);

  useEffect(() => {
    if (isOpen) {

      setLogs([]);
      setIsProcessing(false);
      setSelectedCategories(["general"]);
      setNewsType("news");
      setPublishImmediately(false);
      setSelectedTitleTemplateId("");
      if (journalists && !selectedJournalistId) {
        const firstActive = journalists.find((j) => j.isActive);
        if (firstActive) setSelectedJournalistId(firstActive._id);
      }
    }
  }, [isOpen, journalists, selectedJournalistId]);

  const handleCategoryChange = (category: SportsCategory) => {
    setSelectedCategories((prev) => {
      if (prev.includes(category)) {
        return prev.length > 1 ? prev.filter((c) => c !== category) : prev;
      }
      return [...prev, category];
    });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedJournalistId || !article) {
      toast.error("Please select an AI Journalist.");
      return;
    }

    setIsProcessing(true);
    setLogs([]);

    const payload = {
      articleId: article.articleId,
      journalistId: selectedJournalistId,
      titleTemplateId: selectedTitleTemplateId || undefined,
      sportsCategory: selectedCategories,
      newsType: newsType,
      status: publishImmediately ? "published" : "draft",
    };

    const response = await fetch("/api/admin/process-external-news", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    if (!response.body) {
      toast.error("Streaming not supported or response body is missing.");
      setIsProcessing(false);
      return;
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();

    while (true) {
      const { value, done } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value);
      const lines = chunk.split("\n\n");

      lines.forEach((line) => {
        if (line.startsWith("data:")) {
          try {
            const json = JSON.parse(line.substring(5));
            if (json.log) {
              setLogs((prev) => [...prev, json.log]);
            }
            if (json.event === "SUCCESS") {
              toast.success("Article processed successfully!");
              queryClient.invalidateQueries({ queryKey: ["externalNews"] });
              queryClient.invalidateQueries({ queryKey: ["adminPosts"] });
              setTimeout(() => onClose(), 1500);
            }
            if (json.event === "ERROR") {
              throw new Error(json.data.message);
            }
          } catch (e: any) {
            toast.error(e.message || "An error occurred while processing.");

          }
        }
      });
    }

    setIsProcessing(false);
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl overflow-hidden">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            Process Article Options
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
            disabled={isProcessing}
          >
            <XCircle size={24} />
          </button>
        </div>

        {isProcessing ? (
          <div className="p-6">
            <h3 className="text-lg font-semibold text-white mb-4 flex items-center gap-2">
              <Loader2 className="animate-spin" /> Generating Article...
            </h3>
            <div
              ref={logContainerRef}
              className="bg-brand-dark p-4 rounded-lg h-96 overflow-y-auto font-mono text-sm text-brand-light space-y-2"
            >
              {logs.map((log, index) => (
                <div key={index} className="flex items-start gap-2">
                  <span className="text-brand-muted">{">"}</span>
                  <span
                    className={
                      log.startsWith("")
                        ? "text-green-400"
                        : log.startsWith("")
                        ? "text-red-400"
                        : ""
                    }
                  >
                    {log}
                  </span>
                </div>
              ))}
            </div>
          </div>
        ) : (
          <form
            onSubmit={handleSubmit}
            className="p-6 space-y-6 max-h-[80vh] overflow-y-auto"
          >
            <p className="text-brand-light">
              Configure options for generating the article:{" "}
              <strong className="text-white">"{article?.title}"</strong>
            </p>

            <div>
              <label
                htmlFor="journalist"
                className="block text-sm font-medium text-brand-light mb-2 flex items-center gap-2"
              >
                <User size={16} /> AI Journalist
              </label>
              <select
                id="journalist"
                value={selectedJournalistId || ""}
                onChange={(e) =>
                  setSelectedJournalistId(e.target.value || null)
                }
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                required
              >
                <option value="">Select AI Journalist...</option>
                {journalists
                  ?.filter((j) => j.isActive)
                  .map((j) => (
                    <option key={j._id} value={j._id}>
                      {j.name}
                    </option>
                  ))}
              </select>
            </div>

            <div>
              <label
                htmlFor="title-template"
                className="block text-sm font-medium text-brand-light mb-2 flex items-center gap-2"
              >
                <Type size={16} /> Title Template (Optional)
              </label>
              <select
                id="title-template"
                value={selectedTitleTemplateId}
                onChange={(e) => setSelectedTitleTemplateId(e.target.value)}
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                disabled={isLoadingTemplates}
              >
                <option value="">
                  {isLoadingTemplates
                    ? "Loading templates..."
                    : "Default (Dynamic Generation)"}
                </option>
                {titleTemplates?.map((template) => (
                  <option key={template._id} value={template._id}>
                    {template.name}
                  </option>
                ))}
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium text-brand-light mb-3 flex items-center gap-2">
                <Tag size={16} /> Sports Categories
              </label>
              <div className="grid grid-cols-2 sm:grid-cols-4 gap-4">
                {availableSportsCategories.map((category) => (
                  <div key={category.id} className="flex items-center">
                    <input
                      id={`category-${category.id}`}
                      type="checkbox"
                      checked={selectedCategories.includes(category.id)}
                      onChange={() => handleCategoryChange(category.id)}
                      className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
                    />
                    <label
                      htmlFor={`category-${category.id}`}
                      className="ml-3 text-sm font-medium text-brand-light"
                    >
                      {category.label}
                    </label>
                  </div>
                ))}
              </div>
            </div>

            <div>
              <label
                htmlFor="newsType"
                className="block text-sm font-medium text-brand-light mb-2 flex items-center gap-2"
              >
                <Type size={16} /> News Type
              </label>
              <select
                id="newsType"
                value={newsType}
                onChange={(e) => setNewsType(e.target.value as NewsType)}
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600"
              >
                {availableNewsTypes.map((type) => (
                  <option key={type.id} value={type.id}>
                    {type.label}
                  </option>
                ))}
              </select>
            </div>

            <div className="flex items-center">
              <input
                id="publishImmediately"
                type="checkbox"
                checked={publishImmediately}
                onChange={(e) => setPublishImmediately(e.target.checked)}
                className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
              />
              <label
                htmlFor="publishImmediately"
                className="ml-2 text-sm font-medium text-brand-light"
              >
                Publish immediately (if unchecked, saves as Draft)
              </label>
            </div>

            <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
              <button
                type="button"
                onClick={onClose}
                className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
              >
                Cancel
              </button>
              <button
                type="submit"
                className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                disabled={!selectedJournalistId}
              >
                <Sparkles size={18} />
                Generate Article
              </button>
            </div>
          </form>
        )}
      </div>
    </div>
  );
};

export default function AdminAutoNewsPage() {
  const queryClient = useQueryClient();

  const [activeTab, setActiveTab] = useState<
    "settings" | "external_news" | "prediction_generation"
  >("external_news");
  const [newsQuery, setNewsQuery] = useState("football OR soccer");
  const [newsLanguage, setNewsLanguage] = useState("en");
  const [fetchSummary, setFetchSummary] = useState<any | null>(null);
  const [currentPage, setCurrentPage] = useState(1);
  const [articlesPerPage, setArticlesPerPage] = useState(10);
  const [statusFilter, setStatusFilter] = useState("fetched");

  const [isProcessModalOpen, setIsProcessModalOpen] = useState(false);
  const [articleToProcess, setArticleToProcess] =
    useState<IExternalNewsArticle | null>(null);

  const [deletingArticleId, setDeletingArticleId] = useState<string | null>(
    null
  );

  const { data: externalNewsData, isLoading: isLoadingNews } =
    useQuery<ExternalNewsResponse>({
      queryKey: ["externalNews", currentPage, articlesPerPage, statusFilter],
      queryFn: () =>
        fetchExternalNews(currentPage, articlesPerPage, statusFilter),
      enabled: activeTab === "external_news",
    });

  const { data: journalists } = useQuery<IAIJournalist[]>({
    queryKey: ["aiJournalists"],
    queryFn: fetchAIJournalists,
  });

  const fetchNewsMutation = useMutation({
    mutationFn: (payload: { query: string; language: string }) =>
      axios.post("/api/admin/fetch-external-news", payload),
    onSuccess: (data) => {
      setFetchSummary(data.data);
      queryClient.invalidateQueries({ queryKey: ["externalNews"] });
      setCurrentPage(1);
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "Failed to fetch news."),
  });

  const deleteArticleMutation = useMutation({
    mutationFn: (articleId: string) => {
      setDeletingArticleId(articleId);
      return axios.delete(`/api/admin/external-news?articleId=${articleId}`);
    },
    onSuccess: () => {
      toast.success("Article deleted!");
      queryClient.invalidateQueries({ queryKey: ["externalNews"] });
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "Failed to delete article."),
    onSettled: () => setDeletingArticleId(null),
  });

  const handleFetchNews = (e: React.FormEvent) => {
    e.preventDefault();
    fetchNewsMutation.mutate({ query: newsQuery, language: newsLanguage });
  };

  const handleOpenProcessModal = (article: IExternalNewsArticle) => {
    setArticleToProcess(article);
    setIsProcessModalOpen(true);
  };

  const handleDeleteArticle = (articleId: string, title: string) => {
    if (window.confirm(`Are you sure you want to delete "${title}"?`)) {
      deleteArticleMutation.mutate(articleId);
    }
  };

  const totalPages = externalNewsData
    ? Math.ceil(externalNewsData.totalCount / articlesPerPage)
    : 0;

  const statusInfo = (
    status: IExternalNewsArticle["status"]
  ): { icon: React.ElementType; color: string } => {
    switch (status) {
      case "processed":
        return { icon: CheckCircle, color: "text-green-400" };
      case "fetched":
        return { icon: DownloadCloud, color: "text-blue-400" };
      case "skipped":
        return { icon: SkipForward, color: "text-yellow-400" };
      case "error":
        return { icon: XCircle, color: "text-red-400" };
      default:
        return { icon: AlertCircle, color: "text-gray-400" };
    }
  };

  return (
    <div>
      <FetchSummaryModal
        summary={fetchSummary}
        onClose={() => setFetchSummary(null)}
      />
      <ProcessArticleModal
        isOpen={isProcessModalOpen}
        onClose={() => setIsProcessModalOpen(false)}
        article={articleToProcess}
        journalists={journalists}
      />
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Sparkles size={28} /> Automated Content Engine
        </h1>
      </div>
      <div className="flex border-b border-gray-700 mb-8">
        <button
          onClick={() => setActiveTab("settings")}
          className={`px-6 py-3 text-lg font-semibold flex items-center gap-2 ${
            activeTab === "settings"
              ? "text-brand-purple border-b-2 border-brand-purple"
              : "text-brand-muted hover:text-white"
          }`}
        >
          <Settings size={20} /> AI Workflow
        </button>
        <button
          onClick={() => setActiveTab("external_news")}
          className={`px-6 py-3 text-lg font-semibold flex items-center gap-2 ${
            activeTab === "external_news"
              ? "text-brand-purple border-b-2 border-brand-purple"
              : "text-brand-muted hover:text-white"
          }`}
        >
          <DownloadCloud size={20} /> External News
        </button>
        <button
          onClick={() => setActiveTab("prediction_generation")}
          className={`px-6 py-3 text-lg font-semibold flex items-center gap-2 ${
            activeTab === "prediction_generation"
              ? "text-brand-purple border-b-2 border-brand-purple"
              : "text-brand-muted hover:text-white"
          }`}
        >
          <Sparkles size={20} /> Match Predictions
        </button>
      </div>

      {activeTab === "settings" && (
        <div className="max-w-4xl mx-auto space-y-12">
          {}
        </div>
      )}

      {activeTab === "external_news" && (
        <div className="space-y-8">
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
            <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
              <DownloadCloud size={24} /> Fetch News from Newsdata.io
            </h2>
            <form
              onSubmit={handleFetchNews}
              className="grid grid-cols-1 md:grid-cols-2 gap-4"
            >
              <div>
                <label
                  htmlFor="newsQuery"
                  className="block text-sm font-medium text-brand-light mb-1"
                >
                  Keywords (qInTitle):
                </label>
                <input
                  type="text"
                  id="newsQuery"
                  value={newsQuery}
                  onChange={(e) => setNewsQuery(e.target.value)}
                  className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                />
              </div>
              <div>
                <label
                  htmlFor="newsLanguage"
                  className="block text-sm font-medium text-brand-light mb-1"
                >
                  Language:
                </label>
                <select
                  id="newsLanguage"
                  value={newsLanguage}
                  onChange={(e) => setNewsLanguage(e.target.value)}
                  className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                >
                  <option value="en">English</option>
                  <option value="tr">Turkish</option>
                </select>
              </div>
              <div className="md:col-span-2 flex justify-end">
                <button
                  type="submit"
                  className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
                  disabled={fetchNewsMutation.isPending}
                >
                  {fetchNewsMutation.isPending ? (
                    <Loader2 size={20} className="animate-spin" />
                  ) : (
                    <DownloadCloud size={20} />
                  )}{" "}
                  {fetchNewsMutation.isPending
                    ? "Fetching..."
                    : "Fetch New Articles"}
                </button>
              </div>
            </form>
          </div>
          <div className="bg-brand-secondary rounded-lg overflow-hidden shadow-xl">
            <div className="p-6">
              <div className="flex flex-col md:flex-row items-start md:items-center justify-between gap-4">
                <h2 className="text-2xl font-bold text-white flex items-center gap-2">
                  <FileText size={24} /> Review & Process Articles
                </h2>
                <div className="flex items-center gap-4">
                  <select
                    value={statusFilter}
                    onChange={(e) => {
                      setStatusFilter(e.target.value);
                      setCurrentPage(1);
                    }}
                    className="p-2 rounded bg-gray-700 text-white border border-gray-600 text-sm"
                  >
                    <option value="fetched">Fetched</option>
                    <option value="processed">Processed</option>
                    <option value="skipped">Skipped</option>
                    <option value="error">Error</option>
                    <option value="">All</option>
                  </select>
                </div>
              </div>
            </div>
            <div className="overflow-x-auto">
              <table className="w-full text-left text-brand-light">
                <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
                  <tr>
                    <th className="p-4">Preview</th>
                    <th className="p-4">Title</th>
                    <th className="p-4">Source</th>
                    <th className="p-4">Status</th>
                    <th className="p-4">Published</th>
                    <th className="p-4">Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {isLoadingNews ? (
                    Array.from({ length: 5 }).map((_, i) => (
                      <tr key={i}>
                        <td colSpan={6} className="p-4 h-20 animate-pulse">
                          <div className="h-full bg-gray-700 rounded"></div>
                        </td>
                      </tr>
                    ))
                  ) : externalNewsData?.articles?.length === 0 ? (
                    <tr>
                      <td
                        colSpan={6}
                        className="p-8 text-center text-brand-muted"
                      >
                        No articles found with this filter.
                      </td>
                    </tr>
                  ) : (
                    externalNewsData?.articles.map((article) => {
                      const { icon: StatusIcon, color: statusColor } =
                        statusInfo(article.status);
                      return (
                        <tr
                          key={article._id}
                          className={`border-t border-gray-700/50 transition-colors ${
                            deletingArticleId === article.articleId
                              ? "bg-brand-dark/50 opacity-50"
                              : "hover:bg-gray-800"
                          }`}
                        >
                          <td className="p-4">
                            <Image
                              src={proxyImageUrl(article.imageUrl)}
                              alt={article.title}
                              width={100}
                              height={56}
                              objectFit="cover"
                              className="rounded-md bg-gray-700"
                            />
                          </td>
                          <td
                            className="p-4 font-medium max-w-sm"
                            title={article.title}
                          >
                            <Link
                              href={article.link}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="hover:text-brand-purple transition-colors"
                            >
                              {article.title}{" "}
                              <ExternalLink
                                size={12}
                                className="inline-block"
                              />
                            </Link>
                          </td>
                          <td className="p-4 text-sm">
                            <div className="flex items-center gap-2">
                              {article.source_icon && (
                                <Image
                                  src={proxyImageUrl(article.source_icon)}
                                  alt=""
                                  width={16}
                                  height={16}
                                  className="rounded-full"
                                />
                              )}
                              <span className="text-brand-muted">
                                {article.link
                                  ?.split("/")[2]
                                  ?.replace("www.", "")}
                              </span>
                            </div>
                          </td>
                          <td className="p-4">
                            <div
                              className={`flex items-center gap-1.5 font-semibold text-xs ${statusColor}`}
                            >
                              <StatusIcon size={12} />
                              <span>
                                {article.status.charAt(0).toUpperCase() +
                                  article.status.slice(1)}
                              </span>
                            </div>
                          </td>
                          <td className="p-4 text-brand-muted text-sm">
                            {format(parseISO(article.pubDate), "dd MMM, HH:mm")}
                          </td>
                          <td className="p-4 flex gap-2 items-center h-full">
                            {article.status === "fetched" && (
                              <button
                                onClick={() => handleOpenProcessModal(article)}
                                className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-3 rounded-lg text-sm hover:opacity-90 disabled:opacity-50"
                              >
                                <Sparkles size={16} />
                                <span>Generate</span>
                              </button>
                            )}
                            {article.status === "processed" &&
                              article.processedPostId && (
                                <Link
                                  href={`/admin/news/edit/${article.processedPostId}`}
                                  className="text-blue-400 hover:text-blue-300 p-2 rounded-full bg-brand-dark"
                                  title="View Processed Post"
                                >
                                  <ExternalLink size={18} />
                                </Link>
                              )}
                            <button
                              onClick={() =>
                                handleDeleteArticle(
                                  article.articleId,
                                  article.title
                                )
                              }
                              className="text-red-400 hover:text-red-300 p-2 rounded-full bg-brand-dark"
                              title="Delete Article"
                              disabled={deleteArticleMutation.isPending}
                            >
                              {deletingArticleId === article.articleId ? (
                                <Loader2 size={18} className="animate-spin" />
                              ) : (
                                <Trash2 size={18} />
                              )}
                            </button>
                          </td>
                        </tr>
                      );
                    })
                  )}
                </tbody>
              </table>
            </div>
            {totalPages > 0 && (
              <div className="p-6 border-t border-gray-700/50">
                <Pagination
                  currentPage={currentPage}
                  totalPages={totalPages}
                  onPageChange={setCurrentPage}
                />
              </div>
            )}
          </div>
        </div>
      )}

      {activeTab === "prediction_generation" && <PredictionGenerationTab />}
    </div>
  );
}

// ===== src/app/admin/banners/page.tsx =====

"use client";

import { useMemo, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { PlusCircle, Edit, Trash2 } from "lucide-react";
import Image from "next/image";
import { IBanner } from "@/models/Banner";
import BannerFormModal from "@/components/admin/BannerFormModal";
import { AD_SLOTS } from "@/config/adSlots";
import { proxyImageUrl } from "@/lib/image-proxy";

const fetchBanners = async (): Promise<IBanner[]> => {
  const { data } = await axios.get("/api/banners");
  return data;
};

export default function AdminBannersPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingBanner, setEditingBanner] = useState<IBanner | null>(null);

  const locationNameMap = useMemo(
    () => new Map(AD_SLOTS.map((s) => [s.id, s.name])),
    []
  );

  const {
    data: banners,
    isLoading,
    error,
  } = useQuery<IBanner[]>({
    queryKey: ["adminBanners"],
    queryFn: fetchBanners,
  });

  const deleteMutation = useMutation({
    mutationFn: (bannerId: string) => axios.delete(`/api/banners/${bannerId}`),
    onSuccess: () => {
      toast.success("Banner deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["adminBanners"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete banner.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingBanner(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (banner: IBanner) => {
    setEditingBanner(banner);
    setIsModalOpen(true);
  };

  const handleDelete = (bannerId: string) => {
    if (
      window.confirm(
        "Are you sure you want to delete this banner? This action cannot be undone."
      )
    ) {
      deleteMutation.mutate(bannerId);
    }
  };

  if (isLoading) return <p className="text-brand-muted">Loading banners...</p>;
  if (error) return <p className="text-red-400">Failed to load banners.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Manage Ad Banners</h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Banner</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Preview</th>
              <th className="p-4">Title</th>
              <th className="p-4">Location</th> {}
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {banners?.map((banner) => (
              <tr
                key={banner._id as string}
                className="border-t border-gray-700/50"
              >
                <td className="p-4">
                  {}
                  <Image
                    src={banner.imageUrl}
                    alt={banner.title}
                    width={120}
                    height={60}

                    objectFit="contain"
                    className="rounded-md bg-gray-700"
                  />
                </td>
                <td className="p-4 font-medium">{banner.title}</td>
                <td className="p-4 font-semibold text-brand-light">
                  {locationNameMap.get(banner.location) || banner.location}
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      banner.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {banner.isActive ? "Active" : "Inactive"}
                  </span>
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <button
                    onClick={() => handleOpenEditModal(banner)}
                    className="text-blue-400 hover:text-blue-300"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() => handleDelete(banner._id as string)}
                    className="text-red-400 hover:text-red-300"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {banners?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No banners found. Click "New Banner" to create one.
          </p>
        )}
      </div>

      <BannerFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        banner={editingBanner}
      />
    </div>
  );
}

// ===== src/app/admin/casino-partners/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  PlusCircle,
  Edit,
  Trash2,
  Crown,
  Link as LinkIcon,
  ExternalLink,
  Loader2,
  CheckCircle,
  XCircle,
} from "lucide-react";
import Image from "next/image";

interface ICasinoPartner {
  _id: string;
  name: string;
  logoUrl: string;
  redirectUrl: string;
  description?: string;
  isFeatured: boolean;
  isActive: boolean;
  order: number;
  createdAt: string;
  updatedAt: string;
}

interface CasinoPartnerFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  partner?: ICasinoPartner | null;
}

const CasinoPartnerFormModal: React.FC<CasinoPartnerFormModalProps> = ({
  isOpen,
  onClose,
  partner,
}) => {
  const queryClient = useQueryClient();
  const [name, setName] = useState(partner?.name || "");
  const [logoUrl, setLogoUrl] = useState(partner?.logoUrl || "");
  const [redirectUrl, setRedirectUrl] = useState(partner?.redirectUrl || "");
  const [description, setDescription] = useState(partner?.description || "");
  const [isFeatured, setIsFeatured] = useState(partner?.isFeatured ?? false);
  const [isActive, setIsActive] = useState(partner?.isActive ?? true);
  const [order, setOrder] = useState(partner?.order ?? 0);

  useEffect(() => {
    if (partner) {
      setName(partner.name);
      setLogoUrl(partner.logoUrl);
      setRedirectUrl(partner.redirectUrl);
      setDescription(partner.description || "");
      setIsFeatured(partner.isFeatured);
      setIsActive(partner.isActive);
      setOrder(partner.order);
    } else {
      setName("");
      setLogoUrl("");
      setRedirectUrl("");
      setDescription("");
      setIsFeatured(false);
      setIsActive(true);
      setOrder(0);
    }
  }, [partner]);

  const createMutation = useMutation({
    mutationFn: (newPartner: Partial<ICasinoPartner>) =>
      axios.post("/api/admin/casino-partners", newPartner),
    onSuccess: () => {
      toast.success("Casino Partner created successfully!");
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersAdmin"] });
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersPublic"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to create partner.");
    },
  });

  const updateMutation = useMutation({
    mutationFn: (updatedPartner: Partial<ICasinoPartner>) =>
      axios.put(`/api/admin/casino-partners/${partner?._id}`, updatedPartner),
    onSuccess: () => {
      toast.success("Casino Partner updated successfully!");
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersAdmin"] });
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersPublic"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to update partner.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !logoUrl.trim() || !redirectUrl.trim()) {
      toast.error("Name, Logo URL, and Redirect URL are required.");
      return;
    }

    const payload = {
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured,
      isActive,
      order: Number(order),
    };

    if (partner) {
      updateMutation.mutate(payload);
    } else {
      createMutation.mutate(payload);
    }
  };

  const isPending = createMutation.isPending || updateMutation.isPending;

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl overflow-hidden">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {partner ? "Edit Casino Partner" : "Create New Casino Partner"}
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label
              htmlFor="name"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Partner Name
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
          </div>
          <div>
            <label
              htmlFor="logoUrl"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Logo URL
            </label>
            {}
            <input
              id="logoUrl"
              type="url"
              value={logoUrl}
              onChange={(e) => setLogoUrl(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
            {logoUrl && (
              <div className="mt-2 text-center">
                <Image
                  src={logoUrl}
                  alt="Logo Preview"
                  width={80}
                  height={40}
                  objectFit="contain"
                  className="rounded-md bg-gray-800 p-1"

                />
              </div>
            )}
          </div>
          <div>
            <label
              htmlFor="redirectUrl"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Redirect URL (Affiliate Link)
            </label>
            <input
              id="redirectUrl"
              type="url"
              value={redirectUrl}
              onChange={(e) => setRedirectUrl(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
            <p className="text-xs text-brand-muted mt-1">
              This is the link users will be redirected to.
            </p>
          </div>
          <div>
            <label
              htmlFor="description"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Description (Optional)
            </label>
            <textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
              rows={3}
              disabled={isPending}
              placeholder="A short internal description of the partner."
            />
          </div>
          <div className="flex flex-col sm:flex-row sm:items-center sm:gap-4 space-y-3 sm:space-y-0">
            <div className="flex items-center">
              <input
                id="isFeatured"
                type="checkbox"
                checked={isFeatured}
                onChange={(e) => setIsFeatured(e.target.checked)}
                className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
                disabled={isPending}
              />
              <label
                htmlFor="isFeatured"
                className="ml-2 text-sm font-medium text-brand-light"
              >
                Featured (Prominent Styling)
              </label>
            </div>
            <div className="flex items-center">
              <input
                id="isActive"
                type="checkbox"
                checked={isActive}
                onChange={(e) => setIsActive(e.target.checked)}
                className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
                disabled={isPending}
              />
              <label
                htmlFor="isActive"
                className="ml-2 text-sm font-medium text-brand-light"
              >
                Active (Display on site)
              </label>
            </div>
            <div className="flex-grow">
              <label
                htmlFor="order"
                className="block text-sm font-medium text-brand-light mb-1 sm:mb-0"
              >
                Order
              </label>
              <input
                id="order"
                type="number"
                value={order}
                onChange={(e) => setOrder(Number(e.target.value))}
                className="w-20 p-2 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                disabled={isPending}
                min="0"
              />
              <p className="text-xs text-brand-muted mt-1">
                Lower number = higher priority.
              </p>
            </div>
          </div>

          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
              disabled={isPending}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={isPending}
            >
              {isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {isPending
                ? partner
                  ? "Updating..."
                  : "Creating..."
                : partner
                ? "Save Changes"
                : "Create Partner"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default function AdminCasinoPartnersPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingPartner, setEditingPartner] = useState<ICasinoPartner | null>(
    null
  );

  const {
    data: partners,
    isLoading,
    error,
  } = useQuery<ICasinoPartner[]>({
    queryKey: ["casinoPartnersAdmin"],
    queryFn: async () => {
      const { data } = await axios.get("/api/admin/casino-partners");
      return data;
    },
    staleTime: 1000 * 60 * 5,
  });

  const deleteMutation = useMutation({
    mutationFn: (partnerId: string) =>
      axios.delete(`/api/admin/casino-partners/${partnerId}`),
    onSuccess: () => {
      toast.success("Casino Partner deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersAdmin"] });
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersPublic"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete partner.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingPartner(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (partner: ICasinoPartner) => {
    setEditingPartner(partner);
    setIsModalOpen(true);
  };

  const handleDelete = (partnerId: string, partnerName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete Casino Partner "${partnerName}"? This action cannot be undone.`
      )
    ) {
      deleteMutation.mutate(partnerId);
    }
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading Casino Partners...</p>;
  if (error)
    return <p className="text-red-400">Failed to load Casino Partners.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Crown size={28} /> Manage Casino Partners
        </h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Partner</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Logo</th>
              <th className="p-4">Name</th>
              <th className="p-4">Featured</th>
              <th className="p-4">Active</th>
              <th className="p-4">Order</th>
              <th className="p-4">Description</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {partners?.map((partner) => (
              <tr key={partner._id} className="border-t border-gray-700/50">
                <td className="p-4">
                  {partner.logoUrl && (
                    <Image
                      src={partner.logoUrl}
                      alt={partner.name}
                      width={60}
                      height={30}
                      objectFit="contain"
                      className="rounded-md bg-gray-700 p-1"
                    />
                  )}
                </td>
                <td className="p-4 font-medium">{partner.name}</td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      partner.isFeatured
                        ? "bg-yellow-500/20 text-yellow-400"
                        : "bg-gray-600/20 text-gray-400"
                    }`}
                  >
                    {partner.isFeatured ? "Yes" : "No"}
                  </span>
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      partner.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {partner.isActive ? "Yes" : "No"}
                  </span>
                </td>
                <td className="p-4 text-brand-muted">{partner.order}</td>
                <td
                  className="p-4 text-brand-muted text-sm max-w-[200px] truncate"
                  title={partner.description}
                >
                  {partner.description || "N/A"}
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <a
                    href={partner.redirectUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-brand-muted hover:text-white"
                    title="Go to Partner Site"
                  >
                    <ExternalLink size={18} />
                  </a>
                  <button
                    onClick={() => handleOpenEditModal(partner)}
                    className="text-blue-400 hover:text-blue-300"
                    title="Edit Partner"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() => handleDelete(partner._id, partner.name)}
                    className="text-red-400 hover:text-red-300"
                    title="Delete Partner"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {partners?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No Casino Partners found. Click "New Partner" to create one.
          </p>
        )}
      </div>

      <CasinoPartnerFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        partner={editingPartner}
      />
    </div>
  );
}

// ===== src/app/admin/dashboard/page.tsx =====

import { getI18n } from "@/lib/i18n/server";

export default async function AdminDashboardPage() {
  const t = await getI18n();

  return (
    <div>
      <h1 className="text-3xl font-bold text-white mb-4">
        {t("admin_dashboard")}
      </h1>
      <p className="text-brand-muted">{t("welcome_to_admin_area")}</p>
      <div className="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6">
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t("manage_users")}</h3>
          <p className="text-sm text-brand-muted mt-2">
            {t("view_and_edit_user_roles")}
          </p>
        </div>
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t("manage_matches")}</h3>
          <p className="text-sm text-brand-muted mt-2">
            {t("update_match_details")}
          </p>
        </div>
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t("view_analytics")}</h3>
          <p className="text-sm text-brand-muted mt-2">
            {t("check_site_traffic")}
          </p>
        </div>
      </div>
    </div>
  );
}

// ===== src/app/admin/faqs/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  PlusCircle,
  Edit,
  Trash2,
  CheckCircle,
  XCircle,
  Loader2,
  HelpCircle,
} from "lucide-react";
import CreatableSelect from "@/components/admin/CreatableSelect";

interface IFaq {
  _id: string;
  question: string;
  answer: string;
  category: string;
  order: number;
  isActive: boolean;
}

const defaultFormState: Omit<IFaq, "_id"> = {
  question: "",
  answer: "",
  category: "General Questions",
  order: 0,
  isActive: true,
};

const FaqFormModal = ({
  isOpen,
  onClose,
  faq,
}: {
  isOpen: boolean;
  onClose: () => void;
  faq: IFaq | null;
}) => {
  const queryClient = useQueryClient();

  const [formData, setFormData] = useState<Omit<IFaq, "_id">>(defaultFormState);

  useEffect(() => {
    if (isOpen) {
      if (faq) {

        setFormData({
          question: faq.question,
          answer: faq.answer,
          category: faq.category,
          order: faq.order,
          isActive: faq.isActive,
        });
      } else {

        setFormData(defaultFormState);
      }
    }
  }, [faq, isOpen]);

  const handleFormChange = (field: keyof typeof formData, value: any) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  const mutation = useMutation({

    mutationFn: (faqData: Omit<IFaq, "_id"> & { _id?: string }) => {
      if (faqData._id) {
        return axios.put("/api/admin/faqs", faqData);
      }
      return axios.post("/api/admin/faqs", faqData);
    },
    onSuccess: () => {
      toast.success(`FAQ ${faq ? "updated" : "created"} successfully!`);
      queryClient.invalidateQueries({ queryKey: ["adminFaqs"] });
      queryClient.invalidateQueries({ queryKey: ["faqCategories"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "An error occurred.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (
      !formData.question.trim() ||
      !formData.answer.trim() ||
      !formData.category.trim()
    ) {
      toast.error("Question, Answer, and Category are required.");
      return;
    }

    const payload = { ...formData, ...(faq && { _id: faq._id }) };
    mutation.mutate(payload);
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {faq ? "Edit FAQ" : "Create New FAQ"}
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">
              Category
            </label>
            <CreatableSelect
              value={formData.category}
              onChange={(value) => handleFormChange("category", value)}
              placeholder="Select or create a category..."
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">
              Question
            </label>
            <input
              type="text"
              value={formData.question}
              onChange={(e) => handleFormChange("question", e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600"
              required
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">
              Answer (HTML allowed)
            </label>
            <textarea
              value={formData.answer}
              onChange={(e) => handleFormChange("answer", e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 resize-y"
              rows={6}
              required
            />
          </div>
          <div className="flex gap-4">
            <div className="flex-1">
              <label className="block text-sm font-medium text-brand-light mb-1">
                Order
              </label>
              <input
                type="number"
                value={formData.order}
                onChange={(e) =>
                  handleFormChange("order", Number(e.target.value))
                }
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600"
              />
            </div>
            <div className="flex items-center pt-6">
              <input
                type="checkbox"
                checked={formData.isActive}
                onChange={(e) => handleFormChange("isActive", e.target.checked)}
                className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded"
              />
              <label className="ml-2 text-sm font-medium text-brand-light">
                Active
              </label>
            </div>
          </div>
          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
              disabled={mutation.isPending}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg disabled:opacity-50 flex items-center gap-2"
              disabled={mutation.isPending}
            >
              {mutation.isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {mutation.isPending ? "Saving..." : "Save FAQ"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default function AdminFaqsPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingFaq, setEditingFaq] = useState<IFaq | null>(null);

  const {
    data: faqs,
    isLoading,
    error,
  } = useQuery<IFaq[]>({
    queryKey: ["adminFaqs"],
    queryFn: () => axios.get("/api/admin/faqs").then((res) => res.data),
  });

  const deleteMutation = useMutation({
    mutationFn: (faqId: string) =>
      axios.delete("/api/admin/faqs", { data: { id: faqId } }),
    onSuccess: () => {
      toast.success("FAQ deleted!");
      queryClient.invalidateQueries({ queryKey: ["adminFaqs"] });
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "Failed to delete FAQ."),
  });

  const handleOpenCreateModal = () => {
    setEditingFaq(null);
    setIsModalOpen(true);
  };
  const handleOpenEditModal = (faq: IFaq) => {
    setEditingFaq(faq);
    setIsModalOpen(true);
  };
  const handleDelete = (faqId: string) => {
    if (window.confirm("Are you sure?")) deleteMutation.mutate(faqId);
  };

  if (isLoading) return <p className="text-brand-muted">Loading FAQs...</p>;
  if (error) return <p className="text-red-400">Failed to load FAQs.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <HelpCircle size={28} /> Manage FAQs
        </h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} /> New FAQ
        </button>
      </div>
      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Order</th>
              <th className="p-4">Category</th>
              <th className="p-4">Question</th>
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {faqs?.map((faq) => (
              <tr key={faq._id} className="border-t border-gray-700/50">
                <td className="p-4 w-20 text-center font-bold">{faq.order}</td>
                <td className="p-4 font-semibold text-brand-muted">
                  {faq.category}
                </td>
                <td className="p-4 font-medium">{faq.question}</td>
                <td className="p-4 w-32">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      faq.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {faq.isActive ? "Active" : "Inactive"}
                  </span>
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <button
                    onClick={() => handleOpenEditModal(faq)}
                    className="text-blue-400 hover:text-blue-300"
                    title="Edit FAQ"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() => handleDelete(faq._id)}
                    className="text-red-400 hover:text-red-300"
                    title="Delete FAQ"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {faqs?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">No FAQs found.</p>
        )}
      </div>
      <FaqFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        faq={editingFaq}
      />
    </div>
  );
}

// ===== src/app/admin/file-manager/page.tsx =====

"use client";

import { useState, useRef, useEffect } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  UploadCloud,
  CheckCircle,
  XCircle,
  Loader2,
  Link as LinkIcon,
  FileText,
  Download,
  Copy,
  Trash2,
  RefreshCw,
} from "lucide-react";
import Image from "next/image";

interface UploadedFile {
  name: string;
  url: string;
  type: string;
  size: number;
}

const fetchUploadedFiles = async (): Promise<UploadedFile[]> => {
  const { data } = await axios.get("/api/upload");
  return data;
};

export default function AdminFileManagerPage() {
  const queryClient = useQueryClient();
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const [downloadUrl, setDownloadUrl] = useState("");
  const [downloadFileName, setDownloadFileName] = useState("");

  const {
    data: existingFiles,
    isLoading: isLoadingFiles,
    error: filesError,
    refetch: refetchFiles,
  } = useQuery<UploadedFile[]>({
    queryKey: ["uploadedFiles"],
    queryFn: fetchUploadedFiles,
    staleTime: 1000 * 60 * 5,
  });

  const [currentUploadedFiles, setCurrentUploadedFiles] = useState<
    UploadedFile[]
  >([]);

  useEffect(() => {
    if (existingFiles) {
      setCurrentUploadedFiles(existingFiles);
    }
  }, [existingFiles]);

  const uploadMutation = useMutation({
    mutationFn: (formData: FormData) => axios.post("/api/upload", formData),
    onSuccess: (data) => {
      toast.success("File uploaded successfully!");
      setCurrentUploadedFiles((prev) => [
        {
          name: data.data.name || selectedFile?.name || "Unknown File",
          url: data.data.url,
          type:
            data.data.type || selectedFile?.type || "application/octet-stream",
          size: data.data.size || selectedFile?.size || 0,
        },
        ...prev.filter((f) => f.url !== data.data.url),
      ]);
      setSelectedFile(null);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
      queryClient.invalidateQueries({ queryKey: ["uploadedFiles"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to upload file.");
      setSelectedFile(null);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    },
  });

  const downloadFromUrlMutation = useMutation({
    mutationFn: (payload: { url: string; fileName?: string }) =>
      axios.post("/api/admin/file-manager/download-from-url", payload),
    onSuccess: (data) => {
      toast.success("File downloaded from URL and uploaded!");
      setCurrentUploadedFiles((prev) => [
        {
          name: data.data.name,
          url: data.data.url,
          type: data.data.type,
          size: data.data.size,
        },
        ...prev.filter((f) => f.url !== data.data.url),
      ]);
      setDownloadUrl("");
      setDownloadFileName("");
      queryClient.invalidateQueries({ queryKey: ["uploadedFiles"] });
    },
    onError: (err: any) => {
      toast.error(
        err.response?.data?.error || "Failed to download file from URL."
      );
    },
  });

  const deleteFileMutation = useMutation({
    mutationFn: (fileKey: string) => axios.delete(`/api/upload?key=${fileKey}`),
    onSuccess: (_, fileKey) => {
      toast.success("File deleted successfully!");

      setCurrentUploadedFiles((prev) => prev.filter((f) => f.name !== fileKey));
      queryClient.invalidateQueries({ queryKey: ["uploadedFiles"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete file.");
    },
  });

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setSelectedFile(file);
    } else {
      setSelectedFile(null);
    }
  };

  const handleUpload = (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedFile) {
      toast.error("Please select a file to upload.");
      return;
    }
    const formData = new FormData();
    formData.append("file", selectedFile);
    uploadMutation.mutate(formData);
  };

  const handleDownloadFromUrl = (e: React.FormEvent) => {
    e.preventDefault();
    if (!downloadUrl.trim()) {
      toast.error("Please enter a URL.");
      return;
    }
    downloadFromUrlMutation.mutate({
      url: downloadUrl,
      fileName: downloadFileName.trim() || undefined,
    });
  };

  const handleDeleteFile = (fileKey: string, fileName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete "${fileName}"? This action cannot be undone.`
      )
    ) {
      deleteFileMutation.mutate(fileKey);
    }
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
    toast.success("URL copied to clipboard!");
  };

  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  };

  const isUploading =
    uploadMutation.isPending || downloadFromUrlMutation.isPending;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <FileText size={28} /> File Manager
        </h1>
      </div>

      {}
      <div className="bg-brand-secondary p-6 rounded-lg mb-8 shadow-xl">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
          <UploadCloud size={24} /> Upload New File
        </h2>
        <form onSubmit={handleUpload} className="space-y-4">
          <div>
            <label
              htmlFor="file-upload"
              className="block text-sm font-medium text-brand-light mb-2"
            >
              Select File
            </label>
            <input
              id="file-upload"
              type="file"
              ref={fileInputRef}
              onChange={handleFileChange}
              className="w-full text-brand-light bg-gray-700 border border-gray-600 rounded-lg p-3 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-brand-purple file:text-white hover:file:opacity-90 cursor-pointer"
              disabled={isUploading}
            />
            {selectedFile && (
              <p className="mt-2 text-sm text-brand-muted">
                Selected: {selectedFile.name} (
                {formatFileSize(selectedFile.size)})
              </p>
            )}
          </div>
          <div className="flex justify-end">
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={!selectedFile || isUploading}
            >
              {uploadMutation.isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {uploadMutation.isPending ? "Uploading..." : "Upload File"}
            </button>
          </div>
        </form>
      </div>

      {}
      <div className="bg-brand-secondary p-6 rounded-lg mb-8 shadow-xl">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
          <Download size={24} /> Download from URL
        </h2>
        <form onSubmit={handleDownloadFromUrl} className="space-y-4">
          <div>
            <label
              htmlFor="download-url"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              File URL
            </label>
            <input
              id="download-url"
              type="url"
              value={downloadUrl}
              onChange={(e) => setDownloadUrl(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              placeholder="e.g., https://example.com/image.jpg"
              required
              disabled={isUploading}
            />
          </div>
          <div>
            <label
              htmlFor="download-filename"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Optional File Name (on S3)
            </label>
            <input
              id="download-filename"
              type="text"
              value={downloadFileName}
              onChange={(e) => setDownloadFileName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              placeholder="e.g., my-custom-image (extension will be added automatically)"
              disabled={isUploading}
            />
          </div>
          <div className="flex justify-end">
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={!downloadUrl.trim() || isUploading}
            >
              {downloadFromUrlMutation.isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <Download size={18} />
              )}
              {downloadFromUrlMutation.isPending
                ? "Downloading..."
                : "Download & Upload"}
            </button>
          </div>
        </form>
      </div>

      {}
      <div className="bg-brand-secondary rounded-lg overflow-hidden shadow-xl">
        <div className="p-6">
          <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
            <LinkIcon size={24} /> Uploaded Files
            <button
              onClick={() => refetchFiles()}
              className="ml-auto text-brand-muted hover:text-white flex items-center gap-1 text-sm"
              disabled={isLoadingFiles || deleteFileMutation.isPending}
            >
              <RefreshCw
                size={16}
                className={isLoadingFiles ? "animate-spin" : ""}
              />{" "}
              Refresh
            </button>
          </h2>
        </div>

        {isLoadingFiles ? (
          <p className="text-center p-8 text-brand-muted">
            Loading files from S3...
          </p>
        ) : filesError ? (
          <p className="text-center p-8 text-red-400">
            Failed to load files from S3: {filesError.message}
          </p>
        ) : currentUploadedFiles.length === 0 ? (
          <p className="text-center p-8 text-brand-muted">
            No files uploaded yet.
          </p>
        ) : (
          <div className="overflow-x-auto">
            <table className="w-full text-left text-brand-light">
              <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
                <tr>
                  <th className="p-4">Preview</th>
                  <th className="p-4">File Name</th>
                  <th className="p-4">Type</th>
                  <th className="p-4">Size</th>
                  <th className="p-4">Public URL</th>
                  <th className="p-4">Actions</th>
                </tr>
              </thead>
              <tbody>
                {currentUploadedFiles.map(
                  (
                    file
                  ) => (
                    <tr key={file.url} className="border-t border-gray-700/50">
                      <td className="p-4">
                        {file.type.startsWith("image/") ? (
                          <Image
                            src={file.url}
                            alt={file.name}
                            width={80}
                            height={45}
                            objectFit="contain"
                            className="rounded-md bg-gray-700"
                          />
                        ) : (
                          <div className="w-20 h-10 bg-gray-700 flex items-center justify-center text-xs text-brand-muted rounded-md">
                            File
                          </div>
                        )}
                      </td>
                      <td
                        className="p-4 font-medium max-w-xs truncate"
                        title={file.name}
                      >
                        {file.name}
                      </td>
                      <td className="p-4 text-brand-muted text-sm">
                        {file.type.split("/")[1] || file.type}
                      </td>
                      <td className="p-4 text-brand-muted text-sm">
                        {formatFileSize(file.size)}
                      </td>
                      <td className="p-4 max-w-sm truncate">
                        <a
                          href={file.url}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="text-blue-400 hover:underline text-sm"
                          title={file.url}
                        >
                          {file.url}
                        </a>
                      </td>
                      <td className="p-4 flex gap-2 items-center">
                        <button
                          onClick={() => copyToClipboard(file.url)}
                          className="text-brand-purple hover:text-brand-purple/80 p-1 rounded-full bg-brand-dark"
                          title="Copy URL"
                        >
                          <Copy size={18} />
                        </button>
                        <button
                          onClick={() => handleDeleteFile(file.name, file.name)}
                          className="text-red-400 hover:text-red-300 p-1 rounded-full bg-brand-dark"
                          title="Delete File"
                          disabled={
                            deleteFileMutation.isPending &&
                            deleteFileMutation.variables === file.name
                          }
                        >
                          {deleteFileMutation.isPending &&
                          deleteFileMutation.variables === file.name ? (
                            <Loader2 size={18} className="animate-spin" />
                          ) : (
                            <Trash2 size={18} />
                          )}
                        </button>
                      </td>
                    </tr>
                  )
                )}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/app/admin/languages/page.tsx =====

"use client";

import { useState, useEffect, useMemo } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { ILanguage } from "@/models/Language";
import {
  PlusCircle,
  Edit,
  Trash2,
  CheckCircle,
  XCircle,
  Loader2,
  Languages,
  Save,
  FileJson,
  UploadCloud,
} from "lucide-react";
import Image from "next/image";

interface LanguageFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  language?: ILanguage | null;
  onSave: () => void;
}

const LanguageFormModal: React.FC<LanguageFormModalProps> = ({
  isOpen,
  onClose,
  language,
  onSave,
}) => {
  const [name, setName] = useState("");
  const [code, setCode] = useState("");
  const [isActive, setIsActive] = useState(true);
  const [flagUrl, setFlagUrl] = useState<string | undefined>(undefined);
  const [isUploading, setIsUploading] = useState(false);

  useEffect(() => {
    if (language) {
      setName(language.name);
      setCode(language.code);
      setIsActive(language.isActive);
      setFlagUrl(language.flagUrl);
    } else {
      setName("");
      setCode("");
      setIsActive(true);
      setFlagUrl(undefined);
    }
  }, [language]);

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setIsUploading(true);
    const formData = new FormData();
    formData.append("file", file);

    try {
      const { data } = await axios.post("/api/upload", formData);
      setFlagUrl(data.url);
      toast.success("Flag uploaded successfully!");
    } catch (error) {
      toast.error("Flag upload failed. Please try again.");
    } finally {
      setIsUploading(false);
    }
  };

  const mutation = useMutation({
    mutationFn: (payload: Partial<ILanguage>) =>
      language?._id
        ? axios.put(`/api/admin/languages/${language._id}`, payload)
        : axios.post("/api/admin/languages", payload),
    onSuccess: () => {
      toast.success(
        `Language ${language ? "updated" : "created"} successfully!`
      );
      onSave();
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to save language.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    mutation.mutate({ name, code, isActive, flagUrl });
  };

  const isMutationPending = mutation.isPending || isUploading;

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-lg">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {language ? "Edit Language" : "Add New Language"}
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label
              htmlFor="name"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Language Name
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white"
              required
              disabled={isMutationPending}
              placeholder="e.g., German"
            />
          </div>
          <div>
            <label
              htmlFor="code"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Language Code (ISO 639-1)
            </label>
            <input
              id="code"
              type="text"
              value={code}
              onChange={(e) => setCode(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white"
              required
              disabled={isMutationPending || !!language}
              placeholder="e.g., de"
            />
            {!!language && (
              <p className="text-xs text-brand-muted mt-1">
                Language code cannot be changed after creation.
              </p>
            )}
          </div>
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">
              Flag Image (Optional)
            </label>
            <div className="mt-2 flex items-center gap-4">
              <div className="w-16 h-12 flex-shrink-0 bg-gray-700 rounded-md flex items-center justify-center">
                {flagUrl ? (
                  <Image
                    src={flagUrl}
                    alt="Flag preview"
                    width={48}
                    height={32}
                    objectFit="contain"
                  />
                ) : (
                  <UploadCloud className="w-8 h-8 text-gray-500" />
                )}
              </div>
              <label
                htmlFor="flag-upload"
                className="relative cursor-pointer bg-gray-600 py-2 px-3 border border-gray-500 rounded-md shadow-sm text-sm leading-4 font-medium text-white hover:bg-gray-700"
              >
                <span>{isUploading ? "Uploading..." : "Upload File"}</span>
                <input
                  id="flag-upload"
                  name="flag-upload"
                  type="file"
                  className="sr-only"
                  onChange={handleImageUpload}
                  disabled={isUploading}
                  accept="image/png, image/jpeg, image/svg+xml, image/webp"
                />
              </label>
            </div>
          </div>
          <div className="flex items-center">
            <input
              id="isActive"
              type="checkbox"
              checked={isActive}
              onChange={(e) => setIsActive(e.target.checked)}
              className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded"
              disabled={isMutationPending}
            />
            <label
              htmlFor="isActive"
              className="ml-2 text-sm font-medium text-brand-light"
            >
              Active (Visible on site)
            </label>
          </div>
          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
              disabled={isMutationPending}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg disabled:opacity-50 flex items-center gap-2"
              disabled={isMutationPending}
            >
              {isMutationPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {isUploading
                ? "Uploading..."
                : mutation.isPending
                ? "Saving..."
                : "Save Language"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default function AdminLanguagesPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingLanguage, setEditingLanguage] = useState<ILanguage | null>(
    null
  );
  const [selectedLocale, setSelectedLocale] = useState("");
  const [translationContent, setTranslationContent] = useState("");

  const { data: languages = [], isLoading: isLoadingLanguages } = useQuery<
    ILanguage[]
  >({
    queryKey: ["languages"],
    queryFn: () => axios.get("/api/admin/languages").then((res) => res.data),
  });

  const { data: defaultLanguageFileContent, isLoading: isLoadingDefaultFile } =
    useQuery<string>({
      queryKey: ["translations", "tr"],
      queryFn: () =>
        axios
          .get("/api/admin/translations?locale=tr")
          .then((res) => JSON.stringify(res.data, null, 2)),
      enabled: true,
      staleTime: Infinity,
    });

  const { refetch: fetchTranslationFile, isFetching: isFetchingFile } =
    useQuery({
      queryKey: ["translations", selectedLocale],
      queryFn: () =>
        axios
          .get(`/api/admin/translations?locale=${selectedLocale}`)
          .then((res) => JSON.stringify(res.data, null, 2)),
      enabled: false,
      onSuccess: (data) => setTranslationContent(data),
      onError: () =>
        toast.error(`Could not load translations for ${selectedLocale}.`),
    });

  useEffect(() => {
    if (selectedLocale) {
      fetchTranslationFile();
    } else {
      setTranslationContent("");
    }
  }, [selectedLocale, fetchTranslationFile]);

  const updateLanguageMutation = useMutation({
    mutationFn: ({
      id,
      payload,
    }: {
      id: string;
      payload: Partial<ILanguage>;
    }) => axios.put(`/api/admin/languages/${id}`, payload),
    onSuccess: () => {
      toast.success("Language status updated!");
      queryClient.invalidateQueries({ queryKey: ["languages"] });
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "Update failed."),
  });

  const deleteLanguageMutation = useMutation({
    mutationFn: (id: string) => axios.delete(`/api/admin/languages/${id}`),
    onSuccess: () => {
      toast.success("Language deleted!");
      queryClient.invalidateQueries({ queryKey: ["languages"] });
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "Deletion failed."),
  });

  const saveTranslationsMutation = useMutation({
    mutationFn: ({ locale, content }: { locale: string; content: string }) =>
      axios.post("/api/admin/translations", { locale, content }),
    onSuccess: () =>
      toast.success(`Translations for '${selectedLocale}' saved!`),
    onError: (err: any) =>
      toast.error(
        err.response?.data?.error || "Save failed. Check JSON format."
      ),
  });

  const handleOpenEditModal = (lang: ILanguage) => {
    setEditingLanguage(lang);
    setIsModalOpen(true);
  };

  const handleDelete = (lang: ILanguage) => {
    if (
      window.confirm(
        `Are you sure you want to delete "${lang.name}"? This will also delete its translation file and cannot be undone.`
      )
    ) {
      deleteLanguageMutation.mutate(lang._id);
    }
  };

  const handleSetDefault = (langId: string) => {
    updateLanguageMutation.mutate({ id: langId, payload: { isDefault: true } });
  };

  const handleSaveTranslations = () => {
    if (!selectedLocale) return;
    saveTranslationsMutation.mutate({
      locale: selectedLocale,
      content: translationContent,
    });
  };

  const activeLanguages = useMemo(
    () => languages.filter((l) => l.isActive),
    [languages]
  );

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Languages size={28} /> Manage Languages
        </h1>
        <button
          onClick={() => {
            setEditingLanguage(null);
            setIsModalOpen(true);
          }}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} /> New Language
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto mb-8">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Language</th>
              <th className="p-4">Code</th>
              <th className="p-4">Status</th>
              <th className="p-4">Default</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {isLoadingLanguages ? (
              <tr>
                <td colSpan={5} className="p-8 text-center text-brand-muted">
                  Loading languages...
                </td>
              </tr>
            ) : (
              languages.map((lang) => (
                <tr key={lang._id} className="border-t border-gray-700/50">
                  <td className="p-4 font-medium">{lang.name}</td>
                  <td className="p-4 text-brand-muted">{lang.code}</td>
                  <td className="p-4">
                    <span
                      className={`px-2 py-1 text-xs font-semibold rounded-full ${
                        lang.isActive
                          ? "bg-green-500/20 text-green-400"
                          : "bg-red-500/20 text-red-400"
                      }`}
                    >
                      {lang.isActive ? "Active" : "Inactive"}
                    </span>
                  </td>
                  <td className="p-4">
                    {lang.isDefault ? (
                      <span className="font-bold text-green-400">Yes</span>
                    ) : (
                      <button
                        onClick={() => handleSetDefault(lang._id)}
                        className="text-xs text-brand-muted hover:text-white"
                        disabled={updateLanguageMutation.isPending}
                      >
                        Set
                      </button>
                    )}
                  </td>
                  <td className="p-4 flex gap-3 items-center h-full">
                    <button
                      onClick={() => handleOpenEditModal(lang)}
                      className="text-blue-400 hover:text-blue-300"
                      title="Edit"
                    >
                      <Edit size={18} />
                    </button>
                    <button
                      onClick={() => handleDelete(lang)}
                      className="text-red-400 hover:text-red-300"
                      title="Delete"
                      disabled={lang.isDefault}
                    >
                      <Trash2 size={18} />
                    </button>
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>

      <div className="bg-brand-secondary rounded-lg p-6">
        <h2 className="text-2xl font-bold text-white mb-4 flex items-center gap-2">
          <FileJson size={24} /> Translation Editor
        </h2>
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div>
            <label className="block text-sm font-medium text-brand-light mb-2">
              1. Select a language to edit
            </label>
            <select
              value={selectedLocale}
              onChange={(e) => setSelectedLocale(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            >
              <option value="">-- Select --</option>
              {activeLanguages.map((l) => (
                <option key={l._id} value={l.code}>
                  {l.name} ({l.code})
                </option>
              ))}
            </select>
            <div className="mt-4">
              <label className="block text-sm font-medium text-brand-light mb-2">
                2. Edit JSON content
              </label>
              <textarea
                value={translationContent}
                onChange={(e) => setTranslationContent(e.target.value)}
                className="w-full h-96 p-3 font-mono text-sm rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
                disabled={!selectedLocale || isFetchingFile}
                placeholder={
                  isFetchingFile
                    ? "Loading..."
                    : "Select a language to load translations."
                }
              />
            </div>
            <button
              onClick={handleSaveTranslations}
              className="mt-4 flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
              disabled={!selectedLocale || saveTranslationsMutation.isPending}
            >
              {saveTranslationsMutation.isPending ? (
                <Loader2 className="animate-spin" size={18} />
              ) : (
                <Save size={18} />
              )}
              Save "{selectedLocale}" Translations
            </button>
          </div>
          <div>
            <label className="block text-sm font-medium text-brand-light mb-2">
              Default Keys Reference (Turkish - read-only)
            </label>
            <textarea
              value={defaultLanguageFileContent || ""}
              readOnly
              className="w-full h-[540px] p-3 font-mono text-sm rounded bg-gray-800/50 text-brand-muted border border-gray-700 resize-none"
              placeholder={
                isLoadingDefaultFile
                  ? "Loading default keys..."
                  : "Default keys could not be loaded."
              }
            />
          </div>
        </div>
      </div>

      <LanguageFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        language={editingLanguage}
        onSave={() =>
          queryClient.invalidateQueries({ queryKey: ["languages"] })
        }
      />
    </div>
  );
}

// ===== src/app/admin/layout.tsx =====

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { redirect } from "next/navigation";
import AdminSidebar from "@/components/admin/AdminSidebar";
import NextAuthProvider from "../NextAuthProvider";
import Providers from "../providers";
import "../globals.css";

export const metadata = {
  title: "FanSkor Admin Panel",
  description: "Management dashboard for FanSkor.",
  robots: {
    index: false,
    follow: false,
  },
};

export default async function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await getServerSession(authOptions);

  if (!session || session.user.role !== "admin") {
    redirect("/login?error=Forbidden");
  }

  return (
    <NextAuthProvider>
      <Providers>
        <div className="flex min-h-screen bg-brand-dark">
          {" "}
          {}
          <AdminSidebar />
          <main className="flex-1 p-8">{children}</main>
        </div>
      </Providers>
    </NextAuthProvider>
  );

}

// ===== src/app/admin/news/create/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { useMutation, useQuery } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import Link from "@/components/StyledLink";
import Image from "next/image";
import { UploadCloud, XCircle, Save, Loader2 } from "lucide-react";
import RichTextEditor from "@/components/admin/RichTextEditor";
import { SportsCategory, NewsType } from "@/models/Post";
import { ILanguage } from "@/models/Language";
import slugify from "slugify";

const fetchActiveLanguages = async (): Promise<ILanguage[]> => {
  const { data } = await axios.get("/api/admin/languages?active=true");
  return data;
};

const availableSportsCategories: { id: SportsCategory; label: string }[] = [
  { id: "football", label: "Football" },
  { id: "basketball", label: "Basketball" },
  { id: "tennis", label: "Tennis" },
  { id: "general", label: "General" },
];

const availableNewsTypes: { id: NewsType; label: string }[] = [
  { id: "news", label: "General News" },
  { id: "highlights", label: "Highlights" },
  { id: "reviews", label: "Match Review" },
  { id: "prediction", label: "Prediction/Analysis" },
];

export default function CreateNewsPostPage() {
  const router = useRouter();
  const searchParams = useSearchParams();

  const [language, setLanguage] = useState("");
  const [translationGroupId, setTranslationGroupId] = useState<
    string | undefined
  >(undefined);
  const [title, setTitle] = useState("");
  const [slug, setSlug] = useState("");
  const [isSlugManuallyEdited, setIsSlugManuallyEdited] = useState(false);
  const [content, setContent] = useState("");
  const [status, setStatus] = useState<"draft" | "published">("draft");
  const [metaTitle, setMetaTitle] = useState("");
  const [metaDescription, setMetaDescription] = useState("");
  const [featuredImage, setFeaturedImage] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [imageTitle, setImageTitle] = useState("");
  const [imageAltText, setImageAltText] = useState("");
  const [selectedSportsCategories, setSelectedSportsCategories] = useState<
    SportsCategory[]
  >(["general"]);
  const [newsType, setNewsType] = useState<NewsType>("news");
  const [linkedFixtureId, setLinkedFixtureId] = useState("");
  const [linkedLeagueId, setLinkedLeagueId] = useState("");
  const [linkedTeamId, setLinkedTeamId] = useState("");

  const { data: languages, isLoading: isLoadingLanguages } = useQuery<
    ILanguage[]
  >({
    queryKey: ["activeLanguages"],
    queryFn: fetchActiveLanguages,
  });

  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newTitle = e.target.value;
    setTitle(newTitle);
    if (!isSlugManuallyEdited) {
      const newSlug = slugify(newTitle, {
        lower: true,
        strict: true,
        remove: /[*+~.()'"!:@]/g,
      });
      setSlug(newSlug);

      setMetaTitle(newTitle);
    }
  };

  const handleSlugChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setIsSlugManuallyEdited(true);
    setSlug(e.target.value);
  };

  useEffect(() => {
    const fromGroupId = searchParams.get("from");
    const langCode = searchParams.get("lang");
    const fromTitle = searchParams.get("title");
    const fromImage = searchParams.get("image");
    const fromCategories = searchParams.get("categories");

    if (fromGroupId && langCode && fromTitle) {
      setTranslationGroupId(fromGroupId);
      setLanguage(langCode);
      setTitle(fromTitle);
      const newSlug = slugify(fromTitle, {
        lower: true,
        strict: true,
        remove: /[*+~.()'"!:@]/g,
      });
      setSlug(newSlug);
      setMetaTitle(fromTitle);

      if (fromImage) setFeaturedImage(fromImage);
      if (fromCategories)
        setSelectedSportsCategories(
          fromCategories.split(",") as SportsCategory[]
        );

      toast.success(`Creating new translation for "${langCode.toUpperCase()}"`);
    }
  }, [searchParams]);

  const handleSportsCategoryChange = (category: SportsCategory) => {
    setSelectedSportsCategories((prev) => {
      if (prev.includes(category)) {
        return prev.length > 1 ? prev.filter((c) => c !== category) : prev;
      }
      return [...prev, category];
    });
  };

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    setIsUploading(true);
    const formData = new FormData();
    formData.append("file", file);
    try {
      const { data } = await axios.post("/api/upload", formData);
      setFeaturedImage(data.url);
      toast.success("Image uploaded!");
    } catch (error) {
      toast.error("Image upload failed.");
    } finally {
      setIsUploading(false);
    }
  };

  const createPostMutation = useMutation({
    mutationFn: (newPost: any) => axios.post("/api/posts", newPost),
    onSuccess: () => {
      toast.success("Post created successfully!");
      router.push("/admin/news");
      router.refresh();
    },
    onError: (error: any) =>
      toast.error(error.response?.data?.error || "Failed to create post."),
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!title.trim() || !content.trim() || !language) {
      toast.error("Title, Content, and Language are required.");
      return;
    }
    createPostMutation.mutate({
      title,
      slug,
      content,
      status,
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle: imageTitle,
      featuredImageAltText: imageAltText,
      sportsCategory: selectedSportsCategories,
      newsType,
      linkedFixtureId: linkedFixtureId ? Number(linkedFixtureId) : undefined,
      linkedLeagueId: linkedLeagueId ? Number(linkedLeagueId) : undefined,
      linkedTeamId: linkedTeamId ? Number(linkedTeamId) : undefined,
      language,
      translationGroupId,
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">
          {translationGroupId ? "Create New Translation" : "Create New Post"}
        </h1>
        <div className="flex gap-4">
          <Link
            href="/admin/news"
            className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
          >
            Cancel
          </Link>
          <button
            type="submit"
            disabled={createPostMutation.isPending || isUploading}
            className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 flex items-center gap-2"
          >
            {createPostMutation.isPending ? (
              <Loader2 size={18} className="animate-spin" />
            ) : (
              <Save size={18} />
            )}
            {createPostMutation.isPending ? "Saving..." : "Save Post"}
          </button>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 items-start">
        <div className="lg:col-span-2 space-y-6">
          <div className="bg-brand-secondary p-6 rounded-lg space-y-6">
            <div>
              <label
                htmlFor="title"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                Title
              </label>
              <input
                id="title"
                type="text"
                value={title}
                onChange={handleTitleChange}
                required
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
            </div>
            <div>
              <label
                htmlFor="slug"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                URL Slug
              </label>
              <input
                id="slug"
                type="text"
                value={slug}
                onChange={handleSlugChange}
                required
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
            </div>
          </div>
          <div className="bg-brand-secondary rounded-lg">
            <div className="p-6 border-b border-gray-700 sticky top-0 bg-brand-secondary z-10">
              <label className="text-lg font-semibold text-white">
                Content
              </label>
            </div>
            <div className="p-6">
              <RichTextEditor value={content} onChange={setContent} />
            </div>
          </div>
        </div>

        <aside className="lg:col-span-1 space-y-6 lg:sticky top-8">
          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">Publishing</h3>
            <div>
              <label
                htmlFor="status"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                Status
              </label>
              <select
                id="status"
                value={status}
                onChange={(e) =>
                  setStatus(e.target.value as "draft" | "published")
                }
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              >
                <option value="draft">Draft</option>
                <option value="published">Published</option>
              </select>
            </div>
            <div>
              <label
                htmlFor="language"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                Language
              </label>
              <select
                id="language"
                value={language}
                onChange={(e) => setLanguage(e.target.value)}
                required
                disabled={isLoadingLanguages || !!translationGroupId}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 disabled:bg-gray-700/50 disabled:cursor-not-allowed"
              >
                <option value="" disabled>
                  {isLoadingLanguages ? "Loading..." : "Select..."}
                </option>
                {languages?.map((lang) => (
                  <option key={lang._id} value={lang.code}>
                    {lang.name}
                  </option>
                ))}
              </select>
            </div>
          </div>

          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">Categorization</h3>
            <div>
              <label className="block text-sm font-medium text-brand-light mb-2">
                Sports Categories
              </label>
              <div className="space-y-2">
                {availableSportsCategories.map((category) => (
                  <div key={category.id} className="flex items-center">
                    <input
                      id={`category-${category.id}`}
                      type="checkbox"
                      checked={selectedSportsCategories.includes(category.id)}
                      onChange={() => handleSportsCategoryChange(category.id)}
                      className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded"
                    />
                    <label
                      htmlFor={`category-${category.id}`}
                      className="ml-3 text-sm font-medium text-brand-light"
                    >
                      {category.label}
                    </label>
                  </div>
                ))}
              </div>
            </div>
            <div>
              <label
                htmlFor="newsType"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                News Type
              </label>
              <select
                id="newsType"
                value={newsType}
                onChange={(e) => setNewsType(e.target.value as NewsType)}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              >
                {availableNewsTypes.map((type) => (
                  <option key={type.id} value={type.id}>
                    {type.label}
                  </option>
                ))}
              </select>
            </div>
          </div>

          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">Featured Image</h3>
            <div className="mt-2 flex justify-center rounded-lg border border-dashed border-gray-600 px-4 py-6">
              {featuredImage ? (
                <div className="relative group w-full h-32">
                  <Image
                    src={featuredImage}
                    alt="Featured preview"
                    layout="fill"
                    objectFit="contain"
                  />
                  <button
                    type="button"
                    onClick={() => setFeaturedImage(null)}
                    className="absolute top-1 right-1 bg-red-600 rounded-full p-0.5 text-white opacity-0 group-hover:opacity-100"
                  >
                    <XCircle size={16} />
                  </button>
                </div>
              ) : (
                <div className="text-center">
                  <UploadCloud className="mx-auto h-10 w-10 text-gray-500" />
                  <div className="mt-2 flex text-sm text-gray-400">
                    <label
                      htmlFor="file-upload"
                      className="relative cursor-pointer rounded-md font-semibold text-brand-purple hover:text-brand-purple/80"
                    >
                      <span>{isUploading ? "Uploading..." : "Upload"}</span>
                      <input
                        id="file-upload"
                        name="file-upload"
                        type="file"
                        className="sr-only"
                        onChange={handleImageUpload}
                        disabled={isUploading}
                        accept="image}
          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">SEO & Linking</h3>
            <div>
              <label
                htmlFor="metaTitle"
                className="block text-sm font-medium text-brand-light mb-1"
              >
                Meta Title
              </label>
              <input
                id="metaTitle"
                type="text"
                value={metaTitle}
                onChange={(e) => setMetaTitle(e.target.value)}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              />
            </div>
            <div>
              <label
                htmlFor="metaDescription"
                className="block text-sm font-medium text-brand-light mb-1"
              >
                Meta Description
              </label>
              <textarea
                id="metaDescription"
                value={metaDescription}
                onChange={(e) => setMetaDescription(e.target.value)}
                rows={3}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              ></textarea>
            </div>
            <div className="grid grid-cols-1 gap-2 pt-2 border-t border-gray-700/50">
              <div>
                <label
                  htmlFor="linkedFixtureId"
                  className="block text-xs font-medium text-brand-light mb-1"
                >
                  Linked Fixture ID
                </label>
                <input
                  id="linkedFixtureId"
                  type="number"
                  value={linkedFixtureId}
                  onChange={(e) => setLinkedFixtureId(e.target.value)}
                  className="w-full p-2 text-sm rounded bg-gray-700 text-white border border-gray-600"
                />
              </div>
              <div>
                <label
                  htmlFor="linkedLeagueId"
                  className="block text-xs font-medium text-brand-light mb-1"
                >
                  Linked League ID
                </label>
                <input
                  id="linkedLeagueId"
                  type="number"
                  value={linkedLeagueId}
                  onChange={(e) => setLinkedLeagueId(e.target.value)}
                  className="w-full p-2 text-sm rounded bg-gray-700 text-white border border-gray-600"
                />
              </div>
              <div>
                <label
                  htmlFor="linkedTeamId"
                  className="block text-xs font-medium text-brand-light mb-1"
                >
                  Linked Team ID
                </label>
                <input
                  id="linkedTeamId"
                  type="number"
                  value={linkedTeamId}
                  onChange={(e) => setLinkedTeamId(e.target.value)}
                  className="w-full p-2 text-sm rounded bg-gray-700 text-white border border-gray-600"
                />
              </div>
            </div>
          </div>
        </aside>
      </div>
    </form>
  );
}

// ===== src/app/admin/news/edit/[postId]/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useRouter, useParams } from "next/navigation";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import Image from "next/image";
import slugify from "slugify";

import StyledLink from "@/components/StyledLink";
import RichTextEditor from "@/components/admin/RichTextEditor";
import TranslationsWidget from "@/components/admin/TranslationsWidget";

import { UploadCloud, XCircle, Save, Loader2 } from "lucide-react";

import { IPost, SportsCategory, NewsType } from "@/models/Post";

const availableSportsCategories: { id: SportsCategory; label: string }[] = [
  { id: "football", label: "Football" },
  { id: "basketball", label: "Basketball" },
  { id: "tennis", label: "Tennis" },
  { id: "general", label: "General" },
];

const availableNewsTypes: { id: NewsType; label: string }[] = [
  { id: "news", label: "General News" },
  { id: "highlights", label: "Highlights" },
  { id: "reviews", label: "Match Review" },
  { id: "prediction", label: "Prediction/Analysis" },
];

const fetchPost = async (postId: string): Promise<IPost> => {
  const { data } = await axios.get(`/api/posts/${postId}`);
  return data;
};

export default function EditNewsPostPage() {
  const router = useRouter();
  const params = useParams();
  const queryClient = useQueryClient();
  const postId = params.postId as string;

  const [title, setTitle] = useState("");
  const [slug, setSlug] = useState("");
  const [isSlugManuallyEdited, setIsSlugManuallyEdited] = useState(true);
  const [content, setContent] = useState("");
  const [status, setStatus] = useState<"draft" | "published">("draft");
  const [metaTitle, setMetaTitle] = useState("");
  const [metaDescription, setMetaDescription] = useState("");
  const [featuredImage, setFeaturedImage] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [imageTitle, setImageTitle] = useState("");
  const [imageAltText, setImageAltText] = useState("");
  const [selectedSportsCategories, setSelectedSportsCategories] = useState<
    SportsCategory[]
  >([]);
  const [newsType, setNewsType] = useState<NewsType>("news");
  const [linkedFixtureId, setLinkedFixtureId] = useState("");
  const [linkedLeagueId, setLinkedLeagueId] = useState("");
  const [linkedTeamId, setLinkedTeamId] = useState("");
  const [language, setLanguage] = useState("");
  const [translationGroupId, setTranslationGroupId] = useState("");

  const {
    data: postData,
    isLoading,
    isError,
  } = useQuery<IPost>({
    queryKey: ["post", postId],
    queryFn: () => fetchPost(postId),
    enabled: !!postId,
  });

  useEffect(() => {
    if (postData) {
      setTitle(postData.title || "");
      setSlug(postData.slug || "");
      setContent(postData.content || "");
      setStatus(postData.status || "draft");
      setMetaTitle(postData.metaTitle || "");
      setMetaDescription(postData.metaDescription || "");
      setFeaturedImage(postData.featuredImage || null);
      setImageTitle(postData.featuredImageTitle || "");
      setImageAltText(postData.featuredImageAltText || "");
      setSelectedSportsCategories(
        Array.isArray(postData.sportsCategory) &&
          postData.sportsCategory.length > 0
          ? postData.sportsCategory
          : ["general"]
      );
      setNewsType(postData.newsType || "news");
      setLinkedFixtureId(postData.linkedFixtureId?.toString() || "");
      setLinkedLeagueId(postData.linkedLeagueId?.toString() || "");
      setLinkedTeamId(postData.linkedTeamId?.toString() || "");
      setLanguage(postData.language || "");
      setTranslationGroupId(postData.translationGroupId?.toString() || "");
      setIsSlugManuallyEdited(true);
    }
  }, [postData]);

  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newTitle = e.target.value;
    setTitle(newTitle);
    if (!isSlugManuallyEdited) {
      setSlug(
        slugify(newTitle, {
          lower: true,
          strict: true,
          remove: /[*+~.()'"!:@]/g,
        })
      );
    }
  };

  const handleSlugChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setIsSlugManuallyEdited(true);
    setSlug(e.target.value);
  };

  const handleSportsCategoryChange = (category: SportsCategory) => {
    setSelectedSportsCategories((prev) => {
      if (prev.includes(category)) {
        return prev.length > 1 ? prev.filter((c) => c !== category) : prev;
      }
      return [...prev, category];
    });
  };

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    setIsUploading(true);
    const formData = new FormData();
    formData.append("file", file);
    try {
      const { data } = await axios.post("/api/upload", formData);
      setFeaturedImage(data.url);
      toast.success("Image uploaded!");
    } catch (error) {
      toast.error("Image upload failed.");
    } finally {
      setIsUploading(false);
    }
  };

  const updatePostMutation = useMutation({
    mutationFn: (updatedPost: Partial<IPost> & { slug?: string }) =>
      axios.put(`/api/posts/${postId}`, updatedPost),
    onSuccess: () => {
      toast.success("Post updated successfully!");
      queryClient.invalidateQueries({ queryKey: ["adminPosts"] });
      queryClient.invalidateQueries({ queryKey: ["post", postId] });
      router.push("/admin/news");
    },
    onError: (error: any) => {
      if (error.response && error.response.data && error.response.data.error) {
        toast.error(`Error: ${error.response.data.error}`);
      } else {
        toast.error("An unexpected error occurred while saving the post.");
      }
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!title.trim() || !content.trim()) {
      toast.error("Title and content cannot be empty.");
      return;
    }
    updatePostMutation.mutate({
      title,
      slug,
      content,
      status,
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle: imageTitle,
      featuredImageAltText: imageAltText,
      sportsCategory: selectedSportsCategories,
      newsType,
      linkedFixtureId: linkedFixtureId ? Number(linkedFixtureId) : undefined,
      linkedLeagueId: linkedLeagueId ? Number(linkedLeagueId) : undefined,
      linkedTeamId: linkedTeamId ? Number(linkedTeamId) : undefined,
    });
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading post data...</p>;
  if (isError) return <p className="text-red-400">Failed to load post data.</p>;

  return (
    <form onSubmit={handleSubmit}>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Edit Post</h1>
        <div className="flex gap-4">
          <StyledLink
            href="/admin/news"
            className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
          >
            Cancel
          </StyledLink>
          <button
            type="submit"
            disabled={updatePostMutation.isPending || isUploading}
            className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 flex items-center gap-2"
          >
            {updatePostMutation.isPending ? (
              <Loader2 size={18} className="animate-spin" />
            ) : (
              <Save size={18} />
            )}
            {updatePostMutation.isPending ? "Saving..." : "Save Changes"}
          </button>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 items-start">
        <div className="lg:col-span-2 space-y-6">
          <div className="bg-brand-secondary p-6 rounded-lg space-y-6">
            <div>
              <label
                htmlFor="title"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                Title
              </label>
              <input
                id="title"
                type="text"
                value={title}
                onChange={handleTitleChange}
                required
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
            </div>
            <div>
              <label
                htmlFor="slug"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                URL Slug
              </label>
              <input
                id="slug"
                type="text"
                value={slug}
                onChange={handleSlugChange}
                required
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
            </div>
          </div>
          <div className="bg-brand-secondary rounded-lg">
            <div className="p-6 border-b border-gray-700 sticky top-0 bg-brand-secondary z-10">
              <label className="text-lg font-semibold text-white">
                Content
              </label>
            </div>
            <div className="p-6">
              {postData && (
                <RichTextEditor value={content} onChange={setContent} />
              )}
            </div>
          </div>
        </div>

        <aside className="lg:col-span-1 space-y-6 lg:sticky top-8">
          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">Publishing</h3>
            <div>
              <label
                htmlFor="status"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                Status
              </label>
              <select
                id="status"
                value={status}
                onChange={(e) =>
                  setStatus(e.target.value as "draft" | "published")
                }
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              >
                <option value="draft">Draft</option>
                <option value="published">Published</option>
              </select>
            </div>
            <div>
              <label className="block text-sm font-medium text-brand-light mb-2">
                Language
              </label>
              <input
                type="text"
                value={language.toUpperCase()}
                readOnly
                disabled
                className="w-full p-2 rounded bg-gray-700/50 text-brand-muted border border-gray-600 cursor-not-allowed"
              />
            </div>
          </div>

          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">Categorization</h3>
            <div>
              <label className="block text-sm font-medium text-brand-light mb-2">
                Sports Categories
              </label>
              <div className="space-y-2">
                {availableSportsCategories.map((category) => (
                  <div key={category.id} className="flex items-center">
                    <input
                      id={`category-${category.id}`}
                      type="checkbox"
                      checked={selectedSportsCategories.includes(category.id)}
                      onChange={() => handleSportsCategoryChange(category.id)}
                      className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded"
                    />
                    <label
                      htmlFor={`category-${category.id}`}
                      className="ml-3 text-sm font-medium text-brand-light"
                    >
                      {category.label}
                    </label>
                  </div>
                ))}
              </div>
            </div>
            <div>
              <label
                htmlFor="newsType"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                News Type
              </label>
              <select
                id="newsType"
                value={newsType}
                onChange={(e) => setNewsType(e.target.value as NewsType)}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              >
                {availableNewsTypes.map((type) => (
                  <option key={type.id} value={type.id}>
                    {type.label}
                  </option>
                ))}
              </select>
            </div>
          </div>

          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">Featured Image</h3>
            <div className="mt-2 flex justify-center rounded-lg border border-dashed border-gray-600 px-4 py-6">
              {featuredImage ? (
                <div className="relative group w-full h-32">
                  <Image
                    src={featuredImage}
                    alt="Featured preview"
                    layout="fill"
                    objectFit="contain"
                  />
                  <button
                    type="button"
                    onClick={() => setFeaturedImage(null)}
                    className="absolute top-1 right-1 bg-red-600 rounded-full p-0.5 text-white opacity-0 group-hover:opacity-100"
                  >
                    <XCircle size={16} />
                  </button>
                </div>
              ) : (
                <div className="text-center">
                  <UploadCloud className="mx-auto h-10 w-10 text-gray-500" />
                  <div className="mt-2 flex text-sm text-gray-400">
                    <label
                      htmlFor="file-upload"
                      className="relative cursor-pointer rounded-md font-semibold text-brand-purple hover:text-brand-purple/80"
                    >
                      <span>{isUploading ? "Uploading..." : "Upload"}</span>
                      <input
                        id="file-upload"
                        name="file-upload"
                        type="file"
                        className="sr-only"
                        onChange={handleImageUpload}
                        disabled={isUploading}
                        accept="image}
          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">SEO & Linking</h3>
            <div>
              <label
                htmlFor="metaTitle"
                className="block text-sm font-medium text-brand-light mb-1"
              >
                Meta Title
              </label>
              <input
                id="metaTitle"
                type="text"
                value={metaTitle}
                onChange={(e) => setMetaTitle(e.target.value)}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              />
            </div>
            <div>
              <label
                htmlFor="metaDescription"
                className="block text-sm font-medium text-brand-light mb-1"
              >
                Meta Description
              </label>
              <textarea
                id="metaDescription"
                value={metaDescription}
                onChange={(e) => setMetaDescription(e.target.value)}
                rows={3}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              ></textarea>
            </div>
            <div className="grid grid-cols-1 gap-2 pt-2 border-t border-gray-700/50">
              <div>
                <label
                  htmlFor="linkedFixtureId"
                  className="block text-xs font-medium text-brand-light mb-1"
                >
                  Linked Fixture ID
                </label>
                <input
                  id="linkedFixtureId"
                  type="number"
                  value={linkedFixtureId}
                  onChange={(e) => setLinkedFixtureId(e.target.value)}
                  className="w-full p-2 text-sm rounded bg-gray-700 text-white border border-gray-600"
                />
              </div>
              <div>
                <label
                  htmlFor="linkedLeagueId"
                  className="block text-xs font-medium text-brand-light mb-1"
                >
                  Linked League ID
                </label>
                <input
                  id="linkedLeagueId"
                  type="number"
                  value={linkedLeagueId}
                  onChange={(e) => setLinkedLeagueId(e.target.value)}
                  className="w-full p-2 text-sm rounded bg-gray-700 text-white border border-gray-600"
                />
              </div>
              <div>
                <label
                  htmlFor="linkedTeamId"
                  className="block text-xs font-medium text-brand-light mb-1"
                >
                  Linked Team ID
                </label>
                <input
                  id="linkedTeamId"
                  type="number"
                  value={linkedTeamId}
                  onChange={(e) => setLinkedTeamId(e.target.value)}
                  className="w-full p-2 text-sm rounded bg-gray-700 text-white border border-gray-600"
                />
              </div>
            </div>
          </div>

          {translationGroupId && (
            <TranslationsWidget
              translationGroupId={translationGroupId}
              currentPostLanguage={language}
              currentPostTitle={title}
            />
          )}
        </aside>
      </div>
    </form>
  );
}

// ===== src/app/admin/news/page.tsx =====

"use client";

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import Link from "@/components/StyledLink";
import { PlusCircle } from "lucide-react";
import { IPost } from "@/models/Post";
import toast from "react-hot-toast";
import { useMemo } from "react";
import { ILanguage } from "@/models/Language";
import TranslationGroupRow from "@/components/admin/TranslationGroupRow";

const fetchAdminPosts = async (): Promise<IPost[]> => {
  const { data } = await axios.get("/api/admin/posts");
  return data;
};

const fetchLanguages = async (): Promise<ILanguage[]> => {
  const { data } = await axios.get("/api/admin/languages");
  return data;
};

export default function AdminNewsPage() {
  const queryClient = useQueryClient();

  const {
    data: posts,
    isLoading: isLoadingPosts,
    error: postsError,
  } = useQuery<IPost[]>({
    queryKey: ["adminPosts"],
    queryFn: fetchAdminPosts,
  });

  const { data: languages, isLoading: isLoadingLanguages } = useQuery<
    ILanguage[]
  >({
    queryKey: ["allLanguages"],
    queryFn: fetchLanguages,
  });

  const languageMap = useMemo(() => {
    if (!languages) return new Map<string, ILanguage>();
    return new Map(languages.map((lang) => [lang.code, lang]));
  }, [languages]);

  const groupedPosts = useMemo(() => {
    if (!posts) return [];
    const groups: Record<string, IPost[]> = {};
    posts.forEach((post) => {
      const groupId = (post.translationGroupId || post._id).toString();
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      groups[groupId].push(post);
    });

    return Object.values(groups).sort((a, b) => {
      const dateA = new Date(
        a.sort(
          (x, y) =>
            new Date(y.createdAt).getTime() - new Date(x.createdAt).getTime()
        )[0].createdAt
      ).getTime();
      const dateB = new Date(
        b.sort(
          (x, y) =>
            new Date(y.createdAt).getTime() - new Date(x.createdAt).getTime()
        )[0].createdAt
      ).getTime();
      return dateB - dateA;
    });
  }, [posts]);

  const deleteMutation = useMutation({
    mutationFn: (postId: string) => axios.delete(`/api/posts/${postId}`),
    onSuccess: (_, postId) => {

      queryClient.setQueryData(["adminPosts"], (oldData: IPost[] | undefined) =>
        oldData ? oldData.filter((post) => post._id !== postId) : []
      );
      toast.success("Post deleted successfully!");
    },
    onError: (error: any) => {
      const message = error.response?.data?.message || "Error deleting post.";
      toast.error(message);
    },
    onSettled: () => {

      queryClient.invalidateQueries({ queryKey: ["adminPosts"] });
    },
  });

  const handleDeletePost = (postId: string, title: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete the post "${title}"? This cannot be undone.`
      )
    ) {
      deleteMutation.mutate(postId);
    }
  };

  const isLoading = isLoadingPosts || isLoadingLanguages;

  if (isLoading) return <p className="text-brand-muted">Loading posts...</p>;
  if (postsError) return <p className="text-red-400">Failed to load posts.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Manage News</h1>
        <Link
          href="/admin/news/create"
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 transition-opacity"
        >
          <PlusCircle size={20} />
          <span>New Post</span>
        </Link>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-hidden">
        <table className="w-full text-left">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4 w-[140px]">Preview</th>
              <th className="p-4">Title & Language</th>
              <th className="p-4">Status</th>
              <th className="p-4">Created At</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {groupedPosts.map((group) => (
              <TranslationGroupRow
                key={
                  group[0].translationGroupId?.toString() ||
                  group[0]._id.toString()
                }
                group={group}
                languageMap={languageMap}
                onDelete={handleDeletePost}
              />
            ))}
          </tbody>
        </table>

        {posts?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No news posts found.
          </p>
        )}
      </div>
    </div>
  );
}

// ===== src/app/admin/pages/author/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { Loader2, Save, UserCircle } from "lucide-react";
import RichTextEditor from "@/components/admin/RichTextEditor";

const PAGE_SLUG = "author";

interface PageContentData {
  title: string;
  content: string;
}

const fetchPageContent = async (slug: string): Promise<PageContentData> => {
  const { data } = await axios.get(`/api/admin/pages/${slug}`);
  return data;
};

export default function EditAuthorPage() {
  const queryClient = useQueryClient();
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");

  const { data, isLoading, error } = useQuery<PageContentData>({
    queryKey: ["pageContent", PAGE_SLUG],
    queryFn: () => fetchPageContent(PAGE_SLUG),
  });

  useEffect(() => {
    if (data) {
      setTitle(data.title || "About the Author");
      setContent(data.content || "");
    }
  }, [data]);

  const mutation = useMutation({
    mutationFn: (pageData: PageContentData) =>
      axios.post(`/api/admin/pages/${PAGE_SLUG}`, pageData),
    onSuccess: () => {
      toast.success("Author page content saved successfully!");
      queryClient.invalidateQueries({ queryKey: ["pageContent", PAGE_SLUG] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to save content.");
    },
  });

  const handleSave = () => {
    if (!title.trim() || !content.trim()) {
      toast.error("Title and Content cannot be empty.");
      return;
    }
    mutation.mutate({ title, content });
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading page content...</p>;
  if (error) return <p className="text-red-400">Failed to load content.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <UserCircle size={28} /> Edit 'Author' Page
        </h1>
        <button
          onClick={handleSave}
          disabled={mutation.isPending}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
        >
          {mutation.isPending ? (
            <Loader2 size={20} className="animate-spin" />
          ) : (
            <Save size={20} />
          )}
          <span>{mutation.isPending ? "Saving..." : "Save Changes"}</span>
        </button>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg space-y-6">
        <div>
          <label
            htmlFor="pageTitle"
            className="block text-sm font-medium text-brand-light mb-2"
          >
            Page Title
          </label>
          <input
            id="pageTitle"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">
            Page Content
          </label>
          {data && <RichTextEditor value={content} onChange={setContent} />}
        </div>
      </div>
    </div>
  );
}

// ===== src/app/admin/pages/gdpr/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { Loader2, Save, DatabaseZap } from "lucide-react";
import RichTextEditor from "@/components/admin/RichTextEditor";

const PAGE_SLUG = "gdpr";

interface PageContentData {
  title: string;
  content: string;
}

const fetchPageContent = async (slug: string): Promise<PageContentData> => {
  const { data } = await axios.get(`/api/admin/pages/${slug}`);
  return data;
};

export default function EditGdprPage() {
  const queryClient = useQueryClient();
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");

  const { data, isLoading, error } = useQuery<PageContentData>({
    queryKey: ["pageContent", PAGE_SLUG],
    queryFn: () => fetchPageContent(PAGE_SLUG),
  });

  useEffect(() => {
    if (data) {
      setTitle(data.title || "GDPR & Data Protection");
      setContent(data.content || "");
    }
  }, [data]);

  const mutation = useMutation({
    mutationFn: (pageData: PageContentData) =>
      axios.post(`/api/admin/pages/${PAGE_SLUG}`, pageData),
    onSuccess: () => {
      toast.success("GDPR page content saved successfully!");
      queryClient.invalidateQueries({ queryKey: ["pageContent", PAGE_SLUG] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to save content.");
    },
  });

  const handleSave = () => {
    if (!title.trim() || !content.trim()) {
      toast.error("Title and Content cannot be empty.");
      return;
    }
    mutation.mutate({ title, content });
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading page content...</p>;
  if (error) return <p className="text-red-400">Failed to load content.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <DatabaseZap size={28} /> Edit 'GDPR' Page
        </h1>
        <button
          onClick={handleSave}
          disabled={mutation.isPending}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
        >
          {mutation.isPending ? (
            <Loader2 size={20} className="animate-spin" />
          ) : (
            <Save size={20} />
          )}
          <span>{mutation.isPending ? "Saving..." : "Save Changes"}</span>
        </button>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg space-y-6">
        <div>
          <label
            htmlFor="pageTitle"
            className="block text-sm font-medium text-brand-light mb-2"
          >
            Page Title
          </label>
          <input
            id="pageTitle"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">
            Page Content
          </label>
          {data && <RichTextEditor value={content} onChange={setContent} />}
        </div>
      </div>
    </div>
  );
}

// ===== src/app/admin/pages/privacy-policy/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { Loader2, Save, Shield } from "lucide-react";
import RichTextEditor from "@/components/admin/RichTextEditor";

const PAGE_SLUG = "privacy-policy";

interface PageContentData {
  title: string;
  content: string;
}

const fetchPageContent = async (slug: string): Promise<PageContentData> => {
  const { data } = await axios.get(`/api/admin/pages/${slug}`);
  return data;
};

export default function EditPrivacyPolicyPage() {
  const queryClient = useQueryClient();
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");

  const { data, isLoading, error } = useQuery<PageContentData>({
    queryKey: ["pageContent", PAGE_SLUG],
    queryFn: () => fetchPageContent(PAGE_SLUG),
  });

  useEffect(() => {
    if (data) {
      setTitle(data.title || "Privacy Policy");
      setContent(data.content || "");
    }
  }, [data]);

  const mutation = useMutation({
    mutationFn: (pageData: PageContentData) =>
      axios.post(`/api/admin/pages/${PAGE_SLUG}`, pageData),
    onSuccess: () => {
      toast.success("Privacy Policy content saved successfully!");
      queryClient.invalidateQueries({ queryKey: ["pageContent", PAGE_SLUG] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to save content.");
    },
  });

  const handleSave = () => {
    if (!title.trim() || !content.trim()) {
      toast.error("Title and Content cannot be empty.");
      return;
    }
    mutation.mutate({ title, content });
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading page content...</p>;
  if (error) return <p className="text-red-400">Failed to load content.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Shield size={28} /> Edit 'Privacy Policy' Page
        </h1>
        <button
          onClick={handleSave}
          disabled={mutation.isPending}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
        >
          {mutation.isPending ? (
            <Loader2 size={20} className="animate-spin" />
          ) : (
            <Save size={20} />
          )}
          <span>{mutation.isPending ? "Saving..." : "Save Changes"}</span>
        </button>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg space-y-6">
        <div>
          <label
            htmlFor="pageTitle"
            className="block text-sm font-medium text-brand-light mb-2"
          >
            Page Title
          </label>
          <input
            id="pageTitle"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">
            Page Content
          </label>
          {data && <RichTextEditor value={content} onChange={setContent} />}
        </div>
      </div>
    </div>
  );
}

// ===== src/app/admin/pages/report-abuse/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { Loader2, Save, AlertTriangle } from "lucide-react";
import RichTextEditor from "@/components/admin/RichTextEditor";

const PAGE_SLUG = "report-abuse";

interface PageContentData {
  title: string;
  content: string;
}

const fetchPageContent = async (slug: string): Promise<PageContentData> => {
  const { data } = await axios.get(`/api/admin/pages/${slug}`);
  return data;
};

export default function EditReportAbusePage() {
  const queryClient = useQueryClient();
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");

  const { data, isLoading, error } = useQuery<PageContentData>({
    queryKey: ["pageContent", PAGE_SLUG],
    queryFn: () => fetchPageContent(PAGE_SLUG),
  });

  useEffect(() => {
    if (data) {
      setTitle(data.title || "Report Abuse");
      setContent(data.content || "");
    }
  }, [data]);

  const mutation = useMutation({
    mutationFn: (pageData: PageContentData) =>
      axios.post(`/api/admin/pages/${PAGE_SLUG}`, pageData),
    onSuccess: () => {
      toast.success("Page content saved successfully!");
      queryClient.invalidateQueries({ queryKey: ["pageContent", PAGE_SLUG] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to save content.");
    },
  });

  const handleSave = () => {
    if (!title.trim() || !content.trim()) {
      toast.error("Title and Content cannot be empty.");
      return;
    }
    mutation.mutate({ title, content });
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading page content...</p>;
  if (error) return <p className="text-red-400">Failed to load content.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <AlertTriangle size={28} /> Edit 'Report Abuse' Page
        </h1>
        <button
          onClick={handleSave}
          disabled={mutation.isPending}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
        >
          {mutation.isPending ? (
            <Loader2 size={20} className="animate-spin" />
          ) : (
            <Save size={20} />
          )}
          <span>{mutation.isPending ? "Saving..." : "Save Changes"}</span>
        </button>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg space-y-6">
        <div>
          <label
            htmlFor="pageTitle"
            className="block text-sm font-medium text-brand-light mb-2"
          >
            Page Title
          </label>
          <input
            id="pageTitle"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">
            Page Content
          </label>
          {}
          {data && <RichTextEditor value={content} onChange={setContent} />}
        </div>
      </div>
    </div>
  );
}

// ===== src/app/admin/pages/terms-and-conditions/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { Loader2, Save, FileText } from "lucide-react";
import RichTextEditor from "@/components/admin/RichTextEditor";

const PAGE_SLUG = "terms-and-conditions";

interface PageContentData {
  title: string;
  content: string;
}

const fetchPageContent = async (slug: string): Promise<PageContentData> => {
  const { data } = await axios.get(`/api/admin/pages/${slug}`);
  return data;
};

export default function EditTermsAndConditionsPage() {
  const queryClient = useQueryClient();
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");

  const { data, isLoading, error } = useQuery<PageContentData>({
    queryKey: ["pageContent", PAGE_SLUG],
    queryFn: () => fetchPageContent(PAGE_SLUG),
  });

  useEffect(() => {
    if (data) {
      setTitle(data.title || "Terms and Conditions");
      setContent(data.content || "");
    }
  }, [data]);

  const mutation = useMutation({
    mutationFn: (pageData: PageContentData) =>
      axios.post(`/api/admin/pages/${PAGE_SLUG}`, pageData),
    onSuccess: () => {
      toast.success("Terms and Conditions saved successfully!");
      queryClient.invalidateQueries({ queryKey: ["pageContent", PAGE_SLUG] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to save content.");
    },
  });

  const handleSave = () => {
    if (!title.trim() || !content.trim()) {
      toast.error("Title and Content cannot be empty.");
      return;
    }
    mutation.mutate({ title, content });
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading page content...</p>;
  if (error) return <p className="text-red-400">Failed to load content.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <FileText size={28} /> Edit 'Terms and Conditions' Page
        </h1>
        <button
          onClick={handleSave}
          disabled={mutation.isPending}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
        >
          {mutation.isPending ? (
            <Loader2 size={20} className="animate-spin" />
          ) : (
            <Save size={20} />
          )}
          <span>{mutation.isPending ? "Saving..." : "Save Changes"}</span>
        </button>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg space-y-6">
        <div>
          <label
            htmlFor="pageTitle"
            className="block text-sm font-medium text-brand-light mb-2"
          >
            Page Title
          </label>
          <input
            id="pageTitle"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">
            Page Content
          </label>
          {data && <RichTextEditor value={content} onChange={setContent} />}
        </div>
      </div>
    </div>
  );
}

// ===== src/app/admin/ticker-messages/page.tsx =====

"use client";

import { useState, useEffect, useMemo } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  PlusCircle,
  Edit,
  Trash2,
  CheckCircle,
  XCircle,
  Loader2,
  Megaphone,
} from "lucide-react";
import { ITickerMessage } from "@/models/TickerMessage";
import { ILanguage } from "@/models/Language";
import TickerTranslationGroupRow from "@/components/admin/TickerTranslationGroupRow";

const fetchActiveLanguages = async (): Promise<ILanguage[]> => {
  const { data } = await axios.get("/api/admin/languages?active=true");
  return data;
};

interface TickerFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  message?: ITickerMessage | null;
}

const TickerFormModal: React.FC<TickerFormModalProps> = ({
  isOpen,
  onClose,
  message,
}) => {
  const queryClient = useQueryClient();
  const [content, setContent] = useState("");
  const [order, setOrder] = useState(0);
  const [isActive, setIsActive] = useState(true);
  const [language, setLanguage] = useState("");

  const { data: languages, isLoading: isLoadingLanguages } = useQuery<ILanguage[]>({
    queryKey: ["activeLanguages"],
    queryFn: fetchActiveLanguages,
  });

  useEffect(() => {
    if (isOpen) {
      if (message) {
        setContent(message.message);
        setOrder(message.order);
        setIsActive(message.isActive);
        setLanguage(message.language);
      } else {

        setContent("");
        setOrder(0);
        setIsActive(true);
        if (languages && languages.length > 0) {
          const defaultLang = languages.find((l) => l.isDefault)?.code || languages[0].code;
          setLanguage(defaultLang);
        } else {
          setLanguage("");
        }

      }
    }
  }, [message, languages, isOpen]);

  const mutation = useMutation({
    mutationFn: (payload: Partial<ITickerMessage>) => {
      if (message?._id) {
        return axios.put("/api/admin/ticker-messages", { _id: message._id, ...payload });
      }
      return axios.post("/api/admin/ticker-messages", payload);
    },
    onSuccess: () => {
      toast.success(`Message ${message ? "updated" : "created"} successfully!`);
      queryClient.invalidateQueries({ queryKey: ["tickerMessagesAdmin"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "An error occurred.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!content.trim() || !language) {
      toast.error("Message content and language are required.");
      return;
    }

    mutation.mutate({ message: content, order: Number(order), isActive, language });

  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-lg">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {message ? "Edit Ticker Message" : "Create New Ticker Message"}
          </h2>
          <button onClick={onClose} className="text-brand-muted hover:text-white">
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">Language</label>
            <select
              value={language}
              onChange={(e) => setLanguage(e.target.value)}
              disabled={!!message || isLoadingLanguages}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 disabled:opacity-50"
              required
            >
              <option value="" disabled>
                {isLoadingLanguages ? "Loading..." : "Select Language"}
              </option>
              {languages?.map((lang) => (
                <option key={lang.code} value={lang.code}>{lang.name}</option>
              ))}
            </select>
          </div>
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">Message Content</label>
            <input
              type="text"
              value={content}
              onChange={(e) => setContent(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600"
              required
            />
          </div>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-brand-light mb-1">Order</label>
              <input
                type="number"
                value={order}
                onChange={(e) => setOrder(Number(e.target.value))}
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600"
              />
              <p className="text-xs text-brand-muted mt-1">Lower number displays first.</p>
            </div>
            <div className="flex items-center pt-6">
              <input
                type="checkbox"
                checked={isActive}
                onChange={(e) => setIsActive(e.target.checked)}
                className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded"
              />
              <label className="ml-2 text-sm font-medium text-brand-light">Active</label>
            </div>
          </div>
          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
              disabled={mutation.isPending}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg disabled:opacity-50 flex items-center gap-2"
              disabled={mutation.isPending}
            >
              {mutation.isPending ? <Loader2 size={18} className="animate-spin" /> : <CheckCircle size={18} />}
              {mutation.isPending ? "Saving..." : "Save Message"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default function AdminTickerMessagesPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingMessage, setEditingMessage] = useState<ITickerMessage | null>(null);

  const { data: messages, isLoading: isLoadingMessages } = useQuery<ITickerMessage[]>({
    queryKey: ["tickerMessagesAdmin"],
    queryFn: () => axios.get("/api/admin/ticker-messages").then((res) => res.data),
  });

  const { data: languages, isLoading: isLoadingLanguages } = useQuery<ILanguage[]>({
    queryKey: ["activeLanguages"],
    queryFn: fetchActiveLanguages,
  });

  const groupedMessages = useMemo(() => {
    if (!messages) return [];
    const groups: Record<string, ITickerMessage[]> = {};
    messages.forEach((msg) => {
      const groupId = (msg.translationGroupId ?? msg._id).toString();
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      groups[groupId].push(msg);
    });
    return Object.values(groups).sort((a, b) => new Date(b[0].createdAt).getTime() - new Date(a[0].createdAt).getTime());
  }, [messages]);

  const deleteMutation = useMutation({
    mutationFn: (messageId: string) => axios.delete("/api/admin/ticker-messages", { data: { id: messageId } }),
    onSuccess: () => {
      toast.success("Message deleted!");
      queryClient.invalidateQueries({ queryKey: ["tickerMessagesAdmin"] });
    },
    onError: (err: any) => toast.error(err.response?.data?.error || "Failed to delete message."),
  });

  const handleOpenCreateModal = () => {
    setEditingMessage(null);
    setIsModalOpen(true);
  };

  const isLoading = isLoadingMessages || isLoadingLanguages;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Megaphone size={28} /> Manage Ticker Messages
        </h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} /> New Message
        </button>
      </div>
      <div className="bg-brand-secondary rounded-lg overflow-hidden">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Order</th>
              <th className="p-4" colSpan={2}>
                Message & Translations
              </th>
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {isLoading ? (
              <tr><td colSpan={5} className="p-8 text-center text-brand-muted">Loading...</td></tr>
            ) : groupedMessages.length > 0 && languages ? (
              groupedMessages.map((group) => (
                <TickerTranslationGroupRow
                  key={group[0].translationGroupId?.toString() || group[0]._id.toString()}
                  group={group}
                  allActiveLanguages={languages}
                  onDelete={(id) => deleteMutation.mutate(id)}
                />
              ))
            ) : (
                <tr>
                    <td colSpan={5} className="text-center p-8 text-brand-muted">
                        No messages found. Click "New Message" to create one.
                    </td>
                </tr>
            )}
          </tbody>
        </table>
      </div>
      <TickerFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        message={editingMessage}
      />
    </div>
  );
}

// ===== src/app/admin/title-templates/page.tsx =====

"use client";

import { useEffect, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  PlusCircle,
  Edit,
  Trash2,
  FileText,
  CheckCircle,
  XCircle,
  Loader2,
} from "lucide-react";
import { ITitleTemplate } from "@/models/TitleTemplate";

interface TitleTemplateFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  template?: ITitleTemplate | null;
}

const TitleTemplateFormModal: React.FC<TitleTemplateFormModalProps> = ({
  isOpen,
  onClose,
  template,
}) => {
  const queryClient = useQueryClient();
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const [templateContent, setTemplateContent] = useState("");
  const [isActive, setIsActive] = useState(true);

  useEffect(() => {
    if (template) {
      setName(template.name);
      setDescription(template.description || "");
      setTemplateContent(template.template);
      setIsActive(template.isActive);
    } else {
      setName("");
      setDescription("");
      setTemplateContent("");
      setIsActive(true);
    }
  }, [template]);

  const mutation = useMutation({
    mutationFn: (payload: Partial<ITitleTemplate>) =>
      template?._id
        ? axios.put(`/api/admin/title-templates/${template._id}`, payload)
        : axios.post("/api/admin/title-templates", payload),
    onSuccess: () => {
      toast.success(
        `Title Template ${template ? "updated" : "created"} successfully!`
      );
      queryClient.invalidateQueries({ queryKey: ["titleTemplates"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to save the template.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !templateContent.trim()) {
      toast.error("Name and Template Content are required.");
      return;
    }
    mutation.mutate({
      name,
      description,
      template: templateContent,
      isActive,
    });
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {template ? "Edit Title Template" : "Create New Title Template"}
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label
              htmlFor="name"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Template Name
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={mutation.isPending}
            />
          </div>
          <div>
            <label
              htmlFor="description"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Description (Optional)
            </label>
            <input
              id="description"
              type="text"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              disabled={mutation.isPending}
            />
          </div>
          <div>
            <label
              htmlFor="templateContent"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Template Content
            </label>
            <textarea
              id="templateContent"
              value={templateContent}
              onChange={(e) => setTemplateContent(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
              rows={4}
              required
              disabled={mutation.isPending}
              placeholder="e.g., {original_title} hakknda ok gelimeler!"
            />
            <p className="text-xs text-brand-muted mt-1">
              Available placeholders: <code>{`{original_title}`}</code>,{" "}
              <code>{`{original_description}`}</code>,{" "}
              <code>{`{journalist_name}`}</code>.
            </p>
          </div>
          <div className="flex items-center">
            <input
              id="isActive"
              type="checkbox"
              checked={isActive}
              onChange={(e) => setIsActive(e.target.checked)}
              className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
              disabled={mutation.isPending}
            />
            <label
              htmlFor="isActive"
              className="ml-2 text-sm font-medium text-brand-light"
            >
              Active (Available for selection in generation modal)
            </label>
          </div>
          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              disabled={mutation.isPending}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={mutation.isPending}
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
            >
              {mutation.isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {mutation.isPending ? "Saving..." : "Save Template"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default function AdminTitleTemplatesPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingTemplate, setEditingTemplate] = useState<ITitleTemplate | null>(
    null
  );

  const {
    data: templates,
    isLoading,
    error,
  } = useQuery<ITitleTemplate[]>({
    queryKey: ["titleTemplates"],
    queryFn: async () => {
      const { data } = await axios.get("/api/admin/title-templates");
      return data;
    },
  });

  const deleteMutation = useMutation({
    mutationFn: (templateId: string) =>
      axios.delete(`/api/admin/title-templates/${templateId}`),
    onSuccess: () => {
      toast.success("Template deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["titleTemplates"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete template.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingTemplate(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (template: ITitleTemplate) => {
    setEditingTemplate(template);
    setIsModalOpen(true);
  };

  const handleDelete = (templateId: string, templateName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete template "${templateName}"?`
      )
    ) {
      deleteMutation.mutate(templateId);
    }
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading templates...</p>;
  if (error) return <p className="text-red-400">Failed to load templates.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <FileText size={28} /> Manage Title Templates
        </h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Template</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Name</th>
              <th className="p-4">Template Preview</th>
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {templates?.map((template) => (
              <tr key={template._id} className="border-t border-gray-700/50">
                <td className="p-4 font-medium">{template.name}</td>
                <td
                  className="p-4 text-brand-muted text-sm max-w-xl truncate font-mono"
                  title={template.template}
                >
                  {template.template}
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      template.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {template.isActive ? "Active" : "Inactive"}
                  </span>
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <button
                    onClick={() => handleOpenEditModal(template)}
                    className="text-blue-400 hover:text-blue-300"
                    title="Edit Template"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() => handleDelete(template._id, template.name)}
                    className="text-red-400 hover:text-red-300"
                    title="Delete Template"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {templates?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No templates found. Click "New Template" to create one.
          </p>
        )}
      </div>

      <TitleTemplateFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        template={editingTemplate}
      />
    </div>
  );
}

// ===== src/app/api/active-leagues/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import { format, addDays } from "date-fns";

const LEAGUES_TO_CHECK = [
  39,
  140,
  135,
  78,
  61,
  2,
  3,
  88,
  94,
  253,
  45,
  48,
  71,
  62,
  144,
  203,
  197,
  218,
];

export async function GET() {
  const today = format(new Date(), "yyyy-MM-dd");
  const nextSevenDays = format(addDays(new Date(), 7), "yyyy-MM-dd");

  const options = (leagueId: number) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: {
      league: leagueId,
      season: new Date().getFullYear().toString(),
      from: today,
      to: nextSevenDays,
    },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {

    const fixtureChecks = LEAGUES_TO_CHECK.map((id) =>
      axios.request(options(id)).then((response) => ({
        leagueId: id,
        hasFixtures: response.data.results > 0,
      }))
    );

    const results = await Promise.allSettled(fixtureChecks);

    const activeLeagueIds = results
      .filter(
        (result) => result.status === "fulfilled" && result.value.hasFixtures
      )
      .map(
        (result) =>
          (result as PromiseFulfilledResult<{ leagueId: number }>).value
            .leagueId
      );

    return NextResponse.json(activeLeagueIds);
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to determine active leagues." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/ai-journalists/[journalistId]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import AIJournalist, { IAIJournalist } from "@/models/AIJournalist";

interface Params {
  params: { journalistId: string };
}

export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { journalistId } = params;
    const journalist = await AIJournalist.findById(journalistId).lean();

    if (!journalist) {
      return NextResponse.json(
        { error: "AI Journalist not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(journalist, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error fetching AI Journalist ${params.journalistId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching AI Journalist." },
      { status: 500 }
    );
  }
}

export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { journalistId } = params;
    const body: Partial<IAIJournalist> = await request.json();
    const { name, description, tonePrompt, isActive } = body;

    if (!name || !tonePrompt) {
      return NextResponse.json(
        { error: "Name and Tone Prompt are required." },
        { status: 400 }
      );
    }

    const updatedJournalist = await AIJournalist.findByIdAndUpdate(
      journalistId,
      { name, description, tonePrompt, isActive },
      { new: true, runValidators: true }
    );

    if (!updatedJournalist) {
      return NextResponse.json(
        { error: "AI Journalist not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(updatedJournalist, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error updating AI Journalist ${params.journalistId}:`,
      error.message
    );
    if (error.code === 11000) {

      return NextResponse.json(
        { error: "Journalist with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error updating AI Journalist." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { journalistId } = params;
    const deletedJournalist = await AIJournalist.findByIdAndDelete(
      journalistId
    );

    if (!deletedJournalist) {
      return NextResponse.json(
        { error: "AI Journalist not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { message: "AI Journalist deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      `Error deleting AI Journalist ${params.journalistId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error deleting AI Journalist." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/ai-journalists/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import AIJournalist, { IAIJournalist } from "@/models/AIJournalist";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const journalists = await AIJournalist.find({}).sort({ name: 1 }).lean();
    return NextResponse.json(journalists, { status: 200 });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error fetching AI Journalists." },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body: Partial<IAIJournalist> = await request.json();
    const { name, description, tonePrompt, isActive } = body;

    if (!name || !tonePrompt) {
      return NextResponse.json(
        { error: "Name and Tone Prompt are required." },
        { status: 400 }
      );
    }

    const newJournalist = new AIJournalist({
      name,
      description,
      tonePrompt,
      isActive: isActive !== undefined ? isActive : true,
    });

    await newJournalist.save();
    return NextResponse.json(newJournalist, { status: 201 });
  } catch (error: any) {

    if (error.code === 11000) {

      return NextResponse.json(
        { error: "Journalist with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error creating AI Journalist." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/ai-prompt/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import AIPrompt, { IAIPrompt, AIPromptType } from "@/models/AIPrompt";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { searchParams } = new URL(request.url);
    const name = searchParams.get("name");
    const type = searchParams.get("type") as AIPromptType;

    if (!name || !type) {
      return NextResponse.json(
        { error: "Prompt name and type are required." },
        { status: 400 }
      );
    }

    const prompt = await AIPrompt.findOne({ name, type }).lean();

    if (!prompt) {
      return NextResponse.json(
        { error: `Prompt '${name}' of type '${type}' not found.` },
        { status: 404 }
      );
    }

    return NextResponse.json(prompt, { status: 200 });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error fetching AI Prompt." },
      { status: 500 }
    );
  }
}

export async function PUT(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body: { id: string; description?: string; prompt: string } =
      await request.json();
    const { id, description, prompt } = body;

    if (!id || !prompt) {
      return NextResponse.json(
        { error: "Prompt ID and content are required for update." },
        { status: 400 }
      );
    }

    const updatedPrompt = await AIPrompt.findByIdAndUpdate(
      id,
      { description, prompt },
      { new: true, runValidators: true }
    );

    if (!updatedPrompt) {
      return NextResponse.json(
        { error: "AI Prompt not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(updatedPrompt, { status: 200 });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error updating AI Prompt." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/casino-partners/[partnerId]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import CasinoPartner, { ICasinoPartner } from "@/models/CasinoPartner";

interface Params {
  params: { partnerId: string };
}

export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { partnerId } = params;
    const partner = await CasinoPartner.findById(partnerId).lean();

    if (!partner) {
      return NextResponse.json(
        { error: "Casino Partner not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(partner, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error fetching Casino Partner ${params.partnerId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching Casino Partner." },
      { status: 500 }
    );
  }
}

export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { partnerId } = params;
    const body: Partial<ICasinoPartner> = await request.json();
    const {
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured,
      isActive,
      order,
    } = body;

    if (!name || !logoUrl || !redirectUrl) {
      return NextResponse.json(
        { error: "Name, Logo URL, and Redirect URL are required." },
        { status: 400 }
      );
    }

    const updatedPartner = await CasinoPartner.findByIdAndUpdate(
      partnerId,
      { name, logoUrl, redirectUrl, description, isFeatured, isActive, order },
      { new: true, runValidators: true }
    );

    if (!updatedPartner) {
      return NextResponse.json(
        { error: "Casino Partner not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(updatedPartner, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error updating Casino Partner ${params.partnerId}:`,
      error.message
    );
    if (error.code === 11000) {

      return NextResponse.json(
        { error: "Partner with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error updating Casino Partner." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { partnerId } = params;
    const deletedPartner = await CasinoPartner.findByIdAndDelete(partnerId);

    if (!deletedPartner) {
      return NextResponse.json(
        { error: "Casino Partner not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { message: "Casino Partner deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      `Error deleting Casino Partner ${params.partnerId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error deleting Casino Partner." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/casino-partners/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import CasinoPartner, { ICasinoPartner } from "@/models/CasinoPartner";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {

    const partners = await CasinoPartner.find({})
      .sort({ order: 1, createdAt: -1 })
      .lean();
    return NextResponse.json(partners, { status: 200 });
  } catch (error: any) {
    :", error.message);
    return NextResponse.json(
      { error: "Server error fetching Casino Partners." },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body: Partial<ICasinoPartner> = await request.json();
    const {
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured,
      isActive,
      order,
    } = body;

    if (!name || !logoUrl || !redirectUrl) {
      return NextResponse.json(
        { error: "Name, Logo URL, and Redirect URL are required." },
        { status: 400 }
      );
    }

    const newPartner = new CasinoPartner({
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured: isFeatured !== undefined ? isFeatured : false,
      isActive: isActive !== undefined ? isActive : true,
      order: order !== undefined ? order : 0,
    });

    await newPartner.save();
    return NextResponse.json(newPartner, { status: 201 });
  } catch (error: any) {

    if (error.code === 11000) {

      return NextResponse.json(
        { error: "Partner with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error creating Casino Partner." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/external-news/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle from "@/models/ExternalNewsArticle";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();

    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get("limit") || "10");
    const skip = parseInt(searchParams.get("skip") || "0");
    const status = searchParams.get("status");

    const query: { status?: string } = {};
    if (status) {
      query.status = status;
    }

    const [articles, totalCount] = await Promise.all([
      ExternalNewsArticle.find(query)
        .sort({ pubDate: -1 })
        .skip(skip)
        .limit(limit)
        .lean(),
      ExternalNewsArticle.countDocuments(query),
    ]);

    return NextResponse.json({
      articles,
      totalCount,
      currentPage: Math.floor(skip / limit) + 1,
      perPage: limit,
    });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error fetching external news articles." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const { searchParams } = new URL(request.url);
    const articleId = searchParams.get("articleId");

    if (!articleId) {
      return NextResponse.json(
        { error: "Article ID is required." },
        { status: 400 }
      );
    }

    await dbConnect();

    const deletedArticle = await ExternalNewsArticle.findOneAndDelete({
      articleId,
    });

    if (!deletedArticle) {
      return NextResponse.json(
        { error: "Article not found." },
        { status: 404 }
      );
    }

    return NextResponse.json({ message: "Article deleted successfully." });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error deleting article." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/faqs/categories/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Faq from "@/models/Faq";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();

    const categories = await Faq.distinct("category");

    const sortedCategories = categories.filter(Boolean).sort();

    return NextResponse.json(sortedCategories);
  } catch (error) {

    return NextResponse.json(
      { error: "Server error fetching categories." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/faqs/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Faq, { IFaq } from "@/models/Faq";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  const faqs = await Faq.find({}).sort({ category: 1, order: 1, createdAt: 1 });
  return NextResponse.json(faqs);
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();
    const body: Partial<IFaq> = await request.json();
    const newFaq = new Faq(body);
    await newFaq.save();
    return NextResponse.json(newFaq, { status: 201 });
  } catch (error: any) {

    return NextResponse.json(
      { error: error.message || "Failed to create FAQ." },
      { status: 400 }
    );
  }
}

export async function PUT(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();
    const body: IFaq = await request.json();

    const { _id, question, answer, category, order, isActive } = body;

    if (!_id) {
      return NextResponse.json(
        { error: "FAQ ID is required for update." },
        { status: 400 }
      );
    }

    const updatedFaq = await Faq.findByIdAndUpdate(
      _id,
      { question, answer, category, order, isActive },
      { new: true, runValidators: true }
    );

    if (!updatedFaq) {
      return NextResponse.json({ error: "FAQ not found." }, { status: 404 });
    }

    return NextResponse.json(updatedFaq);
  } catch (error: any) {

    return NextResponse.json(
      { error: error.message || "Failed to update FAQ." },
      { status: 400 }
    );
  }
}

export async function DELETE(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();
    const { id } = await request.json();

    if (!id) {
      return NextResponse.json(
        { error: "FAQ ID is required for deletion." },
        { status: 400 }
      );
    }

    const deletedFaq = await Faq.findByIdAndDelete(id);

    if (!deletedFaq) {
      return NextResponse.json({ error: "FAQ not found." }, { status: 404 });
    }

    return NextResponse.json({ message: "FAQ deleted successfully." });
  } catch (error: any) {

    return NextResponse.json(
      { error: error.message || "Failed to delete FAQ." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/fetch-external-news/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle from "@/models/ExternalNewsArticle";
import axios from "axios";

interface NewsDataItem {
  article_id: string;
  title: string;
  link: string;
  keywords?: string[] | null;

  creator?: string | string[] | null;
  video_url?: string | null;
  description?: string | null;
  content?: string | null;
  pubDate: string;
  image_url?: string | null;
  source_id?: string;
  source_priority?: number;
  source_url?: string;
  source_icon?: string | null;
  language?: string;
  country?: string[];
  category?: string[];
  sentiment?: string;
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { query, language, country, category } = await request.json();

    const newsDataApiKey = process.env.NEXT_PUBLIC_NEWSDATA_IO_API_KEY;
    if (!newsDataApiKey) {
      return NextResponse.json(
        { error: "Server configuration error: News API key missing." },
        { status: 500 }
      );
    }

    const apiUrl = "https://newsdata.io/api/1/news";
    const params: Record<string, string | number> = {
      apikey: newsDataApiKey,
      qInTitle: query || "football OR soccer",
      language: language || "en",
    };
    if (country && country.length > 0) params.country = country.join(",");
    if (category && category.length > 0) params.category = category.join(",");

    const response = await axios.get(apiUrl, { params });
    const newsItems: NewsDataItem[] = response.data.results || [];

    let newArticlesCount = 0;
    let skippedArticlesCount = 0;
    let failedArticlesCount = 0;

    const processingPromises = newsItems.map(async (item) => {
      try {
        const existingArticle = await ExternalNewsArticle.findOne({
          articleId: item.article_id,
        });
        if (existingArticle) {
          return { status: "skipped" };
        }

        let creatorArray: string[] = [];
        if (item.creator) {
          creatorArray = Array.isArray(item.creator)
            ? item.creator
            : [item.creator];
        }

        const newArticle = new ExternalNewsArticle({
          articleId: item.article_id,
          title: item.title,
          link: item.link,
          creator: creatorArray,
          description: item.description,
          content: item.content,
          pubDate: new Date(item.pubDate),
          imageUrl: item.image_url,

          language: item.language,
          country: item.country || [],
          category: item.category || [],
          status: "fetched",
        });

        await newArticle.save();
        return { status: "saved" };
      } catch (saveError: any) {
        console.error(
          `[Fetch External News] Error saving article ${item.article_id}:`,
          saveError.message
        );
        return { status: "failed" };
      }
    });

    const results = await Promise.allSettled(processingPromises);

    results.forEach((result) => {
      if (result.status === "fulfilled") {
        if (result.value.status === "saved") newArticlesCount++;
        if (result.value.status === "skipped") skippedArticlesCount++;
        if (result.value.status === "failed") failedArticlesCount++;
      } else {
        failedArticlesCount++;
      }
    });

    return NextResponse.json(
      {
        message: `Fetch complete. Saved: ${newArticlesCount}. Skipped: ${skippedArticlesCount}. Failed: ${failedArticlesCount}.`,
        newArticlesCount,
        skippedArticlesCount,
        failedArticlesCount,
      },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      "[Fetch External News] Critical error fetching from newsdata.io:",
      error.message
    );
    if (axios.isAxiosError(error)) {
      return NextResponse.json(
        {
          error: `Failed to fetch news from external API: ${
            error.response?.data?.results?.message || error.message
          }`,
        },
        { status: error.response?.status || 500 }
      );
    }
    return NextResponse.json(
      { error: "Server error fetching external news." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/file-manager/download-from-url/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import axios from "axios";
import crypto from "crypto";
import path from "path";
import slugify from "slugify";
import { promises as fs } from "fs";

const UPLOAD_DIR = path.join(process.cwd(), "public/uploads");

const ensureUploadDirExists = async () => {
  try {
    await fs.mkdir(UPLOAD_DIR, { recursive: true });
  } catch (error) {

    throw new Error("Could not create upload directory on the server.");
  }
};

const generateFileName = (bytes = 32) =>
  crypto.randomBytes(bytes).toString("hex");

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const {
      url,
      fileName: providedFileName,
    }: { url: string; fileName?: string } = await request.json();

    if (!url) {
      return NextResponse.json({ error: "URL is required." }, { status: 400 });
    }

    console.log(
      `[File Manager - Download URL] Attempting to download from URL: ${url}`
    );

    const response = await axios.get(url, {
      responseType: "arraybuffer",
      timeout: 30000,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });

    const fileBuffer = Buffer.from(response.data, "binary");
    const contentType =
      response.headers["content-type"] || "application/octet-stream";
    const contentLength = response.headers["content-length"]
      ? parseInt(response.headers["content-length"])
      : fileBuffer.length;

    if (contentLength === 0) {
      throw new Error("Downloaded file is empty.");
    }
    if (contentLength > 20 * 1024 * 1024) {

      throw new Error("File size exceeds 20MB limit for direct download.");
    }

    let fileExtension = "";
    const mimeMap: { [key: string]: string } = {
      "image/jpeg": ".jpg",
      "image/png": ".png",
      "image/gif": ".gif",
      "image/webp": ".webp",
      "application/pdf": ".pdf",

    };
    fileExtension =
      mimeMap[contentType.toLowerCase()] ||
      path.extname(new URL(url).pathname) ||
      "";

    const uniqueBaseName = generateFileName();
    const finalFileName = providedFileName
      ? `${slugify(providedFileName, {
          lower: true,
          strict: true,
        })}${fileExtension}`
      : `${uniqueBaseName}${fileExtension}`;

    const filePath = path.join(UPLOAD_DIR, finalFileName);
    await ensureUploadDirExists();
    await fs.writeFile(filePath, fileBuffer);

    const publicUrl = `/uploads/${finalFileName}`;
    console.log(
      `[File Manager - Download URL] File successfully saved locally: ${publicUrl}`
    );

    return NextResponse.json({
      message: "File downloaded and saved successfully",
      url: publicUrl,
      name: finalFileName,
      type: contentType,
      size: contentLength,
    });
  } catch (error: any) {
    console.error(
      `[File Manager - Download URL] Failed to download or save from URL: ${error.message}`,
      "\nFull Error:",
      error
    );
    let errorMessage = "Failed to download and upload file from URL.";
    let clientStatus = 500;

    if (axios.isAxiosError(error)) {
      if (error.response) {
        errorMessage = `External URL error: Status ${error.response.status} - ${error.response.statusText}`;
        clientStatus = error.response.status;
      } else if (error.request) {
        errorMessage = `Network error: Could not reach external URL.`;
        clientStatus = 502;
      } else {
        errorMessage = `Request setup error: ${error.message}`;
      }
    } else if (error instanceof Error) {
      errorMessage = error.message;
      if (errorMessage.includes("File size exceeds")) clientStatus = 413;
      if (errorMessage.includes("Downloaded file is empty")) clientStatus = 400;
    }

    return NextResponse.json({ error: errorMessage }, { status: clientStatus });
  }
}

// ===== src/app/api/admin/generate-prediction-news/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post from "@/models/Post";
import AIPrompt from "@/models/AIPrompt";
import AIJournalist from "@/models/AIJournalist";
import { GoogleGenerativeAI } from "@google/generative-ai";
import axios from "axios";
import { proxyAndUploadImage } from "@/lib/image-processing-server";
import slugify from "slugify";

const genAI = new GoogleGenerativeAI(
  process.env.NEXT_PUBLIC_GEMINI_API_KEY as string
);
const model = genAI.getGenerativeModel({ model: "gemini-2.5-pro" });
const TITLE_PROMPT_NAME = "AI Title Generation";
const PREDICTION_PROMPT_NAME = "AI Prediction Content Generation";

async function getFixtureData(fixtureId: number) {
  const options = (endpoint: string, params: object) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  const fixtureResponse = await axios.request(
    options("fixtures", { id: fixtureId })
  );
  const fixtureData = fixtureResponse.data.response[0];
  if (!fixtureData) {
    throw new Error(`Fixture data not found for ID: ${fixtureId}`);
  }

  const { home, away } = fixtureData.teams;
  const [h2hRes, homeFormRes, awayFormRes] = await Promise.all([
    axios.request(
      options("fixtures/headtohead", { h2h: `${home.id}-${away.id}` })
    ),
    axios.request(options("fixtures", { team: home.id, last: 5 })),
    axios.request(options("fixtures", { team: away.id, last: 5 })),
  ]);

  return {
    ...fixtureData,
    h2h: h2hRes.data.response,
    homeForm: homeFormRes.data.response
      .map((m: any) =>
        m.teams.home.winner ? "W" : m.teams.away.winner ? "L" : "D"
      )
      .join(""),
    awayForm: awayFormRes.data.response
      .map((m: any) =>
        m.teams.away.winner ? "W" : m.teams.home.winner ? "L" : "D"
      )
      .join(""),
  };
}

async function generatePredictionTitle(
  homeTeamName: string,
  awayTeamName: string,
  leagueName: string,
  journalistId?: string
): Promise<string> {
  const titlePromptDoc = await AIPrompt.findOne({
    name: TITLE_PROMPT_NAME,
    type: "title",
  });
  const defaultTitlePrompt =
    "You are an expert sports journalist. Your ONLY task is to generate a new, original, SEO-friendly title in TURKISH for a news article based on the following match. The new title MUST be highly distinct, capture a fresh angle, and be plain text only with no markdown or quotes.\n\nMatch: {home_team} vs {away_team}\nLeague: {league_name}\n\nGenerated Title:";

  let finalTitlePrompt = titlePromptDoc?.prompt || defaultTitlePrompt;
  let journalistTonePrompt = "";
  if (journalistId) {
    const journalist = await AIJournalist.findById(journalistId);
    if (journalist && journalist.isActive) {
      journalistTonePrompt = `As "${journalist.name}", your unique journalistic voice and tone should be: ${journalist.tonePrompt}\n\n`;
    }
  }

  const fullPrompt = `${journalistTonePrompt}${finalTitlePrompt}`
    .replace("{home_team}", homeTeamName)
    .replace("{away_team}", awayTeamName)
    .replace("{league_name}", leagueName);

  const result = await model.generateContent(fullPrompt);
  const responseText = (await result.response).text().trim();
  return responseText.replace(/[\*#"\n]/g, "");
}

async function generatePredictionContent(
  predictionData: any,
  journalistId?: string
): Promise<string> {
  const contentPromptDoc = await AIPrompt.findOne({
    name: PREDICTION_PROMPT_NAME,
    type: "prediction_content",
  });

  const enhancedPrompt = `
You are an expert sports journalist and a charismatic storyteller. Your task is to transform the provided raw match data into a compelling, conversational, and humanized narrative in **PURE HTML** and **TURKISH**. Your writing should be engaging, insightful, and optimized for readability and SEO.

**CRITICAL INSTRUCTIONS:**
1.  **HTML ONLY:** Your entire response **MUST** be pure, valid HTML. Use tags like \`<h2>\`, \`<h3>\`, \`<p>\`, \`<strong>\`, \`<em>\`, \`<ul>\`, and \`<li>\`.
2.  **NO MARKDOWN:** **ABSOLUTELY NO MARKDOWN SYNTAX** like \`#\` or \`*\` is allowed.
3.  **NO PREAMBLE:** Your response must start directly with an HTML tag (e.g., \`<h2>\`). Do not write "Here is the article...".
4.  **LANGUAGE & TONE:** The entire article **MUST** be in Turkish. Adopt a conversational, authoritative, and engaging tone. Ask rhetorical questions to the reader. Use vivid language and analogies to make statistics interesting.

**CONTENT & SEO GUIDELINES:**
*   **Narrative Flow:** Don't just list data. Weave the stats, H2H, and form into a story about the upcoming match. Create a compelling argument for why the match is important.
*   **Heading Hierarchy:** Use descriptive \`<h2>\` and \`<h3>\` tags that naturally include keywords (e.g., "Takmlarn Son Form Durumu," "Kritik Mcadele Alanlar," "Man Anahtar Oyuncular"). **Do not use \`<h1>\`**.
*   **Keyword Integration:** Naturally use the team names, league name, and related terms like "ma tahmini," "analiz," "kadrolar," and "puan durumu" throughout the text.
*   **Provide Value:** Your analysis should give the reader a deeper understanding of what to expect, beyond just the raw numbers.

**ARTICLE STRUCTURE (Example Flow):**
1.  **Etkileyici Giri (Engaging Intro):** Start with a hook. Example: "<h2>Futbolseverler Nefeslerini Tuttu: {league_name} Sahnesinde Dev Randevu!</h2><p>Bu hafta sonu {league_name} sahnesi, {home_team_name} ile {away_team_name} arasnda nefes kesecek bir mcadeleye ev sahiplii yapyor. Peki bu kritik 90 dakikada bizleri neler bekliyor? Gelin, hep birlikte bu dev man ifrelerini zelim.</p>"
2.  **Takmlarn Form Durumu (Team Form):** Analyze the recent form of both teams. Discuss their recent wins, losses, and what this momentum means.
3.  **Gemiin zleri: H2H Analizi (H2H Analysis):** Discuss past encounters. Who has the historical upper hand?
4.  **Puan Durumundaki Yansmalar (Standings Impact):** Explain the stakes. What does a win, loss, or draw mean for each team's position in the league?
5.  **Man Anahtar Oyuncular (Key Players):** Identify one key player from each team who could decide the fate of the match and explain why.
6.  **Fanskor'un Gznden Man Kaderi (Fanskor's Prediction):** State the prediction clearly and justify it conversationally based on the analysis above.
7.  **Sonu ve Beklentiler (Conclusion):** Summarize and look ahead. End with a question to engage the reader.

**Provided Match Data (use this to write the article):**
\`\`\`json
{match_data}
\`\`\`

**Your Generated HTML Article (Must start with \`<h2>\`):**
`;

  let finalContentPrompt = contentPromptDoc?.prompt || enhancedPrompt;
  const { league, teams, h2h, homeForm, awayForm } = predictionData;
  const dataForPrompt = {
    league_name: league.name,
    home_team_name: teams.home.name,
    away_team_name: teams.away.name,
    h2h_results: h2h.slice(0, 3),
    home_form: homeForm,
    away_form: awayForm,
  };

  finalContentPrompt = finalContentPrompt.replace(
    "{match_data}",
    JSON.stringify(dataForPrompt, null, 2)
  );

  let journalistTonePrompt = "";
  if (journalistId) {
    const journalist = await AIJournalist.findById(journalistId);
    if (journalist && journalist.isActive) {
      journalistTonePrompt = `As "${journalist.name}", your unique journalistic voice and tone should be: ${journalist.tonePrompt}\n\n`;
    }
  }

  const fullPrompt = `${journalistTonePrompt}${finalContentPrompt}`;
  const result = await model.generateContent(fullPrompt);
  const aiResponseText = (await result.response).text();

  return aiResponseText
    .trim()
    .replace(/^```(?:html)?\n?|```$/g, "")
    .trim();
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }
  await dbConnect();

  try {
    const {
      fixtureId,
      journalistId,
      sportsCategory = "football",
    } = await request.json();

    if (!fixtureId || !journalistId) {
      return NextResponse.json(
        { error: "Fixture ID and Journalist ID are required." },
        { status: 400 }
      );
    }

    const existingPost = await Post.findOne({ originalFixtureId: fixtureId });
    if (existingPost) {
      return NextResponse.json(
        {
          message: "Prediction post already exists.",
          postId: existingPost._id,
        },
        { status: 200 }
      );
    }

    const fixtureData = await getFixtureData(fixtureId);
    const { teams, league } = fixtureData;

    const newPostTitle = await generatePredictionTitle(
      teams.home.name,
      teams.away.name,
      league.name,
      journalistId
    );
    const predictionContent = await generatePredictionContent(
      fixtureData,
      journalistId
    );

    const featuredImageUrl = await proxyAndUploadImage(
      teams.home.logo || teams.away.logo,
      `${teams.home.name}-vs-${teams.away.name}-prediction`
    );

    const postSlug = slugify(newPostTitle, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });
    const existingSlug = await Post.findOne({ slug: postSlug });
    const finalSlug = existingSlug
      ? `${postSlug}-${Date.now().toString().slice(-5)}`
      : postSlug;

    const plainTextContent = predictionContent.replace(/<[^>]*>?/gm, "");

    const newPost = new Post({
      title: newPostTitle,
      content: predictionContent,
      slug: finalSlug,
      status: "draft",
      author:
        (await AIJournalist.findById(journalistId))?.name ||
        "AI Auto-Generator",
      isAIGenerated: true,
      sportsCategory: [sportsCategory],
      newsType: "prediction",
      linkedFixtureId: fixtureId,
      linkedLeagueId: league.id,
      featuredImage: featuredImageUrl,
      featuredImageTitle: `${teams.home.name} vs ${teams.away.name} Prediction`,
      featuredImageAltText: `${teams.home.name} vs ${teams.away.name} match prediction`,
      metaTitle: `${newPostTitle} | Ma Tahmini`,
      metaDescription: plainTextContent.substring(0, 160) + "...",
      originalFixtureId: fixtureId,
    });

    await newPost.save();

    return NextResponse.json(
      {
        message: "Prediction news generated successfully!",
        postId: newPost._id,
      },
      { status: 201 }
    );
  } catch (error: any) {
    console.error(
      `[Generate Prediction] Critical error: ${error.message}`,
      error
    );
    return NextResponse.json(
      { error: "Server error generating prediction news." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/i18n-cache/invalidate/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { i18nCache } from "@/lib/i18n/i18n.cache";

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {

    await i18nCache.reload();

    return NextResponse.json(
      {
        success: true,
        message: "i18n cache has been successfully invalidated and reloaded.",
        loadedLocales: i18nCache.getLocales(),
        defaultLocale: i18nCache.getDefaultLocale(),
      },
      { status: 200 }
    );
  } catch (error: any) {

    return NextResponse.json(
      {
        success: false,
        error: "Failed to invalidate cache due to a server error.",
      },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/languages/[languageId]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Language, { ILanguage } from "@/models/Language";
import path from "path";
import { promises as fs } from "fs";

const LOCALES_DIR = path.join(process.cwd(), "src/locales");

interface Params {
  params: { languageId: string };
}

export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { languageId } = params;
  await dbConnect();

  try {
    const body: Partial<ILanguage> = await request.json();

    delete (body as any).code;

    if (body.isDefault) {
      const language = await Language.findById(languageId);
      if (!language) {
        return NextResponse.json(
          { error: "Language not found." },
          { status: 404 }
        );
      }
      Object.assign(language, body);
      await language.save();
      const updatedLanguage = language.toObject();
      console.log(
        `[I18N_CACHE] Invalidation needed. Language default status changed.`
      );
      return NextResponse.json(updatedLanguage, { status: 200 });
    }

    const updatedLanguage = await Language.findByIdAndUpdate(languageId, body, {
      new: true,
      runValidators: true,
    });

    if (!updatedLanguage) {
      return NextResponse.json(
        { error: "Language not found." },
        { status: 404 }
      );
    }

    console.log(
      `[I18N_CACHE] Invalidation needed. Language '${updatedLanguage.code}' was updated.`
    );
    return NextResponse.json(updatedLanguage, { status: 200 });
  } catch (error: any) {

    if (error.code === 11000) {
      return NextResponse.json(
        { error: "Language name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error updating language." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { languageId } = params;
  await dbConnect();

  try {
    const languageToDelete = await Language.findById(languageId);

    if (!languageToDelete) {
      return NextResponse.json(
        { error: "Language not found." },
        { status: 404 }
      );
    }

    if (languageToDelete.isDefault) {
      return NextResponse.json(
        { error: "Cannot delete the default language." },
        { status: 400 }
      );
    }

    await Language.findByIdAndDelete(languageId);

    const filePath = path.join(LOCALES_DIR, `${languageToDelete.code}.json`);
    try {
      await fs.unlink(filePath);
    } catch (fileError: any) {

      if (fileError.code !== "ENOENT") {

      }
    }

    console.log(
      `[I18N_CACHE] Invalidation needed. Language '${languageToDelete.code}' was deleted.`
    );
    return NextResponse.json(
      { message: "Language deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error deleting language." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/languages/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Language from "@/models/Language";
import path from "path";
import { promises as fs } from "fs";

const LOCALES_DIR = path.join(process.cwd(), "src/locales");

const ensureLocalesDirExists = async () => {
  try {
    await fs.mkdir(LOCALES_DIR, { recursive: true });
  } catch (error) {

    throw new Error(
      "Server configuration error: Could not access locales directory."
    );
  }
};

export async function GET(request: Request) {

  await dbConnect();

  try {
    const session = await getServerSession(authOptions);
    const isAdmin = session?.user?.role === "admin";

    const query = isAdmin ? {} : { isActive: true };

    const languages = await Language.find(query).sort({ name: 1 });
    return NextResponse.json(languages, { status: 200 });
  } catch (error: any) {
    console.error(
      "[API/admin/languages] Error fetching languages:",
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching languages." },
      { status: 500 }
    );
  }
}
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body = await request.json();
    const { name, code, isDefault, isActive, flagUrl } = body;

    if (!name || !code) {
      return NextResponse.json(
        { error: "Name and code are required." },
        { status: 400 }
      );
    }

    const newLanguage = new Language({
      name,
      code,
      isDefault,
      isActive,
      flagUrl,
    });
    await newLanguage.save();

    await ensureLocalesDirExists();
    const filePath = path.join(LOCALES_DIR, `${code}.json`);
    await fs.writeFile(filePath, JSON.stringify({}, null, 2), "utf-8");

    console.log(
      `[I18N_CACHE] Invalidation needed. Language '${code}' was added.`
    );

    return NextResponse.json(newLanguage, { status: 201 });
  } catch (error: any) {

    if (error.code === 11000) {
      return NextResponse.json(
        { error: `Language with code or name already exists.` },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error creating language." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/pages/[pageSlug]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import PageContent from "@/models/PageContent";

interface Params {
  params: { pageSlug: string };
}

export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { pageSlug } = params;
  await dbConnect();

  const pageContent = await PageContent.findOne({ pageSlug });

  if (!pageContent) {
    return NextResponse.json({
      pageSlug,
      title: "",
      content: "",
    });
  }

  return NextResponse.json(pageContent);
}

export async function POST(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { pageSlug } = params;
  try {
    const body = await request.json();
    const { title, content } = body;

    if (!title || !content) {
      return NextResponse.json(
        { error: "Title and content are required." },
        { status: 400 }
      );
    }

    await dbConnect();

    const updatedContent = await PageContent.findOneAndUpdate(
      { pageSlug },
      { title, content },
      {
        new: true,
        upsert: true,
        runValidators: true,
      }
    );

    return NextResponse.json(updatedContent, { status: 200 });
  } catch (error: any) {
    console.error(
      `[API/admin/pages] POST Error for slug "${pageSlug}":`,
      error
    );
    return NextResponse.json(
      { error: error.message || "Failed to save page content." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/posts/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post from "@/models/Post";

export async function GET(request: Request) {

  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();

    const posts = await Post.find({}).sort({ createdAt: -1 }).lean();

    return NextResponse.json(posts);
  } catch (error) {
    console.error(
      "[API/admin/posts GET] Server error fetching posts for admin:",
      error
    );
    return NextResponse.json(
      { error: "Server error fetching posts" },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/posts/translations/[groupId]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post from "@/models/Post";

interface Params {
  params: { groupId: string };
}

export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  const { groupId } = params;

  if (!groupId) {
    return NextResponse.json(
      { error: "Translation Group ID is required." },
      { status: 400 }
    );
  }

  try {

    const translations = await Post.find({ translationGroupId: groupId })
      .select("title slug language _id createdAt")
      .lean();

    return NextResponse.json(translations, { status: 200 });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error fetching translations." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/process-external-news/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle from "@/models/ExternalNewsArticle";
import { processSingleArticle } from "@/lib/ai-processing";
import { NewsType, SportsCategory } from "@/models/Post";

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {

    const {
      articleId,
      journalistId,
      titleTemplateId,
      sportsCategory,
      newsType,
      status,
    }: {
      articleId: string;
      journalistId?: string;
      titleTemplateId?: string;
      sportsCategory: SportsCategory[];
      newsType: NewsType;
      status: "draft" | "published";
    } = await request.json();

    if (
      !articleId ||
      !sportsCategory ||
      sportsCategory.length === 0 ||
      !newsType
    ) {
      return NextResponse.json(
        { error: "Missing required parameters." },
        { status: 400 }
      );
    }

    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder();
        const sendEvent = (log: string) => {
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify({ log })}\n\n`)
          );
        };

        try {
          await dbConnect();
          const externalArticle = await ExternalNewsArticle.findOne({
            articleId,
          });

          if (!externalArticle) {
            throw new Error("External news article not found.");
          }

          const result = await processSingleArticle(externalArticle, {
            journalistId,
            titleTemplateId,
            sportsCategory,
            newsType,
            status,
            onProgress: sendEvent,
          });

          if (result.success) {
            controller.enqueue(
              encoder.encode(
                `data: ${JSON.stringify({
                  event: "SUCCESS",
                  data: result,
                })}\n\n`
              )
            );
          } else {
            throw new Error("Article processing failed in the final step.");
          }
        } catch (error: any) {

          controller.enqueue(
            encoder.encode(
              `data: ${JSON.stringify({
                event: "ERROR",
                data: { message: error.message },
              })}\n\n`
            )
          );
        } finally {
          controller.close();
        }
      },
    });

    return new Response(stream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      },
    });
  } catch (error: any) {
    console.error(
      "[Process News API] Initial Body Parse Error:",
      error.message
    );
    return NextResponse.json(
      { error: "An unexpected server error occurred." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/ticker-messages/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import TickerMessage from "@/models/TickerMessage";
import redis from "@/lib/redis";
import mongoose from "mongoose";

const CACHE_KEY_PREFIX = "ticker-messages:active:";

const invalidateCache = async (locale: string) => {
  await redis.del(`${CACHE_KEY_PREFIX}${locale}`);
};

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();
  const messages = await TickerMessage.find({}).sort({ order: 1, createdAt: -1 });
  return NextResponse.json(messages);
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body = await request.json();
    await dbConnect();

    const newMessage = new TickerMessage(body);

    if (!body.translationGroupId) {
      newMessage.translationGroupId = new mongoose.Types.ObjectId();
    }

    await newMessage.save();
    await invalidateCache(newMessage.language);
    return NextResponse.json(newMessage, { status: 201 });
  } catch (error: any) {

    if (error instanceof mongoose.Error.ValidationError) {
        return NextResponse.json({ error: error.message }, { status: 400 });
    }
    return NextResponse.json({ error: "Failed to create message." }, { status: 500 });
  }
}

export async function PUT(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body = await request.json();
    const { _id, ...updateData } = body;
    await dbConnect();
    const updatedMessage = await TickerMessage.findByIdAndUpdate(_id, updateData, { new: true, runValidators: true });
    if (!updatedMessage) {
      return NextResponse.json({ error: "Message not found" }, { status: 404 });
    }
    await invalidateCache(updatedMessage.language);
    return NextResponse.json(updatedMessage);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}

export async function DELETE(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const { id } = await request.json();
    await dbConnect();
    const deletedMessage = await TickerMessage.findByIdAndDelete(id);
    if (!deletedMessage) {
      return NextResponse.json({ error: "Message not found" }, { status: 404 });
    }
    await invalidateCache(deletedMessage.language);
    return NextResponse.json({ message: "Message deleted successfully" });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// ===== src/app/api/admin/ticker-messages/translate/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import TickerMessage from "@/models/TickerMessage";
import Language from "@/models/Language";
import { GoogleGenerativeAI } from "@google/generative-ai";
import redis from "@/lib/redis";

const genAI = new GoogleGenerativeAI(process.env.NEXT_PUBLIC_GEMINI_API_KEY as string);
const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

const CACHE_KEY_PREFIX = "ticker-messages:active:";

async function translateText(text: string, sourceLang: string, targetLang: string): Promise<string> {
  const prompt = `Translate the following text from ${sourceLang} to ${targetLang}. Return ONLY the translated text, without any quotes, labels, or extra formatting.

Text to translate: "${text}"`;

  const result = await model.generateContent(prompt);
  return (await result.response).text().trim().replace(/["']/g, "");
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const { sourceMessageId } = await request.json();
    if (!sourceMessageId) {
      return NextResponse.json({ error: "Source Message ID is required" }, { status: 400 });
    }

    await dbConnect();

    const sourceMessage = await TickerMessage.findById(sourceMessageId);

    if (!sourceMessage) {
      return NextResponse.json({ error: "Source message not found" }, { status: 404 });
    }

    const [allLanguages, existingTranslations] = await Promise.all([

      Language.find({}).lean(),

      TickerMessage.find({ translationGroupId: sourceMessage.translationGroupId }).lean(),
    ]);

    const sourceLangDetails = allLanguages.find(lang => lang.code === (sourceMessage.language ?? 'en') );
    if (!sourceLangDetails) {

        return NextResponse.json({ error: `Source language code '${sourceMessage.language}' could not be found in the database.` }, { status: 400 });
    }

    const existingLangCodes = new Set(existingTranslations.map(t => t.language));

    const targetLanguages = allLanguages.filter(lang => lang.isActive && !existingLangCodes.has(lang.code));

    if (targetLanguages.length === 0) {
      return NextResponse.json({ message: "All active languages are already translated." });
    }

    let translatedCount = 0;
    const translationPromises = targetLanguages.map(async (targetLang) => {
      const translatedText = await translateText(sourceMessage.message, sourceLangDetails.name, targetLang.name);

      const newMessage = new TickerMessage({
        message: translatedText,
        language: targetLang.code,
        translationGroupId: sourceMessage.translationGroupId,
        isActive: sourceMessage.isActive,
        order: sourceMessage.order,
      });

      await newMessage.save();
      await redis.del(`${CACHE_KEY_PREFIX}${targetLang.code}`);
      translatedCount++;
    });

    await Promise.allSettled(translationPromises);

    return NextResponse.json({ message: `Successfully created ${translatedCount} new translation(s).` });

  } catch (error: any) {

    return NextResponse.json({ error: "Failed to generate translations." }, { status: 500 });
  }
}

// ===== src/app/api/admin/title-templates/[templateId]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import TitleTemplate, { ITitleTemplate } from "@/models/TitleTemplate";

interface Params {
  params: { templateId: string };
}

export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { templateId } = params;
    const template = await TitleTemplate.findById(templateId).lean();

    if (!template) {
      return NextResponse.json(
        { error: "Title Template not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(template, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error fetching Title Template ${params.templateId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching Title Template." },
      { status: 500 }
    );
  }
}

export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { templateId } = params;
    const body: Partial<ITitleTemplate> = await request.json();
    const { name, description, template, isActive } = body;

    if (!name || !template) {
      return NextResponse.json(
        { error: "Name and Template content are required." },
        { status: 400 }
      );
    }

    const updatedTemplate = await TitleTemplate.findByIdAndUpdate(
      templateId,
      { name, description, template, isActive },
      { new: true, runValidators: true }
    );

    if (!updatedTemplate) {
      return NextResponse.json(
        { error: "Title Template not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(updatedTemplate, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error updating Title Template ${params.templateId}:`,
      error.message
    );
    if (error.code === 11000) {
      return NextResponse.json(
        { error: "A template with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error updating Title Template." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { templateId } = params;
    const deletedTemplate = await TitleTemplate.findByIdAndDelete(templateId);

    if (!deletedTemplate) {
      return NextResponse.json(
        { error: "Title Template not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { message: "Title Template deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      `Error deleting Title Template ${params.templateId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error deleting Title Template." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/title-templates/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import TitleTemplate, { ITitleTemplate } from "@/models/TitleTemplate";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {

    const { searchParams } = new URL(request.url);
    if (searchParams.get("active") !== "true") {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }
  }

  await dbConnect();

  try {
    const { searchParams } = new URL(request.url);
    const activeOnly = searchParams.get("active") === "true";

    const query = activeOnly ? { isActive: true } : {};

    const templates = await TitleTemplate.find(query).sort({ name: 1 }).lean();
    return NextResponse.json(templates, { status: 200 });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error fetching Title Templates." },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body: Partial<ITitleTemplate> = await request.json();
    const { name, description, template, isActive } = body;

    if (!name || !template) {
      return NextResponse.json(
        { error: "Name and Template content are required." },
        { status: 400 }
      );
    }

    const newTemplate = new TitleTemplate({
      name,
      description,
      template,
      isActive: isActive !== undefined ? isActive : true,
    });

    await newTemplate.save();
    return NextResponse.json(newTemplate, { status: 201 });
  } catch (error: any) {
    if (error.code === 11000) {
      return NextResponse.json(
        { error: "A template with this name already exists." },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { error: "Server error creating Title Template." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/translations/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import path from "path";
import { promises as fs } from "fs";
import { i18nCache } from "@/lib/i18n/i18n.cache";
const LOCALES_DIR = path.join(process.cwd(), "src/locales");

export async function GET(request: Request) {

  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { searchParams } = new URL(request.url);
  const locale = searchParams.get("locale");

  if (!locale) {
    return NextResponse.json(
      { error: "Locale parameter is required." },
      { status: 400 }
    );
  }

  try {
    const filePath = path.join(LOCALES_DIR, `${locale}.json`);
    const fileContent = await fs.readFile(filePath, "utf-8");
    return NextResponse.json(JSON.parse(fileContent), { status: 200 });
  } catch (error: any) {
    if (error.code === "ENOENT") {
      return NextResponse.json(
        { error: `Translation file for locale '${locale}' not found.` },
        { status: 404 }
      );
    }
    console.error(
      `Error reading translation file for locale '${locale}':`,
      error
    );
    return NextResponse.json(
      { error: "Server error reading translation file." },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const { locale, content } = await request.json();

    if (!locale || content === undefined) {
      return NextResponse.json(
        { error: "Locale and content are required." },
        { status: 400 }
      );
    }

    let parsedContent;
    try {
      parsedContent =
        typeof content === "string" ? JSON.parse(content) : content;
    } catch (e) {
      return NextResponse.json(
        { error: "Invalid JSON content provided." },
        { status: 400 }
      );
    }

    const filePath = path.join(LOCALES_DIR, `${locale}.json`);
    await fs.writeFile(
      filePath,
      JSON.stringify(parsedContent, null, 2),
      "utf-8"
    );

    await i18nCache.reload();
    console.log(
      `[I18N_CACHE] Reload triggered by update to '${locale}' translations.`
    );

    return NextResponse.json(
      { message: `Translations for '${locale}' saved successfully.` },
      { status: 200 }
    );
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error saving translation file." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/upcoming-fixtures-for-prediction/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post from "@/models/Post";
import axios from "axios";
import { format, addDays } from "date-fns";

const LEAGUES_TO_PREDICT = new Set([

  39, 140, 135, 78, 61,

  2, 3, 848,

  88, 94, 203, 197, 218, 144,

  253, 262, 71, 128,

  45, 143, 137, 81,

  98, 292, 179,

  11, 13, 4,
]);

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  const { searchParams } = new URL(request.url);
  const limit = parseInt(searchParams.get("limit") || "10");
  const skip = parseInt(searchParams.get("skip") || "0");

  const datePromises = [];
  for (let i = 0; i < 7; i++) {
    const date = format(addDays(new Date(), i), "yyyy-MM-dd");
    const apiOptions = {
      method: "GET",
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
      params: { date: date, timezone: "Europe/Istanbul" },
      headers: {
        "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
      },
    };
    datePromises.push(axios.request(apiOptions));
  }

  try {
    const responses = await Promise.allSettled(datePromises);

    const allFetchedFixtures: any[] = responses
      .filter(
        (result) => result.status === "fulfilled" && result.value.data.response
      )
      .flatMap(
        (result) => (result as PromiseFulfilledResult<any>).value.data.response
      );

    console.log(
      `[API/upcoming-fixtures] Fetched a total of ${allFetchedFixtures.length} fixtures from the API across the next 7 days.`
    );

    const finishedOrCancelledStatuses = new Set([
      "FT",
      "AET",
      "PEN",
      "PST",
      "CANC",
      "ABD",
      "AWD",
      "WO",
    ]);

    const upcomingFixtures = allFetchedFixtures.filter(
      (fixture) =>

        LEAGUES_TO_PREDICT.has(fixture.league.id) &&

        !finishedOrCancelledStatuses.has(fixture.fixture.status.short) &&

        fixture.fixture &&
        fixture.fixture.id &&
        fixture.teams?.home &&
        fixture.teams?.away
    );

    console.log(
      `[API/upcoming-fixtures] Filtered down to ${upcomingFixtures.length} valid upcoming fixtures from our target leagues.`
    );

    const fixtureIds = upcomingFixtures.map((f) => f.fixture.id);
    const processedPredictions = await Post.find({
      sport: "prediction",
      originalFixtureId: { $in: fixtureIds },
    })
      .select("originalFixtureId _id")
      .lean();

    const processedMap = new Map(
      processedPredictions.map((post) => [post.originalFixtureId, post._id])
    );

    const enhancedFixtures = upcomingFixtures.map((fixture) => ({
      ...fixture,
      processedPostId:
        processedMap.get(fixture.fixture.id)?.toString() || undefined,
    }));

    enhancedFixtures.sort((a, b) => {
      const dateA = new Date(a.fixture.date).getTime();
      const dateB = new Date(b.fixture.date).getTime();
      return dateA - dateB;
    });

    const paginatedFixtures = enhancedFixtures.slice(skip, skip + limit);

    return NextResponse.json(
      {
        fixtures: paginatedFixtures,
        totalCount: enhancedFixtures.length,
        currentPage: Math.floor(skip / limit) + 1,
        perPage: limit,
      },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      "[API/admin/upcoming-fixtures-for-prediction] Error fetching upcoming fixtures:",
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching upcoming fixtures for prediction." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/auth/[...nextauth]/route.ts =====

import NextAuth, { NextAuthOptions } from "next-auth";
import { MongoDBAdapter } from "@auth/mongodb-adapter";
import clientPromise from "@/lib/mongoClient";
import GoogleProvider from "next-auth/providers/google";
import CredentialsProvider from "next-auth/providers/credentials";
import dbConnect from "@/lib/dbConnect";
import User, { IUser } from "@/models/User";
import bcrypt from "bcrypt";

export const authOptions: NextAuthOptions = {
  adapter: MongoDBAdapter(clientPromise),

  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
    CredentialsProvider({
      name: "Credentials",
      credentials: {},
      async authorize(credentials: any) {
        if (!credentials?.email || !credentials.password) {
          throw new Error("Please enter an email and password");
        }

        await dbConnect();

        const user = await User.findOne({ email: credentials.email }).select(
          "+password"
        );

        if (!user || !user.password) {
          throw new Error("Invalid credentials");
        }

        const isPasswordCorrect = await bcrypt.compare(
          credentials.password,
          user.password
        );

        if (!isPasswordCorrect) {
          throw new Error("Invalid credentials");
        }

        return user;
      },
    }),
  ],

  session: { strategy: "jwt" },

  callbacks: {
    jwt: async ({ token, user }) => {
      if (user) {
        const u = user as IUser;
        token.role = u.role;
        token.id = u.id as string;
      }
      return token;
    },

    session: async ({ session, token }) => {
      if (session?.user) {
        session.user.role = token.role as "user" | "admin";
        session.user.id = token.id as string;
      }
      return session;
    },
  },

  pages: { signIn: "/login" },

  secret: process.env.NEXT_PUBLIC_NEXTAUTH_SECRET,
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };

// ===== src/app/api/banners/[bannerId]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Banner, { IBanner } from "@/models/Banner";

interface Params {
  params: { bannerId: string };
}

export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { bannerId } = params;
  try {
    const body: Partial<IBanner> = await request.json();

    const { title, imageUrl, linkUrl, isActive, location } = body;

    await dbConnect();

    const updatedBanner = await Banner.findByIdAndUpdate(
      bannerId,
      {

        title,
        imageUrl,
        linkUrl,
        isActive,
        location,
      },
      { new: true, runValidators: true }
    );

    if (!updatedBanner) {
      return NextResponse.json({ error: "Banner not found" }, { status: 404 });
    }

    return NextResponse.json(updatedBanner);
  } catch (error) {

    return NextResponse.json(
      { error: "Server error updating banner" },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { bannerId } = params;
  try {
    await dbConnect();
    const deletedBanner = await Banner.findByIdAndDelete(bannerId);
    if (!deletedBanner) {
      return NextResponse.json({ error: "Banner not found" }, { status: 404 });
    }
    return NextResponse.json({ message: "Banner deleted successfully" });
  } catch (error) {
    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}

// ===== src/app/api/banners/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Banner, { IBanner } from "@/models/Banner";

export async function GET(request: Request) {

  const { searchParams } = new URL(request.url);
  const activeOnly = searchParams.get("active") === "true";
  const location = searchParams.get("location");

  const query: { isActive?: boolean; location?: string } = {};
  if (activeOnly) {
    query.isActive = true;
  }
  if (location) {
    query.location = location;
  }

  try {
    await dbConnect();
    const banners = await Banner.find(query).sort({ createdAt: -1 });
    return NextResponse.json(banners);
  } catch (error) {

    return NextResponse.json(
      { error: "Server error fetching banners" },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body: Partial<IBanner> = await request.json();

    console.log(
      "[API/Banners] Received POST request with body:",
      JSON.stringify(body, null, 2)
    );

    const { title, imageUrl, linkUrl, isActive, location } = body;

    if (!title || !imageUrl || !linkUrl || !location) {
      console.error(
        "[API/Banners] Validation failed. Missing required fields."
      );
      return NextResponse.json(
        { error: "Title, Image URL, Link URL, and Location are required" },
        { status: 400 }
      );
    }

    await dbConnect();

    const newBanner = new Banner({
      title,
      imageUrl,
      linkUrl,
      isActive,
      location,
    });

    await newBanner.save();

    return NextResponse.json(newBanner, { status: 201 });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error creating banner" },
      { status: 500 }
    );
  }
}

// ===== src/app/api/batch-predictions/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";

import { generatePrediction } from "@/lib/prediction-engine";
import { convertPercentageToOdds } from "@/lib/odds-converter";

type FanskorOdds = {
  home: string;
  draw: string;
  away: string;
};

const apiRequest = async (
  endpoint: string,
  params: object
): Promise<any | null> => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    timeout: 8000,
  };
  try {
    const response = await axios.request(options);
    return response.data.response;
  } catch (error: any) {
    console.error(
      `[API-Football Sub-Request Error] Endpoint: '${endpoint}', Params: ${JSON.stringify(
        params
      )}, Error: ${error.message}`
    );
    return null;
  }
};

export async function POST(request: Request) {
  try {
    const { fixtureIds }: { fixtureIds: number[] } = await request.json();

    if (!Array.isArray(fixtureIds) || fixtureIds.length === 0) {
      return NextResponse.json(
        { error: "An array of fixture IDs is required." },
        { status: 400 }
      );
    }

    const fixtures: any[] | null = await apiRequest("fixtures", {
      ids: fixtureIds.join("-"),
    });

    if (!fixtures || fixtures.length === 0) {
      return NextResponse.json({});
    }

    const dataPromises = fixtures.map(async (fixture) => {
      const { teams, league, fixture: fixtureDetails } = fixture;
      const [homeTeamStats, awayTeamStats, h2h, standings] = await Promise.all([
        apiRequest("teams/statistics", {
          league: league.id,
          season: league.season,
          team: teams.home.id,
        }),
        apiRequest("teams/statistics", {
          league: league.id,
          season: league.season,
          team: teams.away.id,
        }),
        apiRequest("fixtures/headtohead", {
          h2h: `${teams.home.id}-${teams.away.id}`,
        }),
        apiRequest("standings", { league: league.id, season: league.season }),
      ]);

      if (!homeTeamStats || !awayTeamStats) {
        return { fixtureId: fixtureDetails.id, predictionData: null };
      }

      const leagueStandings = standings?.[0]?.league?.standings?.[0] || [];
      const homeTeamRank = leagueStandings.find(
        (s: any) => s.team.id === teams.home.id
      )?.rank;
      const awayTeamRank = leagueStandings.find(
        (s: any) => s.team.id === teams.away.id
      )?.rank;

      return {
        fixtureId: fixtureDetails.id,
        predictionData: {
          h2h,
          homeTeamStats,
          awayTeamStats,
          homeTeamId: teams.home.id,
          homeTeamRank,
          awayTeamRank,
          matchStatus: fixtureDetails.status.short,
        },
      };
    });

    const settledResults = await Promise.allSettled(dataPromises);
    const oddsMap: Record<number, FanskorOdds> = {};

    settledResults.forEach((result) => {
      if (result.status === "fulfilled" && result.value?.predictionData) {
        const { fixtureId, predictionData } = result.value;
        try {

          const predictionResult = generatePrediction(
            predictionData.h2h,
            predictionData.homeTeamStats,
            predictionData.awayTeamStats,
            predictionData.homeTeamId,
            predictionData.homeTeamRank,
            predictionData.awayTeamRank,
            null,
            predictionData.matchStatus
          );

          oddsMap[fixtureId] = {
            home: convertPercentageToOdds(predictionResult.home),
            draw: convertPercentageToOdds(predictionResult.draw),
            away: convertPercentageToOdds(predictionResult.away),
          };
        } catch (engineError: any) {
          console.error(
            `[Prediction Engine Error] for fixture ${fixtureId}: ${engineError.message}`
          );
        }
      } else if (result.status === "rejected") {
        console.error(
          `[Batch Predictions] Data promise failed for a fixture:`,
          result.reason
        );
      }
    });

    console.log(
      `[Batch Predictions] Successfully generated odds for ${
        Object.keys(oddsMap).length
      } fixtures using the standardized engine.`
    );
    return NextResponse.json(oddsMap);
  } catch (error) {
    console.error(
      "[Batch Predictions] Critical unhandled error in POST handler:",
      error
    );
    return NextResponse.json(
      {
        error:
          "Failed to generate batch predictions due to a critical server error.",
      },
      { status: 500 }
    );
  }
}

// ===== src/app/api/casino-partners/route.ts =====

import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import CasinoPartner from "@/models/CasinoPartner";

export async function GET(request: Request) {
  await dbConnect();

  try {
    const { searchParams } = new URL(request.url);
    const featuredOnly = searchParams.get("featured") === "true";

    const query: { isActive: boolean; isFeatured?: boolean } = {
      isActive: true,
    };
    if (featuredOnly) {
      query.isFeatured = true;
    }

    const partners = await CasinoPartner.aggregate([
      { $match: query },
      { $addFields: { __rand: { $rand: {} } } },
      { $sort: { order: 1, isFeatured: -1, __rand: 1 } },
      { $project: { __rand: 0 } },
      { $limit: 10 },
    ]);

    return NextResponse.json(partners, { status: 200 });
  } catch (error: any) {
    :", error.message);
    return NextResponse.json(
      { error: "Server error fetching Casino Partners." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/contact/route.ts =====

import { NextResponse } from "next/server";

interface ContactFormData {
  name: string;
  email: string;
  subject: string;
  message: string;
}

export async function POST(request: Request) {
  try {
    const { name, email, subject, message }: ContactFormData =
      await request.json();

    if (!name || !email || !subject || !message) {
      return NextResponse.json(
        { error: "All fields are required." },
        { status: 400 }
      );
    }
    if (!email.includes("@") || !email.includes(".")) {
      return NextResponse.json(
        { error: "Please enter a valid email address." },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { message: "Your message has been sent successfully!" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      "[Contact API] Error processing contact form submission:",
      error.message
    );
    return NextResponse.json(
      { error: "An unexpected error occurred." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/countries/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';
import { Country } from '@/types/api-football';

export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/countries`,
    headers: {

      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);

    const transformedCountries: Country[] = response.data.response

      .filter((country: any) => country.name && country.code && country.flag)

      .map((country: any) => ({
        name: country.name,
        code: country.code,
        flagUrl: country.flag,
      }));

    transformedCountries.sort((a, b) => a.name.localeCompare(b.name));

    return NextResponse.json(transformedCountries);

  } catch (error) {

    return NextResponse.json(
      { error: 'Failed to fetch country data.' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/country-stats/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";

const POPULAR_LEAGUE_IDS = [
  39, 140, 135, 78, 61, 88, 94, 253, 2, 3, 45, 48, 71, 62, 144, 203, 197, 218,
];
const season = new Date().getFullYear();

export async function GET() {
  const options = (leagueId: number) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
    params: { league: leagueId, season: season },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    const teamPromises = POPULAR_LEAGUE_IDS.map((id) =>
      axios.request(options(id))
    );
    const responses = await Promise.allSettled(teamPromises);

    const allTeamsResponses = responses
      .filter(
        (result) => result.status === "fulfilled" && result.value.data.response
      )
      .flatMap(
        (result) => (result as PromiseFulfilledResult<any>).value.data.response
      );

    const uniqueTeams = Array.from(
      new Map(allTeamsResponses.map((item) => [item.team.id, item])).values()
    );

    const countryTeamCounts: { [key: string]: number } = {};
    uniqueTeams.forEach((item) => {
      const countryName = item.team.country;
      if (countryName) {
        if (!countryTeamCounts[countryName]) {
          countryTeamCounts[countryName] = 0;
        }
        countryTeamCounts[countryName]++;
      }
    });

    return NextResponse.json(countryTeamCounts);
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to fetch country statistics." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/cron/process-news-batch/route.ts =====

import { NextResponse } from "next/server";
import { headers } from "next/headers";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle from "@/models/ExternalNewsArticle";

import { processSingleArticle } from "@/lib/ai-processing";

const BATCH_SIZE = 5;

export async function GET(request: Request) {

  const headersList = headers();
  const authHeader = headersList.get("authorization");

  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {

    return new Response("Unauthorized", { status: 401 });
  }

  console.log(
    "[CRON] Authorized request received. Starting news processing batch."
  );

  try {
    await dbConnect();

    const articlesToProcess = await ExternalNewsArticle.find({
      status: "fetched",
    })
      .sort({ pubDate: -1 })
      .limit(BATCH_SIZE);

    if (articlesToProcess.length === 0) {

      return NextResponse.json({ message: "No new articles to process." });
    }

    console.log(
      `[CRON] Found ${articlesToProcess.length} articles to process.`
    );
    let successCount = 0;
    let failureCount = 0;

    for (const article of articlesToProcess) {

      const result = await processSingleArticle(article);

      if (result.success) {
        successCount++;
      } else {
        failureCount++;
      }
    }

    const report = {
      message: "CRON job completed.",
      processed: successCount,
      failed: failureCount,
      total: articlesToProcess.length,
    };

    return NextResponse.json(report);
  } catch (error: any) {
    console.error(
      "[CRON] A critical error occurred during the batch processing job:",
      error
    );
    return NextResponse.json(
      { error: "Internal Server Error during CRON job." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/directory/countries/route.ts =====

import { NextResponse, NextRequest } from "next/server";
import axios from "axios";

export async function GET(request: NextRequest) {
  try {

    const protocol = request.headers.get("x-forwarded-proto") || "http";
    const host = request.headers.get("host");

    const internalApiUrl = `${protocol}://${host}/api/leagues?fetchAll=true`;

    const leaguesResponse = await axios.get(internalApiUrl);
    const allLeagues = leaguesResponse.data;

    if (!allLeagues || allLeagues.length === 0) {
      return NextResponse.json([]);
    }

    const leagueCounts: { [key: string]: number } = {};
    allLeagues.forEach((league: any) => {
      if (league.countryName) {
        leagueCounts[league.countryName] =
          (leagueCounts[league.countryName] || 0) + 1;
      }
    });

    const countriesResponse = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/countries`,
      {
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );

    const allCountries = countriesResponse.data.response;

    let enrichedCountries = allCountries
      .map((country: any) => ({
        name: country.name,
        code: country.code,
        flagUrl: country.flag,
        leagueCount: leagueCounts[country.name] || 0,
      }))
      .filter(
        (country: any) =>
          country.leagueCount > 0 &&
          country.name &&
          country.code &&
          country.flagUrl
      );

    enrichedCountries.sort((a, b) => a.name.localeCompare(b.name));

    return NextResponse.json(enrichedCountries);
  } catch (error) {

    if (axios.isAxiosError(error)) {

    }
    return NextResponse.json(
      { error: "Failed to build country directory." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/directory/teams/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';
import redis from '@/lib/redis';

const POPULAR_LEAGUE_IDS = [
  39, 140, 135, 78, 61, 88, 94, 253, 2,
];
const season = new Date().getFullYear();
const CACHE_KEY = `teams:popular:${season}`;
const CACHE_TTL_SECONDS = 60 * 60 * 24;

export async function GET() {
  try {

    const cachedData = await redis.get(CACHE_KEY);
    if (cachedData) {

      return NextResponse.json(JSON.parse(cachedData));
    }

    const options = (leagueId: number) => ({
      method: 'GET',
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
      params: { league: leagueId, season: season },
      headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    });

    const teamPromises = POPULAR_LEAGUE_IDS.map(id => axios.request(options(id)));
    const responses = await Promise.allSettled(teamPromises);

    const allTeamsResponses = responses
      .filter(result => result.status === 'fulfilled' && result.value.data.response)
      .flatMap(result => (result as PromiseFulfilledResult<any>).value.data.response);

    const uniqueTeams = Array.from(new Map(allTeamsResponses.map(item => [item.team.id, item])).values());

    uniqueTeams.sort((a, b) => a.team.name.localeCompare(b.team.name));

    if (uniqueTeams.length > 0) {
      await redis.set(CACHE_KEY, JSON.stringify(uniqueTeams), "EX", CACHE_TTL_SECONDS);

    }

    return NextResponse.json(uniqueTeams);

  } catch (error) {

    return NextResponse.json(
      { error: 'Failed to fetch teams data.' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/faqs/route.ts =====

import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import Faq from "@/models/Faq";

export async function GET() {
  try {
    await dbConnect();

    const faqs = await Faq.find({ isActive: true })
      .sort({ category: 1, order: 1 })
      .lean();

    return NextResponse.json(faqs);
  } catch (error) {

    return NextResponse.json(
      { error: "Server error fetching FAQs." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/find-live-matches/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: { live: 'all' },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);

    return NextResponse.json(response.data.response);
  } catch (error) {

    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src/app/api/fixtures/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import { format, addDays } from "date-fns";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get("league");
  const date = searchParams.get("date");
  const season = searchParams.get("season");

  const axiosOptions = (params: object) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params,
    headers: {
      "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  });

  try {
    let matchesData: any[] = [];

    if (leagueId && season) {
      const response = await axios.request(axiosOptions({ league: leagueId, season: season }));
      matchesData = response.data.response.sort((a: any, b: any) => new Date(a.fixture.date).getTime() - new Date(b.fixture.date).getTime());
    } else if (leagueId && date) {
      const response = await axios.request(axiosOptions({ league: leagueId, season: new Date(date).getFullYear().toString(), date: date }));
      matchesData = response.data.response;
    } else if (leagueId) {
      const today = format(new Date(), "yyyy-MM-dd");
      const nextSevenDays = format(addDays(new Date(), 7), "yyyy-MM-dd");
      const response = await axios.request(axiosOptions({ league: leagueId, season: new Date().getFullYear().toString(), from: today, to: nextSevenDays }));
      matchesData = response.data.response;
    } else if (date) {
      const response = await axios.request(axiosOptions({ date: date }));
      matchesData = response.data.response;
    } else {
      const todayStr = format(new Date(), "yyyy-MM-dd");
      const tomorrowStr = format(addDays(new Date(), 1), "yyyy-MM-dd");
      const [liveResponse, todayResponse, tomorrowResponse] = await Promise.all([
        axios.request(axiosOptions({ live: "all" })),
        axios.request(axiosOptions({ date: todayStr })),
        axios.request(axiosOptions({ date: tomorrowStr })),
      ]);
      const allMatches = [...liveResponse.data.response, ...todayResponse.data.response, ...tomorrowResponse.data.response];
      matchesData = Array.from(new Map(allMatches.map((m) => [m.fixture.id, m])).values());
    }

    return NextResponse.json(matchesData);

  } catch (error) {

    return NextResponse.json(
      { error: "Failed to fetch fixture data." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/global-live/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,

    params: { live: 'all' },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);

    return NextResponse.json(response.data.response);
  } catch (error) {

    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src/app/api/highlights/latest/route.ts =====

import { NextResponse } from "next/server";
import { getLatestPopularHighlights } from "@/lib/data/highlightly";
import axios from "axios";

async function isValidEmbed(url: string): Promise<boolean> {
  try {
    const response = await axios.head(url, {
      timeout: 3000,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });

    return response.status >= 200 && response.status < 300;
  } catch (error) {

    return false;
  }
}

export async function GET(request: Request) {
  try {
    const latestHighlights = await getLatestPopularHighlights();

    if (!latestHighlights || latestHighlights.length === 0) {
      return NextResponse.json({ highlights: [] }, { status: 200 });
    }

    const validationPromises = latestHighlights.map((highlight: any) =>
      isValidEmbed(highlight.embedUrl)
    );

    const validationResults = await Promise.allSettled(validationPromises);

    const validHighlights = latestHighlights.filter((_, index) => {
      const result = validationResults[index];
      return result.status === "fulfilled" && result.value === true;
    });

    const headers = new Headers();
    headers.set(
      "Cache-control",
      "public, s-maxage=300, stale-while-revalidate=600"
    );

    return NextResponse.json(
      { highlights: validHighlights },
      { status: 200, headers }
    );
  } catch (error: any) {
    console.error(
      `[API/highlights/latest] Error fetching or validating popular highlights:`,
      error.message
    );
    return NextResponse.json(
      { error: "Failed to fetch latest highlights from the provider." },
      { status: 502 }
    );
  }
}

// ===== src/app/api/highlights/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import { getMatchHighlights } from "@/lib/data/highlightly";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get("fixtureId");

  if (!fixtureId) {
    return NextResponse.json(
      { error: "Fixture ID is required" },
      { status: 400 }
    );
  }

  try {

    const sportsApiUrl = `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures?id=${fixtureId}`;
    const sportsApiResponse = await axios.get(sportsApiUrl, {
      headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    });

    const fixtureData = sportsApiResponse.data.response[0];
    if (!fixtureData) {
      return NextResponse.json(
        { error: "Fixture data not found." },
        { status: 404 }
      );
    }

    const { league, teams } = fixtureData;

    const highlightlyParams = {
      leagueName: league.name,
      homeTeamName: teams.home.name,
      awayTeamName: teams.away.name,
      limit: 40,
    };

    const highlightsData = await getMatchHighlights(highlightlyParams);

    const headers = new Headers();
    headers.set(
      "Cache-Control",
      "public, s-maxage=600, stale-while-revalidate=1200"
    );

    let finalData = { highlights: highlightsData.data ?? [] };

    return NextResponse.json(finalData, { status: 200, headers });
  } catch (error: any) {
    console.error(
      `[API/highlights] Error processing highlights for fixture ${fixtureId}:`,
      error.message
    );

    return NextResponse.json(
      { error: "Failed to fetch highlights from the provider." },
      { status: 502 }
    );
  }
}

// ===== src/app/api/image-proxy/route.ts =====

import { NextRequest, NextResponse } from "next/server";
import redis from "@/lib/redis";

const CACHE_TTL_SECONDS = 60 * 60 * 24 * 7;

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const imageUrl = searchParams.get("url");

  if (!imageUrl) {
    return NextResponse.json(
      { error: "Image URL is required" },
      { status: 400 }
    );
  }

  const cacheKey = `image:${imageUrl}`;

  try {

    const cachedData = await redis.hgetall(cacheKey);

    if (cachedData && cachedData.buffer && cachedData.contentType) {

      const imageBuffer = Buffer.from(cachedData.buffer, 'binary');

      return new NextResponse(imageBuffer, {
        status: 200,
        headers: {
          "Content-Type": cachedData.contentType,
          "Cache-Control": "public, max-age=604800, immutable",
          "X-Cache-Status": "HIT",
        },
      });
    }

    const response = await fetch(imageUrl, {
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });

    if (!response.ok) {
      throw new Error(`Upstream fetch failed with status ${response.status}`);
    }

    const imageBuffer = Buffer.from(await response.arrayBuffer());
    const contentType = response.headers.get("content-type") || "image/png";

    const pipeline = redis.pipeline();
    pipeline.hset(cacheKey, {
        buffer: imageBuffer.toString('binary'),
        contentType: contentType,
    });
    pipeline.expire(cacheKey, CACHE_TTL_SECONDS);
    await pipeline.exec();

    return new NextResponse(imageBuffer, {
      status: 200,
      headers: {
        "Content-Type": contentType,
        "Cache-Control": "public, max-age=604800, immutable",
        "X-Cache-Status": "MISS",
      },
    });

  } catch (error: any) {

    return NextResponse.redirect(new URL("/images/placeholder-logo.svg", request.url));
  }
}

// ===== src/app/api/leagues/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import { League } from "@/types/api-football";
import { generateLeagueSlug } from "@/lib/generate-league-slug";
import redis from "@/lib/redis";

const POPULAR_LEAGUE_IDS = new Set([39, 140, 135, 78, 61, 88, 94, 253, 203]);
const POPULAR_CUP_IDS = new Set([2, 3, 531, 45, 9, 11]);
const CACHE_TTL_SECONDS = 60 * 60 * 24;

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const country = searchParams.get("country");
  const type = searchParams.get("type");
  const fetchAll = searchParams.get("fetchAll");

  const cacheKey = `leagues:${fetchAll ? 'all' : country || 'popular'}:${type || 'all'}`;

  try {

    const cachedData = await redis.get(cacheKey);
    if (cachedData) {

      return NextResponse.json(JSON.parse(cachedData));
    }

    const params: { current: string; country?: string; type?: string } = {
      current: "true",
    };
    if (country) params.country = country;
    if (type) params.type = type;

    const options = {
      method: "GET",
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/leagues`,
      params: params,
      headers: {
        "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
      },
    };

    const response = await axios.request(options);
    let allLeagues = response.data.response;

    if (!country && !fetchAll) {
      const popularIds = type === "cup" ? POPULAR_CUP_IDS : POPULAR_LEAGUE_IDS;
      allLeagues = allLeagues.filter((item: any) =>
        popularIds.has(item.league.id)
      );
    }

    const transformedData: League[] = allLeagues
      .filter(
        (item: any) => item.league.id && item.league.name && item.league.logo
      )
      .map((item: any) => ({
        id: item.league.id,
        name: item.league.name,
        logoUrl: item.league.logo,
        countryName: item.country.name,
        countryFlagUrl: item.country.flag,
        type: item.league.type,
        href: generateLeagueSlug(item.league.name, item.league.id),
      }));

    transformedData.sort((a, b) => a.name.localeCompare(b.name));

    if (transformedData.length > 0) {
        await redis.set(cacheKey, JSON.stringify(transformedData), "EX", CACHE_TTL_SECONDS);

    }

    return NextResponse.json(transformedData);

  } catch (error) {

    return NextResponse.json(
      { error: "Failed to fetch league data." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/live-matches/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');

  if (!leagueId) {
    return NextResponse.json({ error: 'League ID is required' }, { status: 400 });
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: {
      league: leagueId,
      live: 'all',
    },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);

    return NextResponse.json(response.data.response);
  } catch (error) {

    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src/app/api/live-odds/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET() {

    const options = {
        method: 'GET',
        url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds/live`,
        params: { bet: '1' },
        headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    };

    try {
        const response = await axios.request(options);

        if (!response.data.response || response.data.response.length === 0) {
            return NextResponse.json({}, { status: 200 });
        }

        const liveOddsObject = response.data.response.reduce((acc: any, fixtureData: any) => {
            const fixtureId = fixtureData.fixture.id;
            const bookmaker = fixtureData.bookmakers?.[0];
            const matchWinnerBet = bookmaker?.bets.find((bet: any) => bet.id === 1);

            if (matchWinnerBet) {
                const odds = matchWinnerBet.values.reduce((oddAcc: any, curr: any) => {
                    if (curr.value === 'Home') oddAcc.home = curr.odd;
                    if (curr.value === 'Draw') oddAcc.draw = curr.odd;
                    if (curr.value === 'Away') oddAcc.away = curr.odd;
                    return oddAcc;
                }, {});
                acc[fixtureId] = odds;
            }
            return acc;
        }, {});

        return NextResponse.json(liveOddsObject, { status: 200 });

    } catch (error) {

        return NextResponse.json(
            { error: 'Failed to fetch live odds data from the provider.' },
            { status: 500 }
        );
    }
}

// ===== src/app/api/live-odds-by-fixture/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";

const extractMainOdds = (odds: any[], betId: number, valueKeys: string[]) => {
  const betData = odds.find((o) => o.id === betId);
  if (!betData) return null;

  let targetValues = betData.values.find((v: any) => v.main === true)
    ? betData.values.filter((v: any) => v.main === true)
    : betData.values;

  const result: { [key: string]: string | null } = {};
  valueKeys.forEach((key) => {
    result[key.toLowerCase()] =
      targetValues.find((v: any) => v.value === key)?.odd || null;
  });

  result.handicap = targetValues[0]?.handicap || null;

  const hasValues = Object.values(result).some(
    (v) => v !== null && v !== undefined
  );
  return hasValues ? result : null;
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get("fixture");

  if (!fixtureId) {
    return NextResponse.json(
      { error: "Fixture ID is required" },
      { status: 400 }
    );
  }

  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds/live`,
    params: { fixture: fixtureId },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };

  try {
    const response = await axios.request(options);
    const liveData = response.data.response[0];

    if (!liveData || !liveData.odds) {
      return NextResponse.json(null);
    }

    const odds = liveData.odds;

    const curatedOdds = {
      asianHandicap: extractMainOdds(odds, 33, ["Home", "Away"]),
      overUnder: extractMainOdds(odds, 36, ["Over", "Under"]),
      matchCorners: extractMainOdds(odds, 20, ["Over", "Under"]),
      nextGoal: extractMainOdds(odds, 85, ["1", "No goal", "2"]),
    };

    return NextResponse.json(curatedOdds);
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to fetch live odds" },
      { status: 500 }
    );
  }
}

// ===== src/app/api/match-details/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import redis from "@/lib/redis";

const CACHE_TTL_LIVE = 30;
const CACHE_TTL_UPCOMING = 30;
const CACHE_TTL_FINISHED = 604800;

const calculateCustomPrediction = (
  h2h: any[],
  homeTeamStats: any,
  awayTeamStats: any,
  homeTeamId: number,
  homeTeamRank: number | undefined,
  awayTeamRank: number | undefined,
  matchEvents: any[] | null,
  matchStatus: string
) => {
  const config = {
    weights: {
      homeAdvantage: 12,
      form: 1.5,
      h2h: 2.5,
      rankDifference: 0.8,
      goalDifference: 6,
      xGInfluence: 3,
      matchActivity: 0.5,
      liveMatchBonus: 5,
    },
    h2hMaxGames: 5,
    drawWeight: 0.85,
  };
  let homeScore = 0;
  let awayScore = 0;
  homeScore += config.weights.homeAdvantage;
  const calculateForm = (formString: string): number => {
    return (
      (formString.match(/W/g) || []).length * 3 +
      (formString.match(/D/g) || []).length * 1
    );
  };
  const homeFormString = homeTeamStats?.form || "";
  const awayFormString = awayTeamStats?.form || "";
  homeScore += calculateForm(homeFormString) * config.weights.form;
  awayScore += calculateForm(awayFormString) * config.weights.form;
  const homeGoalsForAvg = homeTeamStats?.goals?.for?.average?.total ?? 0;
  const homeGoalsAgainstAvg =
    homeTeamStats?.goals?.against?.average?.total ?? 0;
  const awayGoalsForAvg = awayTeamStats?.goals?.for?.average?.total ?? 0;
  const awayGoalsAgainstAvg =
    awayTeamStats?.goals?.against?.average?.total ?? 0;
  const homeGoalDiff = homeGoalsForAvg - homeGoalsAgainstAvg;
  const awayGoalDiff = awayGoalsForAvg - awayGoalsAgainstAvg;
  homeScore += homeGoalDiff * config.weights.goalDifference;
  awayScore += awayGoalDiff * config.weights.goalDifference;
  const simulateXG = (avgGoals: number) => Math.min(avgGoals * 1.1, 3.0);
  const homeXG = simulateXG(homeGoalsForAvg);
  const awayXG = simulateXG(awayGoalsForAvg);
  const xgDiff = homeXG - awayXG;
  homeScore += xgDiff * config.weights.xGInfluence;
  awayScore -= xgDiff * config.weights.xGInfluence;
  if (h2h && h2h.length > 0) {
    h2h.slice(0, config.h2hMaxGames).forEach((match) => {
      if (match.teams.home.winner) {
        homeTeamId === match.teams.home.id
          ? (homeScore += config.weights.h2h)
          : (awayScore += config.weights.h2h);
      } else if (match.teams.away.winner) {
        homeTeamId === match.teams.away.id
          ? (homeScore += config.weights.h2h)
          : (awayScore += config.weights.h2h);
      } else {
        homeScore += config.weights.h2h / 2;
        awayScore += config.weights.h2h / 2;
      }
    });
  }
  if (homeTeamRank != null && awayTeamRank != null) {
    const rankDiff = Math.abs(homeTeamRank - awayTeamRank);
    if (homeTeamRank < awayTeamRank) {
      homeScore += rankDiff * config.weights.rankDifference;
    } else if (awayTeamRank < homeTeamRank) {
      awayScore += rankDiff * config.weights.rankDifference;
    }
  }
  const isLiveMatch = ["1H", "HT", "2H", "ET", "BT", "P", "LIVE"].includes(
    matchStatus
  );
  if (isLiveMatch) {
    homeScore += config.weights.liveMatchBonus;
    awayScore += config.weights.liveMatchBonus;
    const recentEventsCount = matchEvents?.filter(
      (event: any) =>
        (event.type === "Goal" || event.type === "Card") &&
        event.time.elapsed > (matchStatus === "1H" ? 1 : 45)
    ).length || 0;
    homeScore += recentEventsCount * config.weights.matchActivity;
    awayScore += recentEventsCount * config.weights.matchActivity;
  }
  homeScore = Math.max(1, homeScore);
  awayScore = Math.max(1, awayScore);
  const drawScore =
    (homeScore + awayScore) *
    (1 - Math.abs(homeScore - awayScore) / (homeScore + awayScore)) *
    config.drawWeight;
  const totalPoints = homeScore + awayScore + drawScore;
  if (totalPoints <= 1) {
    return { home: 33, draw: 34, away: 33 };
  }
  let homePercent = Math.round((homeScore / totalPoints) * 100);
  let awayPercent = Math.round((awayScore / totalPoints) * 100);
  let drawPercent = 100 - homePercent - awayPercent;
  if (homePercent + awayPercent + drawPercent !== 100) {
    const diff = 100 - (homePercent + awayPercent + drawPercent);
    if (homePercent >= awayPercent && homePercent >= drawPercent) {
      homePercent += diff;
    } else if (awayPercent >= homePercent && awayPercent >= drawPercent) {
      awayPercent += diff;
    } else {
      drawPercent += diff;
    }
  }
  return {
    home: homePercent,
    draw: drawPercent,
    away: awayPercent,
  };
};

const convertPercentageToOdds = (percent: number): string => {
  if (percent <= 0) return "INF";
  return (100 / percent).toFixed(2);
};

const fetchAllDataForFixture = async (fixtureId: string | number) => {
  const options = (endpoint: string, params: object) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  const fixtureResponse = await axios.request(
    options("fixtures", { id: fixtureId })
  );
  const fixtureData = fixtureResponse.data.response[0];

  if (!fixtureData) {
    throw new Error(`Fixture not found with ID: ${fixtureId}`);
  }

  const { league, teams } = fixtureData;
  const { home: homeTeam, away: awayTeam } = teams;

  const [
    eventsResponse,
    statsResponse,
    h2hResponse,
    predictionResponse,
    homeStatsResponse,
    awayStatsResponse,
    oddsResponse,
    standingsResponse,
  ] = await Promise.all([
    axios.request(options("fixtures/events", { fixture: fixtureId })),
    axios.request(options("fixtures/statistics", { fixture: fixtureId })),
    axios.request(
      options("fixtures/headtohead", { h2h: `${homeTeam.id}-${awayTeam.id}` })
    ),
    axios.request(options("predictions", { fixture: fixtureId })),
    axios.request(
      options("teams/statistics", {
        league: league.id,
        season: league.season,
        team: homeTeam.id,
      })
    ),
    axios.request(
      options("teams/statistics", {
        league: league.id,
        season: league.season,
        team: awayTeam.id,
      })
    ),
    axios.request(options("odds", { fixture: fixtureId, bet: "1" })),
    axios.request(
      options("standings", { league: league.id, season: league.season })
    ),
  ]);

  const standings =
    standingsResponse.data.response[0]?.league?.standings[0] || [];
  const homeTeamRank = standings.find(
    (s: any) => s.team.id === homeTeam.id
  )?.rank;
  const awayTeamRank = standings.find(
    (s: any) => s.team.id === awayTeam.id
  )?.rank;

  const customPredictionPercentages = calculateCustomPrediction(
    h2hResponse.data.response,
    homeStatsResponse.data.response,
    awayStatsResponse.data.response,
    homeTeam.id,
    homeTeamRank,
    awayTeamRank,
    eventsResponse.data.response,
    fixtureData.fixture.status.short
  );

  const customPredictionOdds = customPredictionPercentages
    ? {
        home: convertPercentageToOdds(customPredictionPercentages.home),
        draw: convertPercentageToOdds(customPredictionPercentages.draw),
        away: convertPercentageToOdds(customPredictionPercentages.away),
      }
    : null;

  return {
    fixture: fixtureData,
    events: eventsResponse.data.response,
    statistics: statsResponse.data.response,
    h2h: h2hResponse.data.response,
    analytics: {
      prediction: predictionResponse.data.response[0] ?? null,
      homeTeamStats: homeStatsResponse.data.response ?? null,
      awayTeamStats: awayStatsResponse.data.response ?? null,
      customPrediction: customPredictionPercentages,
      customOdds: customPredictionOdds,
      bookmakerOdds: oddsResponse.data.response[0]?.bookmakers ?? [],
    },
  };
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get("fixture");

  if (!fixtureId) {
    return NextResponse.json(
      { error: "Fixture ID is required" },
      { status: 400 }
    );
  }

  const cacheKey = `match-details:${fixtureId}`;

  try {

    const cachedData = await redis.get(cacheKey);
    if (cachedData) {

      return NextResponse.json(JSON.parse(cachedData));
    }

    const matchDetails = await fetchAllDataForFixture(fixtureId);

    const status = matchDetails.fixture.fixture.status.short;
    let ttl = CACHE_TTL_UPCOMING;
    if (["1H", "HT", "2H", "ET", "P", "LIVE"].includes(status)) {
      ttl = CACHE_TTL_LIVE;
    } else if (["FT", "AET", "PEN"].includes(status)) {
      ttl = CACHE_TTL_FINISHED;
    }

    await redis.set(cacheKey, JSON.stringify(matchDetails), "EX", ttl);

    return NextResponse.json(matchDetails);

  } catch (error: any) {
    console.error(
      `[API /match-details] Error for fixture ${fixtureId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Failed to fetch match details." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/odds/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);
    const fixtureId = searchParams.get('fixture');

    if (!fixtureId) {
        return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
    }

    const options = {
        method: 'GET',
        url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds`,
        params: {
            fixture: fixtureId,
            bookmaker: '8',
            bet: '1'
        },
        headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    };

    try {

        const response = await axios.request(options);

        if (!response.data.response || response.data.response.length === 0) {

            return NextResponse.json(null, { status: 200 });
        }

        const bookmaker = response.data.response[0].bookmakers[0];

        const matchWinnerBet = bookmaker.bets.find((bet: any) => bet.id === 1);

        if (!matchWinnerBet || !matchWinnerBet.values) {

            return NextResponse.json(null, { status: 200 });
        }

        const odds = matchWinnerBet.values.reduce((acc: any, curr: any) => {
            if (curr.value === 'Home') acc.home = curr.odd;
            if (curr.value === 'Draw') acc.draw = curr.odd;
            if (curr.value === 'Away') acc.away = curr.odd;
            return acc;
        }, {});

        return NextResponse.json(odds, { status: 200 });

    } catch (error) {

        return NextResponse.json(
            { error: 'Failed to fetch odds data from the provider.' },
            { status: 500 }
        );
    }
}

// ===== src/app/api/pages/[pageSlug]/route.ts =====

import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import PageContent from "@/models/PageContent";

interface Params {
  params: Promise<{ pageSlug: string }>;
}

export async function GET(request: Request, { params }: Params) {
  try {
    const { pageSlug } = await params;
    if (!pageSlug) {
      return NextResponse.json(
        { error: "Page slug is required." },
        { status: 400 }
      );
    }

    await dbConnect();

    const pageContent = await PageContent.findOne({ pageSlug }).lean();

    if (!pageContent) {
      return NextResponse.json(
        { error: "Page content not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(pageContent);
  } catch (error) {
    console.error(
      `[API/pages] Error fetching page content for slug "${
        (await params).pageSlug
      }":`,
      error
    );
    return NextResponse.json(
      { error: "Server error fetching page content." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/posts/[postId]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post, { IPost } from "@/models/Post";
import slugify from "slugify";

interface Params {
  params: { postId: string };
}

export async function GET(request: Request, { params }: Params) {

  const { postId } = params;
  try {
    await dbConnect();
    const post = await Post.findById(postId);
    if (!post) {
      return NextResponse.json({ error: "Post not found" }, { status: 404 });
    }
    return NextResponse.json(post);
  } catch (error) {

    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}

export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { postId } = params;
  try {
    const body: Partial<IPost> & { slug?: string } = await request.json();
    const { title, slug, content } = body;

    if (!title || !content) {
      return NextResponse.json(
        { error: "Title and content are required." },
        { status: 400 }
      );
    }

    await dbConnect();

    const existingPost = await Post.findById(postId);
    if (!existingPost) {
      return NextResponse.json({ error: "Post not found" }, { status: 404 });
    }

    const finalSlug = slugify(slug || title, { lower: true, strict: true });

    const slugExists = await Post.findOne({
      slug: finalSlug,
      language: existingPost.language,
      _id: { $ne: postId },
    });

    if (slugExists) {
      return NextResponse.json(
        {
          error: `The slug '${finalSlug}' is already in use by another post in this language.`,
        },
        { status: 409 }
      );
    }

    const updatedPost = await Post.findByIdAndUpdate(
      postId,
      { ...body, slug: finalSlug },
      { new: true, runValidators: true }
    );

    return NextResponse.json(updatedPost);
  } catch (error: any) {

    if (error.code === 11000) {
      return NextResponse.json(
        {
          error:
            "This slug is already in use for this language. Please choose a unique slug.",
        },
        { status: 409 }
      );
    }
    if (error.name === "ValidationError") {
      return NextResponse.json({ error: error.message }, { status: 400 });
    }

    return NextResponse.json(
      { error: "An unexpected server error occurred while updating the post." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, { params }: Params) {

  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { postId } = params;
  try {
    await dbConnect();
    const deletedPost = await Post.findByIdAndDelete(postId);
    if (!deletedPost) {
      return NextResponse.json({ error: "Post not found" }, { status: 404 });
    }
    return NextResponse.json({ message: "Post deleted successfully" });
  } catch (error) {

    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}

// ===== src/app/api/posts/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post, { IPost } from "@/models/Post";
import slugify from "slugify";
import mongoose from "mongoose";
import { getNews } from "@/lib/data/news";

const DEFAULT_LOCALE = "tr";

export async function GET(request: Request) {

  const { searchParams } = new URL(request.url);
  const locale = searchParams.get("language") || DEFAULT_LOCALE;
  const limit = searchParams.get("limit");
  const sportsCategory = searchParams.get("sportsCategory") as
    | IPost["sportsCategory"][number]
    | null;
  const excludeSportsCategory = searchParams.get("excludeSportsCategory") as
    | IPost["sportsCategory"][number]
    | null;

  try {
    const curatedNews = await getNews({
      locale,
      sportsCategory: sportsCategory || undefined,
      excludeSportsCategory: excludeSportsCategory || undefined,
    });
    const limitedNews = limit
      ? curatedNews.slice(0, parseInt(limit, 10))
      : curatedNews;
    return NextResponse.json(limitedNews);
  } catch (error) {

    return NextResponse.json(
      { error: "Server error fetching posts" },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body: Partial<IPost> & {
      language: string;
      translationGroupId?: string;
      slug?: string;
    } = await request.json();
    const { title, slug, content, language } = body;

    if (!title || !content || !language) {
      return NextResponse.json(
        { error: "Title, content, and language are required" },
        { status: 400 }
      );
    }

    await dbConnect();

    const finalSlug = slugify(slug || title, { lower: true, strict: true });

    const slugExists = await Post.findOne({ slug: finalSlug, language });
    if (slugExists) {
      return NextResponse.json(
        {
          error: `A post with the slug '${finalSlug}' already exists in this language.`,
        },
        { status: 409 }
      );
    }

    const newPost = new Post({
      ...body,
      slug: finalSlug,
      author: session.user.name || "Admin",
      translationGroupId: body.translationGroupId
        ? new mongoose.Types.ObjectId(body.translationGroupId)
        : new mongoose.Types.ObjectId(),
    });

    await newPost.save();
    return NextResponse.json(newPost, { status: 201 });
  } catch (error: any) {

    if (error.code === 11000) {
      return NextResponse.json(
        {
          error:
            "This slug is already in use for this language. Please choose a unique slug.",
        },
        { status: 409 }
      );
    }
    if (error.name === "ValidationError") {
      return NextResponse.json({ error: error.message }, { status: 400 });
    }

    return NextResponse.json(
      { error: "An unexpected server error occurred while creating the post." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/predictions/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get('fixture');

  if (!fixtureId) {
    return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/predictions`,
    params: { fixture: fixtureId },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    if (!response.data.response || response.data.response.length === 0) {
      return NextResponse.json({ error: 'No prediction available.' }, { status: 404 });
    }

    const predictionData = response.data.response[0];

    const transformedPrediction = {
      teams: {
        home: {
          id: predictionData.teams.home.id,
          name: predictionData.teams.home.name,
          logo: predictionData.teams.home.logo,
        },
        away: {
          id: predictionData.teams.away.id,
          name: predictionData.teams.away.name,
          logo: predictionData.teams.away.logo,
        }
      },
      percent: {
        home: parseInt(predictionData.predictions.percent.home.replace('%', '')),
        draw: parseInt(predictionData.predictions.percent.draw.replace('%', '')),
        away: parseInt(predictionData.predictions.percent.away.replace('%', '')),
      }
    };

    return NextResponse.json(transformedPrediction);

  } catch (error) {

    return NextResponse.json({ error: 'Failed to fetch prediction data.' }, { status: 500 });
  }
}

// ===== src/app/api/search/fixtures/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import { format, addDays } from "date-fns";

const apiRequest = async (endpoint: string, params: object): Promise<any[]> => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    timeout: 8000,
  };
  try {
    const response = await axios.request(options);
    return response.data.response;
  } catch (error: any) {
    console.error(
      `[API Search Helper] Error fetching '${endpoint}' with params ${JSON.stringify(
        params
      )}:`,
      error.message
    );
    return [];
  }
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get("q");

  if (!query || query.length < 3) {
    return NextResponse.json(
      { error: "A search query with at least 3 characters is required." },
      { status: 400 }
    );
  }

  const season = new Date().getFullYear().toString();
  const fromDate = format(new Date(), "yyyy-MM-dd");
  const toDate = format(addDays(new Date(), 30), "yyyy-MM-dd");

  try {

    const [teamResults, leagueResults] = await Promise.all([
      apiRequest("teams", { search: query }),
      apiRequest("leagues", { search: query }),
    ]);

    const teamIds = teamResults.map((t: any) => t.team.id);
    const leagueIds = leagueResults.map((l: any) => l.league.id);

    if (teamIds.length === 0 && leagueIds.length === 0) {

      return NextResponse.json([]);
    }

    const fixturePromises: Promise<any[]>[] = [];

    teamIds.forEach((teamId) => {
      fixturePromises.push(
        apiRequest("fixtures", {
          team: teamId,
          season: season,
          from: fromDate,
          to: toDate,
        })
      );
    });

    leagueIds.forEach((leagueId) => {
      fixturePromises.push(
        apiRequest("fixtures", {
          league: leagueId,
          season: season,
          from: fromDate,
          to: toDate,
        })
      );
    });

    const allFixtureResponses = await Promise.all(fixturePromises);
    const allFixtures = allFixtureResponses.flat();

    const uniqueFixtures = Array.from(
      new Map(allFixtures.map((m) => [m.fixture.id, m])).values()
    );

    uniqueFixtures.sort((a, b) => a.fixture.timestamp - b.fixture.timestamp);

    return NextResponse.json(uniqueFixtures);
  } catch (error: any) {
    console.error(
      `[API Search] Critical error for query "${query}":`,
      error.message
    );
    return NextResponse.json(
      { error: "Failed to fetch search results." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/sports/[sport]/fixtures/route.ts =====

import { NextResponse } from 'next/server';
import { getSportService } from '@/services/sports';

export async function GET(
  request: Request,
  { params }: { params: { sport: string } }
) {
  const { searchParams } = new URL(request.url);
  const sport = params.sport;

  const queryParams: { [key: string]: any } = {};
  searchParams.forEach((value, key) => {
    queryParams[key] = value;
  });

  try {

    const sportService = getSportService(sport);

    const fixtures = await sportService.getFixtures(queryParams);

    return NextResponse.json(fixtures);

  } catch (error: any) {

    return NextResponse.json(
      { error: `Failed to fetch fixture data for ${sport}.` },
      { status: 500 }
    );
  }
}

// ===== src/app/api/standings/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import { generateLeagueSlug } from "@/lib/generate-league-slug";
import redis from "@/lib/redis";

const CACHE_TTL_SECONDS = 60 * 60 * 2;

type TeamStanding = {
  rank: number;
  team: { id: number; name: string; logo: string };
  points: number;
  goalsDiff: number;
  all: { played: number; win: number; draw: number; lose: number };
  description: string | null;
  group: string;
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get("league");
  const season =
    searchParams.get("season") || new Date().getFullYear().toString();

  if (!leagueId) {
    return NextResponse.json(
      { error: "League ID is required" },
      { status: 400 }
    );
  }

  const cacheKey = `standings:${leagueId}:${season}`;

  try {

    const cachedData = await redis.get(cacheKey);
    if (cachedData) {

      return NextResponse.json(JSON.parse(cachedData));
    }

    const options = {
      method: "GET",
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/standings`,
      params: { league: leagueId, season: season },
      headers: {
        "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
      },
    };

    const response = await axios.request(options);

    if (!response.data.response || response.data.response.length === 0) {
      const emptyResponse = { league: null, standings: [] };
      await redis.set(cacheKey, JSON.stringify(emptyResponse), "EX", CACHE_TTL_SECONDS);
      return NextResponse.json(emptyResponse);
    }

    const data = response.data.response[0];

    const transformedData = {
      league: {
        id: data.league.id,
        name: data.league.name,
        logo: data.league.logo,
        type: data.league.type,
        href: generateLeagueSlug(data.league.name, data.league.id),
      },
      standings: data.league.standings,
    };

    await redis.set(cacheKey, JSON.stringify(transformedData), "EX", CACHE_TTL_SECONDS);

    return NextResponse.json(transformedData);

  } catch (error) {

    return NextResponse.json(
      { error: "Failed to fetch standings data" },
      { status: 500 }
    );
  }
}

// ===== src/app/api/team-details/route.ts =====

import { NextResponse } from 'next/server';
import { fetchTeamDetails } from '@/lib/data/team';

export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);
    const teamId = searchParams.get('team');

    if (!teamId) {
        return NextResponse.json({ error: 'Team ID is required' }, { status: 400 });
    }

    const teamData = await fetchTeamDetails(teamId);

    if (!teamData) {

        return NextResponse.json({ error: 'Failed to fetch team details or team not found' }, { status: 500 });
    }

    return NextResponse.json(teamData);
}

// ===== src/app/api/team-trophies/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const teamId = searchParams.get("team");

  if (!teamId) {
    return NextResponse.json({ error: "Team ID is required" }, { status: 400 });
  }

  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/trophies`,
    params: { team: teamId },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };

  try {
    const response = await axios.request(options);

    const sortedTrophies = response.data.response.sort((a: any, b: any) => {
      const seasonB = parseInt(b.season.split("-")[0]);
      const seasonA = parseInt(a.season.split("-")[0]);
      return seasonB - seasonA;
    });
    return NextResponse.json(sortedTrophies);
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to fetch trophies" },
      { status: 500 }
    );
  }
}

// ===== src/app/api/teams/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');
  const season = searchParams.get('season');

  if (!leagueId || !season) {
    return NextResponse.json(
      { error: 'League ID and season are required' },
      { status: 400 }
    );
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
    params: {
      league: leagueId,
      season: season,
    },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);

    return NextResponse.json(response.data.response);

  } catch (error) {

    return NextResponse.json(
      { error: 'Failed to fetch teams data.' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/teams-by-country/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";

const season = new Date().getFullYear();

const apiRequest = async (endpoint: string, params: object) => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };
  const response = await axios.request(options);
  return response.data.response;
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const country = searchParams.get("country");

  if (!country) {
    return NextResponse.json(
      { error: "Country parameter is required" },
      { status: 400 }
    );
  }

  try {

    const leagues = await apiRequest("leagues", { country: country });
    if (!leagues || leagues.length === 0) {

      return NextResponse.json({ teams: [], count: 0 });
    }

    const leagueIds = leagues.map((l: any) => l.league.id);

    const teamPromises = leagueIds.map((id: any) =>
      apiRequest("teams", { league: id, season: season })
    );
    const responses = await Promise.allSettled(teamPromises);

    const allTeamsResponses = responses
      .filter((result) => result.status === "fulfilled" && result.value)
      .flatMap((result) => (result as PromiseFulfilledResult<any>).value);

    const uniqueTeams = Array.from(
      new Map(allTeamsResponses.map((item) => [item.team.id, item])).values()
    );

    uniqueTeams.sort((a, b) => a.team.name.localeCompare(b.team.name));

    return NextResponse.json({
      teams: uniqueTeams,
      count: uniqueTeams.length,
    });
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to fetch teams data for this country." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/ticker-messages/route.ts =====

import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import TickerMessage from "@/models/TickerMessage";
import redis from "@/lib/redis";

const CACHE_TTL_SECONDS = 60 * 5;
const DEFAULT_LOCALE = "tr";

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const locale = searchParams.get("locale") || DEFAULT_LOCALE;

    const cacheKey = `ticker-messages:active:${locale}`;

    const cachedData = await redis.get(cacheKey);
    if (cachedData) {
      return NextResponse.json(JSON.parse(cachedData));
    }

    await dbConnect();
    const messages = await TickerMessage.find({
      isActive: true,
      language: locale,
    }).sort({
      order: 1,
      createdAt: -1,
    });

    await redis.set(
      cacheKey,
      JSON.stringify(messages),
      "EX",
      CACHE_TTL_SECONDS
    );

    return NextResponse.json(messages);
  } catch (error) {

    return NextResponse.json(
      { error: "Server error fetching ticker messages" },
      { status: 500 }
    );
  }
}

// ===== src/app/api/top-scorers/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';
import redis from '@/lib/redis';

const CACHE_TTL_SECONDS = 60 * 60 * 6;

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');
  const season = searchParams.get('season');

  if (!leagueId || !season) {
    return NextResponse.json(
      { error: 'League ID and season are required' },
      { status: 400 }
    );
  }

  const cacheKey = `top-scorers:${leagueId}:${season}`;

  try {

    const cachedData = await redis.get(cacheKey);
    if (cachedData) {

      return NextResponse.json(JSON.parse(cachedData));
    }

    const options = {
      method: 'GET',
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/players/topscorers`,
      params: {
        league: leagueId,
        season: season,
      },
      headers: {
        'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
      },
    };

    const response = await axios.request(options);
    const topScorers = response.data.response;

    if (topScorers && topScorers.length > 0) {
        await redis.set(cacheKey, JSON.stringify(topScorers), "EX", CACHE_TTL_SECONDS);

    }

    return NextResponse.json(topScorers);

  } catch (error) {

    return NextResponse.json(
      { error: 'Failed to fetch top scorers data.' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/upcoming-matches/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';
import { format, subDays, addDays } from 'date-fns';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');

  if (!leagueId) {

    return NextResponse.json({ error: 'League ID is required' }, { status: 400 });
  }

  const season = new Date().getFullYear().toString();
  const today = format(new Date(), 'yyyy-MM-dd');
  const nextSevenDays = format(addDays(new Date(), 7), 'yyyy-MM-dd');

  const options = (params: object) => ({
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params,
    headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {

    const upcomingResponse = await axios.request(options({
      league: leagueId,
      season: season,
      from: today,
      to: nextSevenDays,
    }));

    let matches = upcomingResponse.data.response;

    if (matches.length === 0) {

      const finishedResponse = await axios.request(options({
        league: leagueId,
        season: season,
        last: 5,
        status: 'FT',
      }));
      matches = finishedResponse.data.response;
    }

    return NextResponse.json(matches);

  } catch (error) {

    return NextResponse.json({ error: 'Failed to fetch match data' }, { status: 500 });
  }
}

// ===== src/app/api/upload/route.ts =====

import { NextResponse } from "next/server";
import {
  S3Client,
  PutObjectCommand,
  ListObjectsV2Command,
  DeleteObjectCommand,
} from "@aws-sdk/client-s3";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import sharp from "sharp";
import path from "path";
import slugify from "slugify";

const s3Client = new S3Client({
  region: "auto",
  endpoint: process.env.NEXT_PUBLIC_R2_ENDPOINT as string,
  credentials: {
    accessKeyId: process.env.NEXT_PUBLIC_R2_ACCESS_KEY_ID as string,
    secretAccessKey: process.env.NEXT_PUBLIC_R2_SECRET_ACCESS_KEY as string,
  },
});

const R2_BUCKET_NAME = process.env.NEXT_PUBLIC_R2_BUCKET_NAME as string;
const R2_PUBLIC_URL = process.env.NEXT_PUBLIC_R2_PUBLIC_BUCKET_URL as string;

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const listObjectsCommand = new ListObjectsV2Command({
      Bucket: R2_BUCKET_NAME,
      MaxKeys: 100,
    });

    const { Contents } = await s3Client.send(listObjectsCommand);

    const files =
      Contents?.map((item) => {
        const key = item.Key || "unknown";
        const fileExtension = path.extname(key).toLowerCase();
        let mimeType = "application/octet-stream";

        if (fileExtension === ".png") mimeType = "image/png";
        else if (fileExtension === ".jpg" || fileExtension === ".jpeg")
          mimeType = "image/jpeg";
        else if (fileExtension === ".gif") mimeType = "image/gif";
        else if (fileExtension === ".webp") mimeType = "image/webp";

        return {
          name: key,
          url: `${R2_PUBLIC_URL}/${key}`,
          size: item.Size || 0,
          lastModified: item.LastModified,
          type: mimeType,
        };
      }) || [];

    files.sort(
      (a, b) =>
        (b.lastModified?.getTime() || 0) - (a.lastModified?.getTime() || 0)
    );

    return NextResponse.json(files, { status: 200 });
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to list files from Cloudflare R2." },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const formData = await request.formData();
    const file = formData.get("file") as File;
    const uploadType = formData.get("uploadType") as string | null;

    if (!file) {
      return NextResponse.json({ error: "No file provided." }, { status: 400 });
    }

    let finalBuffer: Buffer;
    let finalContentType: string = file.type;
    let finalFileExtension: string;

    if (file.type === "image/gif") {
      finalBuffer = Buffer.from(await file.arrayBuffer());
      finalContentType = "image/gif";
      finalFileExtension = ".gif";
    } else {

      const inputBuffer = Buffer.from(await file.arrayBuffer());
      let sharpInstance = sharp(inputBuffer);

      if (uploadType === "banner") {

        sharpInstance = sharpInstance.resize(1200, 1200, {
          fit: "inside",
          withoutEnlargement: true,
        });
      } else {

        sharpInstance = sharpInstance.resize(1200, 630, {
          fit: "inside",
          withoutEnlargement: true,
        });
      }

      finalBuffer = await sharpInstance.webp({ quality: 80 }).toBuffer();
      finalContentType = "image/webp";
      finalFileExtension = ".webp";
    }

    const originalFilename = file.name;
    const extension = path.extname(originalFilename);
    const basename = path.basename(originalFilename, extension);
    const slug = slugify(basename, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });
    const uniqueSuffix = Date.now().toString().slice(-6);

    const newFileName = `fanskor-${slug}-${uniqueSuffix}${finalFileExtension}`;

    const putObjectCommand = new PutObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: newFileName,
      Body: finalBuffer,
      ContentType: finalContentType,
    });

    await s3Client.send(putObjectCommand);

    const publicUrl = `${R2_PUBLIC_URL}/${newFileName}`;

    return NextResponse.json({
      message: "File uploaded successfully",
      url: publicUrl,
      name: newFileName,
      type: finalContentType,
      size: finalBuffer.length,
    });
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to upload image to Cloudflare R2." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { searchParams } = new URL(request.url);
  const fileKey = searchParams.get("key");

  if (!fileKey) {
    return NextResponse.json(
      { error: "File key is required for deletion." },
      { status: 400 }
    );
  }

  try {
    const deleteObjectCommand = new DeleteObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: fileKey,
    });

    await s3Client.send(deleteObjectCommand);

    return NextResponse.json(
      { message: "File deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {

    if (error.name === "NoSuchKey") {
      return NextResponse.json(
        { error: "File not found on Cloudflare R2." },
        { status: 404 }
      );
    }
    return NextResponse.json(
      { error: error.message || "Failed to delete file from Cloudflare R2." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/votes/route.ts =====

import { NextResponse } from 'next/server';
import dbConnect from '@/lib/dbConnect';
import Vote from '@/models/Vote';

export async function GET(request: Request) {

    const { searchParams } = new URL(request.url);
    const fixtureId = searchParams.get('fixture');

    if (!fixtureId) {
        return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
    }

    try {
        await dbConnect();
        const votes = await Vote.findOne({ fixtureId: Number(fixtureId) });

        if (!votes) {

            return NextResponse.json({ homeVotes: 0, drawVotes: 0, awayVotes: 0 });
        }

        return NextResponse.json(votes);
    } catch (error) {

        return NextResponse.json({ error: 'Server error fetching votes' }, { status: 500 });
    }
}

export async function POST(request: Request) {
    const { fixtureId, vote } = await request.json();

    if (!fixtureId || !['home', 'draw', 'away'].includes(vote)) {
        return NextResponse.json({ error: 'Valid fixtureId and vote type are required' }, { status: 400 });
    }

    try {
        await dbConnect();

        const updatedVote = await Vote.findOneAndUpdate(
            { fixtureId: Number(fixtureId) },
            { $inc: { [`${vote}Votes`]: 1 } },
            {
                upsert: true,
                new: true
            }
        );

        return NextResponse.json(updatedVote);
    } catch (error) {
        return NextResponse.json({ error: 'Server error submitting vote' }, { status: 500 });
    }
}

// ===== src/app/globals.css =====

@font-face {
  font-display: swap;
  font-family: "Inter";
  font-style: normal;
  font-weight: 400;
  src: url("../../public/fonts/inter-v19-latin-regular.woff2") format("woff2");
}

@font-face {
  font-display: swap;
  font-family: "Inter";
  font-style: normal;
  font-weight: 500;
  src: url("../../public/fonts/inter-v19-latin-500.woff2") format("woff2");
}

@font-face {
  font-display: swap;
  font-family: "Inter";
  font-style: normal;
  font-weight: 600;
  src: url("../../public/fonts/inter-v19-latin-600.woff2") format("woff2");
}

@font-face {
  font-display: swap;
  font-family: "Inter";
  font-style: normal;
  font-weight: 700;
  src: url("../../public/fonts/inter-v19-latin-700.woff2") format("woff2");
}

@font-face {
  font-display: swap;
  font-family: "Inter";
  font-style: normal;
  font-weight: 800;
  src: url("../../public/fonts/inter-v19-latin-800.woff2") format("woff2");
}

@import "tailwindcss";

@tailwind base;
@tailwind components;
@tailwind utilities;
@import "nprogress/nprogress.css";
@import "slick-carousel/slick/slick.css";
@import "slick-carousel/slick/slick-theme.css";

@keyframes ring {
  0% {
    transform: rotate(0);
  }
  10% {
    transform: rotate(14deg);
  }
  20% {
    transform: rotate(-8deg);
  }
  30% {
    transform: rotate(14deg);
  }
  40% {
    transform: rotate(-4deg);
  }
  50% {
    transform: rotate(10deg);
  }
  60% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(0);
  }
}

.animate-ring {
  transform-origin: top center;
  animation: ring 2s ease-in-out infinite;
}

.prose {

  --tw-prose-body: theme("colors.slate.300");
  --tw-prose-invert-body: theme("colors.slate.300");
}

.prose p {

  line-height: 1.75;
}

.prose h2 {
  color: #ffffff;
  font-size: 1.875rem;
  font-weight: 700;
  margin-top: 2.5em;
  margin-bottom: 1.25em;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid #4a5568;
  line-height: 1.3;
}

.prose h3 {
  color: #e2e8f0;
  font-size: 1.5rem;
  font-weight: 600;
  margin-top: 2em;
  margin-bottom: 1em;
  line-height: 1.4;
}

.prose strong {
  color: #ffffff;
}
.prose em {
  color: #e2e8f0;
}
.prose ul,
.prose ol {
  list-style-position: outside;
  padding-left: 1.5em;
}
.prose ul > li,
.prose ol > li {
  padding-left: 0.5em;
  margin-top: 0.75em;
}
.prose ul > li::marker {
  color: var(--brand-accent);
}
.prose a {
  color: var(--brand-accent);
  text-decoration: none;
  transition: all 0.2s ease-in-out;
  font-weight: 500;
}
.prose a:hover {
  text-decoration: underline;
  color: #ffffff;
  background-color: var(--brand-accent);
  padding: 0.1em 0.2em;
  border-radius: 0.25rem;
}

.prose blockquote {
  position: relative;
  font-style: italic;
  color: #cbd5e1;
  padding: 1rem 1.5rem 1rem 3rem;
  border-left: none;
  background-color: rgba(71, 85, 105, 0.1);
  border-radius: 0.5rem;
  margin-top: 2em;
  margin-bottom: 2em;
}
.prose blockquote::before {
  content: "";
  position: absolute;
  left: 0.75rem;
  top: 0.5rem;
  font-size: 3rem;
  line-height: 1;
  color: var(--brand-accent);
  font-family: Georgia, serif;
}
.prose blockquote p {
  margin: 0;
}

:root {
  --color-background: #020202;
  --color-primary: #1a1a1a;
  --color-secondary: #2a2a2a;

  --text-primary: #fffffd;
  --text-secondary: #e0e0e0;
  --text-muted: #9e9e9e;

  --brand-accent: #ed5c19;
  --brand-live: #ef4444;
  --brand-yellow: #fbbf24;
}

body {
  background-color: var(--color-background);
  color: var(--text-primary);
  font-family: var(--font-sans);
}

.custom-scrollbar {
  overflow-y: auto;
  scroll-behavior: smooth;

  scrollbar-width: thin;
  scrollbar-color: #393f47 transparent;
}

.custom-scrollbar::-webkit-scrollbar {
  width: 8px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background-color: #f3f4f6;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background-color: #1f2937;
  border-radius: 10px;
}
.bg-brand-secondary {
  background-color: var(--tw-color-brand-secondary);
}

.slick-dots li.slick-active div {
  background-color: #8b5cf6 !important;
}

@keyframes breathing-glow {
  0%,
  100% {
    box-shadow: 0 0 10px 0px rgba(52, 211, 153, 0.4);
    transform: scale(1);
  }
  50% {
    box-shadow: 0 0 25px 5px rgba(52, 211, 153, 0.7);
    transform: scale(1.05);
  }
}

.animate-breathing-glow {
  animation: breathing-glow 2.5s ease-in-out infinite;
}

.tiptap > * + * {
  margin-top: 0.75em;
}

.tiptap ul,
.tiptap ol {
  padding: 0 1rem;
}

.tiptap h1,
.tiptap h2,
.tiptap h3,
.tiptap h4,
.tiptap h5,
.tiptap h6 {
  line-height: 1.1;
}

.tiptap code {
  background-color: rgba(255, 255, 255, 0.1);
  color: #a1a1aa;
  padding: 0.2rem 0.4rem;
  border-radius: 0.25rem;
  font-size: 0.9em;
}

.tiptap pre {
  background: #18181b;
  color: #fff;
  font-family: "JetBrainsMono", "Courier New", Courier, monospace;
  padding: 0.75rem 1rem;
  border-radius: 0.5rem;
}

.tiptap pre code {
  color: inherit;
  padding: 0;
  background: none;
  font-size: 0.8rem;
}

.tiptap img {
  max-width: 100%;
  height: auto;
}

.tiptap blockquote {
  padding-left: 1rem;
  border-left: 2px solid rgba(255, 255, 255, 0.2);
}

.tiptap hr {
  border: none;
  border-top: 2px solid rgba(255, 255, 255, 0.2);
  margin: 2rem 0;
}

.slick-dots li.slick-active div {
  background-color: #8b5cf6;
}

#nprogress .bar {
  background: var(--brand-accent) !important;
  height: 3px !important;
}
#nprogress .peg {
  box-shadow: 0 0 10px var(--brand-accent), 0 0 5px var(--brand-accent) !important;
}

.bg-brand-secondary {
  background-color: var(--color-primary);
}
.text-brand-light {
  color: var(--text-primary);
}
.text-brand-muted {
  color: var(--text-muted);
}

@keyframes fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.animate-fade-in {
  animation: fade-in 0.3s ease-out forwards;
}

// ===== src/app/layout.tsx =====

import "./globals.css";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html suppressHydrationWarning={true}>
      {}
      <body
        className="bg-background text-text-primary"
        suppressHydrationWarning={true}
      >
        {children}
      </body>
    </html>
  );
}

// ===== src/app/login/LoginForm.tsx =====

"use client";

import { useState } from "react";
import { signIn } from "next-auth/react";
import { useRouter, useSearchParams } from "next/navigation";

export default function LoginForm() {
  const router = useRouter();
  const searchParams = useSearchParams();

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState(() => {
    const err = searchParams.get("error");
    if (err === "Forbidden") {
      return "Access Denied. You must be an administrator.";
    }
    return err || "";
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    const result = await signIn("credentials", {
      redirect: false,
      email,
      password,
    });

    if (result?.error) {
      setError("Invalid credentials. Please try again.");
    } else if (result?.ok) {
      const callbackUrl = searchParams.get("callbackUrl") || "/admin/dashboard";
      router.push(callbackUrl);
    }
  };

  return (
    <form
      onSubmit={handleSubmit}
      className="p-8 rounded-lg shadow-lg bg-brand-secondary w-full max-w-sm"
    >
      <h1 className="text-2xl font-bold mb-6 text-center text-white">
        Admin Login
      </h1>
      {error && (
        <p className="bg-red-500/20 text-red-400 p-3 rounded mb-4 text-sm">
          {error}
        </p>
      )}
      <div className="space-y-4">
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="Email"
          required
          className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 placeholder:text-brand-muted focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-brand-secondary focus:ring-brand-purple"
        />
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="Password"
          required
          className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 placeholder:text-brand-muted focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-brand-secondary focus:ring-brand-purple"
        />
      </div>
      <button
        type="submit"
        className="w-full mt-6 bg-brand-purple text-white font-bold py-3 rounded-lg hover:opacity-90 transition-opacity focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-brand-secondary focus:ring-brand-purple"
      >
        Sign In
      </button>
    </form>
  );
}

// ===== src/app/login/page.tsx =====

import { Suspense } from "react";
import LoginForm from "./LoginForm";

const LoginFormSkeleton = () => (
  <div className="p-8 rounded-lg shadow-lg bg-brand-secondary w-full max-w-sm animate-pulse">
    <div className="h-8 w-3/4 mx-auto rounded-md bg-gray-700 mb-6"></div>
    <div className="space-y-4">
      <div className="h-12 w-full rounded bg-gray-700"></div>
      <div className="h-12 w-full rounded bg-gray-700"></div>
    </div>
    <div className="h-12 w-full mt-6 rounded-lg bg-brand-purple/50"></div>
  </div>
);

export default function LoginPage() {
  return (

    <div className="flex items-center justify-center min-h-screen bg-brand-dark">
      <Suspense fallback={<LoginFormSkeleton />}>
        <LoginForm />
      </Suspense>
    </div>
  );
}

// ===== src/app/page.tsx =====

import { redirect } from "next/navigation";

const DEFAULT_LOCALE = "tr";

export default function RootPage() {

  redirect(`/${DEFAULT_LOCALE}`);
}

// ===== src/app/providers.tsx =====

"use client";

import ProgressBar from "@/components/ProgressBar";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { useState } from "react";
import { Toaster } from "react-hot-toast";

export default function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>
      {}
      <div suppressHydrationWarning={true}>
        <Toaster
          position="top-right"
          toastOptions={{
            style: {
              background: "#333",
              color: "#fff",
            },
          }}
        />
      </div>
      <ProgressBar />
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}

// ===== src/app/sitemap-leagues.xml/route.ts =====

import axios from "axios";
import slugify from "slugify";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

const SUPPORTED_LOCALES = ["tr", "en", "fr", "es", "zu"];
const DEFAULT_LOCALE = "tr";

type SitemapEntry = {
  url: string;
  lastModified?: string | Date;
  changeFrequency?: "daily" | "weekly" | "monthly";
  priority?: number;
};

const getPath = (path: string, locale: string) => {
  if (locale === DEFAULT_LOCALE) return path;
  return `/${locale}${path}`;
};

const generateLeagueSlug = (name: string, id: number): string => {
  const slug = slugify(name, {
    lower: true,
    strict: true,
    remove: /[*+~.()'"!:@]/g,
  });
  return `/football/league/${slug}-${id}`;
};

const generateXml = (entries: SitemapEntry[]) =>
  `<?xml version="1.0" encoding="UTF-8"?>
     <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
       ${entries
         .map(
           (entry) => `
         <url>
           <loc>${entry.url}</loc>
           <lastmod>${new Date(
             entry.lastModified || new Date()
           ).toISOString()}</lastmod>
           <changefreq>${entry.changeFrequency}</changefreq>
           <priority>${entry.priority}</priority>
         </url>
       `
         )
         .join("")}
     </urlset>`;

export async function GET() {
  try {
    const { data: leagues } = await axios.get(
      `${BASE_URL}/api/leagues?fetchAll=true`
    );

    const sitemapEntries: SitemapEntry[] = leagues.flatMap((league: any) =>
      SUPPORTED_LOCALES.map((locale) => ({
        url: `${BASE_URL}${getPath(
          generateLeagueSlug(league.name, league.id),
          locale
        )}`,
        lastModified: new Date(),
        changeFrequency: "monthly",
        priority: 0.7,
      }))
    );

    const xml = generateXml(sitemapEntries);

    return new Response(xml, {
      headers: {
        "Content-Type": "application/xml",
      },
    });
  } catch (error) {

    return new Response("Error generating sitemap.", { status: 500 });
  }
}

// ===== src/app/sitemap-matches.xml/route.ts =====

import axios from "axios";
import slugify from "slugify";
import { format, subDays, addDays } from "date-fns";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

const SUPPORTED_LOCALES = ["tr", "en", "fr", "es", "zu"];
const DEFAULT_LOCALE = "tr";

type SitemapEntry = {
  url: string;
  lastModified?: string | Date;
  changeFrequency?: "daily" | "weekly" | "monthly";
  priority?: number;
};

const getPath = (path: string, locale: string) => {
  if (locale === DEFAULT_LOCALE) return path;
  return `/${locale}${path}`;
};

const generateMatchSlug = (
  homeName: string,
  awayName: string,
  fixtureId: number
): string => {
  const slugifyPart = (str: string) =>
    slugify(str, { lower: true, strict: true, remove: /[*+~.()'"!:@]/g });
  return `/football/match/${slugifyPart(homeName)}-vs-${slugifyPart(
    awayName
  )}-${fixtureId}`;
};

const generateXml = (entries: SitemapEntry[]) =>
  `<?xml version="1.0" encoding="UTF-8"?>
     <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
       ${entries
         .map(
           (entry) => `
         <url>
           <loc>${entry.url}</loc>
           <lastmod>${new Date(
             entry.lastModified || new Date()
           ).toISOString()}</lastmod>
           <changefreq>${entry.changeFrequency}</changefreq>
           <priority>${entry.priority}</priority>
         </url>
       `
         )
         .join("")}
     </urlset>`;

export async function GET() {
  try {
    const today = new Date();
    const fromDate = format(subDays(today, 30), "yyyy-MM-dd");
    const toDate = format(addDays(today, 30), "yyyy-MM-dd");

    const { data: matches } = await axios.get(
      `${BASE_URL}/api/fixtures?from=${fromDate}&to=${toDate}`
    );

    const sitemapEntries: SitemapEntry[] = matches.flatMap((match: any) =>
      SUPPORTED_LOCALES.map((locale) => ({
        url: `${BASE_URL}${getPath(
          generateMatchSlug(
            match.teams.home.name,
            match.teams.away.name,
            match.fixture.id
          ),
          locale
        )}`,
        lastModified: new Date(match.fixture.date),
        changeFrequency: "daily",
        priority: 0.9,
      }))
    );

    const xml = generateXml(sitemapEntries);

    return new Response(xml, {
      headers: {
        "Content-Type": "application/xml",
      },
    });
  } catch (error) {

    return new Response("Error generating sitemap.", { status: 500 });
  }
}

// ===== src/app/sitemap-news.xml/route.ts =====

import axios from "axios";
import { IPost } from "@/models/Post";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

const DEFAULT_LOCALE = "tr";

type SitemapEntry = {
  url: string;
  lastModified?: string | Date;
  changeFrequency?: "daily" | "weekly" | "monthly";
  priority?: number;
};

const getPath = (path: string, locale: string) => {

  if (locale === DEFAULT_LOCALE) {
    return path;
  }
  return `/${locale}${path}`;
};

const generateXml = (entries: SitemapEntry[]) =>
  `<?xml version="1.0" encoding="UTF-8"?>
     <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
       ${entries
         .map(
           (entry) => `
         <url>
           <loc>${entry.url}</loc>
           <lastmod>${new Date(
             entry.lastModified || new Date()
           ).toISOString()}</lastmod>
           <changefreq>${entry.changeFrequency}</changefreq>
           <priority>${entry.priority}</priority>
         </url>
       `
         )
         .join("")}
     </urlset>`;

export async function GET() {
  try {
    const { data: posts }: { data: IPost[] } = await axios.get(
      `${BASE_URL}/api/posts?status=published`
    );

    const sitemapEntries: SitemapEntry[] = posts.map((post) => {

      const basePath = `/news/${post.slug}`;

      const finalPath = getPath(basePath, post.language);

      return {
        url: `${BASE_URL}${finalPath}`,
        lastModified: new Date(post.updatedAt || post.createdAt),
        changeFrequency: "weekly",
        priority: 0.8,
      };
    });

    const xml = generateXml(sitemapEntries);

    return new Response(xml, {
      headers: {
        "Content-Type": "application/xml",
      },
    });
  } catch (error) {

    return new Response("Error generating sitemap.", { status: 500 });
  }
}

// ===== src/app/sitemap-static.xml/route.ts =====

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

const SUPPORTED_LOCALES = ["tr", "en", "fr", "es", "zu"];
const DEFAULT_LOCALE = "tr";

type SitemapEntry = {
  url: string;
  lastModified?: string | Date;
  changeFrequency?:
    | "always"
    | "hourly"
    | "daily"
    | "weekly"
    | "monthly"
    | "yearly"
    | "never";
  priority?: number;
};

const getPath = (path: string, locale: string) => {
  if (locale === DEFAULT_LOCALE) {
    return path === "/" ? "" : path;
  }
  return `/${locale}${path}`;
};

export async function GET() {
  const staticPaths = [
    { path: "/", priority: 1.0, changeFrequency: "daily" },
    { path: "/football/news", priority: 0.9, changeFrequency: "daily" },
    { path: "/news", priority: 0.9, changeFrequency: "daily" },
    { path: "/football/leagues", priority: 0.9, changeFrequency: "daily" },
    { path: "/football/teams", priority: 0.9, changeFrequency: "daily" },
    { path: "/contact-us", priority: 0.5, changeFrequency: "monthly" },
    { path: "/faq", priority: 0.6, changeFrequency: "monthly" },
    { path: "/author", priority: 0.4, changeFrequency: "yearly" },
    { path: "/report-abuse", priority: 0.4, changeFrequency: "yearly" },
    { path: "/privacy-policy", priority: 0.3, changeFrequency: "yearly" },
    { path: "/terms-and-conditions", priority: 0.3, changeFrequency: "yearly" },
    { path: "/gdpr", priority: 0.3, changeFrequency: "yearly" },
  ];

  const sitemapEntries: SitemapEntry[] = staticPaths.flatMap((page) =>
    SUPPORTED_LOCALES.map((locale) => ({
      url: `${BASE_URL}${getPath(page.path, locale)}`,
      lastModified: new Date(),
      changeFrequency: page.changeFrequency as SitemapEntry["changeFrequency"],
      priority: page.priority,
    }))
  );

  const generateXml = (entries: SitemapEntry[]) =>
    `<?xml version="1.0" encoding="UTF-8"?>
     <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
       ${entries
         .map(
           (entry) => `
         <url>
           <loc>${entry.url}</loc>
           <lastmod>${new Date(
             entry.lastModified || new Date()
           ).toISOString()}</lastmod>
           <changefreq>${entry.changeFrequency}</changefreq>
           <priority>${entry.priority}</priority>
         </url>
       `
         )
         .join("")}
     </urlset>`;

  const xml = generateXml(sitemapEntries);

  return new Response(xml, {
    headers: {
      "Content-Type": "application/xml",
    },
  });
}

// ===== src/app/sitemap-teams.xml/route.ts =====

import axios from "axios";
import slugify from "slugify";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

const SUPPORTED_LOCALES = ["tr", "en", "fr", "es", "zu"];
const DEFAULT_LOCALE = "tr";

type SitemapEntry = {
  url: string;
  lastModified?: string | Date;
  changeFrequency?: "daily" | "weekly" | "monthly";
  priority?: number;
};

const getPath = (path: string, locale: string) => {
  if (locale === DEFAULT_LOCALE) return path;
  return `/${locale}${path}`;
};

const generateTeamSlug = (name: string, id: number): string => {
  const slug = slugify(name, {
    lower: true,
    strict: true,
    remove: /[*+~.()'"!:@]/g,
  });
  return `/football/team/${slug}-${id}`;
};

const generateXml = (entries: SitemapEntry[]) =>
  `<?xml version="1.0" encoding="UTF-8"?>
     <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
       ${entries
         .map(
           (entry) => `
         <url>
           <loc>${entry.url}</loc>
           <lastmod>${new Date(
             entry.lastModified || new Date()
           ).toISOString()}</lastmod>
           <changefreq>${entry.changeFrequency}</changefreq>
           <priority>${entry.priority}</priority>
         </url>
       `
         )
         .join("")}
     </urlset>`;

export async function GET() {
  try {
    const { data: teamsData } = await axios.get(
      `${BASE_URL}/api/directory/teams`
    );

    const sitemapEntries: SitemapEntry[] = teamsData.flatMap((teamData: any) =>
      SUPPORTED_LOCALES.map((locale) => ({
        url: `${BASE_URL}${getPath(
          generateTeamSlug(teamData.team.name, teamData.team.id),
          locale
        )}`,
        lastModified: new Date(),
        changeFrequency: "weekly",
        priority: 0.6,
      }))
    );

    const xml = generateXml(sitemapEntries);

    return new Response(xml, {
      headers: {
        "Content-Type": "application/xml",
      },
    });
  } catch (error) {

    return new Response("Error generating sitemap.", { status: 500 });
  }
}

// ===== src/app/sitemap.xml/route.ts =====

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

const generateSitemapIndexXml = () => {
  const sitemaps = [
    "sitemap-static.xml",
    "sitemap-news.xml",
    "sitemap-leagues.xml",
    "sitemap-teams.xml",
    "sitemap-matches.xml",
  ];

  const sitemapEntries = sitemaps
    .map(
      (route) => `
    <sitemap>
      <loc>${BASE_URL}/${route}</loc>
      <lastmod>${new Date().toISOString()}</lastmod>
    </sitemap>
  `
    )
    .join("");

  return `<?xml version="1.0" encoding="UTF-8"?>
    <sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
      ${sitemapEntries}
    </sitemapindex>
  `;
};

export async function GET() {
  const xml = generateSitemapIndexXml();

  return new Response(xml, {
    headers: {
      "Content-Type": "application/xml",
    },
  });
}

// ===== src/components/Accordion.tsx =====

"use client";

import { useState, ReactNode } from 'react';
import { ChevronDown } from 'lucide-react';

interface AccordionProps {
  title: ReactNode;
  statusNode?: ReactNode;
  children: ReactNode;
  defaultOpen?: boolean;
}

export default function Accordion({ title, statusNode, children, defaultOpen = false }: AccordionProps) {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <div className="border-b border-gray-700/50 last:border-b-0">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="w-full flex justify-between items-center p-4 transition-colors duration-200 bg-gray-800/50 hover:bg-gray-800/80"
      >
        {}
        <div className="flex items-center gap-4">
            {}
            <div className="font-bold text-lg text-white text-left">{title}</div>
            {}
            {statusNode}
        </div>

        {}
        <ChevronDown
          size={24}
          className={`transform transition-transform duration-300 flex-shrink-0 ${isOpen ? 'rotate-180' : ''}`}
        />
      </button>

      {}
      <div
        className={`grid transition-all duration-300 ease-in-out ${
          isOpen ? 'grid-rows-[1fr] opacity-100' : 'grid-rows-[0fr] opacity-0'
        }`}
      >
        <div className="overflow-hidden">
          <div className="p-4 space-y-3 bg-brand-dark/30">{children}</div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/AdSlotWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import Link from "next/link";
import { IBanner } from "@/models/Banner";

import { proxyImageUrl } from "@/lib/image-proxy";

interface AdSlotWidgetProps {
  location: string;
}

const fetchBannerForSlot = async (
  location: string
): Promise<IBanner | null> => {
  try {
    const { data } = await axios.get(
      `/api/banners?location=${location}&active=true`
    );
    return data?.[0] || null;
  } catch (error) {

    return null;
  }
};

const AdBannerSkeleton = () => (
  <div className="w-full h-[250px] bg-brand-secondary rounded-lg animate-pulse"></div>
);

export default function AdSlotWidget({ location }: AdSlotWidgetProps) {
  const {
    data: banner,
    isLoading,
    isError,
  } = useQuery<IBanner | null>({
    queryKey: ["banner", location],
    queryFn: () => fetchBannerForSlot(location),
    staleTime: 1000 * 60 * 5,
    refetchOnWindowFocus: false,
  });

  if (isLoading) {
    return <AdBannerSkeleton />;
  }

  if (isError || !banner) {
    return null;
  }

  return (
    <div className="w-full">
      <Link
        href={banner.linkUrl}
        target="_blank"
        rel="noopener sponsored"
        className="relative block w-full overflow-hidden rounded-lg group"
        aria-label={`Advertisement: ${banner.title}`}
      >
        {}
        {}
        <Image
          src={banner.imageUrl}
          alt={banner.title}
          width={300}
          height={250}
          unoptimized={true}
          className="w-full h-auto object-cover transition-transform duration-300 group-hover:scale-105"
        />

        <div className="absolute bottom-0 left-0 p-4 w-full">
          <p className="text-lg font-bold text-white drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)]">
            {banner.title}
          </p>
          <span className="text-xs text-gray-300 drop-shadow-md">
            Advertisement
          </span>
        </div>
      </Link>
    </div>
  );
}

// ===== src/components/BettingPromotionWidget.tsx =====

"use client";

import { memo } from 'react';
import { ShieldCheck } from 'lucide-react';

const BettingPromotionWidget = memo(function BettingPromotionWidget() {

    const handleBetClick = () => {

    };

    return (
        <div className="bg-gradient-to-br from-green-500/20 to-brand-purple/20 p-4 rounded-xl border border-green-400/30 text-center space-y-3">

            <h3 className="text-lg font-bold text-white">
                Exclusive Welcome Offer!
            </h3>

            <p className="text-sm text-brand-light">
                Get a <span className="font-bold text-green-400">100% bonus</span> on your first deposit to bet on today's matches.
            </p>

            {}
            <div className="relative pt-2">
                {}
                <span className="absolute top-2 left-0 inline-flex h-full w-full rounded-lg bg-green-400 opacity-75 animate-ping"></span>

                <button
                    onClick={handleBetClick}
                    className="relative w-full bg-[#16A34A] text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2 hover:bg-green-700 transition-colors"
                >
                    <ShieldCheck size={18} />
                    <span>Claim Your Bonus Now</span>
                </button>
            </div>

            <p className="text-xs text-brand-muted/80">
                18+ | T&Cs apply. Please gamble responsibly.
            </p>
        </div>
    );
});

export default BettingPromotionWidget;

// ===== src/components/CasinoPartnerWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { Crown } from "lucide-react";
import StyledLink from "./StyledLink";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useTranslation } from "@/hooks/useTranslation";

interface ICasinoPartner {
  _id: string;
  name: string;
  logoUrl: string;
  redirectUrl: string;
  description?: string;
  isFeatured: boolean;
  isActive: boolean;
  order: number;
}

const fetchCasinoPartners = async (): Promise<ICasinoPartner[]> => {
  const { data } = await axios.get("/api/casino-partners");
  return data;
};

const CasinoPartnerWidget: React.FC = () => {
  const { t } = useTranslation();
  const {
    data: partners,
    isLoading,
    isError,
  } = useQuery<ICasinoPartner[]>({
    queryKey: ["casinoPartnersPublic"],
    queryFn: fetchCasinoPartners,
    staleTime: 1000 * 60 * 15,
  });

  if (isLoading) {
    return (
      <div className="bg-brand-secondary rounded-lg shadow-lg p-4 animate-pulse space-y-4">
        <div className="h-6 w-3/4 bg-gray-700 rounded mb-4"></div>
        <div className="h-10 bg-gray-700 rounded"></div>
        <div className="h-10 bg-gray-700 rounded"></div>
        <div className="h-10 bg-gray-700 rounded"></div>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="bg-brand-secondary rounded-lg shadow-lg p-4 text-red-400">
        {t("error_loading_partners")}
      </div>
    );
  }

  if (!partners || partners.length === 0) {
    return (
      <div className="bg-brand-secondary rounded-lg shadow-lg p-4 text-brand-muted text-center">
        {t("no_active_partners")}
      </div>
    );
  }

  return (
    <div className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden">
      <div className="p-4 border-b border-gray-700">
        <p className="text-xl font-bold text-white flex items-center gap-2">
          <Crown size={20} className="text-brand-purple" />{" "}
          {t("partner_casinos_title")}
        </p>
      </div>
      <div className="p-4 space-y-3">
        {partners.map((partner) => (
          <StyledLink
            key={partner._id}
            href={partner.redirectUrl}
            target="_blank"
            rel="noopener noreferrer nofollow"
            className={`
              block rounded-lg p-3 transition-all duration-300 transform
              ${
                partner.isFeatured
                  ? "bg-gradient-to-br from-[#ea5a1e40] to-[#ea5a1e] border border-[#ea5a1e] hover:border-[#ea5a1e] shadow-xl shadow-brand-purple/30 transform scale-[1.02] -translate-y-0.5"
                  : "bg-brand-dark/50 border border-gray-700 hover:bg-brand-dark/70"
              }
              hover:shadow-2xl hover:shadow-brand-purple/50
              flex items-center gap-3 relative overflow-hidden group
            `}
            title={partner.description || partner.name}
            gaEventName="casino_partner_click"
            gaEventParams={{
              partner_name: partner.name,
              is_featured: partner.isFeatured,
            }}
          >
            {partner.isFeatured && (
              <div className="absolute inset-0 bg-[#ea5a1e32] opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none"></div>
            )}
            <div className="h-15 w-15 flex justify-center items-center">
              <Image
                src={partner.logoUrl}
                alt={`${partner.name} Logo`}
                width={60}
                height={60}
                objectFit="contain"
                unoptimized={true}
                className=" rounded-lg bg-gray-900 p-1 z-10"
              />
            </div>
            <div className="flex flex-col flex-grow truncate z-10">
              <span
                className={`font-semibold text-lg truncate
                                  ${
                                    partner.isFeatured
                                      ? "text-white"
                                      : "text-brand-light"
                                  }`}
              >
                {partner.name}
              </span>
              {partner.description && (
                <span
                  className={`text-sm text-white mt-0.5 truncate
                                      ${
                                        partner.isFeatured
                                          ? "text-white"
                                          : "text-brand-muted"
                                      }`}
                >
                  {partner.description}
                </span>
              )}
            </div>

            {partner.isFeatured && (
              <Crown size={20} className="text-yellow-400 flex-shrink-0 z-10" />
            )}
          </StyledLink>
        ))}
      </div>
    </div>
  );
};

export default CasinoPartnerWidget;

// ===== src/components/CompactNewsItem.tsx =====

"use client";

import Image from "next/image";
import Link from "next/link";
import { IPost } from "@/models/Post";
import { formatDistanceToNow } from "date-fns";
import { Calendar, User } from "lucide-react";

interface CompactNewsItemProps {
  post: IPost;
}

export function CompactNewsItemSkeleton() {
  return (
    <div className="flex items-center gap-4 p-4 animate-pulse">
      <div className="w-24 h-16 bg-gray-700 rounded-md flex-shrink-0"></div>
      <div className="flex-1 space-y-2">
        <div className="h-5 w-full bg-gray-600 rounded"></div>
        <div className="h-5 w-4/5 bg-gray-600 rounded"></div>
        <div className="h-3 w-1/3 bg-gray-700 rounded mt-3"></div>
      </div>
    </div>
  );
}

export default function CompactNewsItem({ post }: CompactNewsItemProps) {
  if (!post) return null;

  const postUrl = `/${post.language}/news/${post.slug}`;

  const placeholderImage = "/images/placeholder-logo.svg";

  return (
    <div className="bg-brand-secondary rounded-lg transition-colors hover:bg-gray-800/50">
      <Link href={postUrl} className="flex items-center gap-4 p-4 group">
        <div className="flex-shrink-0 w-24 h-16 relative">
          <Image
            src={post.featuredImage || placeholderImage}
            alt={post.title}
            layout="fill"
            objectFit="cover"
            className="rounded-md"
          />
        </div>
        <div className="flex-1 min-w-0">
          <h3 className="font-bold text-white leading-tight text-base md:text-lg line-clamp-2 mb-2 group-hover:text-brand-purple transition-colors">
            {post.title}
          </h3>
          <div className="flex items-center gap-4 text-xs text-brand-muted">
            <div className="flex items-center gap-1.5">
              <User size={12} />
              <span>{post.author}</span>
            </div>
            <div className="flex items-center gap-1.5">
              <Calendar size={12} />
              <time dateTime={new Date(post.createdAt).toISOString()}>
                {formatDistanceToNow(new Date(post.createdAt), {
                  addSuffix: true,
                })}
              </time>
            </div>
          </div>
        </div>
      </Link>
    </div>
  );
}

// ===== src/components/ContactFormClient.tsx =====

"use client";

import { useState } from "react";
import { useMutation } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { Loader2, CheckCircle } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

const ContactFormClient: React.FC = () => {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [subject, setSubject] = useState("");
  const [message, setMessage] = useState("");
  const { t } = useTranslation();

  const contactMutation = useMutation({
    mutationFn: (formData: {
      name: string;
      email: string;
      subject: string;
      message: string;
    }) => axios.post("/api/contact", formData),
    onSuccess: () => {
      toast.success(t("contact_form_success_message"));
      setName("");
      setEmail("");
      setSubject("");
      setMessage("");
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || t("contact_form_error_message"));
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    contactMutation.mutate({ name, email, subject, message });
  };

  return (
    <div className="bg-brand-secondary p-8 rounded-lg shadow-xl">
      <h2 className="text-3xl font-bold text-white mb-6">
        {t("contact_us_form_title")}
      </h2>
      <form onSubmit={handleSubmit} className="space-y-5">
        <div>
          <label
            htmlFor="name"
            className="block text-sm font-medium text-brand-light mb-1"
          >
            {t("your_name_label")}
          </label>
          <input
            type="text"
            id="name"
            value={name}
            onChange={(e) => setName(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            required
            disabled={contactMutation.isPending}
          />
        </div>
        <div>
          <label
            htmlFor="email"
            className="block text-sm font-medium text-brand-light mb-1"
          >
            {t("your_email_label")}
          </label>
          <input
            type="email"
            id="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            required
            disabled={contactMutation.isPending}
          />
        </div>
        <div>
          <label
            htmlFor="subject"
            className="block text-sm font-medium text-brand-light mb-1"
          >
            {t("subject_label")}
          </label>
          <input
            type="text"
            id="subject"
            value={subject}
            onChange={(e) => setSubject(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            required
            disabled={contactMutation.isPending}
          />
        </div>
        <div>
          <label
            htmlFor="message"
            className="block text-sm font-medium text-brand-light mb-1"
          >
            {t("your_message_label")}
          </label>
          <textarea
            id="message"
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            rows={5}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
            required
            disabled={contactMutation.isPending}
          ></textarea>
        </div>
        <button
          type="submit"
          className="w-full bg-[#ea5a1e] text-white font-bold py-3 rounded-lg hover:opacity-90 transition-opacity flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
          disabled={contactMutation.isPending}
        >
          {contactMutation.isPending ? (
            <Loader2 size={20} className="animate-spin" />
          ) : (
            <CheckCircle size={20} />
          )}
          {contactMutation.isPending
            ? t("sending_button_text")
            : t("send_message_button_text")}
        </button>
      </form>
    </div>
  );
};

export default ContactFormClient;

// ===== src/components/CountryDropdown.tsx =====

"use client";

import { useState, useRef, useEffect } from 'react';
import Image from 'next/image';
import { ChevronDown, Globe } from 'lucide-react';
import { useQuery } from '@tanstack/react-query';
import axios from 'axios';
import { Country } from '@/types/api-football';
import { useLeagueContext } from '@/context/LeagueContext';
import { useTranslation } from '@/hooks/useTranslation';

const fetchCountries = async (): Promise<Country[]> => {
  const { data } = await axios.get('/api/countries');
  return data;
};

export default function CountryDropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const { t } = useTranslation();

  const { selectedCountry, setSelectedCountry } = useLeagueContext();

  const globalOption: Country = {
      name: t('global'),
      code: 'GLOBAL_VIEW',
      flagUrl: '',
  };

  const { data: countries, isLoading } = useQuery<Country[]>({
    queryKey: ['countries', globalOption.name],
    queryFn: fetchCountries,
    staleTime: 1000 * 60 * 60 * 24,
    refetchOnWindowFocus: false,
    select: (data) => {
      return [globalOption, ...data];
    },
  });

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleSelect = (country: Country) => {
    if (country.code === 'GLOBAL_VIEW') {
      setSelectedCountry(null);
    } else {
      setSelectedCountry(country);
    }
    setIsOpen(false);
  };

  return (
    <div className="relative" ref={dropdownRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        disabled={isLoading}
        className="flex items-center gap-2 bg-brand-secondary px-4 py-2 rounded-lg text-brand-light font-medium hover:bg-gray-700/50 transition-colors disabled:opacity-50 disabled:cursor-wait w-40 justify-between"
      >
        {isLoading ? (
          <span className="flex-grow text-left">{t('loading')}...</span>
        ) : selectedCountry ? (
          <>
            <Image
              src={selectedCountry.flagUrl}
              alt={selectedCountry.name}
              width={20}
              height={15}
              className="flex-shrink-0"
            />
            <span className="truncate flex-grow text-left">{selectedCountry.name}</span>
          </>
        ) : (
          <>
            <Globe size={16} className="flex-shrink-0" />
            <span className="truncate flex-grow text-left">{t('global')}</span>
          </>
        )}
        <ChevronDown size={16} className={`transition-transform duration-200 flex-shrink-0 ${isOpen ? 'rotate-180' : ''}`} />
      </button>

      {isOpen && countries && (
        <div className="absolute top-full mt-2 w-56 max-h-80 overflow-y-auto bg-brand-secondary rounded-lg shadow-lg z-50 border border-gray-700/50 custom-scrollbar">
          <ul className="text-brand-light">
            {countries.map((country) => (
              <li key={country.code || country.name}>
                <button
                  onClick={() => handleSelect(country)}
                  className="flex w-full items-center gap-3 px-4 py-2.5 text-sm hover:bg-brand-purple transition-colors"
                >
                  {country.code === 'GLOBAL_VIEW' ? (
                    <Globe size={16} className="h-4 w-5 text-center" />
                  ) : (
                    <Image src={country.flagUrl} alt={country.name} width={20} height={15} />
                  )}
                  <span>{country.name}</span>
                </button>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}

// ===== src/components/DatePicker.tsx =====

"use client";

import { useState, useRef, useEffect } from 'react';
import { format } from 'date-fns';
import { DayPicker } from 'react-day-picker';
import { Calendar as CalendarIcon } from 'lucide-react';
import 'react-day-picker/dist/style.css';

interface DatePickerProps {
  date: Date;
  setDate: (date: Date) => void;
}

export default function DatePicker({ date, setDate }: DatePickerProps) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleDaySelect = (selectedDate: Date | undefined) => {
    if (selectedDate) {
      setDate(selectedDate);
      setIsOpen(false);
    }
  };

  return (
    <div className="relative" ref={dropdownRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center justify-center gap-2 w-full min-w-[280px] text-lg font-bold p-2 rounded-md hover:bg-brand-purple"
      >
        <CalendarIcon size={20} />
        <span>{format(date, 'eeee, dd MMMM yyyy')}</span>
      </button>

      {isOpen && (
        <div className="absolute top-full mt-2 bg-brand-secondary border border-gray-600 rounded-lg shadow-lg z-20 p-2">
          <DayPicker
            mode="single"
            selected={date}
            onSelect={handleDaySelect}
            initialFocus

            classNames={{
              caption: 'flex justify-center py-2 mb-4 relative items-center',
              caption_label: 'text-sm font-medium text-white',
              nav: 'flex items-center',
              nav_button: 'h-6 w-6 bg-transparent hover:bg-brand-purple p-1 rounded-md',
              nav_button_previous: 'absolute left-1.5',
              nav_button_next: 'absolute right-1.5',
              table: 'w-full border-collapse',
              head_row: 'flex font-medium text-brand-muted',
              head_cell: 'w-full p-2',
              row: 'flex w-full mt-2',
              cell: 'text-white',
              day: 'h-8 w-8 p-0 hover:bg-brand-purple rounded-md',
              day_selected: 'bg-brand-purple font-bold',
              day_today: 'bg-gray-700 rounded-md',
              day_outside: 'text-brand-muted opacity-50',
              day_disabled: 'text-brand-muted opacity-50 cursor-not-allowed',
            }}
          />
        </div>
      )}
    </div>
  );
}

// ===== src/components/DesktopMatchListItem.tsx =====

"use client";

import { useState, useMemo } from "react";
import Image from "next/image";
import Link from "@/components/StyledLink";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import {
  History,
  CheckCircle,
  XCircle,
  TrendingUp,
  Loader2,
} from "lucide-react";
import { generateMatchSlug } from "@/lib/generate-match-slug";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useTranslation } from "@/hooks/useTranslation";
import ZonedDate from "./ZonedDate";

type Odds = { home: string; draw: string; away: string } | undefined | null;
const fetchFanskorOdds = async (fixtureId: number): Promise<Odds | null> => {
  try {
    const { data } = await axios.post("/api/batch-predictions", {
      fixtureIds: [fixtureId],
    });
    return data[fixtureId] || null;
  } catch (error) {
    console.error(
      `Failed to fetch Fanskor odds for fixture ${fixtureId}`,
      error
    );
    return null;
  }
};

interface DesktopMatchListItemProps {
  match: any;
  isLive: boolean;
}

export default function DesktopMatchListItem({
  match,
  isLive,
}: DesktopMatchListItemProps) {
  const { fixture, teams, goals } = match;
  const { t } = useTranslation();

  const slug = generateMatchSlug(teams.home, teams.away, fixture.id);
  const isFinished = ["FT", "AET", "PEN"].includes(fixture.status.short);

  const [showResult, setShowResult] = useState(false);

  const { data: customOdds, isLoading } = useQuery({
    queryKey: ["customOdds", fixture.id],
    queryFn: () => fetchFanskorOdds(fixture.id),
    enabled: showResult,
    staleTime: Infinity,
    refetchOnWindowFocus: false,
  });

  const { predictedOutcome, lowestOddValue } = useMemo(() => {
    if (!customOdds) return { predictedOutcome: null, lowestOddValue: null };
    const odds = {
      home: parseFloat(customOdds.home || "999"),
      draw: parseFloat(customOdds.draw || "999"),
      away: parseFloat(customOdds.away || "999"),
    };
    const minOdd = Math.min(odds.home, odds.draw, odds.away);
    if (minOdd === odds.home)
      return { predictedOutcome: "Home", lowestOddValue: customOdds.home };
    if (minOdd === odds.away)
      return { predictedOutcome: "Away", lowestOddValue: customOdds.away };
    return { predictedOutcome: "Draw", lowestOddValue: customOdds.draw };
  }, [customOdds]);

  const actualResult = useMemo(() => {
    if (!isFinished) return null;
    if (teams.home.winner) return "Home";
    if (teams.away.winner) return "Away";
    return "Draw";
  }, [isFinished, teams]);

  const wasPredictionCorrect = predictedOutcome === actualResult;

  const CustomOddBox = ({
    value,
    label,
    isFavorite,
  }: {
    value: string | undefined;
    label: string;
    isFavorite: boolean;
  }) => {
    const favoriteClasses =
      "bg-gradient-to-br from-[var(--brand-accent)] to-[#c54c14] text-white shadow-lg shadow-[var(--brand-accent)]/20";
    const defaultClasses =
      "bg-[var(--color-primary)] text-[var(--text-secondary)]";
    return (
      <div
        className={`flex flex-col items-center justify-center p-1 rounded-md w-16 h-12 transition-all duration-300 ${
          isFavorite ? favoriteClasses : defaultClasses
        }`}
      >
        <span
          className={`text-xs font-semibold ${
            isFavorite ? "opacity-80" : "text-[var(--text-muted)]"
          }`}
        >
          {label}
        </span>
        <span className="text-base font-black">{value || "-"}</span>
      </div>
    );
  };

  return (
    <div
      className="group flex items-center p-2 rounded-lg transition-all duration-300 ease-in-out border border-transparent hover:border-[var(--brand-accent)]/20 hover:bg-[var(--color-primary)]"
      style={{ backgroundColor: "var(--color-secondary)" }}
    >
      <Link href={slug} className="flex flex-1 items-center min-w-0">
        <div className="w-16 flex-shrink-0 text-center text-sm font-semibold">
          {isLive ? (
            <div className="flex items-center justify-center gap-1.5 text-green-400">
              <span className="h-1.5 w-1.5 rounded-full bg-green-500"></span>
              <span>{fixture.status.elapsed}'</span>
            </div>
          ) : isFinished ? (
            <div className="text-text-muted">{t("ft_short")}</div>
          ) : (
            <div className="text-text-primary">
              <ZonedDate date={fixture.date} format="HH:mm" />
            </div>
          )}
        </div>
        <div className="flex-1 flex flex-col gap-1.5 pr-4">
          <div className="flex items-center gap-3">
            <Image
              src={proxyImageUrl(teams.home.logo)}
              alt={teams.home.name}
              width={20}
              height={20}
              unoptimized={true}
            />
            <span className="font-semibold text-base text-text-primary">
              {teams.home.name}
            </span>
          </div>
          <div className="flex items-center gap-3">
            <Image
              src={proxyImageUrl(teams.away.logo)}
              alt={teams.away.name}
              width={20}
              height={20}
              unoptimized={true}
            />
            <span className="font-semibold text-base text-text-primary">
              {teams.away.name}
            </span>
          </div>
        </div>
        <div
          className={`w-10 flex-shrink-0 flex flex-col items-center gap-1.5 text-base font-bold ${
            isLive ? "text-green-400" : "text-text-primary"
          }`}
        >
          <span>{goals.home ?? "-"}</span>
          <span>{goals.away ?? "-"}</span>
        </div>
      </Link>

      <div className="w-64 flex-shrink-0 flex items-center justify-end gap-4 pl-4 border-l border-gray-700/50">
        <div className="flex-1 text-center">
          {isFinished ? (
            !showResult ? (
              <button
                onClick={() => setShowResult(true)}
                className="flex items-center justify-center gap-2 w-full text-sm font-semibold bg-[var(--color-primary)] border border-[var(--text-muted)]/20 text-text-muted hover:bg-[var(--text-muted)] hover:text-black rounded-md p-2.5 transition-all duration-200"
              >
                <History size={16} /> {t("see_prediction_result")}
              </button>
            ) : isLoading ? (
              <div className="flex justify-center items-center gap-2 text-sm font-semibold text-text-muted p-2.5">
                <Loader2 size={16} className="animate-spin" />{" "}
                {t("loading_result")}
              </div>
            ) : customOdds ? (
              <div
                className={`flex items-center justify-center gap-2 p-2.5 rounded-md text-sm font-bold ${
                  wasPredictionCorrect
                    ? "bg-green-500/10 text-green-400"
                    : "bg-gray-700/50 text-text-muted"
                }`}
              >
                {wasPredictionCorrect ? (
                  <CheckCircle size={18} />
                ) : (
                  <XCircle size={18} />
                )}
                <span>
                  {t("predicted_result", {
                    outcome: predictedOutcome,
                    odds: lowestOddValue,
                  })}
                </span>
              </div>
            ) : (
              <span className="text-xs text-text-muted font-semibold">
                {t("prediction_data_unavailable")}
              </span>
            )
          ) : !showResult ? (
            <button
              onClick={() => setShowResult(true)}
              className="flex items-center justify-center gap-2 w-full text-sm font-semibold bg-[var(--brand-accent)]/10 border border-[var(--brand-accent)]/50 text-[var(--brand-accent)] hover:bg-[var(--brand-accent)] hover:text-white rounded-md p-2.5 transition-all duration-200"
            >
              <TrendingUp size={16} />
              {t("show_odds")}
            </button>
          ) : isLoading ? (
            <div className="flex justify-center items-center gap-2 text-sm font-semibold text-text-muted p-2.5">
              <Loader2 size={16} className="animate-spin" />{" "}
              {t("calculating_odds")}
            </div>
          ) : customOdds ? (
            <div className="flex items-center justify-around gap-1">
              <CustomOddBox
                value={customOdds.home}
                label={t("odd_label_home")}
                isFavorite={predictedOutcome === "Home"}
              />
              <CustomOddBox
                value={customOdds.draw}
                label={t("odd_label_draw")}
                isFavorite={predictedOutcome === "Draw"}
              />
              <CustomOddBox
                value={customOdds.away}
                label={t("odd_label_away")}
                isFavorite={predictedOutcome === "Away"}
              />
            </div>
          ) : (
            <span className="text-xs text-text-muted font-semibold">
              {t("odds_unavailable")}
            </span>
          )}
        </div>
      </div>
    </div>
  );
}

export const MatchListItemSkeleton = () => (
  <div
    className="flex items-center p-2 rounded-lg animate-pulse"
    style={{ backgroundColor: "var(--color-secondary)" }}
  >
    <div className="flex-1 flex items-center">
      <div className="w-16 flex-shrink-0">
        <div className="h-5 w-10 mx-auto rounded bg-[var(--color-primary)]"></div>
      </div>
      <div className="flex-1 flex flex-col gap-3">
        <div className="flex items-center gap-3 w-4/5">
          <div className="w-6 h-6 rounded-full bg-[var(--color-primary)]"></div>
          <div className="h-5 w-full rounded bg-[var(--color-primary)]"></div>
        </div>
        <div className="flex items-center gap-3 w-4/5">
          <div className="w-6 h-6 rounded-full bg-[var(--color-primary)]"></div>
          <div className="h-5 w-full rounded bg-[var(--color-primary)]"></div>
        </div>
      </div>
      <div className="w-10 flex-shrink-0 flex flex-col items-center gap-3">
        <div className="h-5 w-4 bg-[var(--color-primary)] rounded"></div>
        <div className="h-5 w-4 bg-[var(--color-primary)] rounded"></div>
      </div>
    </div>
    <div className="w-64 flex-shrink-0 pl-4 border-l border-gray-700/50 flex items-center justify-end gap-4">
      <div className="w-full h-11 rounded-md bg-[var(--color-primary)]"></div>
      <div className="w-6 h-6 rounded-full bg-[var(--color-primary)]"></div>
    </div>
  </div>
);

// ===== src/components/DirectoryCard.tsx =====

import Image from "next/image";
import StyledLink from "./StyledLink";
import { League } from "@/types/api-football";
import { proxyImageUrl } from "@/lib/image-proxy";
import { Star } from "lucide-react";

export const DirectoryCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg p-4 flex items-center gap-4 animate-pulse">
    <div className="w-10 h-10 rounded-full bg-gray-700"></div>
    <div className="space-y-2 flex-1">
      <div className="h-4 w-3/4 rounded bg-gray-600"></div>
      <div className="h-3 w-1/2 rounded bg-gray-600"></div>
    </div>
  </div>
);

interface DirectoryCardProps extends League {
  isPopular?: boolean;
}

export default function DirectoryCard({
  id,
  name,
  logoUrl,
  countryName,
  href,
  isPopular,
}: DirectoryCardProps) {

  const containerClasses = isPopular
    ? "border-l-4 border-brand-purple"
    : "border-l-4 border-transparent";

  return (
    <StyledLink href={href} className="block group h-full">
      {}
      <div
        className={`bg-brand-secondary rounded-lg flex items-center gap-4 p-4 h-full transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20 ${containerClasses}`}
      >
        <Image
          src={proxyImageUrl(logoUrl)}
          alt={`${name} logo`}
          width={40}
          height={40}
          className="flex-shrink-0"
        />
        <div className="flex-1 min-w-0">
          <h3 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
            {name}
          </h3>
          <p className="text-sm text-brand-muted">{countryName}</p>
        </div>
        {}
        {isPopular && (
          <div className="flex-shrink-0" title="Popular Competition">
            <Star className="w-5 h-5 text-yellow-500/80" />
          </div>
        )}
      </div>
    </StyledLink>
  );
}

// ===== src/components/FaqAccordion.tsx =====

"use client";

import { useState } from "react";
import { ChevronDown } from "lucide-react";

interface FaqAccordionProps {
  question: string;
  answer: string;
}

export default function FaqAccordion({ question, answer }: FaqAccordionProps) {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="border-b border-gray-700/50 last:border-b-0">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="w-full flex justify-between items-center text-left p-6 hover:bg-[var(--color-primary)]/50 transition-colors"
        aria-expanded={isOpen}
      >
        {}
        <h3
          className={`text-lg font-semibold transition-colors ${
            isOpen ? "text-[var(--brand-accent)]" : "text-white"
          }`}
        >
          {question}
        </h3>
        <ChevronDown
          size={24}
          className={`text-[var(--brand-accent)] transform transition-transform duration-300 flex-shrink-0 ${
            isOpen ? "rotate-180" : ""
          }`}
        />
      </button>

      <div
        className={`grid transition-all duration-300 ease-in-out ${
          isOpen ? "grid-rows-[1fr] opacity-100" : "grid-rows-[0fr] opacity-0"
        }`}
      >
        <div className="overflow-hidden">
          {}
          <div
            className="px-6 pb-6 text-text-secondary leading-relaxed"
            dangerouslySetInnerHTML={{ __html: answer }}
          />
        </div>
      </div>
    </div>
  );
}

// ===== src/components/FaqClient.tsx =====

"use client";

import { useState, useMemo } from "react";
import Link from "next/link";
import FaqAccordion from "./FaqAccordion";
import { Info, Search, MessageSquarePlus } from "lucide-react";
import { IFaq } from "@/models/Faq";
import { useTranslation } from "@/hooks/useTranslation";

interface FaqClientProps {
  initialFaqs: IFaq[];
}

export default function FaqClient({ initialFaqs }: FaqClientProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const { t } = useTranslation();

  const groupedAndFilteredFaqs = useMemo(() => {
    if (!initialFaqs) return {};

    const filtered =
      searchTerm.length > 2
        ? initialFaqs.filter(
            (faq) =>
              faq.question.toLowerCase().includes(searchTerm.toLowerCase()) ||
              faq.answer.toLowerCase().includes(searchTerm.toLowerCase())
          )
        : initialFaqs;

    return filtered.reduce((acc, faq) => {
      const category = faq.category || "General Questions";
      if (!acc[category]) acc[category] = [];
      acc[category].push(faq);
      return acc;
    }, {} as Record<string, IFaq[]>);
  }, [initialFaqs, searchTerm]);

  const categories = Object.keys(groupedAndFilteredFaqs);

  return (
    <>
      <div className="relative">
        <Search
          className="absolute left-4 top-1/2 -translate-y-1/2 text-text-muted"
          size={20}
        />
        <input
          type="text"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          placeholder={t("faq_search_placeholder")}
          className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-4 pl-12 text-white placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-[var(--brand-accent)]"
        />
      </div>

      {categories.length > 0 ? (
        categories.map((category) => (
          <div
            key={category}
            className="bg-brand-secondary rounded-lg shadow-xl overflow-hidden"
          >
            <h2 className="text-2xl font-bold text-white p-6 border-b border-gray-700/50">
              {category}
            </h2>
            <div>
              {groupedAndFilteredFaqs[category].map((faq) => (
                <FaqAccordion
                  key={faq._id}
                  question={faq.question}
                  answer={faq.answer}
                />
              ))}
            </div>
          </div>
        ))
      ) : (
        <div className="bg-brand-secondary rounded-lg p-8 text-center text-text-muted">
          <Info size={32} className="mx-auto mb-3" />
          <p>{t("faq_no_results_message", { searchTerm })}</p>
        </div>
      )}

      <div className="bg-[var(--brand-accent)]/10 border border-[var(--brand-accent)]/20 p-6 rounded-lg text-center">
        <h3 className="text-xl font-bold text-white mb-2">
          {t("faq_cant_find_answer_title")}
        </h3>
        <p className="text-text-secondary mb-4">
          {t("faq_cant_find_answer_subtitle")}
        </p>
        <Link
          href="/contact-us"
          className="inline-flex items-center justify-center gap-2 bg-[var(--brand-accent)] text-white font-bold py-2 px-5 rounded-lg hover:opacity-90 transition-opacity"
        >
          <MessageSquarePlus size={18} /> {t("contact_support_button")}
        </Link>
      </div>
    </>
  );
}

// ===== src/components/FeaturedNewsRow.tsx =====

import Image from "next/image";
import Link from "next/link";
import { IPost } from "@/models/Post";
import { format } from "date-fns";
import { ArrowUpRight, Calendar, User } from "lucide-react";

interface FeaturedNewsRowProps {
  post: IPost;
  tFeaturedArticle: string;
  tReadMore: string;
}

export function FeaturedNewsRowSkeleton() {
  return (
    <div className="bg-brand-secondary rounded-lg flex flex-col sm:flex-row gap-0 animate-pulse mb-8">
      <div className="w-full sm:w-2/5 h-64 sm:h-auto bg-gray-700 rounded-t-lg sm:rounded-l-lg sm:rounded-tr-none flex-shrink-0"></div>
      <div className="w-full p-8 space-y-4">
        <div className="h-4 w-1/3 bg-gray-600 rounded"></div>
        <div className="h-8 w-full bg-gray-600 rounded"></div>
        <div className="h-8 w-4/5 bg-gray-600 rounded"></div>
        <div className="h-4 w-full bg-gray-600 rounded"></div>
        <div className="h-4 w-2/3 bg-gray-600 rounded"></div>
      </div>
    </div>
  );
}

export default function FeaturedNewsRow({
  post,
  tFeaturedArticle,
  tReadMore,
}: FeaturedNewsRowProps) {

  if (!post) return null;

  const postUrl = `/news/${post.slug}`;

  return (
    <div className="bg-brand-secondary rounded-lg flex flex-col sm:flex-row items-center transition-shadow hover:shadow-2xl hover:shadow-brand-purple/10 mb-8">
      {}
      <Link
        href={postUrl}
        className="block w-full sm:w-2/5 flex-shrink-0 h-64 sm:h-80"
      >
        <div className="relative w-full h-full">
          {post.featuredImage ? (
            <Image
              src={post.featuredImage}
              alt={post.featuredImageAltText || post.title}
              layout="fill"
              objectFit="cover"
              className="rounded-t-lg sm:rounded-l-lg sm:rounded-tr-none"
            />
          ) : (
            <div className="w-full h-full bg-gray-800 flex items-center justify-center rounded-t-lg sm:rounded-l-lg sm:rounded-tr-none">
              <span className="text-brand-muted">No Image</span>
            </div>
          )}
        </div>
      </Link>

      {}
      <div className="p-6 md:p-8 flex flex-col flex-1 min-w-0">
        <p className="text-sm text-brand-purple font-bold mb-2">
          {tFeaturedArticle} {}
        </p>
        <h2 className="font-bold text-white leading-tight mb-3 text-2xl md:text-3xl">
          <Link href={postUrl} className="hover:underline">
            {post.title}
          </Link>
        </h2>
        {post.metaDescription && (
          <p className="text-brand-light text-base flex-grow mb-4 line-clamp-3">
            {post.metaDescription}
          </p>
        )}
        <div className="mt-auto">
          <Link
            href={postUrl}
            className="text-brand-purple font-semibold text-sm flex items-center gap-1"
          >
            {tReadMore} <ArrowUpRight size={16} /> {}
          </Link>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/FinishedMatchSlide.tsx =====

"use client";

import Image from 'next/image';
import { format } from 'date-fns';
import { Calendar, History } from 'lucide-react';

interface MatchSlideProps {
  match: any;
}

export default function FinishedMatchSlide({ match }: MatchSlideProps) {
  const { teams, fixture, goals, league } = match;

  return (
    <div className="relative w-full h-64 overflow-hidden rounded-2xl bg-brand-secondary text-white">
      {}
      <Image
        src="https://images.unsplash.com/photo-1508098682722-e99c43a406b2?q=80&w=2070&auto=format&fit=crop"
        alt="Dark stadium background"
        layout="fill"
        objectFit="cover"
        className="z-0 opacity-80"
      />
      <div className="absolute inset-0 bg-black/70 z-10" />

      {}
      <div className="relative z-20 flex h-full flex-col items-center justify-center p-4">
        <p className="font-semibold tracking-wider text-brand-muted flex items-center gap-2">
            <History size={14} />
            Recent Result
        </p>
        <p className="text-sm text-brand-muted mb-4">{league.round}</p>

        <div className="flex items-center justify-around w-full max-w-2xl my-2">
          {}
          <div className="flex flex-col items-center gap-2 text-center w-1/3">
            <Image src={teams.home.logo} alt={teams.home.name} width={48} height={48}/>
            <h2 className="text-xl font-bold truncate">{teams.home.name}</h2>
          </div>

          {}
          <span className="text-5xl font-black text-white mx-4">
            {goals.home} - {goals.away}
          </span>

          {}
          <div className="flex flex-col items-center gap-2 text-center w-1/3">
            <Image src={teams.away.logo} alt={teams.away.name} width={48} height={48}/>
            <h2 className="text-xl font-bold truncate">{teams.away.name}</h2>
          </div>
        </div>

        <div className="mt-6 flex items-center gap-2 text-brand-muted">
            <Calendar size={16} />
            <span>{format(new Date(fixture.date), "dd MMMM yyyy")}</span>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/Footer.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Link from "next/link";
import Image from "next/image";
import { IPost } from "@/models/Post";
import { useTranslation } from "@/hooks/useTranslation";

const FooterLink = ({
  href,
  children,
}: {
  href: string;
  children: React.ReactNode;
}) => (
  <Link
    href={href}
    className="text-sm text-brand-muted hover:text-white transition-colors"
  >
    {children}
  </Link>
);
const FooterColumn = ({
  title,
  children,
}: {
  title: string;
  children: React.ReactNode;
}) => (
  <div className="space-y-4">
    <h4 className="font-bold text-white uppercase tracking-wider">{title}</h4>
    <div className="flex flex-col space-y-3">{children}</div>
  </div>
);

const fetchRecentPosts = async (): Promise<IPost[]> => {
  const { data } = await axios.get("/api/posts?status=published&limit=5");
  return data;
};

const fetchRecentFootballScores = async () => {
  return [
    { id: 1, home: "RB Salzburg", away: "Real Madrid", href: "#" },
    { id: 2, home: "Juventus", away: "Man City", href: "#" },
    { id: 3, home: "Man City", away: "Al-Ain", href: "#" },
    { id: 4, home: "Benfica", away: "Chelsea", href: "#" },
    { id: 5, home: "Esprance", away: "Chelsea", href: "#" },
  ];
};

export default function Footer() {
  const { t } = useTranslation();

  const { data: recentPosts } = useQuery({
    queryKey: ["recentPostsFooter"],
    queryFn: fetchRecentPosts,
    staleTime: 1000 * 60 * 10,
  });

  const { data: footballScores } = useQuery({
    queryKey: ["recentScoresFooter"],
    queryFn: fetchRecentFootballScores,
    staleTime: 1000 * 60 * 5,
  });

  return (
    <footer className="bg-brand-secondary text-white py-12">
      <div className="container mx-auto px-4">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8 mb-12">
          <div className="space-y-8">
            <div>
              <p className="font-bold text-white uppercase tracking-wider mb-4">
                {t("footer_about_title")}
              </p>
              <p className="text-sm text-brand-muted leading-relaxed">
                {t("footer_about_text")}
              </p>
            </div>
            <div>
              <p className="font-bold text-white uppercase tracking-wider mb-4">
                {t("news")}
              </p>
              <div className="text-sm text-brand-muted space-y-2">
                {recentPosts?.map((post) => (
                  <Link
                    key={post._id as string}
                    href={`/football/news/${post.slug}`}
                    className="block truncate hover:text-white transition-colors"
                  >
                    {post.title}
                  </Link>
                ))}
              </div>
            </div>
          </div>

          <div>
            <FooterColumn title={t("football")}>
              <FooterLink href="https://fanskor.com/football/league/premier-league-39">
                Premier League
              </FooterLink>
              <FooterLink href="https://fanskor.com/football/league/la-liga-140">
                LaLiga
              </FooterLink>
              <FooterLink href="https://fanskor.com/football/league/serie-a-135">
                Serie A
              </FooterLink>
              <FooterLink href="https://fanskor.com/football/league/bundesliga-78">
                Bundesliga
              </FooterLink>
              <FooterLink href="https://fanskor.com/football/league/ligue-1-61">
                Ligue 1
              </FooterLink>
              <FooterLink href="https://fanskor.com/football/league/uefa-champions-league-2">
                UEFA Champions League
              </FooterLink>
            </FooterColumn>
          </div>

          <div>
            <FooterColumn title={t("footer_football_scores_title")}>
              {footballScores?.map((score) => (
                <FooterLink key={score.id} href={score.href}>
                  {score.home} - {score.away}
                </FooterLink>
              ))}
            </FooterColumn>
          </div>

          <div>
            <FooterColumn title={t("footer_information_title")}>
              <FooterLink href="/contact-us">{t("contact_us")}</FooterLink>
              <FooterLink href="/faq">{t("faq_title")}</FooterLink>
              <FooterLink href="/author">{t("author_title")}</FooterLink>
              <FooterLink href="/report-abuse">
                {t("report_abuse_title")}
              </FooterLink>
              <FooterLink href="/privacy-policy">
                {t("privacy_policy_title")}
              </FooterLink>
              <FooterLink href="/terms-and-conditions">
                {t("terms_and_conditions_title")}
              </FooterLink>
            </FooterColumn>
          </div>
        </div>

        <div className="flex flex-col md:flex-row justify-between items-center border-t border-gray-700/50 pt-8 mb-8">
          <div className="mb-6 md:mb-0">
            <Image
              src="/fanskor-transparent.webp"
              alt="Fanskor logo"
              width={280}
              height={40}
            />
          </div>
          <div className="flex items-center gap-6 md:gap-8">
            <Link href="/responsible-gaming" title="Responsible Gaming">
              <Image
                src="/images/logos/18plus.svg"
                alt="18+ Responsible Gaming"
                width={40}
                height={40}
              />
            </Link>
            <Link href="/about-us#credibility" title="Verified by GamCare">
              <Image
                src="/images/logos/gamcare.svg"
                alt="GamCare Verified"
                width={110}
                height={35}
              />
            </Link>
            <Link href="/responsible-gaming#gambleaware" title="BeGambleAware">
              <Image
                src="/images/logos/begambleaware.svg"
                alt="BeGambleAware"
                width={190}
                height={25}
              />
            </Link>
            <Link href="/about-us#security" title="Secure Connection">
              <Image
                src="/images/logos/dmca-protected.svg"
                alt="DMCA Protected"
                width={180}
                height={35}
              />
            </Link>
          </div>
        </div>

        <div className="flex flex-col md:flex-row justify-between items-center text-sm text-brand-muted">
          <p className="mb-4 md:mb-0">
             {new Date().getFullYear()} Fanskor - {t("footer_rights_reserved")}
          </p>
          <div className="flex flex-wrap justify-center gap-x-4 gap-y-2">
            <FooterLink href="/privacy-policy">
              {t("privacy_policy_title")}
            </FooterLink>
            <FooterLink href="/terms-and-conditions">
              {t("terms_and_conditions_title")}
            </FooterLink>
            <FooterLink href="/gdpr">{t("gdpr_title")}</FooterLink>
          </div>
        </div>
      </div>
    </footer>
  );
}

// ===== src/components/Header.tsx =====

"use client";

import { useState, useEffect, useRef, Suspense } from "react";
import { usePathname } from "next/navigation";
import Image from "next/image";
import {
  FaBasketballBall,
  FaTrophy,
  FaUsers,
  FaNewspaper,
} from "react-icons/fa";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { IPost } from "@/models/Post";

import { IoMdFootball } from "react-icons/io";
import { IoTennisball } from "react-icons/io5";
import LanguageDropdown from "./LanguageDropdown";
import { useTranslation } from "@/hooks/useTranslation";
import StyledLink from "./StyledLink";
import NavDropdown from "./NavDropdown";
import NotificationDropdown from "./NotificationDropdown";
import { ArrowRight, Bell, Menu, X } from "lucide-react";
import Ticker from "./Ticker";

type NavIcon = React.ElementType;

interface SubLink {
  name: string;
  href: string;
  description: string;
  icon?: NavIcon;
}

interface NavItem {
  title: string;
  href: string;
  icon: NavIcon;
  isDropdown?: boolean;
  subLinks?: SubLink[];
}

const fetchLatestPost = async (): Promise<IPost | null> => {
  try {
    const { data } = await axios.get("/api/posts?status=published&limit=1");
    return data[0] || null;
  } catch {
    return null;
  }
};

export default function Header() {
  const { t } = useTranslation();
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const [isNotificationOpen, setIsNotificationOpen] = useState(false);
  const [hasUnread, setHasUnread] = useState(false);
  const notificationRef = useRef<HTMLDivElement>(null);
  const pathname = usePathname();

  const { data: latestPost } = useQuery<IPost | null>({
    queryKey: ["latestPostForIndicator"],
    queryFn: fetchLatestPost,
    staleTime: 1000 * 60,
  });

  useEffect(() => {
    if (latestPost) {
      const lastReadPostId = localStorage.getItem("lastReadPostId");
      if (latestPost._id !== lastReadPostId) {
        setHasUnread(true);
      }
    }
  }, [latestPost]);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        notificationRef.current &&
        !notificationRef.current.contains(event.target as Node)
      ) {
        setIsNotificationOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const handleNotificationToggle = () => {
    setIsNotificationOpen((prev) => !prev);
    if (hasUnread && latestPost) {
      localStorage.setItem("lastReadPostId", latestPost._id as string);
      setHasUnread(false);
    }
  };

  const navItems: NavItem[] = [
    {
      title: t("football"),
      href: "/football",
      icon: IoMdFootball,
      isDropdown: true,
      subLinks: [
        {
          name: t("leagues"),
          href: "/football/leagues",
          description: t("leagues_description"),
          icon: FaTrophy,
        },
        {
          name: t("teams"),
          href: "/football/teams",
          description: t("teams_description"),
          icon: FaUsers,
        },
        {
          name: t("football_news"),
          href: "/football/news",
          description: t("football_news_description"),
          icon: FaNewspaper,
        },
      ],
    },
    { title: t("basketball"), href: "#", icon: FaBasketballBall },
    { title: t("tennis"), href: "#", icon: IoTennisball },
    {
      title: t("news"),
      href: "/news",
      icon: FaNewspaper,
    },
  ];

  const handleMobileLinkClick = () => {
    setIsMobileMenuOpen(false);
  };

  return (
    <>
    <>
      {}
      <header className="relative w-full border-b border-gray-700/50 shadow-xl shadow-black/20 z-50">
        <div className="container mx-auto flex h-24 items-center justify-between px-4 lg:px-6">
          <StyledLink href="/" className="flex items-center flex-shrink-0">
            <Image
              src={"/fanskor.webp"}
              alt="fanskor-logo"
              width={180}
              height={60}
            />
          </StyledLink>
          <nav className="hidden lg:flex items-center flex-grow justify-center gap-12 px-8">
            {navItems.map((item) => (
              <li key={item.title} className="list-none">
                {item.isDropdown && item.subLinks ? (
                  <NavDropdown
                    title={item.title}
                    icon={item.icon}
                    subLinks={item.subLinks}
                  />
                ) : (
                  <StyledLink
                    href={item.href}
                    className={`relative flex items-center gap-2 py-2 text-base font-semibold transition-colors group ${
                      pathname.startsWith(item.href)
                        ? "text-white"
                        : "text-[var(--text-secondary)] hover:text-white"
                    } ${
                      pathname.startsWith(item.href)
                        ? "after:absolute after:bottom-0 after:left-0 after:w-full after:h-0.5 after:bg-[var(--brand-accent)] after:rounded-t-sm"
                        : "after:absolute after:bottom-0 after:left-1/2 after:w-0 after:h-0.5 after:bg-[var(--brand-accent)] after:rounded-t-sm group-hover:after:w-full group-hover:after:left-0 after:transition-all after:duration-300"
                    }`}
                  >
                    <item.icon size={20} />
                    {item.title}
                  </StyledLink>
                )}
              </li>
            ))}
          </nav>

          <div
            className="hidden lg:flex items-center gap-6 flex-shrink-0"
            ref={notificationRef}
          >
            <div className="relative">
              <button
                onClick={handleNotificationToggle}
                className="text-brand-light hover:text-white transition-colors p-2"
              >
                <Bell
                  size={24}
                  className={`text-[var(--brand-accent)] ${
                    hasUnread ? "animate-ring" : ""
                  }`}
                />
                {hasUnread && (
                  <span className="absolute top-2 right-2 block h-2 w-2 rounded-full bg-red-500 ring-2 ring-brand-dark" />
                )}
              </button>
              {isNotificationOpen && (
                <NotificationDropdown
                  onClose={() => setIsNotificationOpen(false)}
                />
              )}
            </div>
            <LanguageDropdown />
          </div>

          <div
            className="flex lg:hidden items-center gap-2 flex-shrink-0"
            ref={notificationRef}
          >
            <div className="relative">
              <button
                onClick={handleNotificationToggle}
                className="text-brand-light hover:text-white transition-colors p-2"
              >
                <Bell
                  size={24}
                  className={`text-[var(--brand-accent)] ${
                    hasUnread ? "animate-ring" : ""
                  }`}
                />
                {hasUnread && (
                  <span className="absolute top-2 right-2 block h-2 w-2 rounded-full bg-red-500 ring-2 ring-brand-dark" />
                )}
              </button>
              {isNotificationOpen && (
                <NotificationDropdown
                  onClose={() => setIsNotificationOpen(false)}
                />
              )}
            </div>
            <button
              className="text-brand-light hover:text-white transition-colors p-2"
              onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}
              aria-label="Toggle mobile menu"
            >
              {isMobileMenuOpen ? <X size={28} /> : <Menu size={28} />}
            </button>
          </div>
        </div>
      </header>

      {isMobileMenuOpen && (
        <div className="fixed inset-0 bg-black/95 z-[999] flex flex-col transform translate-x-0 animate-slide-in-right">
          <div className="flex items-center justify-between px-6 py-4 border-b border-gray-800/50 flex-shrink-0">
            <StyledLink href="/" className="flex items-center gap-3 group">
              <Image
                src={"/fanskor.webp"}
                alt="fanskor-logo"
                width={150}
                height={50}
              />
            </StyledLink>
            <button
              onClick={() => setIsMobileMenuOpen(false)}
              className="text-brand-light hover:text-white transition-colors p-2"
              aria-label="Close mobile menu"
            >
              <X size={32} />
            </button>
          </div>
          <div className="mt-8 pb-4 border-b border-gray-800/50 flex flex-col gap-4 px-6 flex-shrink-0">
            <LanguageDropdown />
          </div>
          <nav className="flex-1 overflow-y-auto custom-scrollbar p-6 pt-4">
            <ul className="space-y-4">
              {navItems.map((item) => (
                <li key={item.title}>
                  {item.isDropdown ? (
                    <div className="space-y-3">
                      <button className="w-full text-left px-4 py-3 text-lg font-bold uppercase text-[var(--text-muted)] tracking-wider border-b border-gray-800/50 flex items-center gap-3">
                        <item.icon size={24} />
                        {item.title}
                      </button>
                      <ul className="space-y-2 pl-4 border-l-2 border-gray-700/50">
                        {item.subLinks!.map((subLink) => (
                          <li key={subLink.name}>
                            <StyledLink
                              href={subLink.href}
                              onClick={handleMobileLinkClick}
                              className="flex justify-between items-center w-full rounded-lg p-3 text-lg font-medium text-brand-light hover:bg-brand-secondary"
                            >
                              <span className="flex items-center gap-3">
                                {subLink.icon && <subLink.icon size={24} />}{" "}
                                {subLink.name}
                              </span>
                              <ArrowRight
                                size={24}
                                className="text-[var(--brand-accent)]"
                              />
                            </StyledLink>
                          </li>
                        ))}
                      </ul>
                    </div>
                  ) : (
                    <StyledLink
                      href={item.href}
                      onClick={handleMobileLinkClick}
                      className="block w-full rounded-lg p-4 text-xl font-bold text-brand-light hover:bg-brand-secondary flex items-center gap-4"
                    >
                      <item.icon size={28} />
                      {item.title}
                    </StyledLink>
                  )}
                </li>
              ))}
            </ul>
          </nav>
        </div>
      )}

    </>
      <Suspense fallback={null}>
       <Ticker />
      </Suspense>
    </>
  );
}

// ===== src/components/HighlightCard.tsx =====

interface Highlight {
  id: string;
  embedUrl: string;
  title: string;
}

interface HighlightSlideProps {
  highlight: Highlight;
}

export default function HighlightSlide({ highlight }: HighlightSlideProps) {
  return (

    <div className="relative w-full" style={{ paddingBottom: "56.25%" }}>
      <iframe
        src={highlight.embedUrl}
        title={highlight.title}
        frameBorder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
        allowFullScreen
        className="absolute top-0 left-0 w-full h-full"
        loading="lazy"
      ></iframe>
    </div>
  );
}

// ===== src/components/HighlightSlide.tsx =====

interface Highlight {
  id: string;
  embedUrl: string;
  title: string;
}

interface HighlightSlideProps {
  highlight: Highlight;
}

export default function HighlightSlide({ highlight }: HighlightSlideProps) {
  return (

    <div className="relative w-full" style={{ paddingBottom: "56.25%" }}>
      <iframe
        src={highlight.embedUrl}
        title={highlight.title}
        frameBorder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
        allowFullScreen
        className="absolute top-0 left-0 w-full h-full"
      ></iframe>
    </div>
  );
}

// ===== src/components/LanguageDropdown.tsx =====

"use client";

import { useState, useTransition, Fragment } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { usePathname, useRouter } from "next/navigation";
import Image from "next/image";
import { ChevronDown, Loader2 } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";
import { ILanguage } from "@/models/Language";
import { Menu, Transition } from "@headlessui/react";
import { setLocaleCookie } from "@/app/actions/language";

const DEFAULT_LOCALE = "tr";

const fetchActiveLanguages = async (): Promise<ILanguage[]> => {
  const { data } = await axios.get("/api/admin/languages");
  return data.filter((lang: ILanguage) => lang.isActive);
};

export default function LanguageDropdown() {
  const [isPending, startTransition] = useTransition();
  const router = useRouter();
  const pathname = usePathname();
  const { locale: currentLocale } = useTranslation();

  const { data: languages, isLoading } = useQuery<ILanguage[]>({
    queryKey: ["activeLanguages"],
    queryFn: fetchActiveLanguages,
    staleTime: 1000 * 60 * 60,
  });

  const selectedLanguage = languages?.find(
    (lang) => lang.code === currentLocale
  );

  const handleSelect = (newLocale: string) => {
    let newPath = "";
    const isSwitchingToDefault = newLocale === DEFAULT_LOCALE;
    const isSwitchingFromDefault = currentLocale === DEFAULT_LOCALE;

    if (isSwitchingToDefault) {

      newPath = pathname.replace(`/${currentLocale}`, "");
    } else if (isSwitchingFromDefault) {

      newPath = `/${newLocale}${pathname}`;
    } else {

      newPath = pathname.replace(`/${currentLocale}`, `/${newLocale}`);
    }

    if (newPath === "") newPath = "/";

    startTransition(() => {

      setLocaleCookie(newLocale).then(() => {
        router.push(newPath);
      });
    });
  };

  const buttonContent = () => {
    if (isLoading || isPending) {
      return <Loader2 size={20} className="animate-spin" />;
    }
    if (selectedLanguage) {
      return (
        <>
          {selectedLanguage.flagUrl ? (
            <Image
              src={selectedLanguage.flagUrl}
              alt={selectedLanguage.name}
              width={20}
              height={15}
              unoptimized
            />
          ) : (
            <span className="font-bold text-sm">
              {selectedLanguage.code.toUpperCase()}
            </span>
          )}
          <span className="text-sm hidden md:block">
            {selectedLanguage.name}
          </span>
          <ChevronDown
            size={16}
            className="transition-transform duration-200 ui-open:rotate-180"
          />
        </>
      );
    }
    return <span>Select Language</span>;
  };

  return (
    <Menu as="div" className="relative inline-block text-left">
      <div>
        <Menu.Button
          disabled={isLoading || isPending}
          className="inline-flex w-full justify-center items-center gap-2 bg-brand-secondary px-3 py-2 rounded-lg text-brand-light font-medium hover:bg-gray-700/50 transition-colors disabled:opacity-50"
        >
          {buttonContent()}
        </Menu.Button>
      </div>

      <Transition
        as={Fragment}
        enter="transition ease-out duration-100"
        enterFrom="transform opacity-0 scale-95"
        enterTo="transform opacity-100 scale-100"
        leave="transition ease-in duration-75"
        leaveFrom="transform opacity-100 scale-100"
        leaveTo="transform opacity-0 scale-95"
      >
        <Menu.Items className="absolute right-0 mt-2 w-48 origin-top-right divide-y divide-gray-700 rounded-md bg-brand-secondary shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none z-[100]">
          <div className="p-1">
            {languages?.map((lang) => (
              <Menu.Item key={lang.code}>
                {({ active }) => (
                  <button
                    onClick={() => handleSelect(lang.code)}
                    disabled={lang.code === currentLocale}
                    className={`${
                      active || lang.code === currentLocale
                        ? "bg-brand-purple text-white"
                        : "text-brand-light"
                    } group flex w-full items-center rounded-md px-2 py-2 text-sm disabled:opacity-70 disabled:cursor-not-allowed`}
                  >
                    <div className="flex items-center gap-3">
                      {lang.flagUrl ? (
                        <Image
                          src={lang.flagUrl}
                          alt={lang.name}
                          width={20}
                          height={15}
                          unoptimized
                        />
                      ) : (
                        <span className="w-5 text-center font-semibold">
                          {lang.code.toUpperCase()}
                        </span>
                      )}
                      <span>{lang.name}</span>
                    </div>
                  </button>
                )}
              </Menu.Item>
            ))}
          </div>
        </Menu.Items>
      </Transition>
    </Menu>
  );
}

// ===== src/components/LatestHighlightsWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Slider from "react-slick";
import HighlightSlide from "./HighlightSlide";
import { ChevronLeft, ChevronRight } from "lucide-react";

interface Highlight {
  id: string;
  embedUrl: string;
  title: string;
}

const fetchLatestHighlights = async (): Promise<Highlight[] | null> => {
  try {
    const { data } = await axios.get("/api/highlights/latest");
    return data?.highlights || null;
  } catch (error) {

    return null;
  }
};

const SliderSkeleton = () => (
  <div className="aspect-video w-full bg-brand-dark rounded-lg animate-pulse"></div>
);

const NextArrow = ({ onClick }: { onClick?: () => void }) => (
  <button
    onClick={onClick}
    className="absolute top-4 right-4 z-10 p-2 bg-black/40 text-white rounded-full hover:bg-black/70 transition-colors"
    aria-label="Next slide"
  >
    <ChevronRight size={20} />
  </button>
);

const PrevArrow = ({ onClick }: { onClick?: () => void }) => (
  <button
    onClick={onClick}
    className="absolute top-4 right-16 z-10 p-2 bg-black/40 text-white rounded-full hover:bg-black/70 transition-colors"
    aria-label="Previous slide"
  >
    <ChevronLeft size={20} />
  </button>
);

export default function LatestHighlightsWidget() {
  const {
    data: highlights,
    isLoading,
    isError,
  } = useQuery<Highlight[] | null>({
    queryKey: ["latestHighlightsWidget"],
    queryFn: fetchLatestHighlights,
    staleTime: 1000 * 60 * 10,
  });

  const sliderSettings = {
    dots: false,
    infinite: true,
    speed: 500,
    slidesToShow: 1,
    slidesToScroll: 1,
    arrows: true,
    nextArrow: <NextArrow />,
    prevArrow: <PrevArrow />,
    autoplay: true,
    autoplaySpeed: 8000,
    pauseOnHover: true,
  };

  if (isError || (!isLoading && (!highlights || highlights.length === 0))) {
    return null;
  }

  return (
    <section className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden">
      {}
      <div className="relative w-full">
        {isLoading ? (
          <SliderSkeleton />
        ) : (
          <Slider {...sliderSettings}>
            {highlights?.map((highlight) => (
              <HighlightSlide key={highlight.id} highlight={highlight} />
            ))}
          </Slider>
        )}
      </div>
    </section>
  );
}

// ===== src/components/LayoutSkeletons.tsx =====

export const HeaderSkeleton = () => (

    <div className="h-20 w-full" style={{ backgroundColor: 'var(--color-primary)' }}></div>
);

export const SidebarSkeleton = () => (

    <div className="hidden lg:block w-72 rounded-xl" style={{ backgroundColor: 'var(--color-primary)' }}></div>
);

// ===== src/components/LeagueListClient.tsx =====

"use client";

import { useState, useMemo, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { League } from "@/types/api-football";
import DirectoryCard, {
  DirectoryCardSkeleton,
} from "@/components/DirectoryCard";
import Pagination from "@/components/Pagination";
import { Search, SearchX } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

const ITEMS_PER_PAGE = 15;

const fetchActiveLeagueIds = async (): Promise<number[]> => {
  const { data } = await axios.get("/api/active-leagues");
  return data;
};

interface LeagueListClientProps {
  initialAllLeagues: League[];
}

export default function LeagueListClient({
  initialAllLeagues,
}: LeagueListClientProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const [filter, setFilter] = useState<"all" | "league" | "cup">("all");
  const [currentPage, setCurrentPage] = useState(1);
  const { t } = useTranslation();

  const { data: activeLeagueIds, isLoading: isLoadingActive } = useQuery({
    queryKey: ["activeLeagueIds"],
    queryFn: fetchActiveLeagueIds,
    staleTime: 1000 * 60 * 10,
  });

  const filteredLeagues = useMemo(() => {
    const activeIdsSet = new Set(activeLeagueIds || []);

    const filtered = initialAllLeagues.filter((league) => {
      const matchesSearch = league.name
        .toLowerCase()
        .includes(searchTerm.toLowerCase());
      const matchesFilter =
        filter === "all" || league.type.toLowerCase() === filter;
      return matchesSearch && matchesFilter;
    });

    const activeLeagues = filtered.filter((l) => activeIdsSet.has(l.id));
    const inactiveLeagues = filtered.filter((l) => !activeIdsSet.has(l.id));

    activeLeagues.sort((a, b) => a.name.localeCompare(b.name));
    inactiveLeagues.sort((a, b) => a.name.localeCompare(b.name));

    return [...activeLeagues, ...inactiveLeagues];
  }, [initialAllLeagues, activeLeagueIds, searchTerm, filter]);

  const { paginatedData, totalPages } = useMemo(() => {
    const total = Math.ceil(filteredLeagues.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    return {
      paginatedData: filteredLeagues.slice(startIndex, endIndex),
      totalPages: total,
    };
  }, [filteredLeagues, currentPage]);

  useEffect(() => {
    setCurrentPage(1);
  }, [searchTerm, filter]);

  return (
    <>
      <div className="bg-brand-secondary p-4 rounded-lg mb-8 flex flex-col md:flex-row items-center gap-4">
        <div className="relative flex-grow w-full">
          <Search
            className="absolute left-3.5 top-1/2 -translate-y-1/2 text-text-muted"
            size={20}
          />
          <input
            type="text"
            placeholder={t("search_leagues_placeholder")}
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-full bg-[var(--color-primary)] border border-gray-700/50 rounded-lg p-3 pl-12 text-white focus:outline-none focus:ring-2 focus:ring-[var(--brand-accent)]"
          />
        </div>
        <div className="flex items-center gap-2 p-1 rounded-lg bg-[var(--color-primary)] w-full md:w-auto">
          <button
            onClick={() => setFilter("all")}
            className={`flex-1 md:flex-none px-4 py-1.5 rounded-md text-sm font-semibold transition-colors ${
              filter === "all"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700/50"
            }`}
          >
            {t("filter_all")}
          </button>
          <button
            onClick={() => setFilter("league")}
            className={`flex-1 md:flex-none px-4 py-1.5 rounded-md text-sm font-semibold transition-colors ${
              filter === "league"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700/50"
            }`}
          >
            {t("filter_leagues")}
          </button>
          <button
            onClick={() => setFilter("cup")}
            className={`flex-1 md:flex-none px-4 py-1.5 rounded-md text-sm font-semibold transition-colors ${
              filter === "cup"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700/50"
            }`}
          >
            {t("filter_cups")}
          </button>
        </div>
      </div>

      <div>
        {isLoadingActive ? (
          <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
            {Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
              <DirectoryCardSkeleton key={i} />
            ))}
          </div>
        ) : paginatedData.length > 0 ? (
          <>
            <div className="mb-4">
              <h2 className="text-xl font-bold text-white">
                {t("showing_competitions", { count: filteredLeagues.length })}
              </h2>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
              {paginatedData.map((league) => (
                <DirectoryCard
                  key={league.id}
                  {...league}
                  isPopular={activeLeagueIds?.includes(league.id)}
                />
              ))}
            </div>
            <Pagination
              currentPage={currentPage}
              totalPages={totalPages}
              onPageChange={setCurrentPage}
            />
          </>
        ) : (
          <div className="text-center py-20 bg-brand-secondary rounded-lg">
            <SearchX size={48} className="mx-auto text-text-muted mb-4" />
            <p className="text-xl font-bold text-white">
              {t("no_leagues_found_title")}
            </p>
            <p className="text-text-muted mt-2">
              {t("no_leagues_found_subtitle", { searchTerm })}
            </p>
          </div>
        )}
      </div>
    </>
  );
}

// ===== src/components/LeagueStandingsSlide.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { League } from "@/types/api-football";

type StandingsData = {
  league: { id: number; name: string; logo: string; };
  standings: TeamStanding[];
};
type TeamStanding = {
  rank: number;
  team: { id: number; name: string; logo: string };
  points: number;
  all: { played: number };
};

const fetchStandingsForLeague = async (leagueId: number): Promise<StandingsData | null> => {
  try {
    const { data } = await axios.get(`/api/standings?league=${leagueId}`);

    if (!data || !data.standings || data.standings.length === 0) {
        return null;
    }
    return data;
  } catch (error) {

    return null;
  }
};

const SlideSkeleton = () => (
    <div className="bg-brand-secondary rounded-xl p-4 lg:p-6 animate-pulse">
        <div className="h-7 w-3/4 rounded bg-gray-600/50 mb-4"></div>
        <div className="space-y-3 mt-4">
            {Array.from({ length: 5 }).map((_, i) => <div key={i} className="h-5 w-full rounded bg-gray-600/50"></div>)}
        </div>
    </div>
);

export default function LeagueStandingsSlide({ league }: { league: League }) {
  const { data, isLoading } = useQuery<StandingsData | null>({
    queryKey: ['standings', league.id],
    queryFn: () => fetchStandingsForLeague(league.id),
    staleTime: 1000 * 60 * 10,
  });

  if (isLoading) return <SlideSkeleton />;

  if (!data) {
    return null;
  }

  const topStandings = data.standings.slice(0, 5);

  return (
    <div className="bg-brand-secondary rounded-xl p-4 lg:p-6 h-full">
      <div className="flex items-center gap-3 mb-4">
        <Image src={data.league.logo} alt={data.league.name} width={32} height={32}/>
        <h3 className="text-xl font-bold text-brand-light truncate">{data.league.name}</h3>
      </div>
      {}
      <table className="w-full text-sm">
        <thead className="text-brand-muted text-xs">
          <tr className="border-b border-gray-700/50">
            <th className="p-2 font-semibold text-left w-8">#</th>
            <th className="p-2 font-semibold text-left">Team</th>
            <th className="p-2 font-semibold text-center">P</th>
            <th className="p-2 font-semibold text-center">Pts</th>
          </tr>
        </thead>
        <tbody>
          {topStandings.map((team: TeamStanding) => (
            <tr key={team.team.id} className="border-t border-gray-700/50">
              <td className="p-2 text-center">{team.rank}</td>
              <td className="p-2 flex items-center gap-2 font-medium truncate">
                <Image src={team.team.logo} alt={team.team.name} width={16} height={16} />
                {team.team.name}
              </td>
              <td className="p-2 text-center text-brand-muted">{team.all.played}</td>
              <td className="p-2 text-center font-bold text-brand-light">{team.points}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

// ===== src/components/LiveMatchCard.tsx =====

"use client";

import { useState, useMemo } from 'react';
import Image from 'next/image';
import { format } from 'date-fns';
import Link from '@/components/StyledLink';
import { History, BarChart2, Star } from 'lucide-react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'axios';
import { useVoteStorage } from '@/hooks/useVoteStorage';
import { useTranslation } from '@/hooks/useTranslation';

interface VoteData {
    homeVotes: number;
    drawVotes: number;
    awayVotes: number;
}

const getVotes = async (fixtureId: number): Promise<VoteData> => {
    const { data } = await axios.get(`/api/votes?fixture=${fixtureId}`);
    return data;
};

const submitVote = async ({ fixtureId, vote }: { fixtureId: number; vote: string }): Promise<VoteData> => {
    const { data } = await axios.post('/api/votes', { fixtureId, vote });
    return data;
};

const TeamRow = ({ team, score, hasMomentum, momentumType, onVote, isVotedFor, isDisabled }: any) => (
    <div className="flex justify-between items-center">
        <div className="flex items-center gap-3 min-w-0">
            <div className="relative flex-shrink-0">
                <Image src={team.logo} alt={team.name} width={32} height={32} className="object-contain h-8 w-8"/>
                {hasMomentum && (
                    <span className="absolute -top-1 -right-1 flex h-3 w-3">
                        <span className={`absolute inline-flex h-full w-full rounded-full ${momentumType === 'Goal' ? 'bg-green-400' : 'bg-red-400'} opacity-75 animate-ping`}></span>
                        <span className={`relative inline-flex rounded-full h-3 w-3 ${momentumType === 'Goal' ? 'bg-green-500' : 'bg-red-500'}`}></span>
                    </span>
                )}
            </div>
            <span className="font-bold text-white truncate">{team.name}</span>
        </div>
        <div className="flex items-center gap-3">
            <span className="text-xl font-black text-white">{score ?? 0}</span>
            <button onClick={onVote} disabled={isDisabled} className="disabled:cursor-not-allowed disabled:opacity-50">
                <Star size={20} className={`transition-all duration-200 ${isVotedFor ? 'text-yellow-400 fill-yellow-400' : 'text-gray-500 hover:text-yellow-400'}`} />
            </button>
        </div>
    </div>
);

export default function MobileLiveMatchCard({ match }: { match: any }) {
  const { fixture, teams, goals, league, events } = match;
  const { t } = useTranslation();
  const queryClient = useQueryClient();
  const { setVote, getVoteForFixture } = useVoteStorage();

  const isFinished = ['FT', 'AET', 'PEN'].includes(fixture.status.short);

  const [votedFor, setVotedFor] = useState<'home' | 'away' | null>(() => getVoteForFixture(fixture.id) as 'home' | 'away' | null);

  const { data: voteData } = useQuery({
      queryKey: ['votes', fixture.id],
      queryFn: () => getVotes(fixture.id),
      staleTime: 1000 * 60,
      enabled: !isFinished,
  });

  const voteMutation = useMutation({
      mutationFn: submitVote,
      onSuccess: () => {
          queryClient.invalidateQueries({ queryKey: ['votes', fixture.id] });
      },
  });

  const handleVote = (choice: 'home' | 'away') => {
      if (votedFor) return;
      setVotedFor(choice);
      setVote(fixture.id, choice);
      voteMutation.mutate({ fixtureId: fixture.id, vote: choice });
  };

  const momentumData = useMemo(() => {

    if (!['1H', 'HT', '2H', 'ET', 'P'].includes(fixture.status.short) || !events || events.length === 0) return { teamId: null, type: null };
    const lastMajorEvent = [...events].reverse().find(e => e.type === 'Goal' || (e.type === 'Card' && e.detail === 'Red Card'));
    if (!lastMajorEvent) return { teamId: null, type: null };
    let momentumTeamId = lastMajorEvent.team.id;
    if (lastMajorEvent.type === 'Card') {
        momentumTeamId = momentumTeamId === teams.home.id ? teams.away.id : teams.home.id;
    }
    return { teamId: momentumTeamId, type: lastMajorEvent.type };
  }, [events, fixture.status.short, teams.home.id, teams.away.id]);

  const totalVotes = (voteData?.homeVotes || 0) + (voteData?.awayVotes || 0);
  const homePercent = totalVotes > 0 ? Math.round(((voteData?.homeVotes || 0) / totalVotes) * 100) : 50;

  return (
    <div className="bg-[#252837] rounded-xl overflow-hidden flex flex-col">
      {}
      <div className="flex justify-between items-center p-3 border-b border-gray-700/50">
          <div className="flex items-center gap-2 min-w-0">
            <Image src={league.logo} alt={league.name} width={20} height={20} className="flex-shrink-0" />
            <span className="text-sm font-semibold truncate text-brand-muted">{league.name}</span>
          </div>
          <div className="flex-shrink-0">
            {['1H', 'HT', '2H', 'ET', 'P'].includes(fixture.status.short) && <div className="flex items-center gap-1.5 text-brand-live font-semibold text-xs"><span className="relative flex h-2 w-2"><span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span><span className="relative inline-flex rounded-full h-2 w-2 bg-brand-live"></span></span><span>{fixture.status.elapsed}'</span></div>}
            {isFinished && <div className="flex items-center gap-1.5 bg-gray-700/50 text-gray-300 px-2 py-0.5 rounded-full text-xs font-semibold"><History size={12} /><span>{t('finished')}</span></div>}
            {!isFinished && !['1H', 'HT', '2H', 'ET', 'P'].includes(fixture.status.short) && <div className="font-bold text-brand-light text-sm">{format(new Date(fixture.date), "HH:mm")}</div>}
          </div>
      </div>

      {}
      <div className="p-3 space-y-2">
          <TeamRow
            team={teams.home}
            score={goals.home}
            hasMomentum={momentumData.teamId === teams.home.id}
            momentumType={momentumData.type}
            onVote={() => handleVote('home')}
            isVotedFor={votedFor === 'home'}
            isDisabled={!!votedFor || isFinished}
          />
          <TeamRow
            team={teams.away}
            score={goals.away}
            hasMomentum={momentumData.teamId === teams.away.id}
            momentumType={momentumData.type}
            onVote={() => handleVote('away')}
            isVotedFor={votedFor === 'away'}
            isDisabled={!!votedFor || isFinished}
          />
      </div>

      {}
      {votedFor && voteData && (
          <div className="px-3 pb-3 space-y-2">
              <div className="flex justify-between items-center">
                  <span className="text-xs font-bold text-white">{homePercent}%</span>
                  <span className="text-xs font-semibold text-brand-muted">Community Rating</span>
                  <span className="text-xs font-bold text-white">{100 - homePercent}%</span>
              </div>
              <div className="flex w-full h-1.5 rounded-full overflow-hidden bg-gray-700">
                  <div className="bg-brand-purple" style={{ width: `${homePercent}%` }}></div>
                  <div className="bg-blue-600" style={{ width: `${100 - homePercent}%` }}></div>
              </div>
          </div>
      )}

      {}
      <div className="p-2 bg-gray-900/30 flex justify-end items-center">
        <Link href={`/football/match/${fixture.id}`} className="flex items-center gap-2 text-xs text-brand-muted hover:text-white transition-colors py-1 px-2">
            <BarChart2 size={14} />
            <span>{t('match_details')}</span>
        </Link>
      </div>
    </div>
  );
}

export const MatchCardSkeleton = () => (
    <div className="bg-[#252837] rounded-xl p-4 flex flex-col gap-4 animate-pulse">
        <div className="flex justify-between items-center">
            <div className="h-4 w-1/3 rounded bg-gray-600/50"></div>
            <div className="h-4 w-1/4 rounded bg-gray-600/50"></div>
        </div>
        <div className="flex items-center justify-between py-4">
            <div className="flex flex-col items-center gap-2 w-1/3"><div className="h-12 w-12 rounded-full bg-gray-600/50"></div><div className="h-4 w-2/3 rounded bg-gray-600/50"></div></div>
            <div className="h-8 w-1/4 rounded bg-gray-600/50"></div>
            <div className="flex flex-col items-center gap-2 w-1/3"><div className="h-12 w-12 rounded-full bg-gray-600/50"></div><div className="h-4 w-2/3 rounded bg-gray-600/50"></div></div>
        </div>
        <div className="h-10 w-full rounded-lg bg-gray-600/50 mt-auto"></div>
    </div>
);

// ===== src/components/LiveMatchUpdater.tsx =====

"use client";

import { useQuery } from '@tanstack/react-query';
import axios from 'axios';

import SidebarMatchItem, { SidebarMatchItemSkeleton } from './SidebarMatchItem';

interface MatchData {
  fixture: { id: number; status: { elapsed: number; }; };
  teams: { home: any; away: any; };
  goals: { home: any; away: any; };
}

const fetchGlobalLiveMatches = async (): Promise<MatchData[]> => {
    const { data } = await axios.get('/api/global-live');
    return data;
};

export default function LiveMatchUpdater({ initialLiveMatches }: { initialLiveMatches: MatchData[] }) {

  const { data: liveMatches, isLoading } = useQuery<MatchData[]>({
    queryKey: ['globalLiveMatches'],
    queryFn: fetchGlobalLiveMatches,
    initialData: initialLiveMatches,
    refetchInterval: 30000,
  });

  if (!liveMatches || liveMatches.length === 0) {
      return <p className="text-sm text-brand-muted text-center py-4">No matches are currently live.</p>;
  }

  return (
    <div className="space-y-1">
      {}
      {liveMatches.slice(0, 5).map(match => (
        <SidebarMatchItem key={match.fixture.id} match={match} />
      ))}
    </div>
  );
}

// ===== src/components/LottiePreloader.tsx =====

"use client";

import Lottie from "lottie-react";

import animationData from "../../public/fanskor-preloader.json";

export default function LottiePreloader() {
  const style = {
    height: 250,
    width: 250,
  };

  return (
    <div className="flex flex-col items-center gap-2">
      <Lottie animationData={animationData} style={style} loop={true} />
    </div>
  );
}

// ===== src/components/MainContent.tsx =====

"use client";

import { useState, Dispatch, SetStateAction } from "react";
import { useLeagueContext } from "@/context/LeagueContext";
import { League } from "@/types/api-football";

import MatchList from "./MatchList";
import StandingsDisplay from "./StandingsDisplay";
import NewsSection from "./NewsSection";
import LeagueDetailView from "./league-detail-view";
import AdSlotWidget from "./AdSlotWidget";
import LatestHighlightsWidget from "./LatestHighlightsWidget";
import { useTranslation } from "@/hooks/useTranslation";

interface MainContentProps {
  sidebarAboutSeoText: string;
  homepageAboutSeoText: string;
}

export const MainContent: React.FC<MainContentProps> = ({
  sidebarAboutSeoText,
  homepageAboutSeoText,
}) => {
  const { selectedLeague } = useLeagueContext();
  const [liveLeagues, setLiveLeagues] = useState<League[]>([]);
  const { t } = useTranslation();

  if (selectedLeague) {

    return (
      <div className="flex-1 p-4 lg:p-8">
        <LeagueDetailView leagueData={selectedLeague} />
      </div>
    );
  }

  return (
    <>
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 p-4 lg:p-0 lg:pl-8">
        <div className="lg:col-span-2 flex flex-col gap-8">
          <MatchList setLiveLeagues={setLiveLeagues} />
          <div className="bg-brand-secondary rounded-lg shadow-lg p-6">
            <h2 className="text-2xl font-bold text-white mb-4">
              {t("about_fanskor_title")}
            </h2>
            <p className="text-brand-light text-base leading-relaxed">
              {homepageAboutSeoText}
            </p>
          </div>
        </div>

        <div className="lg:col-span-1 flex flex-col gap-6">
          <LatestHighlightsWidget />
          <AdSlotWidget location="homepage_right_sidebar" />
          <StandingsDisplay />
          <div className="space-y-8 gap-8">
            <section className="bg-brand-secondary rounded-lg shadow-lg p-6">
              <h2 className="text-2xl font-bold text-white mb-4">
                {t("about_fanskor_title")}
              </h2>
              <p className="text-brand-light text-base leading-relaxed">
                {sidebarAboutSeoText}
              </p>
            </section>
            <NewsSection />
          </div>
        </div>
      </div>
    </>
  );
};

// ===== src/components/MatchDateNavigator.tsx =====

"use client";

import { useState, useRef, useEffect } from "react";
import { format, addDays, subDays, isToday, Locale } from "date-fns";
import { DayPicker } from "react-day-picker";
import "react-day-picker/dist/style.css";
import {
  Calendar as CalendarIcon,
  ChevronLeft,
  ChevronRight,
} from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

import { enUS, tr, fr, es } from "date-fns/locale";

interface DateNavigatorProps {
  selectedDate: Date;
  onDateChange: (date: Date) => void;
}

const dateLocales: Record<string, Locale> = { en: enUS, tr,  fr, es, };

export default function MatchDateNavigator({
  selectedDate,
  onDateChange,
}: DateNavigatorProps) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const { t, locale } = useTranslation();

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const handleDaySelect = (date: Date | undefined) => {
    if (date) {
      onDateChange(date);
      setIsOpen(false);
    }
  };

  const handleTodayClick = () => {
    onDateChange(new Date());
    setIsOpen(false);
  };

  const currentLocale = dateLocales[locale] || enUS;

  return (
    <div className="relative w-full" ref={dropdownRef}>
      <div className="flex items-center justify-between rounded-lg p-2 bg-brand-secondary">
        <button
          onClick={handleTodayClick}
          disabled={isToday(selectedDate)}
          className="px-4 py-2 text-sm font-semibold text-white rounded-md hover:bg-brand-purple/80 transition-colors disabled:opacity-50 disabled:hover:bg-transparent"
          aria-label="Go to today's date"
        >
          {t("today")}
        </button>

        <div className="flex items-center gap-2">
          <button
            onClick={() => onDateChange(subDays(selectedDate, 1))}
            className="p-2 transition-colors hover:bg-gray-700/50 rounded-full"
            aria-label="Previous day"
          >
            <ChevronLeft size={20} />
          </button>

          <button
            onClick={() => setIsOpen(!isOpen)}
            className="flex items-center gap-2 px-4 py-2 rounded-md hover:bg-gray-700/50 transition-colors"
            aria-expanded={isOpen}
          >
            <CalendarIcon size={18} className="text-text-muted" />
            <span className="font-bold text-lg text-white capitalize">
              {format(selectedDate, "d MMMM", { locale: currentLocale })}
            </span>
          </button>

          <button
            onClick={() => onDateChange(addDays(selectedDate, 1))}
            className="p-2 transition-colors hover:bg-gray-700/50 rounded-full"
            aria-label="Next day"
          >
            <ChevronRight size={20} />
          </button>
        </div>
        <div className="w-[84px]"></div>
      </div>

      <div
        className={`absolute top-full right-0 mt-2 bg-brand-secondary border border-gray-700/50 rounded-lg shadow-2xl z-20
                   transition-all duration-200 ease-out
                   ${
                     isOpen
                       ? "opacity-100 translate-y-0"
                       : "opacity-0 -translate-y-2 pointer-events-none"
                   }`}
      >
        <DayPicker
          mode="single"
          selected={selectedDate}
          onSelect={handleDaySelect}
          initialFocus
          locale={currentLocale}
          classNames={{
            root: "p-3",
            caption: "flex justify-between items-center mb-4",
            caption_label: "text-base font-bold text-white capitalize",
            nav_button:
              "h-8 w-8 flex items-center justify-center rounded-full hover:bg-gray-700 transition-colors",
            head_row: "flex",
            head_cell:
              "w-10 h-10 flex items-center justify-center font-semibold text-brand-muted text-sm",
            row: "flex w-full mt-2",
            cell: "flex items-center justify-center",
            day: "h-10 w-10 text-white rounded-full hover:bg-brand-purple/60 transition-colors cursor-pointer",
            day_selected:
              "bg-brand-purple text-white font-bold hover:bg-brand-purple",
            day_today:
              "ring-2 ring-brand-purple ring-offset-2 ring-offset-brand-secondary",
            day_outside: "text-brand-muted/40 cursor-default",
            day_disabled: "text-brand-muted/40 cursor-not-allowed",
          }}
        />
      </div>
    </div>
  );
}

// ===== src/components/MatchList.tsx =====

"use client";

import { useEffect, useMemo, useState, Dispatch, SetStateAction } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { useLeagueContext } from "@/context/LeagueContext";
import { League } from "@/types/api-football";
import MatchListItem, { MatchListItemSkeleton } from "./MatchListItem";
import MatchDateNavigator from "./MatchDateNavigator";
import {
  Globe,
  ChevronsDown,
  Search,
  XCircle,
  ChevronLeft,
  ChevronRight,
} from "lucide-react";
import { format } from "date-fns";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useTranslation } from "@/hooks/useTranslation";

function useDebounce(value: string, delay: number) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  return debouncedValue;
}

type StatusFilter = "all" | "live" | "finished" | "scheduled";
const INITIAL_MATCHES_TO_SHOW = 5;
const MATCHES_PER_PAGE = 10;
const LEAGUES_PER_PAGE = 8;

const fetchAllMatches = async (
  leagueId: number | null,
  date: Date
): Promise<any[]> => {
  const dateString = format(date, "yyyy-MM-dd");
  const url = leagueId
    ? `/api/fixtures?league=${leagueId}&date=${dateString}`
    : `/api/fixtures?date=${dateString}`;
  const { data } = await axios.get(url);
  return data;
};
const fetchGlobalLiveMatches = async (): Promise<any[]> => {
  const { data } = await axios.get("/api/global-live");
  return data;
};
const searchFixtures = async (query: string): Promise<any[]> => {
  if (query.length < 3) return [];
  const { data } = await axios.get(
    `/api/search/fixtures?q=${encodeURIComponent(query)}`
  );
  return data;
};

const LeagueGroupHeader = ({
  league,
}: {
  league: { name: string; logo: string; country: string; flag: string | null };
}) => (
  <div
    className="flex items-center gap-3 p-3 sticky top-0 z-10"
    style={{ backgroundColor: "var(--color-primary)" }}
  >
    <div className="w-[28px] h-[28px] flex items-center justify-center">
      {league.country === "World" ? (
        <Globe size={24} className="text-text-muted" />
      ) : (
        league.flag && (
          <Image
            src={proxyImageUrl(league.flag)}
            alt={league.country}
            width={28}
            height={28}
            className="rounded-full object-contain"
          />
        )
      )}
    </div>
    <div>
      <p className="font-bold text-base text-white">{league.country}</p>
      <p className="text-sm text-text-muted">{league.name}</p>
    </div>
  </div>
);

const TabButton = ({
  label,
  isActive,
  liveCount,
  onClick,
  hasLiveIndicator,
}: {
  label: string;
  isActive: boolean;
  liveCount?: number;
  onClick: () => void;
  hasLiveIndicator?: boolean;
}) => (
  <button
    onClick={onClick}
    className={`relative flex-1 md:flex-none flex items-center justify-center gap-2 px-3 md:px-4 py-2.5 rounded-lg text-xs md:text-sm font-bold transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-brand-purple/50 ${
      isActive
        ? "bg-brand-purple text-white shadow-lg"
        : "bg-transparent text-text-muted hover:text-white"
    }`}
  >
    {hasLiveIndicator && (
      <span className="relative flex h-3 w-3">
        <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span>
        <span className="relative inline-flex rounded-full h-3 w-3 bg-brand-live"></span>
      </span>
    )}
    {label}
    {liveCount && liveCount > 0 && (
      <span className="ml-1 flex items-center justify-center text-[10px] font-bold text-white bg-brand-live rounded-full h-4 w-4">
        {liveCount}
      </span>
    )}
  </button>
);

export default function MatchList({
  setLiveLeagues,
}: {
  setLiveLeagues: Dispatch<SetStateAction<League[]>>;
}) {
  const { selectedLeague } = useLeagueContext();
  const [activeStatusFilter, setActiveStatusFilter] =
    useState<StatusFilter>("all");
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [visibleMatchCounts, setVisibleMatchCounts] = useState<
    Record<string, number>
  >({});
  const [searchTerm, setSearchTerm] = useState("");
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  const { t } = useTranslation();

  const STATUS_MAP: Record<StatusFilter, string[]> = {
    all: [],
    live: ["1H", "HT", "2H", "ET", "P", "LIVE"],
    finished: ["FT", "AET", "PEN"],
    scheduled: ["NS", "TBD", "PST"],
  };

  const [currentPage, setCurrentPage] = useState(1);

  const {
    data: allMatches,
    isLoading,
    error,
  } = useQuery({
    queryKey: [
      "allMatches",
      selectedLeague?.id || "global",
      format(selectedDate, "yyyy-MM-dd"),
    ],
    queryFn: () => fetchAllMatches(selectedLeague?.id || null, selectedDate),
    enabled: activeStatusFilter !== "live" && !debouncedSearchTerm,
  });

  const { data: liveMatchesData, isLoading: isLoadingLive } = useQuery({
    queryKey: ["globalLiveMatchesList"],
    queryFn: fetchGlobalLiveMatches,
    enabled: activeStatusFilter === "live" && !debouncedSearchTerm,
  });

  const { data: searchResults, isLoading: isLoadingSearch } = useQuery({
    queryKey: ["fixtureSearch", debouncedSearchTerm],
    queryFn: () => searchFixtures(debouncedSearchTerm),
    enabled: debouncedSearchTerm.length >= 3,
  });

  const { data: globalLiveCount } = useQuery({
    queryKey: ["globalLiveCount"],
    queryFn: fetchGlobalLiveMatches,
    select: (data) => data.length,
    refetchInterval: 30000,
    staleTime: 25000,
  });

  useEffect(() => {
    setVisibleMatchCounts({});
    setCurrentPage(1);
  }, [selectedDate, activeStatusFilter, debouncedSearchTerm]);

  const groupedMatches = useMemo(() => {
    const isSearching = debouncedSearchTerm.length >= 3;
    const matchesToProcess = isSearching
      ? searchResults
      : activeStatusFilter === "live"
      ? liveMatchesData
      : allMatches;

    if (!matchesToProcess) return [];

    const statusFilter = STATUS_MAP[activeStatusFilter];
    const matchesToGroup =
      !isSearching && statusFilter.length > 0
        ? matchesToProcess.filter((m) =>
            statusFilter.includes(m.fixture.status.short)
          )
        : matchesToProcess;

    matchesToGroup.sort(
      (a, b) =>
        new Date(a.fixture.date).getTime() - new Date(b.fixture.date).getTime()
    );

    return matchesToGroup.reduce((acc, match) => {
      const groupKey = isSearching
        ? format(new Date(match.fixture.date), "yyyy-MM-dd")
        : match.league.id;
      const leagueInfo = {
        ...match.league,
        name: isSearching
          ? format(new Date(match.fixture.date), "eeee, dd MMMM")
          : match.league.name,
      };
      if (!acc[groupKey]) acc[groupKey] = { leagueInfo, matches: [] };
      acc[groupKey].matches.push(match);
      return acc;
    }, {} as Record<string, { leagueInfo: any; matches: any[] }>);
  }, [
    allMatches,
    liveMatchesData,
    searchResults,
    activeStatusFilter,
    debouncedSearchTerm,
    STATUS_MAP,
  ]);

  const paginatedLeagueGroups = useMemo(() => {
    const leagueEntries = Object.entries(groupedMatches);
    const totalPages = Math.ceil(leagueEntries.length / LEAGUES_PER_PAGE);
    const startIndex = (currentPage - 1) * LEAGUES_PER_PAGE;
    const endIndex = startIndex + LEAGUES_PER_PAGE;
    return {
      paginatedEntries: leagueEntries.slice(startIndex, endIndex),
      totalPages,
      totalLeagues: leagueEntries.length,
    };
  }, [groupedMatches, currentPage]);

  const handleLoadMore = (leagueId: string | number) => {
    setVisibleMatchCounts((prevCounts) => ({
      ...prevCounts,
      [leagueId]:
        (prevCounts[leagueId] || INITIAL_MATCHES_TO_SHOW) + MATCHES_PER_PAGE,
    }));
  };

  const isCurrentlyLoading =
    (isLoading && !debouncedSearchTerm && activeStatusFilter !== "live") ||
    (isLoadingLive && !debouncedSearchTerm && activeStatusFilter === "live") ||
    (isLoadingSearch && debouncedSearchTerm.length >= 3);

  return (
    <div className="space-y-4">
      <div
        className="flex flex-col gap-3 p-2 rounded-xl"
        style={{ backgroundColor: "var(--color-primary)" }}
      >
        <h1 className="py-2 italic">{t("homepage_seo_text_title")}</h1>
        <div className="relative">
          <Search
            className="absolute left-3 top-1/2 -translate-y-1/2 text-text-muted"
            size={20}
          />
          <input
            type="text"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            placeholder={t("search_fixtures_placeholder")}
            className="w-full bg-[var(--color-secondary)] border border-gray-700/50 rounded-lg p-3 pl-11 text-white placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-[var(--brand-accent)]"
          />
          {searchTerm && (
            <button
              onClick={() => setSearchTerm("")}
              className="absolute right-3 top-1/2 -translate-y-1/2 text-text-muted hover:text-white"
            >
              <XCircle size={18} />
            </button>
          )}
        </div>
        {!debouncedSearchTerm && (
          <>
            <div className="flex justify-center">
              <MatchDateNavigator
                selectedDate={selectedDate}
                onDateChange={setSelectedDate}
              />
            </div>
            <div
              className="flex items-center gap-1 p-1 rounded-xl w-full"
              style={{ backgroundColor: "var(--color-secondary)" }}
            >
              {[
                { key: "all", label: t("filter_all") },
                { key: "live", label: t("filter_live") },
                { key: "finished", label: t("filter_finished") },
                { key: "scheduled", label: t("filter_scheduled") },
              ].map((tab) => (
                <TabButton
                  key={tab.key}
                  label={tab.label}
                  isActive={activeStatusFilter === tab.key}
                  liveCount={tab.key === "live" ? globalLiveCount : undefined}
                  hasLiveIndicator={
                    tab.key === "live" && (globalLiveCount ?? 0) > 0
                  }
                  onClick={() => setActiveStatusFilter(tab.key as StatusFilter)}
                />
              ))}
            </div>
          </>
        )}
      </div>

      <div className="space-y-4">
        {isCurrentlyLoading ? (
          <div
            style={{ backgroundColor: "var(--color-primary)" }}
            className="rounded-lg p-2 space-y-2"
          >
            {Array.from({ length: 10 }).map((_, i) => (
              <MatchListItemSkeleton key={i} />
            ))}
          </div>
        ) : paginatedLeagueGroups.paginatedEntries.length > 0 ? (
          <>
            {paginatedLeagueGroups.paginatedEntries.map(
              ([groupKey, { leagueInfo, matches }]: any) => {
                const visibleCount =
                  visibleMatchCounts[groupKey] || INITIAL_MATCHES_TO_SHOW;
                const remainingMatches = matches.length - visibleCount;
                const hasMore = remainingMatches > 0;
                return (
                  <div
                    key={groupKey}
                    style={{ backgroundColor: "var(--color-primary)" }}
                    className="rounded-lg overflow-hidden"
                  >
                    <LeagueGroupHeader league={leagueInfo} />
                    <div className="p-2 space-y-2">
                      {matches.slice(0, visibleCount).map((match: any) => (
                        <MatchListItem key={match.fixture.id} match={match} />
                      ))}
                      {hasMore && (
                        <button
                          onClick={() => handleLoadMore(groupKey)}
                          className="w-full flex items-center justify-center gap-2 text-sm font-semibold text-text-muted p-3 rounded-lg transition-colors hover:text-white"
                          style={{ backgroundColor: "var(--color-secondary)" }}
                        >
                          <ChevronsDown size={16} />{" "}
                          {t("show_more_matches", {
                            count: Math.min(MATCHES_PER_PAGE, remainingMatches),
                          })}
                        </button>
                      )}
                    </div>
                  </div>
                );
              }
            )}
            {paginatedLeagueGroups.totalPages > 1 && (
              <div className="flex items-center justify-between p-2">
                <button
                  onClick={() => setCurrentPage((p) => p - 1)}
                  disabled={currentPage === 1}
                  className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-brand-secondary rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50 transition-colors"
                >
                  <ChevronLeft size={16} />
                  <span>{t("previous")}</span>
                </button>
                <span className="text-sm font-semibold text-brand-muted">
                  {t("page_of", {
                    currentPage,
                    totalPages: paginatedLeagueGroups.totalPages,
                  })}
                </span>
                <button
                  onClick={() => setCurrentPage((p) => p + 1)}
                  disabled={currentPage === paginatedLeagueGroups.totalPages}
                  className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-brand-secondary rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50 transition-colors"
                >
                  <span>{t("next")}</span>
                  <ChevronRight size={16} />
                </button>
              </div>
            )}
          </>
        ) : (
          <div
            className="text-center py-20 rounded-lg"
            style={{ backgroundColor: "var(--color-primary)" }}
          >
            <p className="text-white font-semibold capitalize">
              {t("no_matches_found_title")}
            </p>
            <p className="text-sm text-text-muted mt-1">
              {debouncedSearchTerm
                ? t("no_search_results_subtitle", {
                    searchTerm: debouncedSearchTerm,
                  })
                : t("no_matches_for_date_subtitle")}
            </p>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/MatchListItem.tsx =====

import DesktopMatchListItem, {
  MatchListItemSkeleton as DesktopSkeleton,
} from "./DesktopMatchListItem";
import MobileMatchListItem, {
  MobileMatchListItemSkeleton as MobileSkeleton,
} from "./MobileMatchListItem";

interface MatchListItemProps {
  match: any;
}

export default function MatchListItem({ match }: MatchListItemProps) {
  const status = match.fixture.status.short;
  const isLive = ["1H", "HT", "2H", "ET", "P", "LIVE"].includes(status);

  return (
    <>
      <div className="hidden lg:block">
        <DesktopMatchListItem match={match} isLive={isLive} />
      </div>
      <div className="block lg:hidden">
        <MobileMatchListItem match={match} />
      </div>
    </>
  );
}

export const MatchListItemSkeleton = () => {
  return (
    <>
      <div className="hidden lg:block">
        <DesktopSkeleton />
      </div>
      <div className="block lg:hidden">
        <MobileSkeleton />
      </div>
    </>
  );
};

// ===== src/components/MatchSlide.tsx =====

import Image from 'next/image';
import { format } from 'date-fns';
import { Calendar, MapPin } from 'lucide-react';

interface MatchSlideProps {
  match: any;
}

export default function MatchSlide({ match }: MatchSlideProps) {
  const { teams, fixture, league } = match;

  return (
    <div className="relative w-full h-64 overflow-hidden rounded-2xl bg-brand-secondary text-white">
      {}
      <Image

        src="https://images.unsplash.com/photo-1579952363873-27f3bade9f55?q=80&w=1935&auto=format&fit=crop"
        alt="Stadium background"
        layout="fill"
        objectFit="cover"
        className="z-0"
      />
      <div className="absolute inset-0 bg-black/70 z-10" />

      {}
      <div className="relative z-20 flex h-full flex-col items-center justify-center p-4">
        <p className="font-semibold tracking-wider text-brand-muted">Upcoming Match</p>
        <p className="text-sm text-brand-muted mb-4">{league.round}</p>

        <div className="flex items-center justify-around w-full max-w-lg my-2">
          {}
          <div className="flex items-center gap-3">
            <Image src={teams.home.logo} alt={teams.home.name} width={40} height={40}/>
            <h2 className="text-3xl sm:text-4xl font-black">{teams.home.name}</h2>
          </div>

          <span className="text-xl font-light text-brand-muted mx-4">VS</span>

          {}
          <div className="flex items-center gap-3">
            <h2 className="text-3xl sm:text-4xl font-black">{teams.away.name}</h2>
            <Image src={teams.away.logo} alt={teams.away.name} width={40} height={40}/>
          </div>
        </div>

        <div className="mt-6 flex flex-col sm:flex-row items-center gap-x-6 gap-y-2 text-brand-muted">
          <div className="flex items-center gap-2">
            <Calendar size={16} />
            <span>{format(new Date(fixture.date), "dd MMMM yyyy  h:mma")}</span>
          </div>
          <div className="flex items-center gap-2">
            <MapPin size={16} />
            <span>{fixture.venue.name}</span>
          </div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/MobileLiveMatchCard.tsx =====

"use client";

import { useState, useMemo } from 'react';
import Image from 'next/image';
import { format } from 'date-fns';
import Link from '@/components/StyledLink';
import { History, ChevronDown, BarChart2 } from 'lucide-react';
import VotingPanel from './VotingPanel';
import { useTranslation } from '@/hooks/useTranslation';

interface MatchCardProps {
  match: any;
}

const TeamRow = ({ team, score, hasMomentum, momentumType }: any) => (
    <div className="flex justify-between items-center">
        <div className="flex items-center gap-3 min-w-0">
            <div className="relative flex-shrink-0">
                <Image src={team.logo} alt={team.name} width={32} height={32} className="object-contain h-8 w-8"/>
                {hasMomentum && (
                    <span className="absolute -top-1 -right-1 flex h-3 w-3">
                        <span className={`absolute inline-flex h-full w-full rounded-full ${momentumType === 'Goal' ? 'bg-green-400' : 'bg-red-400'} opacity-75 animate-ping`}></span>
                        <span className={`relative inline-flex rounded-full h-3 w-3 ${momentumType === 'Goal' ? 'bg-green-500' : 'bg-red-500'}`}></span>
                    </span>
                )}
            </div>
            <span className="font-bold text-white truncate">{team.name}</span>
        </div>
        <span className="text-xl font-black text-white">{score ?? 0}</span>
    </div>
);

export default function MobileLiveMatchCard({ match }: MatchCardProps) {
  const { fixture, teams, goals, league, events } = match;
  const [isExpanded, setIsExpanded] = useState(false);
  const { t } = useTranslation();

  const isLive = ['1H', 'HT', '2H', 'ET', 'P'].includes(fixture.status.short);
  const isFinished = ['FT', 'AET', 'PEN'].includes(fixture.status.short);
  const isUpcoming = !isLive && !isFinished;

  const momentumData = useMemo(() => {
    if (!isLive || !events || events.length === 0) return { teamId: null, type: null };
    const lastMajorEvent = [...events].reverse().find(e => e.type === 'Goal' || (e.type === 'Card' && e.detail === 'Red Card'));
    if (!lastMajorEvent) return { teamId: null, type: null };
    let momentumTeamId = lastMajorEvent.team.id;
    if (lastMajorEvent.type === 'Card') {
        momentumTeamId = momentumTeamId === teams.home.id ? teams.away.id : teams.home.id;
    }
    return { teamId: momentumTeamId, type: lastMajorEvent.type };
  }, [events, isLive, teams.home.id, teams.away.id]);

  return (
    <div className="bg-[#252837] rounded-xl overflow-hidden flex flex-col">
      {}
      <div className="flex justify-between items-center p-3 border-b border-gray-700/50">
          <div className="flex items-center gap-2 min-w-0">
            <Image src={league.logo} alt={league.name} width={20} height={20} className="flex-shrink-0" />
            <span className="text-sm font-semibold truncate text-brand-muted">{league.name}</span>
          </div>
          <div className="flex-shrink-0">
            {isLive && <div className="flex items-center gap-1.5 text-brand-live font-semibold text-xs"><span className="relative flex h-2 w-2"><span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span><span className="relative inline-flex rounded-full h-2 w-2 bg-brand-live"></span></span><span>{fixture.status.elapsed}'</span></div>}
            {isFinished && <div className="flex items-center gap-1.5 bg-gray-700/50 text-gray-300 px-2 py-0.5 rounded-full text-xs font-semibold"><History size={12} /><span>{t('finished')}</span></div>}
            {isUpcoming && <div className="font-bold text-brand-light text-sm">{format(new Date(fixture.date), "HH:mm")}</div>}
          </div>
      </div>

      {}
      <div className="p-3 space-y-2">
          <TeamRow
            team={teams.home}
            score={goals.home}
            hasMomentum={momentumData.teamId === teams.home.id}
            momentumType={momentumData.type}
          />
          <TeamRow
            team={teams.away}
            score={goals.away}
            hasMomentum={momentumData.teamId === teams.away.id}
            momentumType={momentumData.type}
          />
      </div>

      {}
      <div className="p-2 bg-gray-900/30 flex justify-between items-center">
        <Link href={`/football/match/${fixture.id}`} className="flex items-center gap-2 text-xs text-brand-muted hover:text-white transition-colors py-1 px-2">
            <BarChart2 size={14} />
            <span>{t('match_details')}</span>
        </Link>
        {!isFinished && (
            <button
                onClick={() => setIsExpanded(!isExpanded)}
                className="flex items-center gap-1.5 text-xs text-green-400 hover:text-green-300 font-bold transition-all duration-300 rounded-lg px-2 py-1.5 bg-green-500/10"
                aria-label={isExpanded ? t('hide_panel') : t('vote_and_see_poll')}
            >
                <span>{t('vote_and_see_poll')}</span>
                <ChevronDown size={14} className={`transition-transform duration-300 ${isExpanded ? 'rotate-180' : ''}`} />
            </button>
        )}
      </div>

      {}
      <div className={`transition-all duration-300 ease-in-out grid ${isExpanded ? 'grid-rows-[1fr]' : 'grid-rows-[0fr]'}`}>
          <div className="overflow-hidden">
            {isExpanded && <VotingPanel fixtureId={fixture.id} teams={teams} />}
          </div>
      </div>
    </div>
  );
}

// ===== src/components/MobileMatchListItem.tsx =====

"use client";

import { useState, useMemo } from "react";
import Image from "next/image";
import Link from "@/components/StyledLink";
import { format } from "date-fns";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import {
  Loader2,
  BarChart2,
  TrendingUp,
  History,
  CheckCircle,
  XCircle,
} from "lucide-react";
import { generateMatchSlug } from "@/lib/generate-match-slug";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useTranslation } from "@/hooks/useTranslation";
import ZonedDate from "./ZonedDate";

type Odds = { home: string; draw: string; away: string } | undefined | null;
const fetchFanskorOdds = async (fixtureId: number): Promise<Odds | null> => {
  try {
    const { data } = await axios.post("/api/batch-predictions", {
      fixtureIds: [fixtureId],
    });
    return data[fixtureId] || null;
  } catch (error) {
    console.error(
      `Failed to fetch Fanskor odds for fixture ${fixtureId}`,
      error
    );
    return null;
  }
};

const TeamRow = ({
  team,
  score,
  isLive,
}: {
  team: { name: string; logo: string; winner: boolean };
  score: number | null;
  isLive: boolean;
}) => (
  <div className="flex items-center justify-between">
    <div className="flex items-center gap-3 min-w-0">
      <Image
        src={proxyImageUrl(team.logo)}
        alt={team.name}
        width={24}
        height={24}
        unoptimized={true}
      />
      <span
        className={`font-semibold text-sm truncate ${
          team.winner ? "text-text-primary" : "text-text-secondary"
        }`}
      >
        {team.name}
      </span>
    </div>
    <span
      className={`font-bold text-sm ${
        isLive
          ? "text-green-400"
          : team.winner
          ? "text-text-primary"
          : "text-text-secondary"
      }`}
    >
      {score ?? "-"}
    </span>
  </div>
);

export default function MobileMatchListItem({ match }: { match: any }) {
  const { fixture, teams, goals } = match;
  const { t } = useTranslation();
  const slug = generateMatchSlug(teams.home, teams.away, fixture.id);
  const [isExpanded, setIsExpanded] = useState(false);

  const isLive = ["1H", "HT", "2H", "ET", "P", "LIVE"].includes(
    fixture.status.short
  );
  const isFinished = ["FT", "AET", "PEN"].includes(fixture.status.short);

  const { data: customOdds, isLoading } = useQuery({
    queryKey: ["customOdds", fixture.id],
    queryFn: () => fetchFanskorOdds(fixture.id),
    enabled: isExpanded,
    staleTime: Infinity,
    refetchOnWindowFocus: false,
  });

  const { predictedOutcome, lowestOddValue } = useMemo(() => {
    if (!customOdds) return { predictedOutcome: null, lowestOddValue: null };
    const odds = {
      home: parseFloat(customOdds.home || "999"),
      draw: parseFloat(customOdds.draw || "999"),
      away: parseFloat(customOdds.away || "999"),
    };
    const minOdd = Math.min(odds.home, odds.draw, odds.away);
    if (minOdd === odds.home)
      return { predictedOutcome: "Home", lowestOddValue: customOdds.home };
    if (minOdd === odds.away)
      return { predictedOutcome: "Away", lowestOddValue: customOdds.away };
    return { predictedOutcome: "Draw", lowestOddValue: customOdds.draw };
  }, [customOdds]);

  const actualResult = useMemo(() => {
    if (!isFinished) return null;
    if (teams.home.winner) return "Home";
    if (teams.away.winner) return "Away";
    return "Draw";
  }, [isFinished, teams]);

  const wasPredictionCorrect = predictedOutcome === actualResult;

  const CustomOddBox = ({
    value,
    label,
    isFavorite,
  }: {
    value: string | undefined;
    label: string;
    isFavorite: boolean;
  }) => {
    const favoriteClasses =
      "bg-gradient-to-br from-[var(--brand-accent)] to-[#c54c14] text-white";
    const defaultClasses =
      "bg-[var(--color-primary)] text-[var(--text-secondary)]";
    return (
      <div
        className={`flex flex-col flex-1 items-center justify-center p-2 rounded-md transition-all duration-300 ${
          isFavorite ? favoriteClasses : defaultClasses
        }`}
      >
        <span
          className={`text-xs font-semibold ${
            isFavorite ? "opacity-80" : "text-[var(--text-muted)]"
          }`}
        >
          {label}
        </span>
        <span className="text-sm font-black">{value || "-"}</span>
      </div>
    );
  };

  return (
    <div
      className="rounded-lg overflow-hidden"
      style={{ backgroundColor: "var(--color-secondary)" }}
    >
      <Link href={`/football/match/${slug}`}>
        <div className="flex items-center gap-2 p-3">
          <div className="w-12 flex-shrink-0 text-center text-xs font-bold">
            {isLive ? (
              <div className="flex flex-col items-center justify-center gap-1 text-green-400">
                <span className="h-1.5 w-1.5 rounded-full bg-green-500"></span>
                <span>{fixture.status.elapsed}'</span>
              </div>
            ) : isFinished ? (
              <div className="text-text-muted">{t("ft_short")}</div>
            ) : (
              <ZonedDate date={fixture.date} format="HH:mm" />
            )}
          </div>
          <div className="flex-1 flex flex-col gap-2">
            <TeamRow team={teams.home} score={goals.home} isLive={isLive} />
            <TeamRow team={teams.away} score={goals.away} isLive={isLive} />
          </div>
        </div>
      </Link>

      {isExpanded && (
        <div className="mx-3 mb-3 pt-3 border-t border-[var(--color-primary)]">
          {isLoading ? (
            <div className="flex justify-center items-center gap-2 text-sm font-semibold text-text-muted p-2.5">
              <Loader2 size={16} className="animate-spin" /> {t("loading")}...
            </div>
          ) : customOdds ? (
            isFinished ? (
              <div
                className={`flex items-center justify-center gap-2 p-2.5 rounded-md text-sm font-bold ${
                  wasPredictionCorrect
                    ? "bg-green-500/10 text-green-400"
                    : "bg-gray-700/50 text-text-muted"
                }`}
              >
                {wasPredictionCorrect ? (
                  <CheckCircle size={18} />
                ) : (
                  <XCircle size={18} />
                )}
                <span>
                  {t("predicted_result", {
                    outcome: predictedOutcome,
                    odds: lowestOddValue,
                  })}
                </span>
              </div>
            ) : (
              <div className="flex items-center justify-around gap-2">
                <CustomOddBox
                  value={customOdds.home}
                  label={t("odd_label_home")}
                  isFavorite={predictedOutcome === "Home"}
                />
                <CustomOddBox
                  value={customOdds.draw}
                  label={t("odd_label_draw")}
                  isFavorite={predictedOutcome === "Draw"}
                />
                <CustomOddBox
                  value={customOdds.away}
                  label={t("odd_label_away")}
                  isFavorite={predictedOutcome === "Away"}
                />
              </div>
            )
          ) : (
            <p className="text-xs text-center text-text-muted p-2">
              {t("prediction_data_unavailable")}
            </p>
          )}
        </div>
      )}

      <div
        className="flex items-center justify-between p-2"
        style={{ backgroundColor: "var(--color-primary)" }}
      >
        <Link
          href={`/football/match/${slug}`}
          className="flex items-center gap-1.5 text-xs text-text-muted font-semibold hover:text-white transition-colors px-2 py-1"
        >
          <BarChart2 size={14} />
          <span>{t("match_details")}</span>
        </Link>
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className="flex items-center gap-1.5 text-xs font-semibold bg-[var(--brand-accent)]/10 text-[var(--brand-accent)] hover:bg-[var(--brand-accent)] hover:text-white rounded-full px-3 py-1.5 transition-all duration-200"
        >
          {isFinished ? <History size={14} /> : <TrendingUp size={14} />}
          <span>
            {isExpanded
              ? isFinished
                ? t("hide_result")
                : t("hide_odds")
              : isFinished
              ? t("see_result")
              : t("show_odds")}
          </span>
        </button>
      </div>
    </div>
  );
}

export const MobileMatchListItemSkeleton = () => (
  <div
    className="flex flex-col p-3 rounded-lg animate-pulse"
    style={{ backgroundColor: "var(--color-secondary)" }}
  >
    <div className="flex items-center gap-3">
      <div className="w-12 h-8 rounded bg-[var(--color-primary)]"></div>
      <div className="flex-1 space-y-2">
        <div className="h-4 w-4/5 rounded bg-[var(--color-primary)]"></div>
        <div className="h-4 w-3/5 rounded bg-[var(--color-primary)]"></div>
      </div>
    </div>
    <div className="h-8 mt-3 rounded-md bg-[var(--color-primary)]"></div>
  </div>
);

// ===== src/components/NavDropdown.tsx =====

"use client";

import { useState } from "react";
import { ChevronDown } from "lucide-react";
import StyledLink from "./StyledLink";
import { usePathname } from "next/navigation";

type NavIcon = React.ElementType;

interface SubLink {
  name: string;
  href: string;
  description: string;
  icon?: NavIcon;
}

interface NavDropdownProps {
  title: string;
  icon: NavIcon;
  subLinks: SubLink[];
}

export default function NavDropdown({
  title,
  icon: Icon,
  subLinks,
}: NavDropdownProps) {
  const [isOpen, setIsOpen] = useState(false);
  const pathname = usePathname();

  const isActive = subLinks.some((link) => pathname.startsWith(link.href));

  return (
    <div
      className="relative"
      onMouseEnter={() => setIsOpen(true)}
      onMouseLeave={() => setIsOpen(false)}
    >
      {}
      <button
        className={`flex items-center gap-2 py-2 text-base font-semibold transition-colors group
                    ${
                      isActive
                        ? "text-white"
                        : "text-[var(--text-secondary)] hover:text-white"
                    }
                    ${
                      isActive
                        ? "after:absolute after:bottom-0 after:left-0 after:w-full after:h-0.5 after:bg-[var(--brand-accent)] after:rounded-t-sm"
                        : "after:absolute after:bottom-0 after:left-1/2 after:w-0 after:h-0.5 after:bg-[var(--brand-accent)] after:rounded-t-sm group-hover:after:w-full group-hover:after:left-0 after:transition-all after:duration-300"
                    }
                `}
      >
        <Icon size={20} />
        <span>{title}</span>
        <ChevronDown
          size={16}
          className={`transition-transform duration-300 ${
            isOpen ? "rotate-180" : ""
          }`}
        />
      </button>

      {}
      <div
        className={`absolute top-full pt-3 transition-all duration-300 ease-in-out ${
          isOpen
            ? "opacity-100 translate-y-0"
            : "opacity-0 -translate-y-2 pointer-events-none"
        }`}
      >
        <div className="bg-[var(--color-secondary)] rounded-lg shadow-2xl border border-gray-700/50 w-64 overflow-hidden">
          <ul className="space-y-1 p-2">
            {subLinks.map((link) => (
              <li key={link.name}>
                <StyledLink
                  href={link.href}
                  className="block p-3 rounded-md hover:bg-[var(--brand-accent)]/20 hover:text-[var(--brand-accent)] transition-colors"
                >
                  <p className="font-bold text-white flex items-center gap-2">
                    {link.icon && <link.icon size={20} />}{" "}
                    {}
                    {link.name}
                  </p>
                  <p className="text-sm text-[var(--text-muted)]">
                    {link.description}
                  </p>
                </StyledLink>
              </li>
            ))}
          </ul>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/NewsCard.tsx =====

"use client";

import Image from "next/image";
import { IPost } from "@/models/Post";
import { formatDistanceToNow } from "date-fns";
import { ArrowRight, Calendar } from "lucide-react";
import StyledLink from "./StyledLink";
import { useTranslation } from "@/hooks/useTranslation";

interface NewsCardProps {
  post: IPost;
  variant?: "featured" | "grid";
}

const categoryColors: Record<string, string> = {
  prediction: "bg-blue-500/10 text-blue-300",
  reviews: "bg-indigo-500/10 text-indigo-300",
  highlights: "bg-amber-500/10 text-amber-300",
  news: "bg-gray-500/10 text-gray-400",
};

export default function NewsCard({ post, variant = "grid" }: NewsCardProps) {
  const { t } = useTranslation();
  if (!post) return null;

  const postUrl = `/news/${post.slug}`;

  const placeholderImage = "/images/placeholder-logo.svg";

  if (variant === "featured") {
    return (
      <StyledLink
        href={postUrl}
        className="block group relative rounded-xl overflow-hidden text-white shadow-lg shadow-black/30"
      >
        <div className="relative w-full aspect-video md:aspect-[2.4/1]">
          <Image
            src={post.featuredImage || placeholderImage}
            alt={post.title}
            layout="fill"
            objectFit="cover"
            className="transition-transform duration-500 ease-in-out group-hover:scale-105"
            priority
          />
          <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-transparent"></div>
        </div>
        <div className="absolute bottom-0 left-0 p-6 md:p-8">
          <span
            className={`text-xs font-bold px-2 py-1 rounded-full mb-3 inline-block ${
              categoryColors[post.newsType] || categoryColors.news
            }`}
          >
            {t(post.newsType)}
          </span>
          <h2 className="font-extrabold text-2xl md:text-4xl leading-tight line-clamp-2 group-hover:text-brand-purple transition-colors">
            {post.title}
          </h2>
          <div className="flex items-center gap-4 text-sm text-brand-muted mt-3">
            <div className="flex items-center gap-1.5">
              <Calendar size={14} />
              <time dateTime={new Date(post.createdAt).toISOString()}>
                {formatDistanceToNow(new Date(post.createdAt), {
                  addSuffix: true,
                })}
              </time>
            </div>
          </div>
        </div>
      </StyledLink>
    );
  }

  return (
    <StyledLink
      href={postUrl}
      className="block group bg-brand-secondary rounded-xl overflow-hidden transition-all duration-300 hover:-translate-y-1 hover:shadow-xl hover:shadow-brand-purple/20 border border-gray-800/50 hover:border-brand-purple/30"
    >
      <div className="relative w-full aspect-video overflow-hidden">
        <Image
          src={post.featuredImage || placeholderImage}
          alt={post.title}
          layout="fill"
          objectFit="cover"
          className="transition-transform duration-300 group-hover:scale-105"
        />
      </div>
      <div className="p-4 flex flex-col flex-grow">
        <div className="flex items-center gap-2 mb-3">
          <span
            className={`text-xs font-bold px-2 py-1 rounded-full ${
              categoryColors[post.newsType] || categoryColors.news
            }`}
          >
            {t(post.newsType)}
          </span>
          <span className="text-xs text-brand-muted flex items-center gap-1.5 ml-auto">
            <Calendar size={12} />
            <time dateTime={new Date(post.createdAt).toISOString()}>
              {formatDistanceToNow(new Date(post.createdAt), {
                addSuffix: true,
              })}
            </time>
          </span>
        </div>
        <h3 className="font-bold text-white leading-tight text-base line-clamp-3 flex-grow group-hover:text-brand-purple transition-colors">
          {post.title}
        </h3>
      </div>
    </StyledLink>
  );
}

export const NewsCardSkeleton = ({
  variant = "grid",
}: {
  variant?: "featured" | "grid";
}) => {
  if (variant === "featured") {
    return (
      <div className="w-full aspect-video md:aspect-[2.4/1] bg-brand-secondary rounded-xl animate-pulse"></div>
    );
  }
  return (
    <div className="bg-brand-secondary rounded-xl animate-pulse">
      <div className="aspect-video w-full bg-gray-700/50 rounded-t-xl"></div>
      <div className="p-4 space-y-3">
        <div className="h-4 w-1/3 bg-gray-700 rounded"></div>
        <div className="h-5 w-full bg-gray-700 rounded"></div>
        <div className="h-5 w-4/5 bg-gray-700 rounded"></div>
      </div>
    </div>
  );
};

// ===== src/components/NewsItemCard.tsx =====

import Image from "next/image";
import Link from "@/components/StyledLink";

export interface NewsArticleType {
  id: string;
  title: string;
  excerpt: string;
  imageUrl: string;
  articleUrl: string;
}

interface NewsItemCardProps {
  article: NewsArticleType;
}

export default function NewsItemCard({ article }: NewsItemCardProps) {
  return (

    <Link
      href={article.articleUrl}
      target="_blank"
      rel="noopener noreferrer"
      className="block"
    >
      <div className="bg-brand-secondary rounded-xl overflow-hidden group transition-all duration-300 hover:shadow-lg hover:shadow-purple-900/20">
        {}
        <div className="relative w-full h-40">
          <Image
            src={article.imageUrl}
            alt={article.title}
            layout="fill"
            unoptimized={true}
            objectFit="cover"
            className="transition-transform duration-300 group-hover:scale-110"
          />
        </div>

        {}
        <div className="p-4">
          <h4 className="font-bold text-lg text-brand-light mb-2 leading-tight group-hover:text-brand-purple transition-colors">
            {article.title}
          </h4>
          <p className="text-sm text-brand-muted line-clamp-3">
            {article.excerpt}
          </p>
        </div>
      </div>
    </Link>
  );
}

export const NewsItemCardSkeleton = () => {
  return (
    <div className="bg-brand-secondary rounded-xl overflow-hidden animate-pulse">
      <div className="w-full h-40 bg-gray-600/50"></div>
      <div className="p-4 space-y-3">
        <div className="h-5 w-full rounded bg-gray-600/50"></div>
        <div className="h-5 w-4/5 rounded bg-gray-600/50"></div>
        <div className="h-3 w-full rounded bg-gray-600/50 mt-2"></div>
        <div className="h-3 w-1/2 rounded bg-gray-600/50"></div>
      </div>
    </div>
  );
};

// ===== src/components/NewsLeagueStandingsSlide.tsx =====

"use client";

import Image from 'next/image';
import Link from '@/components/StyledLink';

interface TeamStanding {
  rank: number;
  team: { id: number; name: string; logo: string; };
  points: number;
}
interface StandingsData {
  league: { id: number; name: string; logo: string; };
  standings: TeamStanding[];
}

export default function NewsLeagueStandingsSlide({ standingsData }: { standingsData: StandingsData }) {
  const { league, standings } = standingsData;

  return (

    <div className="px-1">
      <div className="bg-brand-secondary rounded-xl p-4 h-full">
        {}
            <Image src={league.logo} alt={league.name} width={32} height={32} />
            <h4 className="font-bold text-xl text-brand-light truncate group-hover:text-brand-purple transition-colors">
              {league.name}
            </h4>
        {}
        <div className="overflow-x-auto">
            <table className="w-full text-sm">
                <thead className="text-brand-muted text-xs">
                    <tr className="border-b border-gray-700/50">
                        <th className="p-2 font-semibold text-center w-8">#</th>
                        <th className="p-2 font-semibold text-left">Team</th>
                        <th className="p-2 font-semibold text-center">Pts</th>
                    </tr>
                </thead>
                <tbody>
                    {}
                    {standings.slice(0, 5).map((team) => (
                    <tr key={team.team.id} className="border-t border-gray-700/50">
                        <td className="p-2 text-center text-brand-muted">{team.rank}</td>
                        <td className="p-2 flex items-center gap-2 font-medium">
                        <Image src={team.team.logo} alt={team.team.name} width={18} height={18} />
                        <span className="truncate">{team.team.name}</span>
                        </td>
                        <td className="p-2 text-center font-bold">{team.points}</td>
                    </tr>
                    ))}
                </tbody>
            </table>
        </div>
      </div>
    </div>
  );
}

export const LeagueStandingsSlideSkeleton = () => (
    <div className="px-1">
        <div className="bg-brand-secondary rounded-xl p-4 animate-pulse">
            <div className="flex items-center gap-3 mb-4">
                <div className="w-8 h-8 rounded-full bg-gray-600/50"></div>
                <div className="h-6 w-3/4 rounded bg-gray-600/50"></div>
            </div>
            <div className="space-y-3 mt-4">
                {Array.from({ length: 5 }).map((_, i) => (
                    <div key={i} className="h-5 w-full rounded bg-gray-600/50"></div>
                ))}
            </div>
        </div>
    </div>
);

// ===== src/components/NewsListItemCompact.tsx =====

"use client";

import Image from "next/image";
import { IPost } from "@/models/Post";
import { formatDistanceToNow } from "date-fns";
import { Calendar, User } from "lucide-react";
import StyledLink from "./StyledLink";
import { useTranslation } from "@/hooks/useTranslation";

interface NewsListItemCompactProps {
  post: IPost;
}

const categoryColors: Record<string, string> = {
  prediction: "border-blue-500/50 text-blue-300",
  reviews: "border-indigo-500/50 text-indigo-300",
  highlights: "border-amber-500/50 text-amber-300",
  news: "border-gray-500/50 text-gray-400",
};

export function NewsListItemCompactSkeleton() {
  return (
    <div className="bg-brand-secondary rounded-lg p-4 flex flex-col sm:flex-row gap-4 md:gap-6 animate-pulse">
      <div className="w-full sm:w-40 md:w-48 flex-shrink-0">
        <div className="w-full aspect-video bg-gray-700 rounded-md"></div>
      </div>
      <div className="flex-1 flex flex-col space-y-3">
        <div className="h-4 w-1/4 bg-gray-600 rounded"></div>
        <div className="h-5 w-full bg-gray-600 rounded"></div>
        <div className="h-5 w-4/5 bg-gray-600 rounded"></div>
        <div className="flex-grow"></div> {}
        <div className="h-3 w-1/2 bg-gray-700 rounded mt-2"></div>
      </div>
    </div>
  );
}

export default function NewsListItemCompact({
  post,
}: NewsListItemCompactProps) {
  const { t } = useTranslation();
  if (!post) return null;

  const postUrl = `/news/${post.slug}`;

  const placeholderImage = "/images/placeholder-logo.svg";

  return (
    <StyledLink
      href={postUrl}
      className="block group bg-brand-secondary rounded-lg transition-shadow duration-300 hover:shadow-xl hover:shadow-brand-purple/20"
    >
      <div className="flex flex-col sm:flex-row items-center gap-4 md:gap-6 p-4">
        {}
        <div className="w-full sm:w-40 md:w-48 flex-shrink-0">
          <div className="relative w-full aspect-video overflow-hidden rounded-md">
            <Image
              src={post.featuredImage || placeholderImage}
              alt={post.title}
              layout="fill"
              objectFit="cover"
              className="transition-transform duration-300 group-hover:scale-105"
            />
          </div>
        </div>

        {}
        <div className="flex-1 flex flex-col self-stretch min-w-0">
          <div className="flex items-center gap-2 mb-2">
            <span
              className={`text-xs font-bold px-2 py-0.5 rounded-full border ${
                categoryColors[post.newsType] || categoryColors.news
              }`}
            >
              {t(post.newsType)}
            </span>
          </div>

          <h3 className="font-bold text-white leading-tight text-lg md:text-xl line-clamp-2 mb-2 group-hover:text-brand-purple transition-colors">
            {post.title}
          </h3>

          {}
          {post.metaDescription && (
            <p className="hidden md:block text-sm text-brand-light line-clamp-2 mb-3">
              {post.metaDescription}
            </p>
          )}

          {}
          <div className="flex-grow"></div>

          {}
          <div className="flex items-center gap-4 text-xs text-brand-muted mt-2">
            <div className="flex items-center gap-1.5" title="Author">
              <User size={12} />
              <span>{post.author}</span>
            </div>
            <div className="flex items-center gap-1.5" title="Publish Date">
              <Calendar size={12} />
              <time dateTime={new Date(post.createdAt).toISOString()}>
                {formatDistanceToNow(new Date(post.createdAt), {
                  addSuffix: true,
                })}
              </time>
            </div>
          </div>
        </div>
      </div>
    </StyledLink>
  );
}

// ===== src/components/NewsSection.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { IPost } from "@/models/Post";
import StyledLink from "./StyledLink";
import { ArrowRight, Newspaper, Info } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";
import SidebarNewsItemWithImage, {
  SidebarNewsItemWithImageSkeleton,
} from "./SidebarNewsItemWithImage";

const fetchNews = async (
  limit: number = 5,
  locale: string
): Promise<IPost[]> => {

  const { data } = await axios.get(
    `/api/posts?status=published&limit=${limit}&language=${locale}`
  );
  return data;
};

export default function NewsSection() {
  const { t, locale } = useTranslation();

  const {
    data: news,
    isLoading,
    isError,
  } = useQuery<IPost[]>({

    queryKey: ["newsArticlesSidebarWidget", locale],
    queryFn: () => fetchNews(5, locale!),
    staleTime: 1000 * 60 * 10,
    enabled: !!locale,
  });

  return (
    <section className="bg-brand-secondary rounded-lg shadow-lg">
      <div className="flex justify-between items-center p-4 border-b border-gray-700/50">
        <h3 className="text-xl font-bold text-white flex items-center gap-2">
          <Newspaper size={20} className="text-brand-purple" />
          {t("latest_news")}
        </h3>
        <StyledLink
          href="/news"
          className="flex items-center gap-1 text-xs font-semibold text-text-muted transition-colors hover:text-white"
        >
          {t("see_all")}
          <ArrowRight size={14} />
        </StyledLink>
      </div>

      <div className="p-2 space-y-1">
        {isLoading ? (
          <>
            <SidebarNewsItemWithImageSkeleton />
            <SidebarNewsItemWithImageSkeleton />
            <SidebarNewsItemWithImageSkeleton />
            <SidebarNewsItemWithImageSkeleton />
            <SidebarNewsItemWithImageSkeleton />
          </>
        ) : isError ? (
          <div className="rounded-lg p-6 text-center text-red-400">
            <p>{t("error_loading_news")}</p>
          </div>
        ) : news && news.length > 0 ? (
          news.map((post) => (
            <SidebarNewsItemWithImage key={post._id as string} post={post} />
          ))
        ) : (
          <div className="rounded-lg p-6 text-center text-text-muted">
            <Info size={28} className="mx-auto mb-2" />
            <p className="text-sm">{t("no_news_yet")}</p>
          </div>
        )}
      </div>
    </section>
  );
}

// ===== src/components/NewsSidebar.tsx =====

"use client";

import React from "react";
import RecentNewsWidget from "./RecentNewsWidget";
import CasinoPartnerWidget from "./CasinoPartnerWidget";
import AdSlotWidget from "./AdSlotWidget";

export default function NewsSidebar({
  children,
}: {
  children?: React.ReactNode;
}) {

  return (
    <aside className="space-y-8 lg:sticky lg:top-8">
      {}
      {children}

      <AdSlotWidget location="news_sidebar" />
      <RecentNewsWidget />
      {}
      {}
      <AdSlotWidget location="news_sidebar_bottom" />
    </aside>
  );
}

// ===== src/components/NotificationDropdown.tsx =====

"use client";

import NotificationList from "./NotificationList";
import Link from "next/link";
import { ArrowRight } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface NotificationDropdownProps {
  onClose: () => void;
}

export default function NotificationDropdown({
  onClose,
}: NotificationDropdownProps) {
  const { t } = useTranslation();

  return (
    <div
      className="fixed top-28 left-1/2 -translate-x-1/2 w-[90vw] max-w-sm
                 md:absolute md:top-full md:left-auto md:right-0 md:translate-x-0 md:w-96
                 bg-brand-secondary rounded-xl shadow-2xl border border-gray-700/50 z-[100] animate-fade-in"
      onClick={(e) => e.stopPropagation()}
    >
      <div className="p-4 border-b border-gray-700/50">
        <h3 className="font-bold text-lg text-white">{t("notifications")}</h3>{" "}
        {}
      </div>
      <div className="max-h-[60vh] overflow-y-auto custom-scrollbar">
        <NotificationList onItemClick={onClose} />
      </div>
      <div className="p-2 border-t border-gray-700/50 text-center">
        <Link
          href="/football/news"
          onClick={onClose}
          className="text-sm font-semibold text-brand-purple hover:underline flex items-center justify-center gap-1"
        >
          {t("view_all_news")} <ArrowRight size={14} />{" "}
          {}
        </Link>
      </div>
    </div>
  );
}

// ===== src/components/NotificationItem.tsx =====

"use client";

import { IPost } from "@/models/Post";
import Link from "next/link";
import Image from "next/image";
import { formatDistanceToNow } from "date-fns";
import { proxyImageUrl } from "@/lib/image-proxy";

interface NotificationItemProps {
  post: IPost;
  onItemClick?: () => void;
}

export default function NotificationItem({
  post,
  onItemClick,
}: NotificationItemProps) {

  const postUrl = `/${post.language}/news/${post.slug}`;

  const placeholderImage = "/images/placeholder-logo.svg";

  return (
    <Link
      href={postUrl}
      onClick={onItemClick}
      className="flex items-start gap-3 p-2 rounded-lg hover:bg-brand-purple/20 transition-colors"
    >
      <div className="flex-shrink-0 w-10 h-10 relative">
        <Image
          src={proxyImageUrl(post.featuredImage || placeholderImage)}
          alt={post.title}
          layout="fill"
          objectFit="cover"
          className="rounded-md"
        />
      </div>
      <div className="flex-1 min-w-0">
        <p className="text-sm font-semibold text-white line-clamp-2">
          {post.title}
        </p>
        <p className="text-xs text-brand-muted mt-0.5">
          {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}
        </p>
      </div>
    </Link>
  );
}

// ===== src/components/NotificationList.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { IPost } from "@/models/Post";
import NotificationItem from "./NotificationItem";
import { BellOff } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

const Skeleton = () => (
  <div className="flex items-start gap-4 p-3 animate-pulse">
    <div className="w-12 h-12 bg-gray-700 rounded-md"></div>
    <div className="flex-1 space-y-2">
      <div className="h-4 w-full bg-gray-700 rounded"></div>
      <div className="h-3 w-1/3 bg-gray-600 rounded"></div>
    </div>
  </div>
);

interface NotificationListProps {
  onItemClick?: () => void;
}

const fetchLatestPosts = async (): Promise<IPost[]> => {
  const { data } = await axios.get("/api/posts?status=published&limit=5");
  return data;
};

export default function NotificationList({
  onItemClick,
}: NotificationListProps) {
  const { t } = useTranslation();

  const {
    data: posts,
    isLoading,
    isError,
  } = useQuery<IPost[]>({
    queryKey: ["latestPostsForNotifications"],
    queryFn: fetchLatestPosts,
    staleTime: 1000 * 60 * 5,
  });

  if (isLoading) {
    return (
      <div className="space-y-1">
        {Array.from({ length: 5 }).map((_, i) => (
          <Skeleton key={i} />
        ))}
      </div>
    );
  }

  if (isError || !posts || posts.length === 0) {
    return (
      <div className="text-center py-10 text-brand-muted">
        <BellOff size={32} className="mx-auto mb-3" />
        <p className="text-sm">{t("no_new_notifications")}</p>{" "}
        {}
      </div>
    );
  }

  return (
    <div className="space-y-1">
      {posts.map((post) => (
        <NotificationItem
          key={post._id as string}
          post={post}
          onItemClick={onItemClick}
        />
      ))}
    </div>
  );
}

// ===== src/components/OddsDisplay.tsx =====

"use client";

import { useQuery } from '@tanstack/react-query';
import axios from 'axios';

type Odds = { home: string; draw: string; away: string; } | undefined | null;

const fetchOdds = async (fixtureId: number): Promise<Odds> => {
    try {
        const { data } = await axios.get(`/api/odds?fixture=${fixtureId}`);
        return data;
    } catch (error) {

        return null;
    }
};

const OddBox = ({ label, value }: { label: string, value: string }) => (
    <div className="flex-1 flex items-center justify-between p-2 rounded-md" style={{ backgroundColor: 'var(--color-primary)' }}>
        <span className="font-bold text-sm text-text-muted">{label}</span>
        <span className="font-bold text-sm text-brand-highlight">{value}</span>
    </div>
);

export default function OddsDisplay({ fixtureId, initialOdds }: { fixtureId: number, initialOdds?: Odds }) {
    const { data: odds, isLoading, isError } = useQuery({
        queryKey: ['odds', fixtureId],
        queryFn: () => fetchOdds(fixtureId),

        enabled: !initialOdds,

        initialData: initialOdds,
        staleTime: 1000 * 60 * 5,
        refetchOnWindowFocus: false,
    });

    const displayData = initialOdds || odds;

    if (isLoading && !initialOdds) {
        return <div className="text-xs text-center text-text-muted p-2 animate-pulse">Loading Odds...</div>;
    }

    if (isError || !displayData) {
        return <div className="text-xs text-center text-text-muted p-2">Odds not available.</div>;
    }

    return (
        <div className="flex items-center justify-center gap-2">
            <OddBox label="1" value={displayData.home} />
            <OddBox label="X" value={displayData.draw} />
            <OddBox label="2" value={displayData.away} />
        </div>
    );
}

// ===== src/components/Pagination.tsx =====

"use client";

import { ChevronLeft, ChevronRight } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
}

export default function Pagination({
  currentPage,
  totalPages,
  onPageChange,
}: PaginationProps) {
  const { t } = useTranslation();

  if (totalPages <= 1) {
    return null;
  }

  const handlePrevious = () => {
    if (currentPage > 1) {
      onPageChange(currentPage - 1);
    }
  };

  const handleNext = () => {
    if (currentPage < totalPages) {
      onPageChange(currentPage + 1);
    }
  };

  return (
    <div className="flex items-center justify-center gap-4 mt-8">
      <button
        onClick={handlePrevious}
        disabled={currentPage === 1}
        className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-brand-secondary rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50 transition-colors"
        aria-label={t("previous_page")}
      >
        <ChevronLeft size={16} />
        <span>{t("previous")}</span>
      </button>

      <span className="text-sm font-semibold text-brand-muted">
        {t("page_of", { currentPage, totalPages })}
      </span>

      <button
        onClick={handleNext}
        disabled={currentPage === totalPages}
        className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-brand-secondary rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50 transition-colors"
        aria-label={t("next_page")}
      >
        <span>{t("next")}</span>
        <ChevronRight size={16} />
      </button>
    </div>
  );
}

// ===== src/components/PopularTeamsList.tsx =====

"use client";

import { useState, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Link from "@/components/StyledLink";
import { usePathname } from "next/navigation";
import Image from "next/image";
import slugify from "slugify";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";
import { proxyImageUrl } from "@/lib/image-proxy";

interface TeamData {
  team: { id: number; name: string; logo: string };
  venue: any;
}

const generateTeamSlug = (name: string, id: number) => {
  const slug = slugify(name, { lower: true, strict: true });
  return `/football/team/${slug}-${id}`;
};

const fetchPopularTeams = async (): Promise<TeamData[]> => {
  const POPULAR_LEAGUE_ID = 39;
  const season = new Date().getFullYear();
  const { data } = await axios.get(
    `/api/teams?league=${POPULAR_LEAGUE_ID}&season=${season}`
  );
  return data;
};

const TeamItemSkeleton = () => (
  <div className="flex items-center p-2.5 rounded-lg animate-pulse">
    <div className="flex items-center gap-3 w-full">
      <div className="h-6 w-6 rounded-full bg-gray-600/50"></div>
      <div className="h-4 w-4/5 rounded bg-gray-600/50"></div>
    </div>
  </div>
);

export default function PopularTeamsList() {
  const pathname = usePathname();
  const [currentPage, setCurrentPage] = useState(1);
  const ITEMS_PER_PAGE = 6;
  const { t } = useTranslation();

  const {
    data: allTeams,
    isLoading,
    isError,
  } = useQuery<TeamData[]>({
    queryKey: ["popularTeams"],
    queryFn: fetchPopularTeams,
    staleTime: 1000 * 60 * 60 * 24,
    refetchOnWindowFocus: false,
  });

  const totalPages = allTeams ? Math.ceil(allTeams.length / ITEMS_PER_PAGE) : 0;

  const paginatedTeams = useMemo(() => {
    if (!allTeams) return [];
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    return allTeams.slice(startIndex, endIndex);
  }, [allTeams, currentPage]);

  if (isLoading) {
    return (
      <div className="space-y-1">
        {Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
          <TeamItemSkeleton key={i} />
        ))}
      </div>
    );
  }

  if (isError || !paginatedTeams || paginatedTeams.length === 0) {
    return (
      <p className="text-brand-muted text-xs p-2.5">
        {t("error_loading_teams")}
      </p>
    );
  }

  return (
    <div>
      <ul className="space-y-1">
        {paginatedTeams.map(({ team }) => {
          const href = generateTeamSlug(team.name, team.id);
          const isActive = pathname.startsWith(href);
          return (
            <li key={team.id}>
              <Link
                href={href}
                className={`w-full flex items-center p-2.5 rounded-lg transition-all duration-200 ${
                  isActive
                    ? "bg-brand-purple shadow-md text-white"
                    : "hover:bg-gray-700/50 text-brand-light"
                }`}
              >
                <div className="flex items-center gap-3 overflow-hidden">
                  <Image
                    src={proxyImageUrl(team.logo)}
                    alt={`${team.name} logo`}
                    width={24}
                    height={24}
                    className="flex-shrink-0"
                  />
                  <span
                    className={`font-bold text-sm truncate ${
                      isActive ? "text-white" : "text-brand-light"
                    }`}
                  >
                    {team.name}
                  </span>
                </div>
              </Link>
            </li>
          );
        })}
      </ul>

      {totalPages > 1 && (
        <div className="flex items-center justify-between mt-4 px-2">
          <button
            onClick={() => setCurrentPage((p) => p - 1)}
            disabled={currentPage === 1}
            className="p-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50"
            aria-label={t("previous_page")}
          >
            <ChevronLeft size={18} />
          </button>
          <span className="text-xs font-semibold text-brand-muted">
            {t("page_of", { currentPage, totalPages })}
          </span>
          <button
            onClick={() => setCurrentPage((p) => p + 1)}
            disabled={currentPage === totalPages}
            className="p-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50"
            aria-label={t("next_page")}
          >
            <ChevronRight size={18} />
          </button>
        </div>
      )}
    </div>
  );
}

// ===== src/components/PostCategories.tsx =====

"use client";

import React from "react";

export type NewsCategory =
  | "all"
  | "trending"
  | "football"
  | "basketball"
  | "tennis"
  | "general"
  | "prediction"
  | "match_reports";

interface PostCategoriesProps {
  activeCategory: NewsCategory;
  onCategoryChange: (category: NewsCategory) => void;
}

const categories: { value: NewsCategory; label: string }[] = [
  { value: "all", label: "All News" },
  { value: "trending", label: "Trending News" },
  { value: "prediction", label: "Prediction" },
  { value: "match_reports", label: "Match Reports" },
];

const PostCategories: React.FC<PostCategoriesProps> = ({
  activeCategory,
  onCategoryChange,
}) => {

  const effectiveActiveCategory =
    activeCategory === "trending" ? "all" : activeCategory;

  const handleClick = (category: NewsCategory) => {
    onCategoryChange(category);
  };

  return (
    <div className="flex flex-wrap gap-3 mb-8">
      {categories.map((category) => {

        const isActive =
          (category.value === "trending" && activeCategory === "trending") ||
          (category.value !== "trending" &&
            effectiveActiveCategory === category.value);

        return (
          <button
            key={category.value}
            onClick={() => handleClick(category.value)}
            className={`
              px-4 py-2 rounded-full font-semibold text-sm transition-all duration-200 ease-in-out
              ${
                isActive
                  ? "bg-brand-purple text-white border border-brand-purple"
                  : "bg-transparent text-white border border-white hover:bg-white/10"
              }
            `}
          >
            {category.label}
          </button>
        );
      })}
    </div>
  );
};

export default PostCategories;

// ===== src/components/PredictionDisplay.tsx =====

"use client";

import { useQuery } from '@tanstack/react-query';
import axios from 'axios';
import Image from 'next/image';

interface PredictionData {
    teams: {
        home: { id: number; name: string; logo: string; };
        away: { id: number; name: string; logo: string; };
    };
    percent: { home: number; draw: number; away: number };
}

const fetchPrediction = async (fixtureId: number): Promise<PredictionData> => {
    const { data } = await axios.get(`/api/predictions?fixture=${fixtureId}`);
    return data;
};

const PredictionSkeleton = () => (
    <div className="pt-4 mt-4 border-t border-gray-700/50 animate-pulse">
        <div className="h-4 w-1/2 mx-auto rounded bg-gray-600/50 mb-4"></div>
        <div className="flex justify-between items-center">
            <div className="flex flex-col items-center gap-2 w-1/4">
                <div className="w-8 h-8 rounded-full bg-gray-600/50"></div>
                <div className="h-5 w-10 rounded bg-gray-600/50"></div>
            </div>
            <div className="h-5 w-10 rounded bg-gray-600/50"></div>
            <div className="flex flex-col items-center gap-2 w-1/4">
                <div className="w-8 h-8 rounded-full bg-gray-600/50"></div>
                <div className="h-5 w-10 rounded bg-gray-600/50"></div>
            </div>
        </div>
        <div className="h-2 w-full rounded-full bg-gray-600/50 mt-3"></div>
    </div>
);

export default function PredictionDisplay({ fixtureId }: { fixtureId: number }) {
    const { data, isLoading, error } = useQuery({
        queryKey: ['prediction', fixtureId],
        queryFn: () => fetchPrediction(fixtureId),
        staleTime: 1000 * 60 * 60,
        retry: 1,
    });

    if (isLoading) return <PredictionSkeleton />;
    if (error || !data) return null;

    const { teams, percent } = data;
    const { home, draw, away } = percent;

    return (
        <div className="pt-4 mt-4 border-t border-gray-700/50 space-y-3">
            <h4 className="text-sm font-semibold text-center text-brand-muted tracking-wider">PREDICTION</h4>
            <div className="flex justify-between items-center text-white">
                <div className="flex flex-col items-center gap-2 w-1/4">
                    {}
                    <Image src={teams.home.logo} alt={teams.home.name} width={32} height={32} className="object-contain"/>
                    <span className="font-bold text-lg">{home}%</span>
                </div>
                <div className="flex flex-col items-center gap-2 opacity-80">
                    <span className="text-xs text-brand-muted">DRAW</span>
                    <span className="font-bold text-lg">{draw}%</span>
                </div>
                <div className="flex flex-col items-center gap-2 w-1/4">
                    {}
                    <Image src={teams.away.logo} alt={teams.away.name} width={32} height={32} className="object-contain"/>
                    <span className="font-bold text-lg">{away}%</span>
                </div>
            </div>
            <div className="flex w-full h-2 rounded-full overflow-hidden bg-gray-800">
                <div className="bg-[#6D28D9] transition-all duration-500" style={{ width: `${home}%` }}></div>
                <div className="bg-gray-500 transition-all duration-500" style={{ width: `${draw}%` }}></div>
                <div className="bg-blue-600 transition-all duration-500" style={{ width: `${away}%` }}></div>
            </div>
        </div>
    );
}

// ===== src/components/ProgressBar.tsx =====

"use client";

import { useEffect } from 'react';
import { usePathname, useSearchParams } from 'next/navigation';
import NProgress from 'nprogress';

export default function ProgressBar() {
  const pathname = usePathname();
  const searchParams = useSearchParams();

  useEffect(() => {

    NProgress.configure({ showSpinner: false });

    NProgress.done();

    return () => {
      NProgress.remove();
    };
  }, [pathname, searchParams]);

  return null;
}

// ===== src/components/RecentNewsWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { IPost } from "@/models/Post";
import SidebarNewsItem, { SidebarNewsItemSkeleton } from "./SidebarNewsItem";
import { ArrowRight, Newspaper, Info } from "lucide-react";
import Link from "next/link";
import { useTranslation } from "@/hooks/useTranslation";

const fetchRecentNews = async (
  limit: number = 4,
  locale: string
): Promise<IPost[]> => {

  const { data } = await axios.get(
    `/api/posts?status=published&limit=${limit}&language=${locale}`
  );
  return data;
};

interface RecentNewsWidgetProps {
  limit?: number;
}

export default function RecentNewsWidget({ limit = 4 }: RecentNewsWidgetProps) {
  const { t, locale } = useTranslation();

  const {
    data: recentPosts,
    isLoading,
    isError,
  } = useQuery<IPost[]>({

    queryKey: ["recentNewsWidget", limit, locale],
    queryFn: () => fetchRecentNews(limit, locale!),
    staleTime: 1000 * 60 * 5,
    enabled: !!locale,
  });

  return (
    <section className="bg-brand-secondary rounded-lg shadow-lg">
      <div className="flex justify-between items-center p-4 border-b border-gray-700/50">
        <h2 className="text-xl font-bold text-white flex items-center gap-2">
          <Newspaper size={20} className="text-[var(--brand-accent)]" />
          {t("latest_news")}
        </h2>
        <Link
          href="/news"
          className="text-xs font-semibold text-text-muted hover:text-white flex items-center gap-1"
        >
          {t("see_all")} <ArrowRight size={14} />
        </Link>
      </div>

      <div className="p-2 space-y-1">
        {isLoading ? (
          <>
            <SidebarNewsItemSkeleton />
            <SidebarNewsItemSkeleton />
            <SidebarNewsItemSkeleton />
            <SidebarNewsItemSkeleton />
          </>
        ) : isError ? (
          <div className="text-center py-6 text-red-400">
            <p>{t("error_loading_news")}</p>
          </div>
        ) : recentPosts && recentPosts.length > 0 ? (
          recentPosts.map((post) => (
            <SidebarNewsItem key={post._id as string} post={post} />
          ))
        ) : (
          <div className="text-center py-6 text-brand-muted">
            <Info size={28} className="mx-auto mb-2" />
            <p className="text-sm">{t("no_news_yet")}</p>
          </div>
        )}
      </div>
    </section>
  );
}

// ===== src/components/Sidebar.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import Link from "@/components/StyledLink";
import { usePathname } from "next/navigation";
import { useLeagueContext } from "@/context/LeagueContext";
import { League } from "@/types/api-football";
import { useTranslation } from "@/hooks/useTranslation";
import PopularTeamsList from "./PopularTeamsList";
import AdSlotWidget from "./AdSlotWidget";
import CasinoPartnerWidget from "./CasinoPartnerWidget";
import { proxyImageUrl } from "@/lib/image-proxy";

const fetchLeagues = async (
  countryName: string | null,
  locale: string
): Promise<League[]> => {

  const endpoint = countryName
    ? `/api/leagues?type=league&country=${encodeURIComponent(
        countryName
      )}&locale=${locale}`
    : `/api/leagues?type=league&locale=${locale}`;

  const { data } = await axios.get(endpoint);
  return data;
};

const LeagueList = ({ leagues }: { leagues: League[] }) => {
  const pathname = usePathname();
  const { t } = useTranslation();

  if (!leagues || leagues.length === 0) {
    return (
      <p className="text-text-muted text-xs p-2.5">
        {t("no_competitions_found")}
      </p>
    );
  }
  return (
    <ul className="space-y-1">
      {leagues.map((league) => {
        const isActive = pathname === league.href;
        return (
          <li key={league.id}>
            <Link
              href={league.href}
              className={`w-full flex items-center justify-between p-2.5 rounded-lg transition-all duration-200 ${
                isActive
                  ? "bg-brand-purple shadow-md text-white"
                  : "hover:bg-gray-700/50 text-text-primary"
              }`}
            >
              <div className="flex items-center gap-3 overflow-hidden">
                <Image
                  src={proxyImageUrl(league.logoUrl)}
                  alt={`${league.name} logo`}
                  width={24}
                  height={24}
                  className="flex-shrink-0"
                  unoptimized={true}
                />
                <span
                  className={`font-bold text-sm truncate ${
                    isActive ? "text-white" : "text-text-primary"
                  }`}
                >
                  {league.name}
                </span>
              </div>
            </Link>
          </li>
        );
      })}
    </ul>
  );
};

const LeagueItemSkeleton = () => (
  <div className="flex items-center justify-between p-2.5 rounded-lg animate-pulse">
    <div className="flex items-center gap-3 w-3/4">
      <div className="h-6 w-6 rounded-full bg-gray-600/50"></div>
      <div className="h-4 w-full rounded bg-gray-600/50"></div>
    </div>
  </div>
);

export default function Sidebar() {
  const { t, locale } = useTranslation();
  const { selectedCountry } = useLeagueContext();

  const {
    data: leagues,
    isLoading: isLoadingLeagues,
    isError,
  } = useQuery<League[]>({

    queryKey: ["leagues", selectedCountry?.name || "global", locale],

    queryFn: () => fetchLeagues(selectedCountry?.name || null, locale),
  });

  const getSidebarTitle = () => {
    if (selectedCountry) {
      return t("leagues_in_country", { country: selectedCountry.name });
    }
    return t("popular_leagues");
  };

  return (
    <aside className="hidden lg:block">
      <div className="flex flex-col gap-4 h-auto">
        {}
          <AdSlotWidget location="homepage_left_sidebar" />
        <section
          className="flex flex-col gap-2 p-3 rounded-xl"
          style={{ backgroundColor: "var(--color-primary)" }}
        >
          <p className="text-sm font-bold uppercase tracking-wider text-text-muted px-2">
            {getSidebarTitle()}
          </p>
          {isLoadingLeagues ? (
            <div className="space-y-1">
              {Array.from({ length: 5 }).map((_, i) => (
                <LeagueItemSkeleton key={i} />
              ))}
            </div>
          ) : isError ? (
            <p className="text-red-400 text-xs p-2.5">
              {t("error_loading_leagues")}
            </p>
          ) : (
            <LeagueList leagues={leagues!} />
          )}
        </section>

        <section
          className="flex flex-col gap-2 p-3 rounded-xl sticky top-8"
          style={{ backgroundColor: "var(--color-primary)" }}
        >
          <p className="text-sm font-bold uppercase tracking-wider text-text-muted px-2">
            {t("popular_teams")}
          </p>
          <PopularTeamsList />
        </section>
      </div>
    </aside>
  );
}

// ===== src/components/SidebarMatchItem.tsx =====

"use client";

import Image from 'next/image';
import Link from '@/components/StyledLink';

interface SidebarMatchItemProps {
  match: {
    fixture: {
      id: number;
      status: {
        elapsed: number;
      };
    };
    teams: {
      home: { name: string; logo: string; };
      away: { name: string; logo: string; };
    };
    goals: {
      home: number;
      away: number;
    };
  };
}

export default function SidebarMatchItem({ match }: SidebarMatchItemProps) {
  const { fixture, teams, goals } = match;

  return (
    <Link
      href={`/football/match/${fixture.id}`}
      className="block p-2.5 rounded-lg transition-colors duration-200 hover:bg-gray-700/50"
    >
      <div className="flex items-center gap-3 w-full">
        {}
        <div className="flex flex-col items-center w-10 text-center text-brand-live font-semibold text-sm">
          <span>{fixture.status.elapsed}'</span>
          <div className="relative flex h-2 w-2 mt-1">
            <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span>
            <span className="relative inline-flex rounded-full h-2 w-2 bg-brand-live"></span>
          </div>
        </div>

        {}
        <div className="flex-1 space-y-1.5 text-sm">
          {}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2 truncate">
              <Image src={teams.home.logo} alt={teams.home.name} width={18} height={18} />
              <span className="font-medium truncate">{teams.home.name}</span>
            </div>
            <span className="font-bold">{goals.home}</span>
          </div>
          {}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2 truncate">
              <Image src={teams.away.logo} alt={teams.away.name} width={18} height={18} />
              <span className="font-medium truncate">{teams.away.name}</span>
            </div>
            <span className="font-bold">{goals.away}</span>
          </div>
        </div>
      </div>
    </Link>
  );
}

export const SidebarMatchItemSkeleton = () => (
    <div className="flex items-center gap-3 w-full p-2.5 animate-pulse">
        <div className="flex flex-col items-center w-10">
            <div className="h-4 w-6 rounded bg-gray-600/50"></div>
            <div className="h-2 w-2 rounded-full bg-gray-600/50 mt-1.5"></div>
        </div>
        <div className="flex-1 space-y-2">
            <div className="flex items-center justify-between">
                <div className="h-4 w-3/5 rounded bg-gray-600/50"></div>
                <div className="h-4 w-4 rounded bg-gray-600/50"></div>
            </div>
            <div className="flex items-center justify-between">
                <div className="h-4 w-3/5 rounded bg-gray-600/50"></div>
                <div className="h-4 w-4 rounded bg-gray-600/50"></div>
            </div>
        </div>
    </div>
);

// ===== src/components/SidebarNewsItem.tsx =====

"use client";

import Link from "next/link";
import { format, formatDistanceToNow } from "date-fns";
import { IPost } from "@/models/Post";
import { ChevronRight } from "lucide-react";

interface SidebarNewsItemProps {
  post: IPost;
}

export const SidebarNewsItemSkeleton = () => (
  <div className="flex flex-col gap-1.5 p-2 animate-pulse">
    <div className="h-4 w-full rounded bg-gray-700"></div>
    <div className="h-3 w-1/3 rounded bg-gray-700"></div>
  </div>
);

export default function SidebarNewsItem({ post }: SidebarNewsItemProps) {

  const postUrl = `/news/${post.slug}`;

  return (
    <Link
      href={postUrl}
      className="block p-3 rounded-lg group hover:bg-[var(--color-primary)] transition-colors"
    >
      <div className="flex items-start justify-between gap-3">
        <div className="flex-1">
          <h4 className="font-semibold text-sm text-text-primary leading-snug group-hover:text-[var(--brand-accent)] transition-colors line-clamp-2">
            {post.title}
          </h4>
          <p className="text-xs text-text-muted mt-1.5">
            {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}
          </p>
        </div>
        <ChevronRight className="w-5 h-5 text-text-muted flex-shrink-0 mt-0.5 group-hover:text-[var(--brand-accent)] transition-colors" />
      </div>
    </Link>
  );
}

// ===== src/components/SidebarNewsItemWithImage.tsx =====

"use client";

import Link from "next/link";
import Image from "next/image";
import { formatDistanceToNow } from "date-fns";
import { IPost } from "@/models/Post";
import { proxyImageUrl } from "@/lib/image-proxy";

interface SidebarNewsItemWithImageProps {
  post: IPost;
}

export const SidebarNewsItemWithImageSkeleton = () => (
  <div className="flex items-center gap-3 p-2 animate-pulse">
    <div className="w-16 h-12 bg-gray-700 rounded-md flex-shrink-0"></div>
    <div className="flex-1 space-y-2">
      <div className="h-4 w-full bg-gray-700 rounded"></div>
      <div className="h-4 w-2/3 bg-gray-700 rounded"></div>
      <div className="h-3 w-1/3 bg-gray-600 rounded"></div>
    </div>
  </div>
);

export default function SidebarNewsItemWithImage({
  post,
}: SidebarNewsItemWithImageProps) {

  const postUrl = `/${post.language}/news/${post.slug}`;

  const placeholderImage = "/images/placeholder-logo.svg";

  return (
    <Link
      href={postUrl}
      className="block p-2 rounded-lg group hover:bg-brand-dark transition-colors"
    >
      <div className="flex items-center gap-3">
        <div className="flex-shrink-0 w-16 h-12 relative">
          <Image
            src={proxyImageUrl(post.featuredImage || placeholderImage)}
            alt={post.title}
            layout="fill"
            objectFit="cover"
            className="rounded-md"
          />
        </div>
        <div className="flex-1 min-w-0">
          <h4 className="font-semibold text-sm text-white leading-snug group-hover:text-brand-purple transition-colors line-clamp-2">
            {post.title}
          </h4>
          <p className="text-xs text-brand-muted mt-1">
            {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}
          </p>
        </div>
      </div>
    </Link>
  );
}

// ===== src/components/SocialShareButtons.tsx =====

"use client";

import {
  FacebookShareButton,
  FacebookIcon,
  TwitterShareButton,
  XIcon,
  WhatsappShareButton,
  WhatsappIcon,
  LinkedinShareButton,
  LinkedinIcon,
  TelegramShareButton,
  TelegramIcon,
  RedditShareButton,
  RedditIcon,
} from 'react-share';

interface SocialShareButtonsProps {
  url: string;
  title: string;
}

export default function SocialShareButtons({ url, title }: SocialShareButtonsProps) {
  const iconSize = 48;
  const iconBgStyle = { background: 'none' };
  const iconClassName = "rounded-full transition-transform duration-200 hover:scale-110";

  return (
    <div className="flex items-center justify-center gap-4 flex-wrap">
      <FacebookShareButton url={url} quote={title} className={iconClassName}>
        <FacebookIcon size={iconSize} round bgStyle={iconBgStyle} />
      </FacebookShareButton>

      <TwitterShareButton url={url} title={title} className={iconClassName}>
        <XIcon size={iconSize} round bgStyle={iconBgStyle} />
      </TwitterShareButton>

      <WhatsappShareButton url={url} title={title} separator=":: " className={iconClassName}>
        <WhatsappIcon size={iconSize} round bgStyle={iconBgStyle} />
      </WhatsappShareButton>

      <LinkedinShareButton url={url} title={title} className={iconClassName}>
        <LinkedinIcon size={iconSize} round bgStyle={iconBgStyle} />
      </LinkedinShareButton>

      <TelegramShareButton url={url} title={title} className={iconClassName}>
        <TelegramIcon size={iconSize} round bgStyle={iconBgStyle} />
      </TelegramShareButton>

      <RedditShareButton url={url} title={title} className={iconClassName}>
        <RedditIcon size={iconSize} round bgStyle={iconBgStyle} />
      </RedditShareButton>
    </div>
  );
}

// ===== src/components/StandingsDisplay.tsx =====

"use client";

import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Slider from "react-slick";
import Image from "next/image";
import { ChevronRight, Info } from "lucide-react";

import { useLeagueContext } from "@/context/LeagueContext";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import StyledLink from "./StyledLink";
import { useTranslation } from "@/hooks/useTranslation";

interface Team {
  id: number;
  name: string;
  logo: string;
}
interface TeamStats {
  played: number;
  win: number;
  draw: number;
  lose: number;
}
interface TeamStanding {
  rank: number;
  team: Team;
  points: number;
  goalsDiff: number;
  group: string;
  description: string | null;
  all: TeamStats;
}
interface League {
  id: number;
  name: string;
  logo: string;
  href: string;
}
interface StandingsResponse {
  league: League | null;
  standings: TeamStanding[][];
}

const POPULAR_LEAGUES = [
  {
    id: 39,
    name: "Premier League",
    logo: "https://media.api-sports.io/football/leagues/39.png",
  },
  {
    id: 140,
    name: "La Liga",
    logo: "https://media.api-sports.io/football/leagues/140.png",
  },
  {
    id: 135,
    name: "Serie A",
    logo: "https://media.api-sports.io/football/leagues/135.png",
  },
  {
    id: 78,
    name: "Bundesliga",
    logo: "https://media.api-sports.io/football/leagues/78.png",
  },
  {
    id: 61,
    name: "Ligue 1",
    logo: "https://media.api-sports.io/football/leagues/61.png",
  },
];

const fetchStandings = async (
  leagueId: number,
  season: number
): Promise<StandingsResponse> => {
  const { data } = await axios.get(
    `/api/standings?league=${leagueId}&season=${season}`
  );
  return data;
};

const getRankIndicatorClass = (description: string | null): string => {
  if (!description) return "bg-gray-700 text-brand-light";
  const desc = description.toLowerCase();
  if (desc.includes("champions league") || desc.includes("promotion"))
    return "bg-green-500/20 text-green-400";
  if (desc.includes("europa league") || desc.includes("qualification"))
    return "bg-orange-500/20 text-orange-400";
  if (desc.includes("conference league") || desc.includes("play-off"))
    return "bg-sky-400/20 text-sky-300";
  if (desc.includes("relegation")) return "bg-red-600/20 text-red-500";
  return "bg-gray-700 text-brand-light";
};

const InternalStandingTable = ({
  group,
  league,
}: {
  group: TeamStanding[];
  league: League;
}) => {
  const { t } = useTranslation();
  const validGroup = group.filter((item) => item && item.team);
  if (validGroup.length === 0) return null;

  return (
    <div className="px-1 overflow-y-auto max-h-96 custom-scrollbar">
      <table className="w-full text-sm">
        <thead className="text-left text-brand-muted sticky top-0 bg-brand-secondary z-10">
          <tr className="text-xs">
            <th className="p-2 w-8 text-center">#</th>
            <th className="p-2">{t("table_header_team")}</th>
            <th className="p-2 text-center">P</th>
            <th className="p-2 text-center">GD</th>
            <th className="p-2 text-center font-bold">Pts</th>
          </tr>
        </thead>
        <tbody className="text-brand-light">
          {validGroup.map((item) => (
            <tr key={item.team.id} className="border-t border-gray-700/50">
              <td className="p-2 text-center">
                <span
                  className={`w-6 h-6 flex items-center justify-center text-xs font-bold rounded-md ${getRankIndicatorClass(
                    item.description
                  )}`}
                >
                  {item.rank}
                </span>
              </td>
              <td className="p-2">
                <StyledLink
                  href={generateTeamSlug(item.team.name, item.team.id)}
                  className="flex items-center gap-2 group"
                >
                  <Image
                    src={proxyImageUrl(item.team.logo)}
                    alt={item.team.name}
                    width={20}
                    height={20}
                  />
                  <span className="font-semibold group-hover:text-brand-purple transition-colors whitespace-nowrap">
                    {item.team.name}
                  </span>
                </StyledLink>
              </td>
              <td className="p-2 text-center">{item.all.played}</td>
              <td className="p-2 text-center">{item.goalsDiff}</td>
              <td className="p-2 text-center font-bold text-white">
                {item.points}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

const StandingsDisplaySkeleton = () => (
  <div className="bg-brand-secondary rounded-lg h-[480px] animate-pulse">
    <div className="p-2 border-b border-gray-700/50 flex space-x-1">
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
    </div>
    <div className="p-4">
      <div className="flex justify-between items-center mb-4">
        <div className="h-5 w-2/5 bg-gray-700 rounded"></div>
        <div className="h-4 w-1/4 bg-gray-700 rounded"></div>
      </div>
      <div className="space-y-2">
        {[...Array(8)].map((_, i) => (
          <div key={i} className="flex items-center gap-3 h-8">
            <div className="w-6 h-6 bg-gray-600 rounded"></div>
            <div className="w-5 h-5 bg-gray-600 rounded-full"></div>
            <div className="flex-1 h-4 bg-gray-600 rounded"></div>
            <div className="w-6 h-4 bg-gray-600 rounded"></div>
          </div>
        ))}
      </div>
    </div>
  </div>
);

export default function StandingsDisplay() {
  const { t } = useTranslation();
  const { selectedLeague } = useLeagueContext();
  const [activePopularLeagueId, setActivePopularLeagueId] = useState(
    POPULAR_LEAGUES[0].id
  );
  const season = new Date().getFullYear();
  const leagueIdToFetch = selectedLeague?.id || activePopularLeagueId;

  const { data, isLoading, isError } = useQuery<StandingsResponse>({
    queryKey: ["standings", leagueIdToFetch, season],
    queryFn: () => fetchStandings(leagueIdToFetch, season),
    staleTime: 1000 * 60 * 15,
  });

  const sliderSettings = {
    dots: true,
    infinite: false,
    speed: 500,
    slidesToShow: 1,
    slidesToScroll: 1,
    arrows: false,
    appendDots: (dots: any) => (
      <div>
        <ul className="m-0 pt-3"> {dots} </ul>
      </div>
    ),
  };

  const sanitizedStandingsGroups = data?.standings?.filter(
    (group) => group && group.length > 0
  );
  const hasStandings =
    sanitizedStandingsGroups && sanitizedStandingsGroups.length > 0;
  const showTabs = !selectedLeague || (selectedLeague && !hasStandings);

  if (isLoading) return <StandingsDisplaySkeleton />;

  return (
    <div className="bg-brand-secondary rounded-lg">
      {showTabs && (
        <div className="flex items-center p-2 space-x-1 border-b border-gray-700/50">
          {POPULAR_LEAGUES.map((popLeague) => (
            <button
              key={popLeague.id}
              onClick={() => setActivePopularLeagueId(popLeague.id)}
              className={`group flex-1 p-2 rounded-md transition-colors ${
                activePopularLeagueId === popLeague.id
                  ? "bg-brand-purple/20"
                  : "hover:bg-white/5"
              }`}
              title={popLeague.name}
            >
              <Image
                src={proxyImageUrl(popLeague.logo)}
                alt={popLeague.name}
                width={24}
                height={24}
                className="mx-auto transition-transform duration-300 ease-in-out group-hover:scale-110"
              />
            </button>
          ))}
        </div>
      )}

      <div className="p-4">
        {hasStandings && data?.league ? (
          <>
            <div className="flex justify-between items-center mb-3">
              <h3 className="text-white font-bold">{data.league.name}</h3>
              <StyledLink
                href={data.league.href}
                className="text-xs text-brand-muted hover:text-white flex items-center gap-1"
              >
                View Full Table <ChevronRight size={14} />
              </StyledLink>
            </div>
            {sanitizedStandingsGroups.length === 1 ? (
              <InternalStandingTable
                group={sanitizedStandingsGroups[0]}
                league={data.league}
              />
            ) : (
              <Slider {...sliderSettings}>
                {sanitizedStandingsGroups.map((group) => (
                  <div key={group[0].group}>
                    <h4 className="text-center text-brand-light font-bold text-sm mb-2">
                      {group[0].group}
                    </h4>
                    <InternalStandingTable
                      group={group}
                      league={data.league!}
                    />
                  </div>
                ))}
              </Slider>
            )}
          </>
        ) : (
          <div className="text-center py-6">
            <Info size={32} className="mx-auto text-brand-muted mb-3" />
            <h4 className="font-bold text-white mb-1">
              {data?.league?.name ||
                selectedLeague?.name ||
                t("no_standings_title")}
            </h4>
            <p className="text-sm text-brand-muted">
              {t("standings_not_available")}
              {showTabs && t("select_another_league_prompt")}
            </p>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/StickyFooterAd.tsx =====

"use client";

import { useState, useEffect, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { X } from "lucide-react";

interface IBanner {
  _id: string;
  title: string;
  imageUrl: string;
  linkUrl: string;
  isActive: boolean;
}

export default function StickyFooterAd() {
  const [isDismissed, setIsDismissed] = useState(true);
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (sessionStorage.getItem("footerAdDismissed") === "true") {
      setIsDismissed(true);
    } else {
      setIsDismissed(false);
    }
  }, []);

  const { data: banners, isLoading } = useQuery<IBanner[]>({

    queryKey: ["sticky_footer"],
    queryFn: () =>
      axios
        .get("/api/banners?active=true&location=sticky_footer")
        .then((res) => res.data),
    staleTime: 5 * 60 * 1000,
    refetchOnWindowFocus: false,
  });

  const randomAd = useMemo(() => {
    if (!banners || banners.length === 0) return null;
    const randomIndex = Math.floor(Math.random() * banners.length);
    return banners[randomIndex];
  }, [banners]);

  useEffect(() => {
    if (!isLoading && randomAd && !isDismissed) {
      const timer = setTimeout(() => setIsVisible(true), 100);
      return () => clearTimeout(timer);
    }
  }, [isLoading, randomAd, isDismissed]);

  const handleDismiss = () => {
    setIsVisible(false);
    setTimeout(() => {
      setIsDismissed(true);
      sessionStorage.setItem("footerAdDismissed", "true");
    }, 500);
  };

  if (!randomAd || isDismissed) {
    return null;
  }

  return (
    <div className="fixed inset-0 top-auto z-50 flex justify-center p-2 pointer-events-none">
      <div
        className={`
          pointer-events-auto flex items-center gap-4 w-full max-w-lg
          bg-brand-secondary/80 backdrop-blur-sm
          border border-gray-600/50 shadow-2xl shadow-black/50 rounded-lg
          transition-all duration-500 ease-in-out
          ${
            isVisible
              ? "translate-y-0 opacity-100"
              : "translate-y-full opacity-0"
          }
        `}
      >
        <a
          href={randomAd.linkUrl}
          target="_blank"
          rel="noopener sponsored"
          className="flex-grow flex items-center gap-4 p-3 group"
        >
          <div className="flex-shrink-0 w-20 h-16 relative">
            <Image
              src={randomAd.imageUrl}
              alt={randomAd.title}
              layout="fill"
              objectFit="cover"
              className="rounded-md"
              unoptimized={true}
            />
          </div>
          <div className="flex-grow min-w-0">
            <p className="text-xs text-brand-muted">Sponsored</p>
            <h4 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
              {randomAd.title}
            </h4>
          </div>
        </a>

        <button
          onClick={handleDismiss}
          className="flex-shrink-0 self-start p-2 text-brand-muted hover:text-white"
          aria-label="Close ad"
        >
          <X size={18} />
        </button>
      </div>
    </div>
  );
}

// ===== src/components/StyledLink.tsx =====

"use client";

import { default as NextLink, LinkProps } from "next/link";
import NProgress from "nprogress";
import React from "react";
import { sendGAEvent } from "@/lib/analytics";
import { useTranslation } from "@/hooks/useTranslation";
import { usePathname } from "next/navigation";

const DEFAULT_LOCALE = "tr";

export default function StyledLink({
  href,
  children,
  className,
  style,
  gaEventName,
  gaEventParams,
  ...props
}: LinkProps & {
  children: React.ReactNode;
  className?: string;
  style?: React.CSSProperties;
  gaEventName?: string;
  gaEventParams?: { [key: string]: any };
} & Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, "href">) {
  const currentPathname = usePathname();

  const isAdminRoute = currentPathname.startsWith("/admin");
  const i18n = !isAdminRoute ? useTranslation() : { locale: DEFAULT_LOCALE };
  const { locale } = i18n;

  const isExternal =
    typeof href === "string" &&
    (href.startsWith("http") || href.startsWith("mailto:"));
  const isAnchor = typeof href === "string" && href.startsWith("#");

  const isAdminLink = typeof href === "string" && href.startsWith("/admin");

  let localizedHref = href;

  if (!isExternal && !isAnchor && !isAdminLink) {
    if (locale === DEFAULT_LOCALE) {
      localizedHref = href;
    } else {
      localizedHref = `/${locale}${href}`;
    }
  }

  const handleLinkClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
    if (gaEventName) {
      sendGAEvent(gaEventName, gaEventParams || {});
    }

    if (localizedHref.toString() !== currentPathname) {
      NProgress.start();
    }

    if (props.onClick) {
      props.onClick(e);
    }
  };

  if (isExternal) {
    return (
      <a
        href={href as string}
        className={className}
        style={style}
        {...props}
        onClick={handleLinkClick}
        target="_blank"
        rel="noopener noreferrer"
      >
        {children}
      </a>
    );
  }

  return (
    <NextLink
      href={localizedHref}
      className={className}
      style={style}
      {...props}
      onClick={handleLinkClick}
    >
      {children}
    </NextLink>
  );
}

// ===== src/components/TableOfContents.tsx =====

"use client";

import { useState, useEffect, useRef } from "react";
import { TocEntry } from "@/lib/toc";
import { List } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface TableOfContentsProps {
  toc: TocEntry[];
}

export default function TableOfContents({ toc }: TableOfContentsProps) {
  const { t } = useTranslation();
  const [activeId, setActiveId] = useState<string | null>(null);
  const observer = useRef<IntersectionObserver | null>(null);

  useEffect(() => {
    if (observer.current) {
      observer.current.disconnect();
    }

    observer.current = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setActiveId(entry.target.id);
          }
        });
      },
      { rootMargin: "0% 0% -60% 0%", threshold: 1.0 }
    );

    const headings = document.querySelectorAll("h2[id], h3[id]");
    headings.forEach((heading) => {
      observer.current?.observe(heading);
    });

    return () => observer.current?.disconnect();
  }, [toc]);

  if (!toc || toc.length === 0) {
    return null;
  }

  const handleLinkClick = (
    e: React.MouseEvent<HTMLAnchorElement>,
    id: string
  ) => {
    e.preventDefault();
    const element = document.getElementById(id);
    if (element) {
      const topOffset =
        element.getBoundingClientRect().top + window.pageYOffset - 100;
      window.scrollTo({
        top: topOffset,
        behavior: "smooth",
      });
      setActiveId(id);
    }
  };

  return (

    <div className="bg-brand-secondary rounded-lg p-6 my-8 border border-gray-700/50">
      {}
      <h3 className="font-bold text-white text-lg mb-4 flex items-center gap-2">
        <List size={20} className="text-brand-purple" />
        {t("table_of_contents")}
      </h3>
      <ul className="space-y-2">
        {toc.map((item) => (
          <li key={item.id}>
            <a
              href={`#${item.id}`}
              onClick={(e) => handleLinkClick(e, item.id)}
              className={`block text-sm transition-colors duration-200 border-l-2
                ${item.level === "h3" ? "pl-6" : "pl-3"}
                ${
                  activeId === item.id
                    ? "border-brand-purple text-white font-semibold"
                    : "border-transparent text-brand-muted hover:text-white hover:border-gray-500"
                }
              `}
            >
              {item.text}
            </a>
          </li>
        ))}
      </ul>
    </div>
  );
}

// ===== src/components/TeamDetailView.tsx =====

import TeamHeader from "./team/TeamHeader";
import TeamSquadWidget from "./team/TeamSquadWidget";
import TeamFixturesWidget from "./team/TeamFixturesWidget";
import LeagueStandingsWidget from "@/components/league-detail-view/LeagueStandingsWidget";
import { generateLeagueSlug } from "@/lib/generate-league-slug";
import { getI18n } from "@/lib/i18n/server";

export default async function TeamDetailView({ teamData }: { teamData: any }) {
  const t = await getI18n();
  const { teamInfo, squad, fixtures, standings } = teamData;
  const { team } = teamInfo;

  const primaryLeague = standings?.[0]?.league;
  const leagueWithHref = primaryLeague
    ? {
        ...primaryLeague,
        href: generateLeagueSlug(primaryLeague.name, primaryLeague.id),
      }
    : null;

  return (
    <div className="space-y-8">
      {}
      <TeamHeader
        team={team}
        countryFlag={fixtures?.[0]?.league?.flag || ""}
        foundedText={t("founded_in", { year: team.founded })}
      />

      <TeamFixturesWidget fixtures={fixtures} />

      {primaryLeague && leagueWithHref && (
        <LeagueStandingsWidget
          standings={standings[0].league.standings}
          league={leagueWithHref}
        />
      )}

      <TeamSquadWidget squad={squad} />
    </div>
  );
}

// ===== src/components/TeamDirectoryCard.tsx =====

"use client";

import Image from "next/image";
import StyledLink from "./StyledLink";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import { proxyImageUrl } from "@/lib/image-proxy";
import { MapPin, Calendar } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface TeamDirectoryCardProps {
  team: {
    id: number;
    name: string;
    logo: string;
    country: string;
    founded?: number;
  };
  venue: { name: string; city: string };
}

export const TeamDirectoryCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg flex flex-col h-full animate-pulse">
    <div className="p-4 flex items-center gap-4">
      <div className="w-12 h-12 rounded-full bg-gray-700"></div>
      <div className="flex-1 space-y-2">
        <div className="h-5 w-full rounded bg-gray-700"></div>
        <div className="h-4 w-1/2 rounded bg-gray-700"></div>
      </div>
    </div>
    <div className="mt-auto border-t border-gray-700/50 p-4 space-y-3">
      <div className="h-3 w-3/4 rounded bg-gray-700"></div>
      <div className="h-3 w-2/3 rounded bg-gray-700"></div>
    </div>
  </div>
);

export default function TeamDirectoryCard({
  team,
  venue,
}: TeamDirectoryCardProps) {
  const { t } = useTranslation();

  const href = generateTeamSlug(team.name, team.id);

  return (
    <StyledLink href={href} className="block group h-full">
      <div className="bg-brand-secondary rounded-lg flex flex-col h-full transition-all duration-300 transform hover:-translate-y-1 hover:shadow-2xl hover:shadow-[var(--brand-accent)]/20">
        <div className="p-4 flex items-center gap-4">
          <Image
            src={proxyImageUrl(team.logo)}
            alt={`${team.name} logo`}
            width={48}
            height={48}
            className="flex-shrink-0"
          />
          <div className="min-w-0 flex-1">
            <h3 className="font-bold text-lg text-white truncate group-hover:text-[var(--brand-accent)] transition-colors">
              {team.name}
            </h3>
            <p className="text-sm text-text-muted">{team.country}</p>
          </div>
        </div>

        <div className="mt-auto border-t border-gray-700/50 p-4 space-y-2">
          {team.founded && (
            <div className="flex items-center gap-2.5 text-sm text-text-secondary">
              <Calendar size={14} className="text-text-muted flex-shrink-0" />
              <span className="font-semibold">
                {t("founded_in", { year: team.founded })}
              </span>
            </div>
          )}
          {venue?.name && (
            <div className="flex items-center gap-2.5 text-sm text-text-secondary">
              <MapPin size={14} className="text-text-muted flex-shrink-0" />
              <span className="font-semibold truncate" title={venue.name}>
                {venue.name}
              </span>
            </div>
          )}
        </div>
      </div>
    </StyledLink>
  );
}

// ===== src/components/TeamListClient.tsx =====

"use client";

import { useState, useMemo, useEffect } from "react";
import { Search, SearchX } from "lucide-react";
import TeamDirectoryCard, {
  TeamDirectoryCardSkeleton,
} from "./TeamDirectoryCard";
import Pagination from "./Pagination";
import { useTranslation } from "@/hooks/useTranslation";

const ITEMS_PER_PAGE = 21;

interface TeamData {
  team: { id: number; name: string; logo: string; country: string };
  venue: { name: string; city: string };
}

interface TeamListClientProps {
  initialTeams: TeamData[];
}

export default function TeamListClient({ initialTeams }: TeamListClientProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const [currentPage, setCurrentPage] = useState(1);
  const { t } = useTranslation();

  const filteredTeams = useMemo(() => {
    if (!initialTeams) return [];

    return searchTerm.length > 2
      ? initialTeams.filter((item) =>
          item.team.name.toLowerCase().includes(searchTerm.toLowerCase())
        )
      : initialTeams;
  }, [initialTeams, searchTerm]);

  const { paginatedData, totalPages } = useMemo(() => {
    const total = Math.ceil(filteredTeams.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    return {
      paginatedData: filteredTeams.slice(startIndex, endIndex),
      totalPages: total,
    };
  }, [filteredTeams, currentPage]);

  useEffect(() => {
    setCurrentPage(1);
  }, [searchTerm]);

  return (
    <div>
      <div className="bg-brand-secondary p-4 rounded-lg mb-8">
        <div className="relative w-full">
          <Search
            className="absolute left-4 top-1/2 -translate-y-1/2 text-text-muted"
            size={20}
          />
          <input
            type="text"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            placeholder={t("search_by_team_name_placeholder")}
            className="w-full bg-[var(--color-primary)] border border-gray-700/50 rounded-lg p-3 pl-12 text-white placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-[var(--brand-accent)]"
          />
        </div>
      </div>

      <div>
        {initialTeams.length === 0 ? (
          <div className="text-center py-20 bg-brand-secondary rounded-lg">
            <p className="text-xl font-bold text-white">
              {t("error_loading_teams_title")}
            </p>
            <p className="text-text-muted mt-2">
              {t("error_loading_teams_subtitle")}
            </p>
          </div>
        ) : paginatedData.length > 0 ? (
          <>
            <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
              {paginatedData.map((item) => (
                <TeamDirectoryCard
                  key={item.team.id}
                  team={item.team}
                  venue={item.venue}
                />
              ))}
            </div>
            <Pagination
              currentPage={currentPage}
              totalPages={totalPages}
              onPageChange={setCurrentPage}
            />
          </>
        ) : (
          <div className="text-center py-20 bg-brand-secondary rounded-lg">
            <SearchX size={48} className="mx-auto text-text-muted mb-4" />
            <p className="text-xl font-bold text-white">
              {t("no_teams_found_title")}
            </p>
            <p className="text-text-muted mt-2">
              {t("no_teams_found_subtitle", { searchTerm: searchTerm })}
            </p>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/TeamsByCountryClient.tsx =====

"use client";

import { useState, useMemo, useEffect } from "react";
import Pagination from "./Pagination";
import { Search, SearchX } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";
import TeamDirectoryCard, {
  TeamDirectoryCardSkeleton,
} from "./TeamDirectoryCard";

const ITEMS_PER_PAGE = 18;

interface TeamData {
  team: any;
  venue: any;
}

interface TeamsByCountryClientProps {
  initialTeams: TeamData[];
}

export default function TeamsByCountryClient({
  initialTeams,
}: TeamsByCountryClientProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const [currentPage, setCurrentPage] = useState(1);
  const { t } = useTranslation();

  const filteredTeams = useMemo(() => {
    if (!initialTeams) return [];
    return searchTerm.length > 2
      ? initialTeams.filter((item) =>
          item.team.name.toLowerCase().includes(searchTerm.toLowerCase())
        )
      : initialTeams;
  }, [initialTeams, searchTerm]);

  const { paginatedData, totalPages } = useMemo(() => {
    const total = Math.ceil(filteredTeams.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    return {
      paginatedData: filteredTeams.slice(startIndex, endIndex),
      totalPages: total,
    };
  }, [filteredTeams, currentPage]);

  useEffect(() => {
    setCurrentPage(1);
  }, [searchTerm]);

  return (
    <>
      <div className="relative flex-grow w-full mb-8">
        <Search
          className="absolute left-3.5 top-1/2 -translate-y-1/2 text-text-muted"
          size={20}
        />
        <input
          type="text"
          placeholder={t("search_by_team_name_placeholder")}
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-3 pl-12 text-white focus:outline-none focus:ring-2 focus:ring-brand-purple"
        />
      </div>

      {paginatedData.length > 0 ? (
        <>
          <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
            {paginatedData.map((teamData) => (
              <TeamDirectoryCard
                key={teamData.team.id}
                team={teamData.team}
                venue={teamData.venue}
              />
            ))}
          </div>
          {totalPages > 1 && (
            <Pagination
              currentPage={currentPage}
              totalPages={totalPages}
              onPageChange={setCurrentPage}
            />
          )}
        </>
      ) : (
        <div className="col-span-full text-center py-20 bg-brand-secondary rounded-lg">
          <SearchX size={32} className="mx-auto text-brand-muted mb-3" />
          <p className="text-xl font-bold text-white">
            {t("no_teams_found_title")}
          </p>
          <p className="text-brand-muted mt-2">
            {t("no_teams_found_subtitle", { searchTerm })}
          </p>
        </div>
      )}
    </>
  );
}

// ===== src/components/Ticker.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Marquee from "react-fast-marquee";
import { IoMdFootball } from "react-icons/io";
import { FaBasketballBall } from "react-icons/fa";
import { IoTennisballOutline } from "react-icons/io5";
import { ITickerMessage } from "@/models/TickerMessage";
import { useTranslation } from "@/hooks/useTranslation";

const fetchTickerMessages = async (
  locale: string
): Promise<ITickerMessage[]> => {
  const { data } = await axios.get(`/api/ticker-messages?locale=${locale}`);
  return data;
};

const SportSeparator = ({ index }: { index: number }) => {
  const icons = [IoMdFootball, FaBasketballBall, IoTennisballOutline];
  const Icon = icons[index % icons.length];
  return (
    <div className="flex items-center justify-center w-12 h-full">
      <Icon className="text-white/80" size={16} />
    </div>
  );
};

export default function Ticker() {
  const { locale } = useTranslation();

  const { data: messages, isLoading } = useQuery<ITickerMessage[]>({
    queryKey: ["tickerMessages", locale],
    queryFn: () => fetchTickerMessages(locale!),
    staleTime: 1000 * 60 * 5,
    refetchOnWindowFocus: true,
    enabled: !!locale,
  });

  if (isLoading || !messages || messages.length === 0) {
    return null;
  }

  return (
    <div className="bg-[var(--brand-accent)] text-white py-2 shadow-md">
      <Marquee gradient={false} speed={50}>
        <div className="flex items-center">
          {messages.map((item, index) => (
            <div key={item._id as string} className="flex items-center">
              <span className="font-semibold text-sm px-6 whitespace-nowrap">
                {item.message}
              </span>
              <SportSeparator index={index} />
            </div>
          ))}
        </div>
      </Marquee>
    </div>
  );
}

// ===== src/components/UpcomingMatchesSlider.tsx =====

"use client";

import Slider from "react-slick";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { useLeagueContext } from "@/context/LeagueContext";

import MatchSlide from "./MatchSlide";
import FinishedMatchSlide from "./FinishedMatchSlide";

const fetchLeagueMatches = async (leagueId: number) => {
  const { data } = await axios.get(`/api/upcoming-matches?league=${leagueId}`);
  return data;
};

const SliderSkeleton = () => (
    <div className="relative w-full h-64 overflow-hidden rounded-2xl bg-brand-secondary p-8 animate-pulse">
        <div className="flex h-full items-center justify-center">
            <div className="h-12 w-80 rounded bg-gray-600/50"></div>
        </div>
    </div>
);

export default function UpcomingMatchesSlider() {
  const { selectedLeague } = useLeagueContext();

  const { data: matches, isLoading } = useQuery({
    queryKey: ['leagueMatches', selectedLeague?.id],
    queryFn: () => fetchLeagueMatches(selectedLeague!.id),
    enabled: !!selectedLeague,
    staleTime: 1000 * 60 * 5,
  });

  const sliderSettings = {
    dots: true,
    infinite: true,
    speed: 500,
    slidesToShow: 1,
    slidesToScroll: 1,
    autoplay: true,
    autoplaySpeed: 7000,
    pauseOnHover: true,
    arrows: false,
    appendDots: (dots: any) => (
      <div><ul className="-bottom-5 relative">{dots}</ul></div>
    ),
  };

  if (isLoading) {
    return <SliderSkeleton />;
  }

  if (!matches || matches.length === 0) {
    return (
        <div className="flex h-64 items-center justify-center rounded-xl bg-brand-secondary text-brand-muted">
            No recent or upcoming matches found for this league.
        </div>
    );
  }

  return (
    <div className="w-full">
      <Slider {...sliderSettings}>
        {matches.map((match: any) => {

          const isFinished = match.fixture.status.short === 'FT';

          return (
            <div key={match.fixture.id} className="px-1">
              {isFinished ? (
                <FinishedMatchSlide match={match} />
              ) : (
                <MatchSlide match={match} />
              )}
            </div>
          );
        })}
      </Slider>
    </div>
  );
}

// ===== src/components/VotingPanel.tsx =====

"use client";

import { useState, memo } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'axios';
import Image from 'next/image';
import { useVoteStorage } from '@/hooks/useVoteStorage';

interface VoteData {
    homeVotes: number;
    drawVotes: number;
    awayVotes: number;
}
interface VotingPanelProps {
    fixtureId: number;
    teams: { home: any; away: any; };
}

const getVotes = async (fixtureId: number): Promise<VoteData> => {
    const { data } = await axios.get(`/api/votes?fixture=${fixtureId}`);
    return data;
};

const submitVote = async ({ fixtureId, vote }: { fixtureId: number; vote: string }): Promise<VoteData> => {
    const { data } = await axios.post('/api/votes', { fixtureId, vote });
    return data;
};

const PanelSkeleton = () => (
    <div className="animate-pulse p-4">
        <div className="h-4 w-1/2 mx-auto rounded bg-gray-600/50 mb-4"></div>
        <div className="grid grid-cols-3 gap-3">
            <div className="h-24 rounded-lg bg-gray-700/50"></div>
            <div className="h-24 rounded-lg bg-gray-700/50"></div>
            <div className="h-24 rounded-lg bg-gray-700/50"></div>
        </div>
    </div>
);

const VotingPanel = memo(function VotingPanel({ fixtureId, teams }: VotingPanelProps) {
    const queryClient = useQueryClient();
    const { setVote, getVoteForFixture } = useVoteStorage();

    const [hasVoted, setHasVoted] = useState(() => !!getVoteForFixture(fixtureId));

    const { data: voteData, isLoading } = useQuery({
        queryKey: ['votes', fixtureId],
        queryFn: () => getVotes(fixtureId),
        staleTime: 1000 * 60,
    });

    const voteMutation = useMutation({
        mutationFn: submitVote,
        onSuccess: () => {

            queryClient.invalidateQueries({ queryKey: ['votes', fixtureId] });
        },
    });

    const handleVote = (choice: 'home' | 'draw' | 'away') => {
        if (hasVoted) return;

        setVote(fixtureId, choice);
        setHasVoted(true);
        voteMutation.mutate({ fixtureId, vote: choice });
    };

    const handleBetClick = (e: React.MouseEvent) => {
        e.stopPropagation();

    };

    if (isLoading) {
        return <PanelSkeleton />;
    }

    if (!voteData) {
        return <p className="text-center text-sm text-brand-muted py-4">Could not load voting data.</p>;
    }

    const totalVotes = voteData.homeVotes + voteData.drawVotes + voteData.awayVotes;
    const homePercent = totalVotes > 0 ? Math.round((voteData.homeVotes / totalVotes) * 100) : 34;
    const awayPercent = totalVotes > 0 ? Math.round((voteData.awayVotes / totalVotes) * 100) : 33;
    const drawPercent = 100 - homePercent - awayPercent;

    return (
        <div className="bg-[#1F1D2B] p-4 border-t-2 border-gray-900/50">
            {!hasVoted ? (

                <>
                    <h4 className="text-center text-sm font-bold text-brand-muted mb-3 tracking-wider">WHO WILL WIN?</h4>
                    <div className="flex justify-center items-stretch gap-3">
                        <button onClick={() => handleVote('home')} className="flex-1 flex flex-col items-center gap-2 p-3 rounded-lg bg-gray-800/60 hover:bg-brand-purple transition-all duration-200 transform hover:-translate-y-1">
                            <Image src={teams.home.logo} alt={teams.home.name} width={48} height={48} className="object-contain h-12"/>
                            <span className="text-xs font-semibold text-white truncate">{teams.home.name}</span>
                        </button>
                        <button onClick={() => handleVote('draw')} className="flex-1 flex flex-col items-center justify-center gap-2 p-3 rounded-lg bg-gray-800/60 hover:bg-brand-purple transition-all duration-200 transform hover:-translate-y-1">
                            <span className="font-bold text-3xl text-white">=</span>
                            <span className="text-xs font-semibold text-white">DRAW</span>
                        </button>
                        <button onClick={() => handleVote('away')} className="flex-1 flex flex-col items-center gap-2 p-3 rounded-lg bg-gray-800/60 hover:bg-brand-purple transition-all duration-200 transform hover:-translate-y-1">
                            <Image src={teams.away.logo} alt={teams.away.name} width={48} height={48} className="object-contain h-12"/>
                            <span className="text-xs font-semibold text-white truncate">{teams.away.name}</span>
                        </button>
                    </div>
                </>
            ) : (

                <>
                    <h4 className="text-xs font-bold text-center text-brand-muted mb-2 tracking-widest">COMMUNITY VOTE</h4>
                    <div className="flex justify-between items-center mb-1">
                        <span className="text-sm font-bold text-white">{homePercent}%</span>
                        <span className="text-xs text-brand-muted">Draw {drawPercent}%</span>
                        <span className="text-sm font-bold text-white">{awayPercent}%</span>
                    </div>
                    <div className="flex w-full h-2 rounded-full overflow-hidden bg-gray-800 mb-4">
                        <div className="bg-brand-purple" style={{ width: `${homePercent}%` }}></div>
                        <div className="bg-gray-500" style={{ width: `${drawPercent}%` }}></div>
                        <div className="bg-blue-600" style={{ width: `${awayPercent}%` }}></div>
                    </div>
                    <div className="relative">
                        <span className="absolute top-0 left-0 inline-flex h-full w-full rounded-lg bg-orange-400 opacity-75 animate-ping"></span>
                        <button onClick={handleBetClick} className="relative w-full bg-orange-500 text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2 hover:bg-orange-600 transition-colors">
                            Bet 10 and Win 1000 
                        </button>
                    </div>
                    <p className="text-xs text-brand-muted mt-1.5 text-center">18+. Gamble responsibly. Verified Partner chinchincasino.com.</p>
                </>
            )}
        </div>
    );
});

export default VotingPanel;

// ===== src/components/ZonedDate.tsx =====

"use client";

import { useTimeZone } from "@/context/TimeZoneContext";
import { formatZonedTime } from "@/lib/date-formatter";

interface ZonedDateProps {

  date: string | Date;

  format?: string;
}

export default function ZonedDate({ date, format = "HH:mm" }: ZonedDateProps) {
  const { timeZone } = useTimeZone();

  if (!timeZone) {
    return <span className="tabular-nums">--:--</span>;
  }

  const formattedDate = formatZonedTime(date, timeZone, format);

  return <span className="tabular-nums">{formattedDate}</span>;
}

// ===== src/components/admin/AIPromptDisplayCard.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  BrainCircuit,
  FileText,
  Type,
  Info,
  AlertTriangle,
  Edit,
  Save,
  X,
  Loader2,
} from "lucide-react";

interface IAIPrompt {
  _id: string;
  name: string;
  prompt: string;
  description?: string;
  type: "title" | "content" | "prediction_content";
}

interface AIPromptDisplayCardProps {
  promptName: string;
  promptType: "title" | "content" | "prediction_content";
}

const fetchAIPrompt = async (
  name: string,
  type: "title" | "content" | "prediction_content"
): Promise<IAIPrompt> => {
  const { data } = await axios.get(
    `/api/admin/ai-prompt?name=${encodeURIComponent(name)}&type=${type}`
  );
  return data;
};

const CardSkeleton = () => (
  <div className="bg-brand-secondary p-6 rounded-lg shadow-xl animate-pulse h-[350px]"></div>
);

export default function AIPromptDisplayCard({
  promptName,
  promptType,
}: AIPromptDisplayCardProps) {
  const queryClient = useQueryClient();
  const [isEditing, setIsEditing] = useState(false);
  const [description, setDescription] = useState("");
  const [promptContent, setPromptContent] = useState("");

  const {
    data: prompt,
    isLoading,
    isError,
    error,
  } = useQuery<IAIPrompt>({
    queryKey: ["aiPrompt", promptName, promptType],
    queryFn: () => fetchAIPrompt(promptName, promptType),
    staleTime: Infinity,
    refetchOnWindowFocus: false,
  });

  useEffect(() => {
    if (prompt) {
      setDescription(prompt.description || "");
      setPromptContent(prompt.prompt);
    }
  }, [prompt]);

  const updateMutation = useMutation({
    mutationFn: (updatedPrompt: {
      id: string;
      description?: string;
      prompt: string;
    }) => axios.put("/api/admin/ai-prompt", updatedPrompt),
    onSuccess: (updatedData) => {
      toast.success("Prompt updated successfully!");
      queryClient.setQueryData(
        ["aiPrompt", promptName, promptType],
        updatedData.data
      );
      setIsEditing(false);
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to update prompt.");
    },
  });

  const handleSave = () => {
    if (!prompt) return;
    if (promptContent.trim() === "") {
      toast.error("Prompt content cannot be empty.");
      return;
    }
    updateMutation.mutate({
      id: prompt._id,
      description,
      prompt: promptContent,
    });
  };

  const handleCancel = () => {
    if (prompt) {
      setDescription(prompt.description || "");
      setPromptContent(prompt.prompt);
    }
    setIsEditing(false);
  };

  if (isLoading) return <CardSkeleton />;

  if (isError) {
    return (
      <div className="bg-red-900/50 border border-red-500/50 p-6 rounded-lg text-red-300">
        <h3 className="font-bold text-lg text-white">{promptName}</h3>
        <p className="text-sm">Error: Prompt not found or server error.</p>
      </div>
    );
  }

  return (
    <div className="bg-brand-secondary p-6 rounded-lg shadow-xl flex flex-col h-full min-h-[350px]">
      <div className="flex justify-between items-start gap-4 mb-4">
        <div className="flex items-start gap-4">
          <div className="flex-shrink-0 bg-brand-purple/20 text-brand-purple p-3 rounded-lg">
            {promptType === "title" ? (
              <Type size={24} />
            ) : (
              <FileText size={24} />
            )}
          </div>
          <div>
            <h3 className="text-xl font-bold text-white">{prompt?.name}</h3>
            {isEditing ? (
              <input
                type="text"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder="Enter a short description..."
                className="w-full mt-1 p-1 text-sm rounded bg-gray-700 text-white border border-gray-600"
              />
            ) : (
              <p className="text-sm text-brand-muted">
                {prompt?.description || "No description."}
              </p>
            )}
          </div>
        </div>
        {!isEditing && (
          <button
            onClick={() => setIsEditing(true)}
            className="flex-shrink-0 p-2 text-brand-muted hover:text-white hover:bg-gray-700 rounded-full"
            title="Edit Prompt"
          >
            <Edit size={16} />
          </button>
        )}
      </div>

      <div className="flex-grow flex flex-col bg-brand-dark p-4 rounded-md">
        {isEditing ? (
          <textarea
            value={promptContent}
            onChange={(e) => setPromptContent(e.target.value)}
            className="w-full h-full flex-grow bg-transparent text-white font-mono text-xs focus:outline-none resize-none"
            rows={10}
          />
        ) : (
          <p className="whitespace-pre-wrap font-mono text-xs text-brand-light">
            {prompt?.prompt}
          </p>
        )}
      </div>

      {isEditing && (
        <div className="flex justify-end gap-3 mt-4">
          <button
            onClick={handleCancel}
            disabled={updateMutation.isPending}
            className="flex items-center gap-2 bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
          >
            <X size={18} /> Cancel
          </button>
          <button
            onClick={handleSave}
            disabled={updateMutation.isPending}
            className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
          >
            {updateMutation.isPending ? (
              <Loader2 size={18} className="animate-spin" />
            ) : (
              <Save size={18} />
            )}
            {updateMutation.isPending ? "Saving..." : "Save"}
          </button>
        </div>
      )}
    </div>
  );
}

// ===== src/components/admin/AdminSidebar.tsx =====

"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import {
  LayoutDashboard,
  Newspaper,
  Image as ImageIcon,
  Sparkles,
  User,
  Crown,
  FileText,
  HelpCircle,
  FileStack,
  ChevronRight,
  AlertTriangle,
  Shield,
  UserCircle,
  DatabaseZap,
  Type,
  Bot,
  Languages,
  Megaphone,
} from "lucide-react";
import { useSession, signOut } from "next-auth/react";

const SubNavItem = ({
  href,
  name,
  icon: Icon,
  isActive,
}: {
  href: string;
  name: string;
  icon: React.ElementType;
  isActive: boolean;
}) => (
  <li>
    <Link
      href={href}
      className={`flex items-center gap-3 p-2 pl-4 rounded-md text-sm transition-colors ${
        isActive
          ? "text-white bg-brand-purple/50"
          : "text-brand-muted hover:text-white hover:bg-gray-700/50"
      }`}
    >
      <Icon size={16} />
      <span>{name}</span>
    </Link>
  </li>
);

export default function AdminSidebar() {
  const pathname = usePathname();
  const { data: session } = useSession();

  const isAiSectionActive =
    pathname.startsWith("/admin/auto-news") ||
    pathname.startsWith("/admin/ai-journalists") ||
    pathname.startsWith("/admin/title-templates");

  const isPagesSectionActive =
    pathname.startsWith("/admin/faqs") || pathname.startsWith("/admin/pages");

  const [isAiOpen, setIsAiOpen] = useState(isAiSectionActive);
  const [isPagesOpen, setIsPagesOpen] = useState(isPagesSectionActive);

  useEffect(() => {
    setIsAiOpen(isAiSectionActive);
  }, [isAiSectionActive]);

  useEffect(() => {
    setIsPagesOpen(isPagesSectionActive);
  }, [isPagesSectionActive]);

  const navItems = [
    { name: "Dashboard", href: "/admin/dashboard", icon: LayoutDashboard },
    { name: "News", href: "/admin/news", icon: Newspaper },
    { name: "Languages", href: "/admin/languages", icon: Languages },
    { name: "Ticker Messages", href: "/admin/ticker-messages", icon: Megaphone },
    { name: "Casino Partners", href: "/admin/casino-partners", icon: Crown },
    { name: "File Manager", href: "/admin/file-manager", icon: FileText },
    { name: "Banners", href: "/admin/banners", icon: ImageIcon },
  ];

  const aiSubNav = [
    { name: "News Engine", href: "/admin/auto-news", icon: Sparkles },
    { name: "AI Journalists", href: "/admin/ai-journalists", icon: User },
    { name: "Title Templates", href: "/admin/title-templates", icon: Type },
  ];

  const pagesSubNav = [
    { name: "FAQs", href: "/admin/faqs", icon: HelpCircle },
    {
      name: "Report Abuse",
      href: "/admin/pages/report-abuse",
      icon: AlertTriangle,
    },
    {
      name: "Privacy Policy",
      href: "/admin/pages/privacy-policy",
      icon: Shield,
    },
    {
      name: "Terms & Conditions",
      href: "/admin/pages/terms-and-conditions",
      icon: FileText,
    },
    { name: "Author Page", href: "/admin/pages/author", icon: UserCircle },
    { name: "GDPR Page", href: "/admin/pages/gdpr", icon: DatabaseZap },
  ];

  return (
    <aside className="w-72 bg-brand-secondary h-screen sticky top-0 p-4 flex flex-col justify-between">
      <div>
        <div className="text-2xl font-bold text-white mb-8 px-2">
          Admin Panel
        </div>
        <nav className="space-y-1">
          {navItems.map((item) => {
            const isActive = pathname === item.href;
            const Icon = item.icon;
            return (
              <Link
                key={item.name}
                href={item.href}
                className={`flex items-center gap-3 p-3 rounded-lg transition-colors duration-200 ${
                  isActive
                    ? "bg-brand-purple text-white"
                    : "text-brand-muted hover:bg-gray-700 hover:text-white"
                }`}
              >
                <Icon size={20} />
                <span>{item.name}</span>
              </Link>
            );
          })}

          <div>
            <button
              onClick={() => setIsAiOpen(!isAiOpen)}
              className={`w-full flex items-center justify-between p-3 rounded-lg transition-colors duration-200 ${
                isAiSectionActive
                  ? "bg-brand-purple text-white"
                  : "text-brand-muted hover:bg-gray-700 hover:text-white"
              }`}
            >
              <div className="flex items-center gap-3">
                <Bot size={20} />
                <span>AI Content Engine</span>
              </div>
              <ChevronRight
                size={18}
                className={`transition-transform duration-300 ${
                  isAiOpen ? "rotate-90" : ""
                }`}
              />
            </button>
            <div
              className={`grid transition-all duration-300 ease-in-out ${
                isAiOpen
                  ? "grid-rows-[1fr] opacity-100 pt-1"
                  : "grid-rows-[0fr] opacity-0"
              }`}
            >
              <ul className="overflow-hidden space-y-1 pl-4">
                {aiSubNav.map((item) => (
                  <SubNavItem
                    key={item.name}
                    href={item.href}
                    name={item.name}
                    icon={item.icon}
                    isActive={pathname.startsWith(item.href)}
                  />
                ))}
              </ul>
            </div>
          </div>

          <div>
            <button
              onClick={() => setIsPagesOpen(!isPagesOpen)}
              className={`w-full flex items-center justify-between p-3 rounded-lg transition-colors duration-200 ${
                isPagesSectionActive
                  ? "bg-brand-purple text-white"
                  : "text-brand-muted hover:bg-gray-700 hover:text-white"
              }`}
            >
              <div className="flex items-center gap-3">
                <FileStack size={20} />
                <span>Pages & FAQs</span>
              </div>
              <ChevronRight
                size={18}
                className={`transition-transform duration-300 ${
                  isPagesOpen ? "rotate-90" : ""
                }`}
              />
            </button>
            <div
              className={`grid transition-all duration-300 ease-in-out ${
                isPagesOpen
                  ? "grid-rows-[1fr] opacity-100 pt-1"
                  : "grid-rows-[0fr] opacity-0"
              }`}
            >
              <ul className="overflow-hidden space-y-1 pl-4">
                {pagesSubNav.map((item) => (
                  <SubNavItem
                    key={item.name}
                    href={item.href}
                    name={item.name}
                    icon={item.icon}
                    isActive={pathname.startsWith(item.href)}
                  />
                ))}
              </ul>
            </div>
          </div>
        </nav>
      </div>

      <div className="border-t border-gray-700 pt-4">
        {session?.user && (
          <div className="mb-4 text-brand-muted text-sm px-3">
            Logged in as{" "}
            <span className="font-semibold text-white">
              {session.user.name || session.user.email}
            </span>
          </div>
        )}
        <button
          onClick={() => signOut({ callbackUrl: "/login" })}
          className="w-full text-left flex items-center gap-3 p-3 rounded-lg text-red-400 hover:bg-gray-700 hover:text-red-300 transition-colors duration-200"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
            className="lucide lucide-log-out"
          >
            <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" />
            <polyline points="17 16 22 12 17 8" />
            <line x1="22" x2="10" y1="12" y2="12" />
          </svg>
          <span>Sign Out</span>
        </button>
      </div>
    </aside>
  );
}

// ===== src/components/admin/BannerFormModal.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import Image from "next/image";
import { IBanner } from "@/models/Banner";
import { AD_SLOTS } from "@/config/adSlots";
import { X, UploadCloud, XCircle } from "lucide-react";

interface BannerFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  banner: Partial<IBanner> | null;
}
type FormData = {
  title: string;
  imageUrl: string;
  linkUrl: string;
  isActive: boolean;
  location: string;
};

export default function BannerFormModal({
  isOpen,
  onClose,
  banner,
}: BannerFormModalProps) {

  const queryClient = useQueryClient();
  const [formData, setFormData] = useState<FormData>({
    title: "",
    imageUrl: "",
    linkUrl: "",
    isActive: true,
    location: AD_SLOTS[0]?.id || "",
  });
  const [isUploading, setIsUploading] = useState(false);
  useEffect(() => {
    if (banner) {
      setFormData({
        title: banner.title || "",
        imageUrl: banner.imageUrl || "",
        linkUrl: banner.linkUrl || "",
        isActive: banner.isActive !== undefined ? banner.isActive : true,
        location: banner.location || AD_SLOTS[0]?.id || "",
      });
    } else {
      setFormData({
        title: "",
        imageUrl: "",
        linkUrl: "",
        isActive: true,
        location: AD_SLOTS[0]?.id || "",
      });
    }
    setIsUploading(false);
  }, [banner, isOpen]);

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setIsUploading(true);
    const uploadFormData = new FormData();
    uploadFormData.append("file", file);

    uploadFormData.append("uploadType", "banner");

    try {
      const { data } = await axios.post("/api/upload", uploadFormData);
      setFormData((prev) => ({ ...prev, imageUrl: data.url }));
      toast.success("Image uploaded successfully!");
    } catch (error) {
      toast.error("Image upload failed. Please try again.");
    } finally {
      setIsUploading(false);
    }
  };

  const mutation = useMutation({
    mutationFn: (newBanner: FormData) => {
      if (banner?._id) {
        return axios.put(`/api/banners/${banner._id}`, newBanner);
      }
      return axios.post("/api/banners", newBanner);
    },
    onSuccess: () => {
      toast.success(
        `Banner ${banner?._id ? "updated" : "created"} successfully!`
      );
      queryClient.invalidateQueries({ queryKey: ["adminBanners"] });
      onClose();
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.error || "An error occurred.");
    },
  });
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (
      !formData.title ||
      !formData.imageUrl ||
      !formData.linkUrl ||
      !formData.location
    ) {
      toast.error("All fields, including an uploaded image, are required.");
      return;
    }
    mutation.mutate(formData);
  };

  if (!isOpen) return null;
  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg p-6 md:p-8 w-full max-w-2xl relative max-h-[90vh] overflow-y-auto">
        <button
          onClick={onClose}
          className="absolute top-4 right-4 text-brand-muted hover:text-white"
        >
          <X size={24} />
        </button>
        <h2 className="text-2xl font-bold text-white mb-6">
          {banner?._id ? "Edit Banner" : "Create New Banner"}
        </h2>

        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label className="block text-sm font-medium text-brand-light mb-2">
              Banner Image
            </label>
            <div className="mt-2 flex justify-center rounded-lg border border-dashed border-gray-600 px-6 py-10">
              {formData.imageUrl ? (
                <div className="relative group w-full h-48">
                  <Image
                    src={formData.imageUrl}
                    alt="Banner preview"
                    layout="fill"
                    objectFit="contain"
                  />
                  <button
                    type="button"
                    onClick={() =>
                      setFormData((prev) => ({ ...prev, imageUrl: "" }))
                    }
                    className="absolute top-2 right-2 bg-red-600 rounded-full p-1 text-white opacity-0 group-hover:opacity-100 transition-opacity"
                    title="Remove image"
                  >
                    <XCircle size={20} />
                  </button>
                </div>
              ) : (
                <div className="text-center">
                  <UploadCloud className="mx-auto h-12 w-12 text-gray-500" />
                  <div className="mt-4 flex text-sm leading-6 text-gray-400">
                    <label
                      htmlFor="banner-image-upload"
                      className="relative cursor-pointer rounded-md font-semibold text-brand-purple focus-within:outline-none focus-within:ring-2 focus-within:ring-brand-purple focus-within:ring-offset-2 focus-within:ring-offset-brand-dark hover:text-brand-purple/80"
                    >
                      <span>
                        {isUploading ? "Uploading..." : "Upload an image"}
                      </span>
                      <input
                        id="banner-image-upload"
                        name="banner-image-upload"
                        type="file"
                        className="sr-only"
                        onChange={handleImageUpload}
                        disabled={isUploading}
                        accept="image/*"
                      />
                    </label>
                    <p className="pl-1">or drag and drop</p>
                  </div>
                  <p className="text-xs leading-5 text-gray-500">
                    PNG, JPG, GIF up to 10MB. Will be converted to WebP.
                  </p>
                </div>
              )}
            </div>
          </div>

          <div>
            <label
              htmlFor="title"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Title
            </label>
            <input
              id="title"
              type="text"
              value={formData.title}
              onChange={(e) =>
                setFormData({ ...formData, title: e.target.value })
              }
              required
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
          </div>
          <div>
            <label
              htmlFor="linkUrl"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Link URL (Destination)
            </label>
            <input
              id="linkUrl"
              type="url"
              value={formData.linkUrl}
              onChange={(e) =>
                setFormData({ ...formData, linkUrl: e.target.value })
              }
              required
              placeholder="https://destination.com"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
          </div>

          <div>
            <label
              htmlFor="location"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Location
            </label>
            <select
              id="location"
              value={formData.location}
              onChange={(e) =>
                setFormData({ ...formData, location: e.target.value })
              }
              className="w-full p-2.5 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            >
              {AD_SLOTS.map((slot) => (
                <option key={slot.id} value={slot.id}>
                  {slot.name}
                </option>
              ))}
            </select>
            <p className="text-xs text-brand-muted mt-1">
              {AD_SLOTS.find((s) => s.id === formData.location)?.description}
            </p>
          </div>

          <div className="flex items-center gap-3">
            <input
              id="isActive"
              type="checkbox"
              checked={formData.isActive}
              onChange={(e) =>
                setFormData({ ...formData, isActive: e.target.checked })
              }
              className="h-4 w-4 rounded border-gray-300 text-brand-purple focus:ring-brand-purple"
            />
            <label
              htmlFor="isActive"
              className="text-sm font-medium text-brand-light"
            >
              Active (Visible on site)
            </label>
          </div>

          <div className="flex justify-end gap-4 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={mutation.isPending || isUploading}
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isUploading
                ? "Uploading..."
                : mutation.isPending
                ? "Saving..."
                : "Save Banner"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}

// ===== src/components/admin/CreatableSelect.tsx =====

"use client";

import { useState, useEffect, useRef } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";

const fetchCategories = async (): Promise<string[]> => {
  const { data } = await axios.get("/api/admin/faqs/categories");
  return data;
};

interface CreatableSelectProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
}

export default function CreatableSelect({
  value,
  onChange,
  placeholder,
}: CreatableSelectProps) {
  const [inputValue, setInputValue] = useState(value);
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const wrapperRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  const { data: categories } = useQuery<string[]>({
    queryKey: ["faqCategories"],
    queryFn: fetchCategories,
  });

  useEffect(() => {
    setInputValue(value);
  }, [value]);

  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (
        wrapperRef.current &&
        !wrapperRef.current.contains(event.target as Node)
      ) {
        setIsDropdownOpen(false);
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [wrapperRef]);

  const filteredCategories =
    categories?.filter((category) =>
      category.toLowerCase().includes(inputValue.toLowerCase())
    ) || [];

  const handleSelect = (selectedValue: string) => {
    setInputValue(selectedValue);
    onChange(selectedValue);
    setIsDropdownOpen(false);
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setInputValue(e.target.value);
    onChange(e.target.value);
    if (!isDropdownOpen) {
      setIsDropdownOpen(true);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      e.preventDefault();
      setIsDropdownOpen(false);
      inputRef.current?.blur();
    }
  };

  return (
    <div className="relative" ref={wrapperRef}>
      <input
        ref={inputRef}
        type="text"
        value={inputValue}
        onChange={handleInputChange}
        onFocus={() => setIsDropdownOpen(true)}
        onKeyDown={handleKeyDown}
        placeholder={placeholder}
        className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
      />

      {isDropdownOpen && (
        <div className="absolute top-full mt-1 w-full bg-brand-dark border border-gray-600 rounded-lg shadow-lg z-10 max-h-60 overflow-y-auto">
          {filteredCategories.length > 0 ? (
            filteredCategories.map((category) => (
              <div
                key={category}
                onClick={() => handleSelect(category)}
                className="p-3 text-white hover:bg-brand-purple cursor-pointer"
              >
                {category}
              </div>
            ))
          ) : (
            <div className="p-3 text-brand-muted">
              {inputValue
                ? `Create new category: "${inputValue}"`
                : "No categories found."}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

// ===== src/components/admin/RichTextEditor.tsx =====

"use client";

import { useEditor, EditorContent, Editor } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import Link from "@tiptap/extension-link";
import Placeholder from "@tiptap/extension-placeholder";
import Underline from "@tiptap/extension-underline";
import Highlight from "@tiptap/extension-highlight";
import Typography from "@tiptap/extension-typography";
import CharacterCount from "@tiptap/extension-character-count";
import Image from "@tiptap/extension-image";
import axios from "axios";
import toast from "react-hot-toast";

import {
  Bold,
  Italic,
  Strikethrough,
  Code,
  List,
  ListOrdered,
  Heading2,
  Heading3,
  Quote,
  Minus,
  Link as LinkIcon,
  Image as ImageIcon,
} from "lucide-react";
import { useEffect } from "react";

interface RichTextEditorProps {
  value: string;
  onChange: (value: string) => void;
}

const uploadPastedImage = async (file: File, editor: Editor) => {
  const loadingToast = toast.loading("Uploading pasted image...");

  try {
    const formData = new FormData();
    formData.append("file", file);

    const { data } = await axios.post("/api/upload", formData);

    if (data.url) {
      editor.chain().focus().setImage({ src: data.url }).run();
      toast.success("Image uploaded successfully!", { id: loadingToast });
    } else {
      throw new Error("Upload failed: No URL returned from API.");
    }
  } catch (error) {

    toast.error("Failed to upload image.", { id: loadingToast });
  }
};

const RichTextEditor: React.FC<RichTextEditorProps> = ({ value, onChange }) => {
  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        heading: {
          levels: [2, 3],
        },
      }),
      Link.configure({ openOnClick: false, autolink: true }),
      Placeholder.configure({
        placeholder: "Write your news article content here...",
      }),
      Underline,
      Highlight.configure({ multicolor: true }),
      Typography,
      CharacterCount.configure({ limit: 100000 }),
      Image.configure({ inline: true, allowBase64: true }),
    ],
    content: value,
    onUpdate: ({ editor }) => {
      onChange(editor.getHTML());
    },
    editorProps: {
      attributes: {

        class:
          "prose prose-invert lg:prose-xl focus:outline-none max-w-none min-h-[400px] border-x border-b border-gray-600 rounded-b-md p-4 bg-gray-800",
      },
      handlePaste: (view, event, slice) => {
        const files = event.clipboardData?.files;
        if (!files || files.length === 0) return false;
        const imageFiles = Array.from(files).filter((file) =>
          file.type.startsWith("image/")
        );
        if (imageFiles.length === 0) return false;
        event.preventDefault();
        imageFiles.forEach((file) => {
          if (view.state.editor) {
            uploadPastedImage(file, view.state.editor);
          }
        });
        return true;
      },
    },
  });

  useEffect(() => {
    if (editor && value !== editor.getHTML()) {
      editor.commands.setContent(value, false);
    }
  }, [value, editor]);

  if (!editor) {
    return null;
  }

  return (

    <div>
      {}
      {}
      {}
      <div className="sticky top-8 z-20 flex flex-wrap items-center gap-1 p-2 border-t border-x border-gray-600 bg-brand-secondary rounded-t-md">
        <button
          onClick={() => editor.chain().focus().toggleBold().run()}
          disabled={!editor.can().chain().focus().toggleBold().run()}
          className={`p-2 rounded ${
            editor.isActive("bold")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Bold size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleItalic().run()}
          disabled={!editor.can().chain().focus().toggleItalic().run()}
          className={`p-2 rounded ${
            editor.isActive("italic")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Italic size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleStrike().run()}
          disabled={!editor.can().chain().focus().toggleStrike().run()}
          className={`p-2 rounded ${
            editor.isActive("strike")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Strikethrough size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleCode().run()}
          disabled={!editor.can().chain().focus().toggleCode().run()}
          className={`p-2 rounded ${
            editor.isActive("code")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Code size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleBulletList().run()}
          disabled={!editor.can().chain().focus().toggleBulletList().run()}
          className={`p-2 rounded ${
            editor.isActive("bulletList")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <List size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleOrderedList().run()}
          disabled={!editor.can().chain().focus().toggleOrderedList().run()}
          className={`p-2 rounded ${
            editor.isActive("orderedList")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <ListOrdered size={18} />
        </button>
        <button
          onClick={() =>
            editor.chain().focus().toggleHeading({ level: 2 }).run()
          }
          className={`p-2 rounded ${
            editor.isActive("heading", { level: 2 })
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Heading2 size={18} />
        </button>
        <button
          onClick={() =>
            editor.chain().focus().toggleHeading({ level: 3 }).run()
          }
          className={`p-2 rounded ${
            editor.isActive("heading", { level: 3 })
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Heading3 size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleBlockquote().run()}
          className={`p-2 rounded ${
            editor.isActive("blockquote")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Quote size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().setHorizontalRule().run()}
          className={`p-2 rounded text-brand-muted hover:bg-gray-600`}
        >
          <Minus size={18} />
        </button>
        <button
          onClick={() => {
            const url = window.prompt("URL");
            if (url) {
              editor.chain().focus().setLink({ href: url }).run();
            }
          }}
          className={`p-2 rounded ${
            editor.isActive("link")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <LinkIcon size={18} />
        </button>
        <button
          onClick={() => {
            const url = window.prompt("Image URL");
            if (url) {
              editor.chain().focus().setImage({ src: url }).run();
            }
          }}
          className={`p-2 rounded text-brand-muted hover:bg-gray-600`}
        >
          <ImageIcon size={18} />
        </button>
      </div>
      <EditorContent editor={editor} />
    </div>
  );
};

export default RichTextEditor;

// ===== src/components/admin/TickerTranslationGroupRow.tsx =====

"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { ITickerMessage } from "@/models/TickerMessage";
import { ILanguage } from "@/models/Language";
import { Trash2, Languages, Loader2 } from "lucide-react";
import TranslationStatusPopover from "./TranslationStatusPopover";

interface TickerTranslationGroupRowProps {
  group: ITickerMessage[];
  allActiveLanguages: ILanguage[];
  onDelete: (messageId: string) => void;
}

export default function TickerTranslationGroupRow({
  group,
  allActiveLanguages,
  onDelete,
}: TickerTranslationGroupRowProps) {
  const queryClient = useQueryClient();
  const masterMessage = group[0];

  const translateMutation = useMutation({
    mutationFn: (sourceMessageId: string) =>
      axios.post("/api/admin/ticker-messages/translate", { sourceMessageId }),
    onSuccess: (data) => {
      toast.success(data.data.message || "Translations generated!");
      queryClient.invalidateQueries({ queryKey: ["tickerMessagesAdmin"] });
    },
    onError: (err: any) => {
      toast.error(
        err.response?.data?.error || "Failed to generate translations."
      );
    },
  });

  const handleTranslateAll = () => {
    translateMutation.mutate(masterMessage._id);
  };

  const handleDeleteAll = () => {
    if (
      window.confirm(
        `Are you sure you want to delete this message and all of its translations? This action cannot be undone.`
      )
    ) {
      group.forEach((msg) => onDelete(msg._id));
    }
  };

  return (
    <tr className="border-t-2 border-gray-800 bg-brand-secondary hover:bg-gray-800/50 transition-colors">
      <td className="p-4 w-20 text-center font-bold align-top">
        {masterMessage.order}
      </td>
      <td className="p-4 align-top">
        <p className="font-bold text-white text-base">{masterMessage.message}</p>
      </td>
      <td className="p-4 align-top">
        {}
        <TranslationStatusPopover
          group={group}
          allActiveLanguages={allActiveLanguages}
        />
        {}
      </td>
      <td className="p-4 align-middle text-sm text-center">
        <span
          className={`px-2 py-1 text-xs font-semibold rounded-full whitespace-nowrap ${
            masterMessage.isActive
              ? "bg-green-500/20 text-green-400"
              : "bg-yellow-500/20 text-yellow-400"
          }`}
        >
          {masterMessage.isActive ? "Active" : "Inactive"}
        </span>
      </td>
      <td className="p-4 align-middle text-center space-y-2">
        <button
          onClick={handleTranslateAll}
          disabled={translateMutation.isPending}
          className="w-full flex items-center justify-center gap-2 text-sm bg-indigo-500/20 text-indigo-300 hover:bg-indigo-500/30 font-semibold px-3 py-1.5 rounded-md transition-colors disabled:opacity-50 disabled:cursor-wait"
        >
          {translateMutation.isPending ? (
            <Loader2 size={16} className="animate-spin" />
          ) : (
            <Languages size={16} />
          )}
          <span>Translate</span>
        </button>
        <button
          onClick={handleDeleteAll}
          className="text-gray-500 hover:text-red-400 transition-colors p-1"
          title="Delete entire translation group"
        >
          <Trash2 size={18} />
        </button>
      </td>
    </tr>
  );
}

// ===== src/components/admin/TranslationGroupRow.tsx =====

"use client";

import Link from "next/link";
import Image from "next/image";
import { format } from "date-fns";
import { IPost } from "@/models/Post";
import { ILanguage } from "@/models/Language";
import { Edit, Plus, Trash2 } from "lucide-react";

interface TranslationGroupRowProps {
  group: IPost[];
  languageMap: Map<string, ILanguage>;
  onDelete: (postId: string, title: string) => void;
}

export default function TranslationGroupRow({
  group,
  languageMap,
  onDelete,
}: TranslationGroupRowProps) {
  const sortedGroup = [...group].sort(
    (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
  );
  const masterPost = sortedGroup[0];
  const existingTranslationsMap = new Map(
    sortedGroup.map((p) => [p.language, p])
  );

  const allActiveLanguages = Array.from(languageMap.values())
    .filter((lang) => lang.isActive)
    .sort((a, b) => a.name.localeCompare(b.name));

  const handleDeleteAll = () => {
    if (
      window.confirm(
        `Are you sure you want to delete the post "${
          masterPost.title
        }" AND all of its ${
          group.length - 1
        } translations? This action cannot be undone.`
      )
    ) {
      group.forEach((post) => {
        onDelete(post._id as string, post.title);
      });
    }
  };

  return (
    <tr className="border-t-2 border-gray-800 bg-brand-secondary hover:bg-gray-800/50 transition-colors">
      <td className="p-4 w-[140px] align-top">
        {masterPost.featuredImage ? (
          <Image
            src={masterPost.featuredImage}
            alt={masterPost.title}
            width={120}
            height={67}
            objectFit="cover"
            className="rounded-md bg-gray-700"
          />
        ) : (
          <div className="w-[120px] h-[67px] bg-gray-700 rounded-md flex items-center justify-center text-xs text-brand-muted">
            No Image
          </div>
        )}
      </td>
      <td className="p-4 align-top" colSpan={2}>
        <div className="flex flex-col gap-3">
          <Link href={`/admin/news/edit/${masterPost._id}`}>
            <h3 className="font-bold text-white text-base hover:text-brand-purple transition-colors">
              {masterPost.title}
            </h3>
          </Link>
          <div className="flex flex-wrap gap-2">
            {allActiveLanguages.map((lang) => {
              const translation = existingTranslationsMap.get(lang.code);
              const isAvailable = !!translation;

              const linkHref = isAvailable
                ? `/admin/news/edit/${translation._id}`
                : {
                    pathname: "/admin/news/create",

                    query: {
                      from: masterPost.translationGroupId.toString(),
                      lang: lang.code,
                      title: `[${lang.code.toUpperCase()}] ${masterPost.title}`,

                      image: masterPost.featuredImage || "",
                      categories: masterPost.sportsCategory.join(","),
                    },
                  };

              const linkTitle = isAvailable
                ? `Edit ${lang.name} translation`
                : `Add ${lang.name} translation`;

              return (
                <div key={lang.code} className="relative group/item">
                  <Link
                    href={linkHref}
                    title={linkTitle}
                    className={`flex-shrink-0 flex items-center gap-1.5 px-2 py-1 rounded-full text-xs font-semibold border transition-all duration-200 hover:-translate-y-0.5 hover:shadow-md ${
                      isAvailable
                        ? "bg-blue-500/10 text-blue-300 border-blue-500/30 hover:bg-blue-500/20"
                        : "bg-gray-700/50 text-gray-400 border-gray-600/50 hover:bg-gray-700"
                    }`}
                  >
                    {lang.flagUrl && (
                      <Image
                        src={lang.flagUrl}
                        alt={lang.name}
                        width={16}
                        height={12}
                        className="rounded-sm"
                      />
                    )}
                    <span className="hidden sm:inline">{lang.name}</span>
                    <span className="sm:hidden">{lang.code.toUpperCase()}</span>
                    {isAvailable ? <Edit size={12} /> : <Plus size={12} />}
                  </Link>
                  {isAvailable && (
                    <button
                      onClick={() =>
                        onDelete(translation._id as string, translation.title)
                      }
                      className="absolute -top-2 -right-2 z-10 p-0.5 bg-red-600 text-white rounded-full opacity-0 group-hover/item:opacity-100 transition-opacity hover:bg-red-500"
                      title={`Delete ${lang.name} translation`}
                    >
                      <Trash2 size={12} />
                    </button>
                  )}
                </div>
              );
            })}
          </div>
        </div>
      </td>
      <td className="p-4 align-middle text-sm text-center">
        <div>
          <span
            className={`px-2 py-1 text-xs font-semibold rounded-full whitespace-nowrap ${
              masterPost.status === "published"
                ? "bg-green-500/20 text-green-400"
                : "bg-yellow-500/20 text-yellow-400"
            }`}
          >
            {masterPost.status}
          </span>
          <p className="text-brand-muted text-xs mt-2">
            {format(new Date(masterPost.createdAt), "dd MMM yyyy")}
          </p>
        </div>
      </td>
      <td className="p-4 align-middle text-center">
        <button
          onClick={handleDeleteAll}
          className="text-gray-500 hover:text-red-400 transition-colors"
          title="Delete entire translation group"
        >
          <Trash2 size={18} />
        </button>
      </td>
    </tr>
  );
}

// ===== src/components/admin/TranslationStatusPopover.tsx =====

"use client";

import { Popover, Transition } from "@headlessui/react";
import { Fragment } from "react";
import Link from "next/link";
import Image from "next/image";
import { ILanguage } from "@/models/Language";
import { ITickerMessage } from "@/models/TickerMessage";
import { Languages, Edit, Plus } from "lucide-react";
import toast from "react-hot-toast";

interface TranslationStatusPopoverProps {
  group: ITickerMessage[];
  allActiveLanguages: ILanguage[];
}

export default function TranslationStatusPopover({
  group,
  allActiveLanguages,
}: TranslationStatusPopoverProps) {
  const existingTranslationsMap = new Map(group.map((p) => [p.language, p]));
  const translatedCount = existingTranslationsMap.size;
  const totalCount = allActiveLanguages.length;

  return (
    <Popover className="relative">
      <Popover.Button className="flex items-center gap-2 rounded-md bg-gray-700/80 px-3 py-1.5 text-xs font-semibold text-brand-light hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-brand-purple">
        <Languages size={14} />
        <span>
          {translatedCount} / {totalCount} Languages
        </span>
      </Popover.Button>
      <Transition
        as={Fragment}
        enter="transition ease-out duration-200"
        enterFrom="opacity-0 translate-y-1"
        enterTo="opacity-100 translate-y-0"
        leave="transition ease-in duration-150"
        leaveFrom="opacity-100 translate-y-0"
        leaveTo="opacity-0 translate-y-1"
      >
        <Popover.Panel className="absolute right-0 z-10 mt-2 w-72 origin-top-right rounded-md bg-brand-dark shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none border border-gray-700">
          <div className="p-2">
            <div className="p-2 font-bold text-white">Translations</div>
            <div className="max-h-60 overflow-y-auto custom-scrollbar space-y-1">
              {allActiveLanguages.map((lang) => {
                const translation = existingTranslationsMap.get(lang.code);
                return (
                  <div
                    key={lang.code}
                    className="flex items-center justify-between p-2 rounded-md hover:bg-brand-secondary"
                  >
                    <div className="flex items-center gap-2">
                      {lang.flagUrl && (
                        <Image
                          src={lang.flagUrl}
                          alt={lang.name}
                          width={20}
                          height={15}
                          className="rounded-sm"
                        />
                      )}
                      <span className="text-sm font-medium text-brand-light">
                        {lang.name}
                      </span>
                    </div>
                    {translation ? (
                      <button
                        onClick={() =>
                          toast.success(
                            `Editing "${translation.message}" in a modal would happen here.`
                          )
                        }
                        className="flex items-center gap-1 text-xs text-blue-400 hover:text-blue-300"
                      >
                        <Edit size={12} /> Edit
                      </button>
                    ) : (
                      <Link
                        href="#"
                        onClick={() =>
                          toast.success(
                            `Creating a new translation for ${lang.name} would happen here.`
                          )
                        }
                        className="flex items-center gap-1 text-xs text-green-400 hover:text-green-300"
                      >
                        <Plus size={12} /> Add
                      </Link>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        </Popover.Panel>
      </Transition>
    </Popover>
  );
}

// ===== src/components/admin/TranslationsWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Link from "next/link";
import Image from "next/image";
import { Plus, Edit, Languages, Loader2 } from "lucide-react";
import { ILanguage } from "@/models/Language";
import { IPost } from "@/models/Post";

interface TranslationsWidgetProps {
  translationGroupId: string;
  currentPostLanguage: string;
  currentPostTitle: string;
}

interface TranslationPost {
  _id: string;
  title: string;
  language: string;
}

const fetchLanguages = async (): Promise<ILanguage[]> => {
  const { data } = await axios.get("/api/admin/languages");
  return data;
};

const fetchTranslations = async (
  groupId: string
): Promise<TranslationPost[]> => {
  if (!groupId) return [];
  const { data } = await axios.get(`/api/admin/posts/translations/${groupId}`);
  return data;
};

export default function TranslationsWidget({
  translationGroupId,
  currentPostLanguage,
  currentPostTitle,
}: TranslationsWidgetProps) {
  const { data: languages, isLoading: isLoadingLanguages } = useQuery<
    ILanguage[]
  >({
    queryKey: ["allLanguages"],
    queryFn: fetchLanguages,
  });

  const { data: translations, isLoading: isLoadingTranslations } = useQuery<
    TranslationPost[]
  >({
    queryKey: ["translations", translationGroupId],
    queryFn: () => fetchTranslations(translationGroupId),
    enabled: !!translationGroupId,
  });

  const languageMap = new Map(languages?.map((lang) => [lang.code, lang]));
  const existingTranslationsMap = new Map(
    translations?.map((t) => [t.language, t])
  );

  const isLoading = isLoadingLanguages || isLoadingTranslations;

  return (
    <div className="bg-gray-800 p-4 border border-gray-600 rounded-lg space-y-4">
      <h3 className="text-lg font-semibold text-white flex items-center gap-2">
        <Languages size={20} /> Translations
      </h3>
      {isLoading ? (
        <div className="flex items-center justify-center py-4">
          <Loader2 className="animate-spin text-brand-muted" />
        </div>
      ) : (
        <div className="space-y-3">
          {languages
            ?.filter((l) => l.isActive)
            .map((lang) => {
              const translation = existingTranslationsMap.get(lang.code);
              const isCurrent = lang.code === currentPostLanguage;

              return (
                <div
                  key={lang.code}
                  className="flex items-center justify-between p-3 bg-brand-secondary rounded-md"
                >
                  <div className="flex items-center gap-3">
                    {lang.flagUrl && (
                      <Image
                        src={lang.flagUrl}
                        alt={lang.name}
                        width={24}
                        height={18}
                      />
                    )}
                    <span className="font-semibold text-brand-light">
                      {lang.name}
                    </span>
                    {isCurrent && (
                      <span className="text-xs bg-brand-purple text-white px-2 py-0.5 rounded-full">
                        Current
                      </span>
                    )}
                  </div>

                  {translation ? (
                    <Link
                      href={`/admin/news/edit/${translation._id}`}
                      className="flex items-center gap-1.5 text-sm text-blue-400 hover:text-blue-300"
                    >
                      <Edit size={14} /> Edit
                    </Link>
                  ) : (
                    <Link
                      href={{
                        pathname: "/admin/news/create",
                        query: {
                          from: translationGroupId,
                          lang: lang.code,
                          title: `Translation of: ${currentPostTitle}`,
                        },
                      }}
                      className="flex items-center gap-1.5 text-sm text-green-400 hover:text-green-300"
                    >
                      <Plus size={14} /> Add Translation
                    </Link>
                  )}
                </div>
              );
            })}
        </div>
      )}
    </div>
  );
}

// ===== src/components/image-templates/FixtureImageTemplate.tsx =====

import React from "react";

interface FixtureImageTemplateProps {
  homeTeamName: string;
  homeTeamLogo: string;
  awayTeamName: string;
  awayTeamLogo: string;
  leagueName: string;
}

export const FixtureImageTemplate = ({
  homeTeamName,
  homeTeamLogo,
  awayTeamName,
  awayTeamLogo,
  leagueName,
}: FixtureImageTemplateProps) => {
  return (
    <div
      style={{
        height: "100%",
        width: "100%",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "space-between",
        fontFamily: '"Poppins"',
        color: "white",
        background: "linear-gradient(to bottom, #1e1b2e, #13111e)",
        padding: "48px",
      }}
    >
      {}
      <div
        style={{
          display: "flex",
          alignSelf: "flex-start",
          fontSize: 28,
          color: "#9e9e9e",
        }}
      >
        {leagueName}
      </div>

      {}
      <div
        style={{
          display: "flex",
          width: "100%",
          alignItems: "center",
          justifyContent: "space-around",
        }}
      >
        {}
        <div
          style={{
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            gap: 24,
            width: 400,
          }}
        >
          <img
            src={homeTeamLogo}
            alt={`${homeTeamName} logo`}
            width={200}
            height={200}
            style={{ objectFit: "contain" }}
          />
          <div style={{ fontSize: 48, fontWeight: 700, textAlign: "center" }}>
            {homeTeamName}
          </div>
        </div>

        {}
        <div style={{ fontSize: 96, fontWeight: 900, color: "#9e9e9e" }}>
          VS
        </div>

        {}
        <div
          style={{
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            gap: 24,
            width: 400,
          }}
        >
          <img
            src={awayTeamLogo}
            alt={`${awayTeamName} logo`}
            width={200}
            height={200}
            style={{ objectFit: "contain" }}
          />
          <div style={{ fontSize: 48, fontWeight: 700, textAlign: "center" }}>
            {awayTeamName}
          </div>
        </div>
      </div>

      {}
      <div
        style={{
          display: "flex",
          alignSelf: "flex-end",
          fontSize: 32,
          fontWeight: 800,
          color: "#ed5c19",
        }}
      >
        FanSkor
      </div>
    </div>
  );
};

// ===== src/components/league-detail-view/LeagueFixturesWidget.tsx =====

"use client";

import { useState, useMemo, useRef, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { DayPicker } from "react-day-picker";
import "react-day-picker/dist/style.css";
import { format, Locale } from "date-fns";
import { enUS, tr, fr, es } from "date-fns/locale";
import { Calendar, Info } from "lucide-react";
import MatchListItem, { MatchListItemSkeleton } from "../MatchListItem";
import { useTranslation } from "@/hooks/useTranslation";

type FixtureView = "upcoming" | "today" | "date";

const dateLocales: Record<string, Locale> = { en: enUS, tr, fr, es };

const fetchFixtures = async (params: {
  leagueId: number;
  upcoming?: boolean;
  date?: string;
}) => {
  const queryParams = new URLSearchParams({
    league: params.leagueId.toString(),
  });

  if (params.date) queryParams.set("date", params.date);
  const { data } = await axios.get(`/api/fixtures?${queryParams.toString()}`);
  return data;
};

export default function LeagueFixturesWidget({
  leagueId,
  season,
}: {
  leagueId: number;
  season: number;
}) {
  const [view, setView] = useState<FixtureView>("today");
  const [selectedDate, setSelectedDate] = useState<Date>(new Date());
  const [isCalendarOpen, setIsCalendarOpen] = useState(false);
  const calendarRef = useRef<HTMLDivElement>(null);
  const { t, locale } = useTranslation();

  const queryParams = useMemo(() => {
    const baseParams = { leagueId, season };
    switch (view) {
      case "today":
        return { ...baseParams, date: format(new Date(), "yyyy-MM-dd") };
      case "date":
        return { ...baseParams, date: format(selectedDate, "yyyy-MM-dd") };

      default:
        return { ...baseParams, date: format(new Date(), "yyyy-MM-dd") };
    }
  }, [view, leagueId, season, selectedDate]);

  const {
    data: fixtures,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["leagueFixtures", queryParams],
    queryFn: () => fetchFixtures(queryParams),
    enabled: !!leagueId,
    staleTime: 1000 * 60 * 5,
  });

  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (
        calendarRef.current &&
        !calendarRef.current.contains(event.target as Node)
      ) {
        setIsCalendarOpen(false);
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [calendarRef]);

  const handleDateSelect = (date: Date | undefined) => {
    if (date) {
      setSelectedDate(date);
      setView("date");
      setIsCalendarOpen(false);
    }
  };

  const renderDateButtonText = () => {
    const currentLocale = dateLocales[locale] || enUS;
    if (view === "date")
      return format(selectedDate, "do MMM", { locale: currentLocale });
    return t("select_date");
  };

  const currentLocale = dateLocales[locale] || enUS;

  return (
    <div className="bg-brand-secondary rounded-xl">
      <div className="flex justify-between items-center p-4 border-b border-gray-700/50">
        <h3 className="text-xl font-bold text-white">{t("fixtures")}</h3>
        <div className="flex items-center gap-1 bg-[var(--color-primary)] p-1 rounded-lg">
          <button
            onClick={() => setView("today")}
            className={`px-3 py-1 text-sm rounded-md font-semibold transition-colors ${
              view === "today"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700"
            }`}
          >
            {t("today")}
          </button>
          <div className="relative" ref={calendarRef}>
            <button
              onClick={() => setIsCalendarOpen(!isCalendarOpen)}
              className={`flex items-center gap-1.5 px-3 py-1 text-sm rounded-md font-semibold transition-colors capitalize ${
                view === "date"
                  ? "bg-[var(--brand-accent)] text-white"
                  : "text-text-muted hover:bg-gray-700"
              }`}
            >
              <Calendar size={14} />
              {renderDateButtonText()}
            </button>
            {isCalendarOpen && (
              <div className="absolute top-full right-0 mt-2 z-20 bg-brand-dark border border-gray-700 rounded-lg shadow-lg">
                <DayPicker
                  mode="single"
                  selected={selectedDate}
                  onSelect={handleDateSelect}
                  className="text-white"
                  initialFocus
                  locale={currentLocale}
                />
              </div>
            )}
          </div>
        </div>
      </div>

      <div className="p-2 space-y-2 max-h-[600px] overflow-y-auto custom-scrollbar">
        {isLoading ? (
          Array.from({ length: 5 }).map((_, i) => (
            <MatchListItemSkeleton key={i} />
          ))
        ) : isError ? (
          <div className="text-center py-10 text-red-400">
            <p>{t("error_loading_fixtures")}</p>
          </div>
        ) : fixtures && fixtures.length > 0 ? (
          fixtures.map((match: any) => (
            <MatchListItem key={match.fixture.id} match={match} />
          ))
        ) : (
          <div className="text-center py-20 text-brand-muted">
            <Info size={32} className="mx-auto mb-3" />
            <p className="font-semibold">{t("no_fixtures_found")}</p>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/league-detail-view/LeagueStandingsWidget.tsx =====

"use client";

import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import StyledLink from "@/components/StyledLink";
import { Info } from "lucide-react";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import { useTranslation } from "@/hooks/useTranslation";

interface TeamStanding {
  rank: number;
  team: { id: number; name: string; logo: string };
  points: number;
  all: { played: number };
  goalsDiff: number;
  description: string | null;
}
interface League {
  id: number;
  name: string;
  logo: string;
  href: string;
}
interface LeagueStandingsWidgetProps {
  standings: TeamStanding[][];
  league: League;
}

const getRankIndicatorClass = (description: string | null): string => {
  if (!description) return "bg-gray-700 text-text-secondary";
  const desc = description.toLowerCase();
  if (desc.includes("champions league"))
    return "bg-blue-500 text-white font-bold";
  if (desc.includes("promotion")) return "bg-green-500 text-white font-bold";
  if (desc.includes("europa league"))
    return "bg-orange-500 text-white font-bold";
  if (desc.includes("relegation")) return "bg-red-600 text-white font-bold";
  return "bg-gray-700 text-text-secondary";
};

export default function LeagueStandingsWidget({
  standings,
  league,
}: LeagueStandingsWidgetProps) {
  const { t } = useTranslation();
  const mainStandings = standings?.[0] || [];

  if (mainStandings.length === 0) {
    return (
      <div className="bg-brand-secondary p-4 rounded-lg text-center h-full flex flex-col justify-center">
        <Info size={28} className="mx-auto text-text-muted mb-2" />
        <p className="text-text-light font-semibold text-sm">
          {t("standings_not_available")}
        </p>
      </div>
    );
  }

  return (
    <div className="bg-brand-secondary rounded-lg h-full flex flex-col">
      <div className="p-4 border-b border-gray-700/50">
        <h3 className="text-lg font-bold text-white">
          {t("league_standings")}
        </h3>
      </div>

      <div className="flex-grow overflow-hidden">
        <div className="h-full overflow-y-auto custom-scrollbar">
          <table className="w-full text-sm border-separate border-spacing-0">
            <thead className="text-left text-text-muted sticky top-0 bg-brand-secondary z-10">
              <tr className="text-xs uppercase">
                <th className="p-2 w-8 text-center font-semibold">
                  {t("table_header_rank_short")}
                </th>
                <th className="p-2 font-semibold">{t("table_header_team")}</th>
                <th className="p-2 text-center font-semibold">
                  {t("table_header_played_short")}
                </th>
                <th className="p-2 text-center font-semibold">
                  {t("table_header_goaldiff_short")}
                </th>
                <th className="p-2 text-center font-bold">
                  {t("table_header_points_short")}
                </th>
              </tr>
            </thead>
            <tbody className="text-brand-light">
              {mainStandings.map((item) => (
                <tr
                  key={item.team.id}
                  className="hover:bg-[var(--color-primary)]/50 transition-colors"
                >
                  <td className="p-2 text-center border-t border-gray-700/50">
                    <span
                      className={`w-6 h-6 flex items-center justify-center text-xs font-bold rounded-md ${getRankIndicatorClass(
                        item.description
                      )}`}
                    >
                      {item.rank}
                    </span>
                  </td>
                  <td className="p-2 border-t border-gray-700/50">
                    <StyledLink
                      href={generateTeamSlug(item.team.name, item.team.id)}
                      className="flex items-center gap-2 group"
                    >
                      <Image
                        src={proxyImageUrl(item.team?.logo)}
                        alt={item.team.name}
                        width={20}
                        height={20}
                      />
                      <span className="font-semibold group-hover:text-[var(--brand-accent)] transition-colors whitespace-nowrap truncate">
                        {item.team.name}
                      </span>
                    </StyledLink>
                  </td>
                  <td className="p-2 text-center text-text-muted border-t border-gray-700/50">
                    {item.all.played}
                  </td>
                  <td className="p-2 text-center text-text-muted border-t border-gray-700/50">
                    {item.goalsDiff}
                  </td>
                  <td className="p-2 text-center font-bold text-white border-t border-gray-700/50">
                    {item.points}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/league-detail-view/LeagueStatCard.tsx =====

import { ReactNode } from 'react';

interface LeagueStatCardProps {
    icon: ReactNode;
    label: string;
    value: string | number;
}

export default function LeagueStatCard({ icon, label, value }: LeagueStatCardProps) {
    return (
        <div className="bg-brand-secondary p-4 rounded-lg flex items-center gap-4">
            <div className="flex-shrink-0 bg-brand-purple/20 text-brand-purple p-3 rounded-lg">
                {icon}
            </div>
            <div>
                <p className="text-sm text-brand-muted">{label}</p>
                <p className="font-bold text-white text-lg">{value}</p>
            </div>
        </div>
    );
}

// ===== src/components/league-detail-view/LeagueTeamsList.tsx =====

"use client";

import { useState, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import TeamCard, { TeamCardSkeleton } from "./TeamCard";
import { Info, Search } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface LeagueTeamsListProps {
  leagueId: number;
  season: number;
  countryName: string;
  countryFlag: string;
}

interface CombinedTeamData {
  team: any;
  venue: any;
  rank?: number;
  description?: string;
  squadSize?: number;
}

const fetchLeagueData = async (leagueId: number, season: number) => {
  const [teamsResponse, standingsResponse] = await Promise.all([
    axios.get(`/api/teams?league=${leagueId}&season=${season}`),
    axios.get(`/api/standings?league=${leagueId}&season=${season}`),
  ]);

  const teamsData = teamsResponse.data;
  const standingsData = standingsResponse.data.standings?.[0] || [];
  const standingsMap = new Map(standingsData.map((s: any) => [s.team.id, s]));

  const combinedData: CombinedTeamData[] = teamsData.map((teamData: any) => {
    const standing: any = standingsMap.get(teamData.team.id);
    return {
      ...teamData,
      rank: standing?.rank,
      description: standing?.description,
    };
  });

  combinedData.sort((a, b) => {
    if (a.rank == null) return 1;
    if (b.rank == null) return -1;
    return a.rank - b.rank;
  });

  return combinedData;
};

export default function LeagueTeamsList({
  leagueId,
  season,
  countryName,
  countryFlag,
}: LeagueTeamsListProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const { t } = useTranslation();

  const {
    data: combinedData,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["leagueCombinedData", leagueId, season],
    queryFn: () => fetchLeagueData(leagueId, season),
    staleTime: 1000 * 60 * 60,
  });

  const filteredTeams = useMemo(() => {
    if (!combinedData) return [];

    return combinedData.filter((teamData: CombinedTeamData) =>
      teamData.team.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [combinedData, searchTerm]);

  const responsiveGridClasses =
    "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4";

  if (isError) {
    return (
      <div className="bg-brand-secondary p-8 rounded-lg text-center">
        <Info size={32} className="mx-auto text-brand-muted mb-3" />
        <p className="text-brand-light font-semibold">
          {t("error_loading_teams")}
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="relative">
        <Search
          className="absolute left-3.5 top-1/2 -translate-y-1/2 text-brand-muted"
          size={20}
        />
        <input
          type="text"
          placeholder={t("search_for_team_placeholder")}
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-3 pl-12 text-white focus:outline-none focus:ring-2 focus:ring-brand-purple"
        />
      </div>

      {isLoading ? (
        <div className={responsiveGridClasses}>
          {Array.from({ length: 12 }).map((_, i) => (
            <TeamCardSkeleton key={i} />
          ))}
        </div>
      ) : filteredTeams.length > 0 ? (
        <div className={responsiveGridClasses}>
          {filteredTeams.map((data: CombinedTeamData) => (
            <TeamCard
              key={data.team.id}
              team={data.team}
              venue={data.venue}
              rank={data.rank}
              countryName={countryName}
              countryFlag={countryFlag}
              rankDescription={data.description}
            />
          ))}
        </div>
      ) : (
        <div className="bg-brand-secondary p-8 rounded-lg text-center">
          <Info size={32} className="mx-auto text-brand-muted mb-3" />
          <p className="text-brand-light font-semibold">
            {t("no_teams_found_for_search", { searchTerm })}
          </p>
        </div>
      )}
    </div>
  );
}

// ===== src/components/league-detail-view/LeagueTopScorersWidget.tsx =====

"use client";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { Trophy, Info } from "lucide-react";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useTranslation } from "@/hooks/useTranslation";

const fetchTopScorers = async (leagueId: number, season: number) => {
  const { data } = await axios.get(
    `/api/top-scorers?league=${leagueId}&season=${season}`
  );
  return data;
};

const PlayerRow = ({ player, rank }: { player: any; rank: number }) => {
  const isTop = rank === 1;
  const bgColor = isTop ? "bg-[var(--brand-accent)]/10" : "bg-transparent";
  const borderColor = isTop
    ? "border-l-[var(--brand-accent)]"
    : "border-l-transparent";

  return (
    <div
      className={`flex items-center gap-3 p-2 rounded-lg transition-colors border-l-4 ${bgColor} ${borderColor}`}
    >
      <span
        className={`w-6 text-center font-bold text-lg ${
          isTop ? "text-[var(--brand-accent)]" : "text-text-muted"
        }`}
      >
        {rank}
      </span>
      <Image
        src={proxyImageUrl(player.player.photo)}
        alt={player.player.name}
        width={36}
        height={36}
        className="rounded-full bg-gray-800"
      />
      <div className="flex-1 min-w-0">
        <p className="font-bold text-white truncate text-sm">
          {player.player.name}
        </p>
        <p className="text-xs text-text-muted truncate">
          {player.statistics[0].team.name}
        </p>
      </div>
      <div
        className={`flex items-center justify-center gap-2 font-bold text-lg p-2 rounded-lg ${
          isTop ? "text-yellow-300" : "text-white"
        }`}
      >
        <Trophy size={16} />
        <span>{player.statistics[0].goals.total}</span>
      </div>
    </div>
  );
};

export default function LeagueTopScorersWidget({
  leagueId,
  season,
}: {
  leagueId: number;
  season: number;
}) {
  const { t } = useTranslation();
  const { data: topScorers, isLoading } = useQuery({
    queryKey: ["topScorers", leagueId, season],
    queryFn: () => fetchTopScorers(leagueId, season),
    staleTime: 1000 * 60 * 60,
  });

  const renderContent = () => {
    if (isLoading) {
      return (
        <div className="space-y-2 p-2 animate-pulse">
          {Array.from({ length: 5 }).map((_, i) => (
            <div key={i} className="flex items-center gap-3 p-2">
              <div className="w-6 h-6 rounded bg-gray-700"></div>
              <div className="w-9 h-9 rounded-full bg-gray-700"></div>
              <div className="flex-1 space-y-1.5">
                <div className="h-4 w-3/4 bg-gray-700 rounded"></div>
                <div className="h-3 w-1/2 bg-gray-700 rounded"></div>
              </div>
              <div className="w-12 h-8 rounded bg-gray-700"></div>
            </div>
          ))}
        </div>
      );
    }

    if (!topScorers || topScorers.length === 0) {
      return (
        <div className="text-center h-full flex flex-col justify-center items-center p-4">
          <Info size={28} className="mx-auto text-text-muted mb-2" />
          <p className="text-text-light font-semibold text-sm">
            {t("top_scorers_not_available")}
          </p>
        </div>
      );
    }

    return (
      <div className="space-y-1 p-2">
        {topScorers.slice(0, 5).map((scorer: any, index: number) => (
          <PlayerRow key={scorer.player.id} player={scorer} rank={index + 1} />
        ))}
      </div>
    );
  };

  return (
    <div className="bg-brand-secondary rounded-lg h-full flex flex-col">
      <div className="p-4 border-b border-gray-700/50">
        <h3 className="text-lg font-bold text-white">
          {t("golden_boot_race")}
        </h3>
      </div>
      <div className="flex-grow">{renderContent()}</div>
    </div>
  );
}

// ===== src/components/league-detail-view/TeamCard.tsx =====

import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import StyledLink from "@/components/StyledLink";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import { Users, MapPin, Calendar } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface TeamCardProps {
  team: any;
  venue: any;
  rank?: number;
  countryName?: string;
  countryFlag?: string;
  squadSize?: number;
  rankDescription?: string;
}

const getRankClasses = (
  description: string | null
): { border: string; text: string } => {
  if (!description)
    return { border: "border-gray-700/50", text: "text-brand-muted" };
  const desc = description.toLowerCase();
  if (desc.includes("champions league") || desc.includes("promotion"))
    return { border: "border-green-500", text: "text-green-400" };
  if (desc.includes("europa league") || desc.includes("qualification"))
    return { border: "border-orange-500", text: "text-orange-400" };
  if (desc.includes("conference league") || desc.includes("play-off"))
    return { border: "border-sky-400", text: "text-sky-300" };
  if (desc.includes("relegation"))
    return { border: "border-red-600", text: "text-red-500" };
  return { border: "border-gray-700/50", text: "text-brand-muted" };
};

export function TeamCardSkeleton() {
  return (
    <div className="bg-brand-secondary rounded-lg flex flex-col h-full animate-pulse">
      <div className="p-4 flex items-start gap-4">
        <div className="w-10 h-10 rounded-full bg-gray-700"></div>
        <div className="flex-1 space-y-2">
          <div className="h-4 w-3/4 bg-gray-600 rounded"></div>
          <div className="h-3 w-1/2 bg-gray-600/50 rounded"></div>
        </div>
      </div>
      <div className="px-4 pb-4 mt-auto space-y-2 border-t border-gray-700/50 pt-3">
        <div className="h-3 w-full bg-gray-600/50 rounded"></div>
        <div className="h-3 w-2/3 bg-gray-600/50 rounded"></div>
      </div>
    </div>
  );
}

export default function TeamCard({
  team,
  venue,
  rank,
  countryName,
  countryFlag,
  squadSize,
  rankDescription,
}: TeamCardProps) {
  const rankClasses = getRankClasses(rankDescription || null);
  const { t } = useTranslation();

  return (
    <StyledLink
      href={generateTeamSlug(team.name, team.id)}
      className="block group h-full"
    >
      <div
        className={`bg-brand-secondary rounded-lg flex flex-col h-full border-l-4 ${rankClasses.border} transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20`}
      >
        <div className="p-4 flex items-start gap-4">
          <Image
            src={proxyImageUrl(team.logo)}
            alt={team.name}
            width={40}
            height={40}
            className="flex-shrink-0 mt-1"
          />
          <div className="flex-1 min-w-0">
            <h4 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
              {team.name}
            </h4>
            {countryName && countryFlag && (
              <div className="flex items-center gap-1.5 text-xs text-brand-muted mt-1">
                <Image
                  src={countryFlag}
                  alt={countryName}
                  width={16}
                  height={16}
                  className="rounded-full"
                />
                <span>{countryName}</span>
              </div>
            )}
          </div>
          {rank && (
            <div className={`text-2xl font-black ${rankClasses.text}`}>
              {rank}
            </div>
          )}
        </div>

        <div className="px-4 pb-4 mt-auto space-y-1.5 border-t border-gray-700/50 pt-3">
          {squadSize && (
            <div className="flex items-center gap-2 text-xs text-brand-muted">
              <Users className="w-3 h-3" />
              <span>
                {t("squad_size")}: {squadSize}
              </span>
            </div>
          )}
          {team.founded && (
            <div className="flex items-center gap-2 text-xs text-brand-muted">
              <Calendar size={12} />
              <span>{t("founded_in", { year: team.founded })}</span>
            </div>
          )}
          {venue?.name && (
            <div className="flex items-center gap-2 text-xs text-brand-muted truncate">
              <MapPin className="w-3 h-3" />
              <span>{venue.name}</span>
            </div>
          )}
        </div>
      </div>
    </StyledLink>
  );
}

// ===== src/components/league-detail-view/index.tsx =====

import Image from "next/image";
import { Shield, Users, Trophy, Flag } from "lucide-react";
import LeagueStatCard from "./LeagueStatCard";
import LeagueFixturesWidget from "./LeagueFixturesWidget";
import LeagueStandingsWidget from "./LeagueStandingsWidget";
import LeagueTopScorersWidget from "./LeagueTopScorersWidget";
import LeagueTeamsList from "./LeagueTeamsList";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateLeagueSlug } from "@/lib/generate-league-slug";

export default function LeagueDetailView({ leagueData }: { leagueData: any }) {
  const { league, country, seasons } = leagueData;
  const currentSeason =
    seasons.find((s: any) => s.current === true)?.year ||
    new Date().getFullYear();

  const leagueWithHref = {
    ...league,
    href: generateLeagueSlug(league.name, league.id),
  };

  return (
    <div className="flex flex-col gap-8">
      {}
      <div className="flex flex-col items-center text-center gap-4 p-4 bg-brand-secondary rounded-xl">
        <Image
          src={proxyImageUrl(league.logo)}
          alt={league.name}
          width={80}
          height={80}
          className="bg-white rounded-full p-2"
        />
        <h1 className="text-4xl font-extrabold text-white">{league.name}</h1>
        <div className="flex items-center gap-2 text-brand-muted">
          {country.flag && (
            <Image
              src={proxyImageUrl(country.flag)}
              alt={country.name}
              width={20}
              height={20}
            />
          )}
          <span>{country.name}</span>
        </div>
      </div>

      {}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <LeagueStatCard icon={<Shield />} label="Type" value={league.type} />
        <LeagueStatCard icon={<Flag />} label="Country" value={country.name} />
        <LeagueStatCard
          icon={<Trophy />}
          label="Current Season"
          value={currentSeason}
        />
        <LeagueStatCard
          icon={<Users />}
          label="Teams"
          value={league.standings?.[0]?.length || "N/A"}
        />
      </div>

      {}
      <LeagueFixturesWidget leagueId={league.id} season={currentSeason} />

      {}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
        {}
        {league.type === "League" && (
          <LeagueStandingsWidget
            standings={league.standings}
            league={leagueWithHref}
          />
        )}

        {}
        <LeagueTopScorersWidget leagueId={league.id} season={currentSeason} />
      </div>

      {}
      <LeagueTeamsList
        leagueId={league.id}
        season={currentSeason}
        countryName={country.name}
        countryFlag={country.flag}
      />
    </div>
  );
}

// ===== src/components/match/BettingPromotionWidget.tsx =====

"use client";

import { memo } from 'react';
import Image from 'next/image';
import { ShieldCheck } from 'lucide-react';

const BettingPromotionWidget = memo(function BettingPromotionWidget() {

    const handleBetClick = () => {

    };

    return (
        <div className="bg-gradient-to-br from-green-500/20 to-brand-purple/20 p-4 rounded-xl border border-green-400/30 text-center space-y-3">

            {}
            {}

            <h3 className="text-lg font-bold text-white">
                Exclusive Welcome Offer!
            </h3>
            <p className="text-sm text-brand-light">
                Get a <span className="font-bold text-green-400">100% bonus</span> on your first deposit to bet on this match.
            </p>

            {}
            <div className="relative pt-2">
                <span className="absolute top-2 left-0 inline-flex h-full w-full rounded-lg bg-green-400 opacity-75 animate-ping"></span>
                <button
                    onClick={handleBetClick}
                    className="relative w-full bg-[#16A34A] text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2 hover:bg-green-700 transition-colors"
                >
                    <ShieldCheck size={18} />
                    <span>Claim Your Bonus</span>
                </button>
            </div>

            <p className="text-xs text-brand-muted/80">
                18+ | T&Cs apply. Gamble responsibly.
            </p>
        </div>
    );
});

export default BettingPromotionWidget;

// ===== src/components/match/FormGuide.tsx =====

"use client";
import { memo } from 'react';

const FormGuide = memo(function FormGuide({ form, teamId }: { form: any[], teamId: number }) {
    if (!form || form.length === 0) return null;

    return (
        <div className="flex items-center gap-1.5">
            {form.map((match: any) => {
                const goals = match.goals;
                const home = match.teams.home;

                let result = 'D';
                if (goals.home !== goals.away) {
                    const winnerId = goals.home > goals.away ? home.id : match.teams.away.id;
                    result = winnerId === teamId ? 'W' : 'L';
                }

                const classes = {
                    W: 'bg-green-500 text-green-900',
                    D: 'bg-gray-500 text-gray-900',
                    L: 'bg-red-500 text-red-900',
                };

                return (
                    <span key={match.fixture.id} className={`flex items-center justify-center w-6 h-6 rounded-full text-xs font-bold ${classes[result as keyof typeof classes]}`}>
                        {result}
                    </span>
                );
            })}
        </div>
    );
});
export default FormGuide;

// ===== src/components/match/HeaderOdds.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";

interface HeaderOddsProps {
  fixtureId: number;
}

const fetchOdds = async (fixtureId: number) => {

  const { data } = await axios.get(`/api/odds?fixture=${fixtureId}`);
  return data;
};

export default function HeaderOdds({ fixtureId }: HeaderOddsProps) {
  const { data: odds, isLoading } = useQuery({
    queryKey: ["headerOdds", fixtureId],
    queryFn: () => fetchOdds(fixtureId),
    staleTime: 1000 * 60 * 60,
    enabled: !!fixtureId,
  });

  const OddBox = ({ label, value }: { label: string; value?: string }) => (
    <div className="flex flex-col items-center justify-center p-2 rounded-md bg-gray-800/50 w-16 h-14">
      <span className="text-xs text-brand-muted">{label}</span>
      <span className="text-sm font-bold text-white">{value || "-"}</span>
    </div>
  );

  if (isLoading) {
    return (
      <div className="flex items-center justify-center gap-2 mt-4 animate-pulse">
        <div className="w-16 h-14 bg-gray-700/50 rounded-md"></div>
        <div className="w-16 h-14 bg-gray-700/50 rounded-md"></div>
        <div className="w-16 h-14 bg-gray-700/50 rounded-md"></div>
      </div>
    );
  }

  if (!odds) return null;

  return (
    <div className="flex items-center justify-center gap-2 mt-4">
      <OddBox label="Home" value={odds.home} />
      <OddBox label="Draw" value={odds.draw} />
      <OddBox label="Away" value={odds.away} />
    </div>
  );
}

// ===== src/components/match/LinkedNewsWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { IPost } from "@/models/Post";
import { Newspaper, Info } from "lucide-react";
import SidebarNewsItem, { SidebarNewsItemSkeleton } from "../SidebarNewsItem";

interface LinkedNewsWidgetProps {
  fixtureId: number;
}

const fetchLinkedNews = async (fixtureId: number): Promise<IPost[]> => {
  const { data } = await axios.get(
    `/api/posts?status=published&linkedFixtureId=${fixtureId}`
  );
  return data;
};

export default function LinkedNewsWidget({ fixtureId }: LinkedNewsWidgetProps) {
  const {
    data: linkedPosts,
    isLoading,
    isError,
  } = useQuery<IPost[]>({
    queryKey: ["linkedNews", fixtureId],
    queryFn: () => fetchLinkedNews(fixtureId),
    staleTime: 1000 * 60 * 5,
    enabled: !!fixtureId,
  });

  if (!isLoading && (isError || !linkedPosts || linkedPosts.length === 0)) {
    return null;
  }

  return (
    <section className="bg-brand-secondary rounded-lg shadow-lg">
      <div className="flex justify-between items-center p-4 border-b border-gray-700/50">
        <h2 className="text-xl font-bold text-white flex items-center gap-2">
          <Newspaper size={20} className="text-[var(--brand-accent)]" />
          Related News
        </h2>
      </div>

      <div className="p-2 space-y-1">
        {isLoading ? (

          <>
            <SidebarNewsItemSkeleton />
            <SidebarNewsItemSkeleton />
          </>
        ) : (

          linkedPosts?.map((post) => (
            <SidebarNewsItem key={post._id as string} post={post} />
          ))
        )}
      </div>
    </section>
  );
}

// ===== src/components/match/LiveOddsWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { TrendingUp, Goal, CornerUpRight, Users } from "lucide-react";

interface LiveOddsWidgetProps {
  fixtureId: string;
}

const fetchLiveOdds = async (fixtureId: string) => {
  const { data } = await axios.get(
    `/api/live-odds-by-fixture?fixture=${fixtureId}`
  );
  return data;
};

const OddsMarketRow = ({
  title,
  icon: Icon,
  oddsData,
  labels,
}: {
  title: string;
  icon: React.ElementType;
  oddsData: any | null;
  labels: { [key: string]: string };
}) => {
  if (!oddsData) return null;

  return (
    <div>
      <h4 className="flex items-center gap-2 text-sm font-semibold text-brand-light mb-2">
        <Icon size={16} className="text-brand-purple" />
        {title} {oddsData.handicap && `(${oddsData.handicap})`}
      </h4>
      <div className="grid grid-cols-2 gap-2">
        {Object.keys(labels).map(
          (key) =>
            oddsData[key] && (
              <div
                key={key}
                className="bg-gray-800/50 p-2 rounded-md flex justify-between items-center text-xs"
              >
                <span className="text-brand-muted">{labels[key]}</span>
                <span className="font-bold text-white">{oddsData[key]}</span>
              </div>
            )
        )}
      </div>
    </div>
  );
};

const LiveOddsSkeleton = () => (
  <div className="bg-brand-secondary p-4 rounded-lg animate-pulse">
    <div className="h-5 w-3/4 mb-4 bg-gray-700 rounded"></div>
    <div className="space-y-4">
      <div className="space-y-2">
        <div className="h-4 w-1/2 bg-gray-600 rounded"></div>
        <div className="grid grid-cols-2 gap-2">
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
        </div>
      </div>
      <div className="space-y-2">
        <div className="h-4 w-1/2 bg-gray-600 rounded"></div>
        <div className="grid grid-cols-2 gap-2">
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
        </div>
      </div>
    </div>
  </div>
);

export default function LiveOddsWidget({ fixtureId }: LiveOddsWidgetProps) {
  const {
    data: liveOdds,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["liveOdds", fixtureId],
    queryFn: () => fetchLiveOdds(fixtureId),
    staleTime: 10 * 1000,
    refetchInterval: 20 * 1000,
    enabled: !!fixtureId,
  });

  if (!isLoading && (isError || !liveOdds)) {
    return null;
  }

  if (isLoading) {
    return <LiveOddsSkeleton />;
  }

  return (
    <div className="bg-brand-secondary p-4 rounded-lg">
      <div className="flex items-center gap-2 mb-4">
        <TrendingUp size={20} className="text-green-400" />
        <h3 className="text-lg font-bold text-white">Live Odds</h3>
        <span className="relative flex h-3 w-3 ml-auto">
          <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
          <span className="relative inline-flex rounded-full h-3 w-3 bg-green-500"></span>
        </span>
      </div>

      <div className="space-y-4">
        <OddsMarketRow
          title="Over / Under"
          icon={Goal}
          oddsData={liveOdds.overUnder}
          labels={{ over: "Over", under: "Under" }}
        />
        <OddsMarketRow
          title="Asian Handicap"
          icon={Users}
          oddsData={liveOdds.asianHandicap}
          labels={{ home: "Home", away: "Away" }}
        />
        <OddsMarketRow
          title="Match Corners"
          icon={CornerUpRight}
          oddsData={liveOdds.matchCorners}
          labels={{ over: "Over", under: "Under" }}
        />
        {}
      </div>
    </div>
  );
}

// ===== src/components/match/MatchActivityWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { useMemo, memo } from "react";
import {
  Clock,
  Goal,
  ArrowLeftRight,
  RectangleVertical,
  Info,
} from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface MatchEvent {
  time: { elapsed: number };
  team: { id: number; name: string; logo: string };
  player: { id: number; name: string };
  assist: { id: number | null; name: string | null };
  type: "Goal" | "Card" | "subst" | "Var";
  detail: string;
}
interface MatchActivityWidgetProps {
  fixtureId: string;
  isLive: boolean;
  homeTeamId: number;
  activitySeoDescription: string;
}

const fetchFixtureEvents = async (fixtureId: string): Promise<MatchEvent[]> => {

  const { data } = await axios.get(`/api/match-details?fixture=${fixtureId}`);
  return data?.events || [];
};

const getEventStyles = (type: string, detail: string) => {
  switch (type) {
    case "Goal":
      return {
        bg: "bg-green-500/10",
        iconColor: "text-green-400",
        glow: "shadow-lg shadow-green-500/10",
      };
    case "Card":
      return detail.includes("Yellow")
        ? { bg: "bg-yellow-500/10", iconColor: "text-yellow-400", glow: "" }
        : { bg: "bg-red-500/10", iconColor: "text-red-400", glow: "" };
    case "subst":
      return { bg: "bg-blue-500/10", iconColor: "text-blue-400", glow: "" };
    default:
      return { bg: "bg-gray-500/10", iconColor: "text-gray-400", glow: "" };
  }
};

const EventIcon = memo(({ type, detail }: { type: string; detail: string }) => {
  const styles = getEventStyles(type, detail);
  const Icon =
    type === "Goal"
      ? Goal
      : type === "Card"
      ? RectangleVertical
      : type === "subst"
      ? ArrowLeftRight
      : Clock;
  return (
    <div
      className={`w-10 h-10 rounded-full flex items-center justify-center ${styles.bg} ${styles.iconColor}`}
    >
      <Icon size={18} />
    </div>
  );
});
EventIcon.displayName = "EventIcon";

const EventRow = memo(
  ({
    event,
    isHomeEvent,
    t,
  }: {
    event: MatchEvent;
    isHomeEvent: boolean;
    t: (key: string, params?: any) => string;
  }) => {
    const styles = getEventStyles(event.type, event.detail);
    const cardBaseClasses = `relative ${styles.bg} ${styles.glow} p-3 rounded-lg w-full max-w-xs transition-transform hover:scale-105`;
    const alignmentClasses = isHomeEvent ? "text-right" : "text-left";

    const assistText = event.assist.name
      ? t("assist_by", { name: event.assist.name })
      : "";

    const eventContent = (
      <div className={`${cardBaseClasses} ${alignmentClasses}`}>
        <p className="font-bold text-white text-sm">{event.player.name}</p>
        {event.type === "subst" ? (
          <p className="text-xs text-text-muted">
            <span className="text-red-400">{t("substitution_out_short")}</span>{" "}
            {" "}
            <span className="text-green-400">{t("substitution_in_short")}</span>{" "}
            {event.assist.name}
          </p>
        ) : (
          <p className="text-xs text-text-muted">
            {event.detail} {assistText}
          </p>
        )}
      </div>
    );

    return (
      <div className="grid grid-cols-[1fr_auto_1fr] items-center gap-3 md:gap-4">
        <div
          className={`flex justify-end ${
            !isHomeEvent && "opacity-0 pointer-events-none"
          }`}
        >
          {isHomeEvent && eventContent}
        </div>
        <div className="z-10 flex-shrink-0 flex items-center justify-center text-sm font-bold text-text-muted bg-brand-secondary h-12 w-12 rounded-full border-4 border-brand-dark">
          <span className="z-20">{event.time.elapsed}'</span>
        </div>
        <div
          className={`flex justify-start ${
            isHomeEvent && "opacity-0 pointer-events-none"
          }`}
        >
          {!isHomeEvent && eventContent}
        </div>
      </div>
    );
  }
);
EventRow.displayName = "EventRow";

export default function MatchActivityWidget({
  fixtureId,
  isLive,
  homeTeamId,
  activitySeoDescription,
}: MatchActivityWidgetProps) {
  const { t } = useTranslation();
  const {
    data: events,
    isLoading,
    isError,
  } = useQuery<MatchEvent[]>({
    queryKey: ["fixtureEvents", fixtureId],
    queryFn: () => fetchFixtureEvents(fixtureId),
    enabled: !!fixtureId,
    refetchInterval: isLive ? 15000 : false,
    staleTime: isLive ? 10000 : 1000 * 60 * 10,
  });

  const sortedEvents = useMemo(() => {
    if (!events) return [];
    return [...events].sort((a, b) => a.time.elapsed - b.time.elapsed);
  }, [events]);

  const renderContent = () => {
    if (isLoading) {
      return (
        <div className="space-y-4">
          {[...Array(3)].map((_, i) => (
            <div key={i} className="flex items-center gap-4 p-3 animate-pulse">
              <div className="flex-1 space-y-2 text-right">
                <div className="h-4 w-3/4 ml-auto bg-gray-700 rounded"></div>
                <div className="h-3 w-1/2 ml-auto bg-gray-700 rounded"></div>
              </div>
              <div className="w-12 h-12 rounded-full bg-gray-700"></div>
              <div className="flex-1 space-y-2">
                <div className="h-4 w-3/4 bg-gray-700 rounded"></div>
                <div className="h-3 w-1/2 bg-gray-700 rounded"></div>
              </div>
            </div>
          ))}
        </div>
      );
    }
    if (isError) {
      return (
        <div className="text-center py-10 text-red-400">
          <p>{t("error_loading_activity")}</p>
        </div>
      );
    }
    if (sortedEvents.length === 0) {
      return (
        <div className="text-center py-10 text-brand-muted">
          <Info size={32} className="mx-auto mb-3" />
          <p>{t("match_not_started")}</p>
        </div>
      );
    }
    return (
      <div className="relative">
        <div className="absolute top-0 left-1/2 h-full w-0.5 -translate-x-1/2 bg-gray-700/50"></div>
        <div className="space-y-4">
          {sortedEvents.map((event, index) => (
            <EventRow
              key={`${event.time.elapsed}-${event.player.id}-${index}`}
              event={event}
              isHomeEvent={event.team.id === homeTeamId}
              t={t}
            />
          ))}
        </div>
      </div>
    );
  };

  return (
    <div className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden">
      <div className="p-4 md:p-6">
        <h2 className="text-2xl font-bold text-white mb-4">
          {t("match_timeline")}
        </h2>
        <p className="italic text-[#a3a3a3] leading-relaxed mb-8 text-sm">
          {activitySeoDescription}
        </p>
        {renderContent()}
      </div>
    </div>
  );
}

// ===== src/components/match/MatchAnalyticsWidget.tsx =====

import { memo } from 'react';
import Image from 'next/image';
import { CheckCircle, XCircle, ShieldQuestion, TrendingUp, TrendingDown } from 'lucide-react';

const FormGuide = memo(function FormGuide({ formString }: { formString: string }) {
    if (!formString) return <span className="text-xs text-text-muted">N/A</span>;

    return (
        <div className="flex items-center gap-1.5">
            {formString.split('').slice(0, 5).map((result, index) => {
                const classes = {
                    W: 'bg-green-500 text-green-900',
                    D: 'bg-gray-500 text-gray-900',
                    L: 'bg-red-500 text-red-900',
                };
                return (
                    <span
                        key={index}
                        className={`flex items-center justify-center w-6 h-6 rounded-full text-xs font-bold ${classes[result as keyof typeof classes]}`}
                    >
                        {result}
                    </span>
                );
            })}
        </div>
    );
});

const MatchAnalyticsWidget = memo(function MatchAnalyticsWidget({ analytics }: { analytics: any }) {

    if (!analytics?.prediction || !analytics.homeTeamStats || !analytics.awayTeamStats) {
        return (
             <div className="bg-brand-secondary rounded-xl">
                <h3 className="text-lg font-bold p-4 border-b border-gray-700/50">Prediction & Form</h3>
                <p className="text-text-muted text-center py-8">Analytics are not available for this match.</p>
            </div>
        );
    }

    const { prediction, homeTeamStats, awayTeamStats } = analytics;
    const { percent } = prediction.predictions;
    const btts = prediction.comparison.btts === 'Yes';
    const overUnder = prediction.comparison.under_over === 'Over 2.5';

    const homePercent = parseFloat(percent.home.replace('%', ''));
    const drawPercent = parseFloat(percent.draw.replace('%', ''));
    const awayPercent = parseFloat(percent.away.replace('%', ''));

    return (
        <div className="bg-brand-secondary rounded-xl">
            <h3 className="text-lg font-bold p-4 border-b border-gray-700/50">Prediction & Form</h3>
            <div className="p-4 space-y-5">

                {}
                <div>
                    <div className="flex justify-between items-center mb-1.5">
                        <div className="flex flex-col items-center gap-1 text-center">
                            <Image src={homeTeamStats.team.logo} alt={homeTeamStats.team.name} width={32} height={32} />
                            <span className="font-bold text-lg text-white">{homePercent}%</span>
                        </div>
                        <div className="flex flex-col items-center gap-1 text-center">
                            <span className="text-text-muted text-sm font-semibold">Draw</span>
                            <span className="font-bold text-lg text-white">{drawPercent}%</span>
                        </div>
                        <div className="flex flex-col items-center gap-1 text-center">
                            <Image src={awayTeamStats.team.logo} alt={awayTeamStats.team.name} width={32} height={32} />
                            <span className="font-bold text-lg text-white">{awayPercent}%</span>
                        </div>
                    </div>
                    {}
                    <div className="flex w-full h-2 rounded-full overflow-hidden" style={{ backgroundColor: 'var(--color-secondary)' }}>
                        <div className="bg-brand-purple" style={{ width: `${homePercent}%` }}></div>
                        <div className="bg-gray-500" style={{ width: `${drawPercent}%` }}></div>
                        <div className="bg-brand-highlight" style={{ width: `${awayPercent}%` }}></div>
                    </div>
                </div>

                {}
                <div className="grid grid-cols-2 gap-3 text-sm">
                    <div className="flex items-center gap-2 p-3 rounded-lg" style={{backgroundColor: 'var(--color-primary)'}}>
                        {btts ? <CheckCircle size={20} className="text-green-400" /> : <XCircle size={20} className="text-red-400" />}
                        <span className="font-semibold">Both Teams to Score</span>
                    </div>
                     <div className="flex items-center gap-2 p-3 rounded-lg" style={{backgroundColor: 'var(--color-primary)'}}>
                        {overUnder ? <TrendingUp size={20} className="text-green-400" /> : <TrendingDown size={20} className="text-red-400" />}
                        <span className="font-semibold">Over 2.5 Goals</span>
                    </div>
                </div>

                {}
                <div className="space-y-3">
                    <div className="flex items-center justify-between">
                        <span className="font-semibold text-text-secondary">{homeTeamStats.team.name}</span>
                        <FormGuide formString={homeTeamStats.form} />
                    </div>
                    <div className="flex items-center justify-between">
                        <span className="font-semibold text-text-secondary">{awayTeamStats.team.name}</span>
                        <FormGuide formString={awayTeamStats.form} />
                    </div>
                </div>

                {}
                {prediction.predictions.advice && (
                    <div className="flex items-center gap-2 p-3 text-center rounded-lg border-2 border-dashed border-gray-700">
                        <ShieldQuestion size={20} className="text-brand-purple flex-shrink-0" />
                        <p className="text-sm font-semibold text-text-secondary">{prediction.predictions.advice}</p>
                    </div>
                )}
            </div>
        </div>
    );
});

export default MatchAnalyticsWidget;

// ===== src/components/match/MatchH2HWidget.tsx =====

"use client";

import { useMemo, useState } from "react";
import Image from "next/image";
import { format } from "date-fns";
import Link from "next/link";
import { ChevronRight, CalendarDays } from "lucide-react";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateMatchSlug } from "@/lib/generate-match-slug";
import { useTranslation } from "@/hooks/useTranslation";

interface MatchH2HWidgetProps {
  h2h: any[];
  teams: {
    home: { id: number; name: string; logo: string };
    away: { id: number; name: string; logo: string };
  };
  currentFixtureId: string;
  h2hSeoDescription: string;
}

export default function MatchH2HWidget({
  h2h,
  teams,
  currentFixtureId,
  h2hSeoDescription,
}: MatchH2HWidgetProps) {
  const [showAll, setShowAll] = useState(false);
  const { t } = useTranslation();

  const filteredH2H = useMemo(
    () =>
      h2h.filter((match) => match.fixture.id !== parseInt(currentFixtureId)),
    [h2h, currentFixtureId]
  );

  const displayedH2H = showAll ? filteredH2H : filteredH2H.slice(0, 5);

  const headToHeadRecords = useMemo(() => {
    if (!filteredH2H || filteredH2H.length === 0) {
      return { homeWins: 0, awayWins: 0, draws: 0 };
    }

    let homeWins = 0;
    let awayWins = 0;
    let draws = 0;

    filteredH2H.forEach((match: any) => {
      if (match.fixture.status.short === "FT") {
        if (match.teams.home.winner) {
          if (match.teams.home.id === teams.home.id) homeWins++;
          else awayWins++;
        } else if (match.teams.away.winner) {
          if (match.teams.away.id === teams.away.id) awayWins++;
          else homeWins++;
        } else {
          draws++;
        }
      }
    });

    return { homeWins, awayWins, draws };
  }, [filteredH2H, teams]);

  return (
    <div className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden">
      <div className="p-6">
        <h2 className="text-2xl font-bold text-white mb-4">
          {t("head_to_head")}
        </h2>
        <p className="italic text-[#a3a3a3] leading-relaxed mb-6">
          {h2hSeoDescription}
        </p>

        {filteredH2H.length === 0 ? (
          <p className="text-brand-muted text-center p-4">
            {t("no_h2h_matches_found")}
          </p>
        ) : (
          <>
            <div className="grid grid-cols-3 text-center gap-4 mb-6">
              <div className="flex flex-col items-center">
                <Image
                  src={proxyImageUrl(teams.home.logo)}
                  alt={teams.home.name}
                  width={50}
                  height={50}
                  className="w-12 h-12 object-contain mb-2"
                />
                <span className="text-white font-semibold text-lg">
                  {headToHeadRecords.homeWins}
                </span>
                <span className="text-brand-muted text-sm">{t("wins")}</span>
              </div>
              <div className="flex flex-col items-center justify-center">
                <span className="text-white font-semibold text-lg">
                  {headToHeadRecords.draws}
                </span>
                <span className="text-brand-muted text-sm">{t("draws")}</span>
              </div>
              <div className="flex flex-col items-center">
                <Image
                  src={proxyImageUrl(teams.away.logo)}
                  alt={teams.away.name}
                  width={50}
                  height={50}
                  className="w-12 h-12 object-contain mb-2"
                />
                <span className="text-white font-semibold text-lg">
                  {headToHeadRecords.awayWins}
                </span>
                <span className="text-brand-muted text-sm">{t("wins")}</span>
              </div>
            </div>

            <div className="space-y-3">
              {displayedH2H.map((match) => (
                <Link
                  key={match.fixture.id}
                  href={generateMatchSlug(
                    match.teams.home.name,
                    match.teams.away.name,
                    match.fixture.id
                  )}
                  className="block bg-gray-800/50 p-3 rounded-md hover:bg-gray-700/50 transition-colors duration-200"
                >
                  <div className="flex items-center justify-between text-sm">
                    <div className="flex items-center gap-2">
                      <CalendarDays size={16} className="text-brand-muted" />
                      <span className="text-brand-muted">
                        {format(new Date(match.fixture.date), "dd MMM yyyy")}
                      </span>
                    </div>
                    <div className="flex items-center gap-3">
                      <div className="flex items-center gap-2">
                        <Image
                          src={proxyImageUrl(match.teams.home.logo)}
                          alt={match.teams.home.name}
                          width={24}
                          height={24}
                          className="w-6 h-6 object-contain"
                        />
                        <span className="text-white font-medium">
                          {match.teams.home.name}
                        </span>
                        <span className="font-bold text-white text-lg">
                          {match.goals.home}
                        </span>
                      </div>
                      <span className="text-brand-muted"> - </span>
                      <div className="flex items-center gap-2">
                        <span className="font-bold text-white text-lg">
                          {match.goals.away}
                        </span>
                        <span className="text-white font-medium">
                          {match.teams.away.name}
                        </span>
                        <Image
                          src={proxyImageUrl(match.teams.away.logo)}
                          alt={match.teams.away.name}
                          width={24}
                          height={24}
                          className="w-6 h-6 object-contain"
                        />
                      </div>
                    </div>
                  </div>
                </Link>
              ))}
            </div>

            {filteredH2H.length > 5 && (
              <div className="text-center mt-6">
                <button
                  onClick={() => setShowAll(!showAll)}
                  className="bg-brand-purple text-white px-4 py-2 rounded-lg text-sm font-semibold hover:opacity-90 transition-opacity"
                >
                  {showAll
                    ? t("show_less")
                    : t("show_all_count", { count: filteredH2H.length })}
                </button>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
}

// ===== src/components/match/MatchHeader.tsx =====

"use client";

import Image from "next/image";
import { format } from "date-fns";
import { useMemo } from "react";
import {
  Clock,
  CalendarDays,
  Shield,
  Zap,
  Sparkles,
  CheckCircle,
  XCircle,
} from "lucide-react";
import Link from "next/link";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateLeagueSlug } from "@/lib/generate-league-slug";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import { useTranslation } from "@/hooks/useTranslation";

interface Team {
  id: number;
  name: string;
  logo: string;
  winner?: boolean | null;
}
interface Fixture {
  fixture: any;
  id: number;
  date: string;
  status: { long: string; short: any; elapsed: number | null };
  teams: { home: Team; away: Team };
  league: {
    id: number;
    name: string;
    country: string;
    logo: string;
    flag: string;
    season: number;
    round: string;
  };
  goals: { home: number | null; away: number | null };
  score: { fulltime: { home: number | null; away: number | null } };
}
interface MatchHeaderProps {
  fixture: Fixture;
  analytics: any;
}

const StatPill = ({
  icon: Icon,
  value,
  colorClass,
}: {
  icon: React.ElementType;
  value: string;
  colorClass: string;
}) => (
  <div
    className={`flex items-center gap-1.5 ${colorClass}/10 text-xs font-semibold ${colorClass} px-2 py-1 rounded-full`}
  >
    <Icon size={14} />
    <span>{value}</span>
  </div>
);

const PredictionResultWidget = ({
  result,
  teams,
  t,
}: {
  result: any;
  teams: { home: Team; away: Team };
  t: (key: string, params?: any) => string;
}) => {
  if (!result.predictedOutcome) {
    return (
      <div className="text-center text-xs text-text-muted py-4">
        {t("prediction_data_unavailable")}
      </div>
    );
  }

  const outcomeTranslations: Record<string, string> = {
    "Home Win": t("outcome_home_win"),
    "Away Win": t("outcome_away_win"),
    Draw: t("outcome_draw"),
  };

  const predictedOutcomeText =
    outcomeTranslations[result.predictedOutcome] || result.predictedOutcome;
  const actualOutcomeText = result.actualOutcome
    ? outcomeTranslations[result.actualOutcome] || result.actualOutcome
    : null;

  if (!result.isFinished) {
    const predictedTeam =
      result.predictedOutcome === "Home Win"
        ? teams.home
        : result.predictedOutcome === "Away Win"
        ? teams.away
        : null;
    return (
      <div className="w-full space-y-2 bg-[var(--brand-accent)]/5 p-3 rounded-lg text-center border border-[var(--brand-accent)]/20">
        <h4 className="text-xs font-bold text-[var(--brand-accent)] uppercase tracking-wider flex items-center justify-center gap-1.5">
          <Sparkles size={14} /> {t("fanskor_prediction")}
        </h4>
        <div className="flex items-center justify-center gap-2">
          {predictedTeam && (
            <Image
              src={proxyImageUrl(predictedTeam.logo)}
              alt={predictedTeam.name}
              width={24}
              height={24}
            />
          )}
          <p className="text-lg font-black text-white">
            {predictedOutcomeText}
          </p>
        </div>
        <p className="text-sm font-semibold text-text-muted">
          {t("confidence_percent", { confidence: result.confidence })}
        </p>
      </div>
    );
  }

  const wasCorrect = result.actualOutcome === result.predictedOutcome;
  const bgColor = wasCorrect ? "bg-green-500/10" : "bg-red-500/10";
  const textColor = wasCorrect ? "text-green-400" : "text-red-400";
  const Icon = wasCorrect ? CheckCircle : XCircle;

  return (
    <div className={`w-full space-y-2 ${bgColor} p-3 rounded-lg text-center`}>
      <h4
        className={`text-xs font-bold ${textColor} uppercase tracking-wider flex items-center justify-center gap-1.5`}
      >
        <Icon size={14} />{" "}
        {wasCorrect ? t("prediction_hit") : t("prediction_missed")}
      </h4>
      {wasCorrect ? (
        <p className="text-lg font-black text-white">{predictedOutcomeText}</p>
      ) : (
        <div className="text-sm text-white">
          <p>
            {t("predicted_label")}:{" "}
            <span className="font-bold">{predictedOutcomeText}</span>
          </p>
          <p className={`${textColor}`}>
            {t("actual_label")}:{" "}
            <span className="font-bold">{actualOutcomeText}</span>
          </p>
        </div>
      )}
    </div>
  );
};

export const MatchHeader: React.FC<MatchHeaderProps> = ({
  fixture,
  analytics,
}) => {
  const { t } = useTranslation();
  const { teams, league, fixture: fixtureDetails, goals, score } = fixture;

  const isLive = useMemo(
    () =>
      ["1H", "HT", "2H", "ET", "BT", "P", "LIVE"].includes(
        fixtureDetails.status?.short || ""
      ),
    [fixtureDetails.status?.short]
  );
  const isFinished = useMemo(
    () => ["FT", "AET", "PEN"].includes(fixtureDetails.status.short),
    [fixtureDetails.status.short]
  );

  const finalScoreHome = score?.fulltime?.home ?? goals?.home;
  const finalScoreAway = score?.fulltime?.away ?? goals?.away;

  const { homeStrength, awayStrength, predictionResult } = useMemo(() => {
    const homeStats = analytics?.homeTeamStats;
    const awayStats = analytics?.awayTeamStats;
    const calcRating = (stats: any) => {
      const avgFor = stats?.goals?.for?.average?.total ?? "1.0";
      const avgAgainst = stats?.goals?.against?.average?.total ?? "1.0";
      return {
        attack: Math.min(10, (parseFloat(avgFor) / 2.0) * 10).toFixed(1),
        defense: Math.min(10, (1.5 / parseFloat(avgAgainst)) * 10).toFixed(1),
      };
    };
    const pred = analytics?.customPrediction;
    let result = {
      isFinished,
      predictedOutcome: null,
      confidence: 0,
      actualOutcome: null,
    };
    if (pred) {
      const maxConfidence = Math.max(pred.home, pred.draw, pred.away);
      let predictedOutcome: "Home Win" | "Draw" | "Away Win" = "Draw";
      if (maxConfidence === pred.home) predictedOutcome = "Home Win";
      if (maxConfidence === pred.away) predictedOutcome = "Away Win";
      result.predictedOutcome = predictedOutcome;
      result.confidence = maxConfidence;
    }
    if (isFinished) {
      result.actualOutcome = teams.home.winner
        ? "Home Win"
        : teams.away.winner
        ? "Away Win"
        : "Draw";
    }
    return {
      homeStrength: calcRating(homeStats),
      awayStrength: calcRating(awayStats),
      predictionResult: result,
    };
  }, [analytics, isFinished, teams]);

  return (
    <div className="bg-brand-secondary rounded-lg overflow-hidden shadow-lg mb-4">
      <div className="p-3 bg-[var(--color-primary)]/50 flex flex-col sm:flex-row items-center justify-between gap-2 text-sm border-b border-gray-700/50">
        <Link
          href={generateLeagueSlug(league.name, league.id)}
          className="flex items-center gap-2 hover:opacity-80 transition-opacity"
        >
          {league.logo && (
            <Image
              src={proxyImageUrl(league.logo)}
              alt={league.name}
              width={24}
              height={24}
            />
          )}
          <span className="font-bold text-white">{league.name}</span>
        </Link>
        <div className="flex items-center gap-4 text-text-muted">
          <div className="flex items-center gap-1.5">
            <CalendarDays size={14} />
            <span>{format(new Date(fixtureDetails.date), "dd MMM yyyy")}</span>
          </div>
          <div className="flex items-center gap-1.5">
            <Clock size={14} />
            <span>{format(new Date(fixtureDetails.date), "HH:mm")}</span>
          </div>
        </div>
      </div>

      <div className="grid grid-cols-3 items-center p-4 md:p-6 gap-2 md:gap-4">
        <div className="flex flex-col items-center justify-start text-center gap-3">
          <Link href={generateTeamSlug(teams.home.name, teams.home.id)}>
            <Image
              src={proxyImageUrl(teams.home.logo)}
              alt={teams.home.name}
              width={80}
              height={80}
              className="w-16 h-16 md:w-20 md:h-20 object-contain hover:scale-110 transition-transform"
            />
          </Link>
          <h2 className="font-bold text-white text-lg md:text-xl truncate w-full">
            {teams.home.name}
          </h2>
          {homeStrength.attack && (
            <div className="flex items-center gap-2">
              <StatPill
                icon={Zap}
                value={homeStrength.attack}
                colorClass="text-green-400 bg-green-500"
              />
              <StatPill
                icon={Shield}
                value={homeStrength.defense}
                colorClass="text-blue-400 bg-blue-500"
              />
            </div>
          )}
        </div>

        <div className="flex flex-col items-center justify-center text-center gap-4">
          <span className="text-4xl md:text-5xl font-black text-white">
            {finalScoreHome ?? "?"} - {finalScoreAway ?? "?"}
          </span>
          <span
            className={`text-xs md:text-sm font-semibold px-3 py-1 rounded-full ${
              isLive
                ? "bg-green-500/20 text-green-400 animate-pulse"
                : "bg-[var(--color-primary)] text-text-muted"
            }`}
          >
            {fixtureDetails.status.long}{" "}
            {isLive && `(${fixtureDetails.status.elapsed}')`}
          </span>
          <PredictionResultWidget
            result={predictionResult}
            teams={teams}
            t={t}
          />
        </div>

        <div className="flex flex-col items-center justify-start text-center gap-3">
          <Link href={generateTeamSlug(teams.away.name, teams.away.id)}>
            <Image
              src={proxyImageUrl(teams.away.logo)}
              alt={teams.away.name}
              width={80}
              height={80}
              className="w-16 h-16 md:w-20 md:h-20 object-contain hover:scale-110 transition-transform"
            />
          </Link>
          <h2 className="font-bold text-white text-lg md:text-xl truncate w-full">
            {teams.away.name}
          </h2>
          {awayStrength.attack && (
            <div className="flex items-center gap-2">
              <StatPill
                icon={Zap}
                value={awayStrength.attack}
                colorClass="text-green-400 bg-green-500"
              />
              <StatPill
                icon={Shield}
                value={awayStrength.defense}
                colorClass="text-blue-400 bg-blue-500"
              />
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

// ===== src/components/match/MatchHighlightsWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Slider from "react-slick";
import { Film, ChevronLeft, ChevronRight } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";
import HighlightSlide from "../HighlightSlide";

import "slick-carousel/slick/slick.css";
import "slick-carousel/slick/slick-theme.css";

interface Highlight {
  id: string;
  embedUrl: string;
  title: string;
}

interface MatchHighlightsWidgetProps {
  fixtureId: string;
}

const fetchHighlights = async (
  fixtureId: string
): Promise<Highlight[] | null> => {
  try {
    const { data } = await axios.get(`/api/highlights?fixtureId=${fixtureId}`);
    return data?.highlights || data || null;
  } catch (error) {
    return null;
  }
};

const NextArrow = ({ onClick }: { onClick?: () => void }) => (
  <button
    onClick={onClick}
    className="absolute top-1/2 -right-4 z-10 p-2 bg-black/40 text-white rounded-full hover:bg-black/70 transition-colors transform -translate-y-1/2"
    aria-label="Next slide"
  >
    <ChevronRight size={24} />
  </button>
);
const PrevArrow = ({ onClick }: { onClick?: () => void }) => (
  <button
    onClick={onClick}
    className="absolute top-1/2 -left-4 z-10 p-2 bg-black/40 text-white rounded-full hover:bg-black/70 transition-colors transform -translate-y-1/2"
    aria-label="Previous slide"
  >
    <ChevronLeft size={24} />
  </button>
);

const SliderSkeleton = () => (
  <div className="animate-pulse">
    <div className="h-8 w-1/3 bg-gray-700 rounded mb-4"></div>
    <div className="aspect-video w-full rounded-lg bg-gray-700/50"></div>
  </div>
);

export default function MatchHighlightsWidget({
  fixtureId,
}: MatchHighlightsWidgetProps) {
  const { t } = useTranslation();

  const {
    data: highlights,
    isLoading,
    isError,
  } = useQuery<Highlight[] | null>({
    queryKey: ["matchHighlights", fixtureId],
    queryFn: () => fetchHighlights(fixtureId),
    staleTime: 1000 * 60 * 5,
    enabled: !!fixtureId,
  });

  const sliderSettings = {
    dots: false,
    infinite: highlights ? highlights.length > 1 : false,
    speed: 500,
    slidesToShow: 1,
    slidesToScroll: 1,
    arrows: true,
    nextArrow: <NextArrow />,
    prevArrow: <PrevArrow />,
    autoplay: true,
    autoplaySpeed: 8000,
    pauseOnHover: true,
  };

  if (isError || (!isLoading && (!highlights || highlights.length === 0))) {
    return null;
  }

  if (isLoading) {
    return <SliderSkeleton />;
  }

  return (
    <div className="w-full">
      <div className="mb-4">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2">
          <Film size={22} className="text-brand-purple" />
          {t("match_highlights_title")}
        </h2>
      </div>
      <div className="relative w-full">
        {" "}
        {}
        <Slider {...sliderSettings}>
          {highlights?.map((highlight) => (
            <HighlightSlide key={highlight.id} highlight={highlight} />
          ))}
        </Slider>
      </div>
    </div>
  );
}

// ===== src/components/match/MatchLineupsWidget.tsx =====

"use client";

import { memo } from "react";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import { Users } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

const mapFormationToPositions = (formation: string, startXI: any[]) => {
  if (!formation) {
    console.warn(
      `Invalid or missing formation string received. Using fallback grid layout.`
    );
    return startXI.map((p, i) => ({
      ...p,
      pos: { x: (i % 4) * 25 + 12.5, y: Math.floor(i / 4) * 25 + 15 },
    }));
  }
  const formationParts = formation.split("-").map(Number);
  if (formationParts.some(isNaN) || startXI.length < 11) {
    return startXI.map((p, i) => ({
      ...p,
      pos: { x: (i % 4) * 25 + 12.5, y: Math.floor(i / 4) * 25 + 15 },
    }));
  }
  const players = [...startXI];
  const positionedPlayers = [];
  const goalkeeper = players.find((p) => p.player.pos === "G");
  if (goalkeeper) {
    positionedPlayers.push({ ...goalkeeper, pos: { x: 50, y: 95 } });
  }
  const outfieldPlayers = players.filter((p) => p.player.pos !== "G").reverse();
  const totalRows = formationParts.length;
  let playerIndex = 0;
  formationParts.forEach((playersInRow, rowIndex) => {
    const y = 85 - ((rowIndex + 1) / (totalRows + 1)) * 75;
    const playersToPosition = outfieldPlayers.slice(
      playerIndex,
      playerIndex + playersInRow
    );
    playersToPosition.forEach((player, i) => {
      const x = (100 / (playersInRow + 1)) * (i + 1);
      positionedPlayers.push({ ...player, pos: { x, y } });
    });
    playerIndex += playersInRow;
  });
  return positionedPlayers;
};

const FootballPitch = ({
  team,
  positionedPlayers,
  colorClass,
}: {
  team: any;
  positionedPlayers: any[];
  colorClass: string;
}) => (
  <div
    className="relative aspect-[7/10] w-full rounded-lg overflow-hidden border border-white/10"
    style={{ background: "radial-gradient(circle, #057F3A 0%, #034F24 100%)" }}
  >
    <div className="absolute inset-0 z-0">
      <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[30%] aspect-square rounded-full border border-white/10"></div>
      <div className="absolute top-1/2 left-0 w-full h-px bg-white/10"></div>
      <div className="absolute top-0 left-[25%] w-[50%] h-[15%] rounded-b-md border-b border-l border-r border-white/10"></div>
    </div>
    <div className="absolute top-0 left-0 right-0 p-3 bg-gradient-to-b from-black/50 to-transparent z-20 flex justify-between items-center">
      <div className="flex items-center gap-2">
        <Image
          src={proxyImageUrl(team.team.logo)}
          alt={team.team.name}
          width={28}
          height={28}
        />
        <h3 className="font-bold text-base text-white">{team.team.name}</h3>
      </div>
      <span className="text-sm font-semibold text-text-muted bg-black/30 px-2 py-1 rounded-md">
        {team.formation || "N/A"}
      </span>
    </div>
    <div className="absolute inset-0 z-10">
      {positionedPlayers.map(({ player, pos }) => (
        <div
          key={player.id}
          className="absolute -translate-x-1/2 -translate-y-1/2 flex flex-col items-center gap-1 group cursor-pointer"
          style={{ top: `${pos.y}%`, left: `${pos.x}%` }}
          title={player.name}
        >
          <div
            className={`w-7 h-7 flex items-center justify-center rounded-full font-bold text-white text-xs shadow-md border-2 border-black/30 transition-all duration-200 group-hover:scale-110 group-hover:shadow-lg ${colorClass}`}
          >
            {player.number}
          </div>
          <span className="text-xs font-semibold text-white bg-black/60 px-1.5 py-0.5 rounded-full whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity duration-200">
            {player.name.split(" ").slice(-1)[0]}
          </span>
        </div>
      ))}
    </div>
  </div>
);

const SubsList = ({
  players,
  t,
}: {
  players: any[];
  t: (key: string) => string;
}) => {
  if (!players || players.length === 0) return null;
  return (
    <div className="bg-[var(--color-primary)]/50 p-3 rounded-lg mt-3">
      <h4 className="flex items-center gap-2 font-bold text-sm mb-2 text-text-muted">
        <Users size={16} /> {t("substitutes")}
      </h4>
      <div className="grid grid-cols-2 gap-x-4 gap-y-1.5 text-xs">
        {players.map((p: any) => (
          <div key={p.player.id} className="flex items-center gap-2 truncate">
            <span className="text-text-muted font-mono w-5 text-center">
              {p.player.number}
            </span>
            <span className="font-medium text-text-secondary truncate">
              {p.player.name}
            </span>
          </div>
        ))}
      </div>
    </div>
  );
};

const MatchLineupsWidget = memo(function MatchLineupsWidget({
  lineups,
}: {
  lineups: any[];
}) {
  const { t } = useTranslation();

  if (!lineups || lineups.length < 2) {
    return (
      <div className="bg-brand-secondary rounded-lg p-6 text-center">
        <h2 className="text-2xl font-bold text-white mb-2">
          {t("starting_lineups")}
        </h2>
        <p className="text-text-muted">{t("lineups_unavailable")}</p>
      </div>
    );
  }

  const homeLineup = lineups[0];
  const awayLineup = lineups[1];
  const homePositionedPlayers = mapFormationToPositions(
    homeLineup.formation,
    homeLineup.startXI
  );
  const awayPositionedPlayers = mapFormationToPositions(
    awayLineup.formation,
    awayLineup.startXI
  );

  return (
    <div className="bg-brand-secondary rounded-lg p-4 md:p-6">
      <h2 className="text-2xl font-bold text-white mb-4 text-center">
        {t("formations")}
      </h2>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <FootballPitch
            team={homeLineup}
            positionedPlayers={homePositionedPlayers}
            colorClass="bg-[var(--brand-accent)]"
          />
          <SubsList players={homeLineup.substitutes} t={t} />
        </div>
        <div>
          <FootballPitch
            team={awayLineup}
            positionedPlayers={awayPositionedPlayers}
            colorClass="bg-blue-600"
          />
          <SubsList players={awayLineup.substitutes} t={t} />
        </div>
      </div>
    </div>
  );
});

export default MatchLineupsWidget;

// ===== src/components/match/MatchPredictionWidget.tsx =====

"use client";

import { useMemo } from "react";
import { useTranslation } from "@/hooks/useTranslation";

interface PredictionData {
  home: number;
  draw: number;
  away: number;
}

interface MatchPredictionWidgetProps {
  apiPrediction: any;
  customPrediction: PredictionData | null;
  bookmakerOdds: any[];
  teams: { home: any; away: any };
}

const MAJOR_BOOKMAKER_IDS = new Set([1, 2, 6, 8, 9, 24, 31]);

const BookmakerOddsRow = ({
  bookmaker,
  bestOdds,
}: {
  bookmaker: any;
  bestOdds: any;
}) => {
  const matchWinnerBet = bookmaker.bets.find((bet: any) => bet.id === 1);
  if (!matchWinnerBet) return null;

  const odds = {
    home:
      matchWinnerBet.values.find((v: any) => v.value === "Home")?.odd || "-",
    draw:
      matchWinnerBet.values.find((v: any) => v.value === "Draw")?.odd || "-",
    away:
      matchWinnerBet.values.find((v: any) => v.value === "Away")?.odd || "-",
  };

  const highlightClass =
    "bg-yellow-500/20 text-brand-yellow ring-1 ring-yellow-500/50";
  const defaultClass = "bg-gray-700/50";

  return (
    <div className="grid grid-cols-4 gap-2 items-center text-sm py-2 border-b border-gray-700/50 last:border-b-0">
      <span className="col-span-1 font-semibold text-brand-light truncate pr-2">
        {bookmaker.name}
      </span>
      <span
        className={`col-span-1 text-center font-mono rounded p-1.5 transition-colors ${
          odds.home === bestOdds.home ? highlightClass : defaultClass
        }`}
      >
        {odds.home}
      </span>
      <span
        className={`col-span-1 text-center font-mono rounded p-1.5 transition-colors ${
          odds.draw === bestOdds.draw ? highlightClass : defaultClass
        }`}
      >
        {odds.draw}
      </span>
      <span
        className={`col-span-1 text-center font-mono rounded p-1.5 transition-colors ${
          odds.away === bestOdds.away ? highlightClass : defaultClass
        }`}
      >
        {odds.away}
      </span>
    </div>
  );
};

export default function MatchPredictionWidget({
  apiPrediction,
  customPrediction,
  bookmakerOdds,
  teams,
}: MatchPredictionWidgetProps) {
  const { t } = useTranslation();

  const majorBookmakers = useMemo(() => {
    if (!bookmakerOdds) return [];
    return bookmakerOdds.filter((bookie) => MAJOR_BOOKMAKER_IDS.has(bookie.id));
  }, [bookmakerOdds]);

  const { bestOdds } = useMemo(() => {
    if (!majorBookmakers || majorBookmakers.length === 0) {
      return { bestOdds: null };
    }

    let maxHome = 0,
      maxDraw = 0,
      maxAway = 0;

    majorBookmakers.forEach((bookie) => {
      const bet = bookie.bets.find((b: any) => b.id === 1);
      if (bet) {
        const homeOdd = parseFloat(
          bet.values.find((v: any) => v.value === "Home")?.odd || "0"
        );
        const drawOdd = parseFloat(
          bet.values.find((v: any) => v.value === "Draw")?.odd || "0"
        );
        const awayOdd = parseFloat(
          bet.values.find((v: any) => v.value === "Away")?.odd || "0"
        );
        if (homeOdd > maxHome) maxHome = homeOdd;
        if (drawOdd > maxDraw) maxDraw = drawOdd;
        if (awayOdd > maxAway) maxAway = awayOdd;
      }
    });

    return {
      bestOdds: {
        home: maxHome.toFixed(2),
        draw: maxDraw.toFixed(2),
        away: maxAway.toFixed(2),
      },
    };
  }, [majorBookmakers]);

  return (
    <div className="bg-brand-secondary p-4 rounded-lg">
      <div className="flex items-center gap-2 mb-4">
        <h3 className="text-lg font-bold text-white">
          {t("prediction_comparison")}
        </h3>
      </div>

      {majorBookmakers && majorBookmakers.length > 0 && bestOdds && (
        <div className="mt-4 pt-4 border-t border-gray-700/50">
          <h4 className="font-semibold text-brand-light mb-2">
            {t("compare_bookmakers", { count: majorBookmakers.length })}
          </h4>
          <div className="grid grid-cols-4 gap-2 text-xs text-brand-muted font-bold mb-1">
            <span className="col-span-1">{t("bookmaker")}</span>
            <span className="col-span-1 text-center">
              {t("odd_label_home")}
            </span>
            <span className="col-span-1 text-center">
              {t("odd_label_draw")}
            </span>
            <span className="col-span-1 text-center">
              {t("odd_label_away")}
            </span>
          </div>
          <div className="space-y-1">
            {majorBookmakers.map((bookie) => (
              <BookmakerOddsRow
                key={bookie.id}
                bookmaker={bookie}
                bestOdds={bestOdds}
              />
            ))}
          </div>
        </div>
      )}
    </div>
  );
}

// ===== src/components/match/MatchStatsWidget.tsx =====

"use client";

import { memo } from "react";
import { BarChart3, Info } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface MatchStatsWidgetProps {
  statistics: any[];
  teams: { home: any; away: any };
}

const StatRow = memo(
  ({
    stat,
    homeValue,
    awayValue,
  }: {
    stat: string;
    homeValue: string | number;
    awayValue: string | number;
  }) => {
    const homeNum = parseFloat(String(homeValue).replace("%", "")) || 0;
    const awayNum = parseFloat(String(awayValue).replace("%", "")) || 0;
    const total = homeNum + awayNum;
    const homePercent = total > 0 ? (homeNum / total) * 100 : 50;

    return (
      <div className="space-y-1.5">
        <div className="flex justify-between items-center text-sm px-1">
          <span className="font-bold text-white w-1/4 text-left">
            {homeValue ?? 0}
          </span>
          <span className="text-text-muted w-1/2 text-center">{stat}</span>
          <span className="font-bold text-white w-1/4 text-right">
            {awayValue ?? 0}
          </span>
        </div>
        <div className="flex w-full h-2 rounded-full overflow-hidden bg-[var(--color-primary)]">
          <div
            className="bg-[var(--brand-accent)] rounded-l-full"
            style={{ width: `${homePercent}%` }}
          ></div>
          <div
            className="bg-blue-500 rounded-r-full"
            style={{ width: `${100 - homePercent}%` }}
          ></div>
        </div>
      </div>
    );
  }
);
StatRow.displayName = "StatRow";

const MatchStatsWidget = memo(function MatchStatsWidget({
  statistics,
  teams,
}: MatchStatsWidgetProps) {
  const { t } = useTranslation();

  if (!statistics || statistics.length < 2) {
    return (
      <div className="bg-brand-secondary rounded-lg p-6">
        <h2 className="text-xl font-bold text-white mb-4 flex items-center gap-2">
          <BarChart3 size={22} /> {t("match_statistics")}
        </h2>
        <div className="text-center py-6 text-brand-muted">
          <Info size={28} className="mx-auto mb-2" />
          <p>{t("live_stats_unavailable")}</p>
        </div>
      </div>
    );
  }

  const homeStats =
    statistics.find((s) => s.team.id === teams.home.id)?.statistics || [];
  const awayStats =
    statistics.find((s) => s.team.id === teams.away.id)?.statistics || [];

  const allStatTypes = Array.from(
    new Set([
      ...homeStats.map((s: any) => s.type),
      ...awayStats.map((s: any) => s.type),
    ])
  );

  return (
    <div className="bg-brand-secondary rounded-lg p-4 md:p-6">
      <h2 className="text-xl font-bold text-white mb-6 flex items-center gap-2">
        <BarChart3 size={22} /> {t("match_statistics")}
      </h2>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-5">
        {allStatTypes.map((type) => {
          const homeStat =
            homeStats.find((s: any) => s.type === type)?.value ?? 0;
          const awayStat =
            awayStats.find((s: any) => s.type === type)?.value ?? 0;

          return (
            <StatRow
              key={type}
              stat={type}
              homeValue={homeStat}
              awayValue={awayStat}
            />
          );
        })}
      </div>
    </div>
  );
});

export default MatchStatsWidget;

// ===== src/components/match/MatchStatusBanner.tsx =====

"use client";

import { memo } from "react";
import { format } from "date-fns";
import { useTranslation } from "@/hooks/useTranslation";

interface MatchStatusBannerProps {
  fixture: any;
}

const MatchStatusBanner = memo(function MatchStatusBanner({
  fixture,
}: MatchStatusBannerProps) {
  const { t } = useTranslation();
  const status = fixture.fixture.status;

  let content = <p>{status.long}</p>;
  let bgClass = "bg-gray-600";

  switch (status.short) {
    case "TBD":
    case "NS":
      content = (
        <p>
          {t("status_upcoming")} -{" "}
          {format(new Date(fixture.fixture.date), "HH:mm")}
        </p>
      );
      bgClass = "bg-blue-600";
      break;
    case "1H":
    case "HT":
    case "2H":
    case "ET":
    case "P":
      content = (
        <p className="animate-pulse">
          {status.elapsed}' - {status.long}
        </p>
      );
      bgClass = "bg-red-600";
      break;
    case "FT":
    case "AET":
    case "PEN":
      content = <p>{t("status_full_time")}</p>;
      bgClass = "bg-gray-800";
      break;
  }

  return (
    <div
      className={`text-center font-bold text-white py-2 rounded-b-xl text-sm tracking-wider mb-8 ${bgClass}`}
    >
      {content}
    </div>
  );
});

export default MatchStatusBanner;

// ===== src/components/match/TeamFormWidget.tsx =====

"use client";

import { useMemo } from "react";
import { TrendingUp, Shield, BarChart2, Info } from "lucide-react";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useTranslation } from "@/hooks/useTranslation";

interface TeamFormWidgetProps {
  teamStats: any;
  team: any;
  location: "Home" | "Away";
  h2hData: any[];
}

const StatRow = ({
  label,
  value,
  highlight = false,
}: {
  label: string;
  value: string | number;
  highlight?: boolean;
}) => (
  <div className="flex justify-between items-center text-sm py-1.5">
    <span className="text-brand-muted">{label}</span>
    <span
      className={`font-bold ${highlight ? "text-brand-purple" : "text-white"}`}
    >
      {value}
    </span>
  </div>
);
const FormPill = ({ result }: { result: "W" | "D" | "L" }) => {
  const styles = {
    W: "bg-green-500/80 text-white",
    D: "bg-yellow-500/80 text-white",
    L: "bg-red-500/80 text-white",
  };
  return (
    <div
      className={`w-6 h-6 flex items-center justify-center rounded-full font-bold text-xs ${styles[result]}`}
    >
      {result}
    </div>
  );
};

export default function TeamFormWidget({
  teamStats,
  team,
  location,
  h2hData,
}: TeamFormWidgetProps) {
  const { t } = useTranslation();

  const { formString, detailedStats } = useMemo(() => {
    let form = "";
    let stats = null;

    if (teamStats?.form) {
      form = teamStats.form;
      stats = {
        fixtures: teamStats.fixtures,
        goals: teamStats.goals,
      };
    }

    else if (h2hData) {
      const teamFixtures = h2hData
        .filter(
          (m: any) => m.teams.home.id === team.id || m.teams.away.id === team.id
        )
        .sort(
          (a: any, b: any) =>
            new Date(b.fixture.date).getTime() - new Date(a.fixture.date).getTime()
        )
        .slice(0, 10);

      form = teamFixtures.map((match: any) => {
        const isHome = match.teams.home.id === team.id;
        if (match.teams.home.winner) return isHome ? 'W' : 'L';
        if (match.teams.away.winner) return isHome ? 'L' : 'W';
        return 'D';
      }).reverse().join('');
    }

    return { formString: form, detailedStats: stats };
  }, [teamStats, h2hData, team.id]);

  if (!formString && !detailedStats) {
    return (
      <div className="bg-brand-secondary p-4 rounded-lg">
        <h3 className="text-lg font-bold text-white mb-2">
          {t("form_and_stats_title", { location })}
        </h3>
        <p className="text-sm text-brand-muted text-center py-4">
          {t("stats_unavailable_for_team")}
        </p>
      </div>
    );
  }

  const formArray = formString.slice(-10).split("");

  return (
    <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
      {}
      <div className="flex items-center gap-3">
        <Image
          src={proxyImageUrl(team.logo)}
          alt={team.name}
          width={40}
          height={40}
        />
        <div>
          <p className="text-xs text-brand-muted">
            {location === "Home" ? t("home_team") : t("away_team")}
          </p>
          <h3 className="text-lg font-bold text-white">{team.name}</h3>
        </div>
      </div>

      {}
      {formArray.length > 0 && (
        <div>
          <h4 className="font-semibold text-brand-light mb-2 flex items-center gap-2">
            <TrendingUp size={16} />{" "}
            {t("recent_form_count", { count: formArray.length })}
          </h4>
          <div className="flex items-center gap-1.5">
            {formArray.map((result: "W" | "D" | "L", index: number) => (
              <FormPill key={index} result={result} />
            ))}
          </div>
        </div>
      )}

      {}
      {detailedStats ? (
        <>
          <div>
            <h4 className="font-semibold text-brand-light mb-1 flex items-center gap-2">
              <BarChart2 size={16} /> {t("performance_title")}
            </h4>
            <div className="bg-gray-800/50 p-2 rounded-md">
              <StatRow
                label={t("matches_played")}
                value={`${detailedStats.fixtures.played.home} (${t("home_short")}) / ${detailedStats.fixtures.played.away} (${t("away_short")})`}
              />
              <StatRow
                label={t("wins")}
                value={`${detailedStats.fixtures.wins.home} (${t("home_short")}) / ${detailedStats.fixtures.wins.away} (${t("away_short")})`}
              />
              <StatRow
                label={t("draws")}
                value={`${detailedStats.fixtures.draws.home} (${t("home_short")}) / ${detailedStats.fixtures.draws.away} (${t("away_short")})`}
              />
              <StatRow
                label={t("losses")}
                value={`${detailedStats.fixtures.loses.home} (${t("home_short")}) / ${detailedStats.fixtures.loses.away} (${t("away_short")})`}
              />
            </div>
          </div>
          <div>
            <h4 className="font-semibold text-brand-light mb-1 flex items-center gap-2">
              <Shield size={16} /> {t("goal_analysis_title")}
            </h4>
            <div className="bg-gray-800/50 p-2 rounded-md">
              <StatRow
                label={t("goals_for")}
                value={detailedStats.goals.for.total.total}
                highlight
              />
              <StatRow
                label={t("goals_against")}
                value={detailedStats.goals.against.total.total}
              />
              <StatRow
                label={t("avg_scored")}
                value={detailedStats.goals.for.average.total}
              />
              <StatRow
                label={t("avg_conceded")}
                value={detailedStats.goals.against.average.total}
              />
            </div>
          </div>
        </>
      ) : (
        <div className="text-center p-3 bg-gray-800/50 rounded-md">
           <Info size={18} className="mx-auto text-brand-muted mb-2" />
           <p className="text-sm text-brand-muted">{t("detailed_stats_unavailable")}</p>
        </div>
      )}
    </div>
  );
}

// ===== src/components/match/TeamStandingsWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { useMemo } from "react";
import Image from "next/image";
import { ChevronRight, Trophy } from "lucide-react";
import Link from "next/link";
import { generateLeagueSlug } from "@/lib/generate-league-slug";
import { generateTeamSlug } from "@/lib/generate-team-slug";

interface TeamStanding {
  rank: number;
  team: { id: number; name: string; logo: string };
  points: number;
  goalsDiff: number;
  all: { played: number; win: number; draw: number; lose: number };
  description: string | null;
  group: string;
}

interface LeagueInfo {
  id: number;
  name: string;
  logo: string;
  type: string;
  href: string;
}

interface StandingsResponse {
  league: LeagueInfo | null;
  standings: TeamStanding[][];
}

interface TeamStandingsWidgetProps {
  leagueId: number;
  season: number;
  homeTeamId: number;
  awayTeamId: number;
  standingsSeoDescription: string;
}

const fetchStandings = async (
  leagueId: number,
  season: number
): Promise<StandingsResponse> => {
  const { data } = await axios.get(
    `/api/standings?league=${leagueId}&season=${season}`
  );
  return data;
};

export default function TeamStandingsWidget({
  leagueId,
  season,
  homeTeamId,
  awayTeamId,
  standingsSeoDescription,
}: TeamStandingsWidgetProps) {
  const {
    data: standingsData,
    isLoading,
    isError,
  } = useQuery<StandingsResponse>({
    queryKey: ["standings", leagueId, season],
    queryFn: () => fetchStandings(leagueId, season),
    enabled: !!leagueId && !!season,
    staleTime: 1000 * 60 * 5,
  });

  const allStandings = useMemo(() => {

    return standingsData?.standings ? standingsData.standings.flat() : [];
  }, [standingsData]);

  const homeTeamRank = useMemo(() => {
    return allStandings.find((s) => s.team.id === homeTeamId);
  }, [allStandings, homeTeamId]);

  const awayTeamRank = useMemo(() => {
    return allStandings.find((s) => s.team.id === awayTeamId);
  }, [allStandings, awayTeamId]);

  const relevantStandings = useMemo(() => {
    if (!homeTeamRank || !awayTeamRank) return [];

    const ranksToShow = new Set<number>();
    ranksToShow.add(homeTeamRank.rank);
    ranksToShow.add(awayTeamRank.rank);

    const sortedRanks = Array.from(ranksToShow).sort((a, b) => a - b);
    const minRank = Math.max(1, sortedRanks[0] - 2);
    const maxRank = sortedRanks[sortedRanks.length - 1] + 2;

    const filteredAndSorted = allStandings
      .filter((s) => s.rank >= minRank && s.rank <= maxRank)
      .sort((a, b) => a.rank - b.rank)
      .slice(0, 5);

    if (!filteredAndSorted.some((s) => s.team.id === homeTeamId)) {
      filteredAndSorted.push(homeTeamRank);
    }
    if (!filteredAndSorted.some((s) => s.team.id === awayTeamId)) {
      filteredAndSorted.push(awayTeamRank);
    }

    return Array.from(new Set(filteredAndSorted)).sort(
      (a, b) => a.rank - b.rank
    );
  }, [homeTeamRank, awayTeamRank, allStandings, homeTeamId, awayTeamId]);

  if (isLoading)
    return (
      <div className="bg-brand-dark rounded-lg p-6 shadow-lg animate-pulse">
        <div className="h-6 w-3/4 bg-gray-700 rounded mb-4"></div>
        <div className="h-4 w-1/2 bg-gray-600 rounded mb-4"></div>
        <div className="space-y-2">
          <div className="h-8 bg-gray-700 rounded"></div>
          <div className="h-8 bg-gray-700 rounded"></div>
          <div className="h-8 bg-gray-700 rounded"></div>
        </div>
      </div>
    );
  if (isError)
    return (
      <div className="bg-brand-dark rounded-lg p-6 text-red-400">
        Failed to load standings.
      </div>
    );
  if (!standingsData?.league)
    return (
      <div className="bg-brand-secondary rounded-lg p-6 text-brand-muted">
        No standings available for this league.
      </div>
    );

  const league = standingsData.league;

  return (
    <div className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden">
      <div className="p-6">
        <h2 className="text-2xl font-bold text-white mb-4">League Standings</h2>
        <Link
          href={league.href}
          className="flex items-center gap-3 mb-6 hover:text-white transition-colors"
        >
          <Image src={league.logo} alt={league.name} width={30} height={30} />
          <span className="text-xl font-semibold">{league.name}</span>
          <ChevronRight size={20} className="text-brand-muted" />
        </Link>

        {}
        <p className="italic text-[#a3a3a3] leading-relaxed mb-6 ">
          {standingsSeoDescription}
        </p>

        <div className="overflow-x-auto">
          <table className="w-full text-left text-brand-light text-sm">
            <thead className="bg-gray-800/50 text-xs text-brand-muted uppercase">
              <tr>
                <th className="p-3">#</th>
                <th className="p-3">Takm</th>
                <th className="p-3">O</th>
                <th className="p-3">G</th>
                <th className="p-3">B</th>
                <th className="p-3">M</th>
                <th className="p-3">Av.</th>
                <th className="p-3">P</th>
              </tr>
            </thead>
            <tbody>
              {relevantStandings.map((teamStanding) => (
                <tr
                  key={teamStanding.team.id}
                  className={`border-t border-gray-700/50 ${
                    teamStanding.team.id === homeTeamId ||
                    teamStanding.team.id === awayTeamId
                      ? "bg-brand-dark font-bold"
                      : ""
                  }`}
                >
                  <td className="p-3">{teamStanding.rank}</td>
                  <td className="p-3 flex items-center gap-2">
                    <Image
                      src={teamStanding.team.logo}
                      alt={teamStanding.team.name}
                      width={20}
                      height={20}
                      className="w-5 h-5 object-contain"
                    />
                    <Link
                      href={generateTeamSlug(
                        teamStanding.team.name,
                        teamStanding.team.id
                      )}
                      className="hover:text-white"
                    >
                      {teamStanding.team.name}
                    </Link>
                  </td>
                  <td className="p-3">{teamStanding.all.played}</td>
                  <td className="p-3">{teamStanding.all.win}</td>
                  <td className="p-3">{teamStanding.all.draw}</td>
                  <td className="p-3">{teamStanding.all.lose}</td>
                  <td className="p-3">{teamStanding.goalsDiff}</td>
                  <td className="p-3">{teamStanding.points}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/match/WinProbability.tsx =====

"use client";
import { memo } from 'react';
import { CircularProgressbar, buildStyles } from 'react-circular-progressbar';
import 'react-circular-progressbar/dist/styles.css';

const WinProbability = memo(function WinProbability({ home, draw, away }: { home: number, draw: number, away: number }) {
    const homeColor = '#8B5CF6';
    const awayColor = '#3B82F6';

    return (
        <div className="w-32 h-32 relative">
            <div className="absolute inset-0 transform scale-75">
                <CircularProgressbar
                    value={away}
                    styles={buildStyles({
                        pathColor: awayColor,
                        trailColor: 'transparent',
                        pathTransitionDuration: 0.5,
                    })}
                />
            </div>
            <CircularProgressbar
                value={home + draw}
                counterClockwise
                styles={buildStyles({
                    pathColor: homeColor,
                    trailColor: 'transparent',
                    pathTransitionDuration: 0.5,
                })}
            />
            <div className="absolute inset-0 flex flex-col items-center justify-center">
                <p className="text-xs text-brand-muted">DRAW</p>
                <p className="font-black text-2xl text-white">{draw}%</p>
            </div>
        </div>
    );
});
export default WinProbability;

// ===== src/components/tabs/LineupsTab.tsx =====

import Image from 'next/image';

const PlayerList = ({ title, players }: { title: string, players: any[] }) => (
  <div>
    <h4 className="font-bold text-lg mb-2 text-brand-muted">{title}</h4>
    <ul className="space-y-3">
      {players.map((p: any) => (
        <li key={p.player.id} className="flex items-center gap-3">
          <span className="text-brand-muted font-mono w-6 text-center">{p.player.number}</span>
          <span>{p.player.name}</span>
        </li>
      ))}
    </ul>
  </div>
);

export default function LineupsTab({ lineups }: { lineups: any[] }) {
  if (!lineups || lineups.length < 2) {
    return <p className="text-brand-muted text-center py-8">Lineups are not yet available.</p>;
  }

  const homeLineup = lineups[0];
  const awayLineup = lineups[1];

  return (
    <div className="p-4 grid grid-cols-1 md:grid-cols-2 gap-8">
      {}
      <div>
        <div className="flex items-center gap-3 mb-4">
          <Image src={homeLineup.team.logo} alt={homeLineup.team.name} width={32} height={32}/>
          <h3 className="font-bold text-xl">{homeLineup.team.name}</h3>
        </div>
        <p className="mb-4 text-brand-muted">Formation: {homeLineup.formation}</p>
        <PlayerList title="Starting XI" players={homeLineup.startXI} />
        <PlayerList title="Substitutes" players={homeLineup.substitutes} />
      </div>
      {}
      <div>
        <div className="flex items-center gap-3 mb-4">
          <Image src={awayLineup.team.logo} alt={awayLineup.team.name} width={32} height={32}/>
          <h3 className="font-bold text-xl">{awayLineup.team.name}</h3>
        </div>
        <p className="mb-4 text-brand-muted">Formation: {awayLineup.formation}</p>
        <PlayerList title="Starting XI" players={awayLineup.startXI} />
        <PlayerList title="Substitutes" players={awayLineup.substitutes} />
      </div>
    </div>
  );
}

// ===== src/components/tabs/StatsTab.tsx =====

import { BarChart2 } from 'lucide-react';

export default function StatsTab({ statistics, teams }: { statistics: any[], teams: any }) {
  if (!statistics || statistics.length < 2) {
    return <p className="text-brand-muted text-center py-8">Statistics are not available for this match.</p>;
  }

  const homeStats = statistics.find((s: any) => s.team.id === teams.home.id)?.statistics || [];
  const awayStats = statistics.find((s: any) => s.team.id === teams.away.id)?.statistics || [];

  const allStatTypes = Array.from(new Set([...homeStats.map((s: any) => s.type), ...awayStats.map((s: any) => s.type)]));

  return (
    <div className="space-y-4 p-4">
      {allStatTypes.map((type) => {
        const homeStat = homeStats.find((s: any) => s.type === type)?.value ?? 0;
        const awayStat = awayStats.find((s: any) => s.type === type)?.value ?? 0;
        const total = (Number(homeStat) || 0) + (Number(awayStat) || 0);
        const homePercent = total > 0 ? ((Number(homeStat) || 0) / total) * 100 : 50;

        return (
          <div key={type}>
            <div className="flex justify-between items-center mb-1 text-sm font-semibold">
              <span>{homeStat ?? 0}</span>
              <span className="text-brand-muted">{type}</span>
              <span>{awayStat ?? 0}</span>
            </div>
            <div className="flex w-full h-2 rounded-full overflow-hidden bg-gray-700">
              <div className="bg-brand-purple" style={{ width: `${homePercent}%` }}></div>
              <div className="bg-blue-600" style={{ width: `${100 - homePercent}%` }}></div>
            </div>
          </div>
        );
      })}
    </div>
  );
}

// ===== src/components/team/TeamFixturesWidget.tsx =====

"use client";

import { useState, useMemo } from "react";
import { Info, CalendarClock } from "lucide-react";
import MatchListItem, { MatchListItemSkeleton } from "../MatchListItem";
import { useTranslation } from "@/hooks/useTranslation";

interface TeamFixturesWidgetProps {
  fixtures: any[];
}

export default function TeamFixturesWidget({
  fixtures,
}: TeamFixturesWidgetProps) {
  const [activeTab, setActiveTab] = useState<"upcoming" | "results">(
    "upcoming"
  );
  const { t } = useTranslation();

  const filteredMatches = useMemo(() => {
    if (!fixtures) return [];

    const sortedFixtures = [...fixtures].sort(
      (a, b) =>
        new Date(a.fixture.date).getTime() - new Date(b.fixture.date).getTime()
    );

    if (activeTab === "upcoming") {
      return sortedFixtures.filter(
        (m: any) => !["FT", "AET", "PEN"].includes(m.fixture.status.short)
      );
    } else {
      return sortedFixtures
        .filter((m: any) =>
          ["FT", "AET", "PEN"].includes(m.fixture.status.short)
        )
        .reverse();
    }
  }, [fixtures, activeTab]);

  return (
    <div className="bg-brand-secondary rounded-xl">
      <div className="flex justify-between items-center p-4 border-b border-gray-700/50">
        <h3 className="text-xl font-bold text-white flex items-center gap-2">
          <CalendarClock size={22} />
          {t("match_schedule")}
        </h3>
        <div className="flex items-center gap-1 bg-[var(--color-primary)] p-1 rounded-lg">
          <button
            onClick={() => setActiveTab("upcoming")}
            className={`px-3 py-1 text-sm rounded-md font-semibold transition-colors ${
              activeTab === "upcoming"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700"
            }`}
          >
            {t("upcoming")}
          </button>
          <button
            onClick={() => setActiveTab("results")}
            className={`px-3 py-1 text-sm rounded-md font-semibold transition-colors ${
              activeTab === "results"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700"
            }`}
          >
            {t("results")}
          </button>
        </div>
      </div>

      <div className="p-2 space-y-2 max-h-[800px] overflow-y-auto custom-scrollbar">
        {!fixtures || fixtures.length === 0 ? (
          <div className="text-center py-20 text-brand-muted">
            <Info size={32} className="mx-auto mb-3" />
            <p className="font-semibold">{t("fixture_data_unavailable")}</p>
          </div>
        ) : filteredMatches.length > 0 ? (
          filteredMatches.map((match: any) => (
            <MatchListItem key={match.fixture.id} match={match} />
          ))
        ) : (
          <div className="text-center py-20 text-brand-muted">
            <Info size={32} className="mx-auto mb-3" />
            <p className="font-semibold">
              {t("no_matches_found_for_tab", { tab: activeTab })}
            </p>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/team/TeamHeader.tsx =====

import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import { Calendar } from "lucide-react";

export default function TeamHeader({
  team,
  countryFlag,
  foundedText,
}: {
  team: any;
  countryFlag: string;
  foundedText: string;
}) {
  return (
    <div className="bg-brand-secondary p-6 rounded-lg mb-8 flex flex-col md:flex-row items-center gap-6">
      <div className="relative">
        <Image
          src={proxyImageUrl(team.logo)}
          alt={`${team.name} logo`}
          width={96}
          height={96}
        />
        {countryFlag && (
          <Image
            src={proxyImageUrl(countryFlag)}
            alt={team.country}
            width={32}
            height={32}
            className="rounded-full absolute -bottom-2 -right-2 border-2 border-brand-secondary"
          />
        )}
      </div>
      <div>
        <h1 className="text-4xl md:text-5xl font-extrabold text-white text-center md:text-left">
          {team.name}
        </h1>
        {team.founded && (
          <div className="flex items-center gap-2 text-brand-muted justify-center md:justify-start mt-2">
            <Calendar size={14} />
            {}
            <span>{foundedText}</span>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/team/TeamInfoWidget.tsx =====

"use client";

import { MapPin, Users } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

const InfoRow = ({
  icon: Icon,
  label,
  value,
}: {
  icon: React.ElementType;
  label: string;
  value: string | number;
}) => (
  <div className="flex justify-between items-center text-sm py-2 border-b border-gray-700/50 last:border-b-0">
    <div className="flex items-center gap-2 text-brand-muted">
      <Icon size={14} />
      <span>{label}</span>
    </div>
    <span className="font-semibold text-white text-right">{value}</span>
  </div>
);

export default function TeamInfoWidget({ venue }: { venue: any }) {
  const { t } = useTranslation();

  return (
    <div className="bg-brand-secondary p-4 rounded-lg">
      <h3 className="text-lg font-bold text-white mb-2">
        {t("venue_information")}
      </h3>
      <div className="space-y-1">
        <InfoRow
          icon={MapPin}
          label={t("stadium")}
          value={venue.name || t("not_available_short")}
        />
        <InfoRow
          icon={MapPin}
          label={t("city")}
          value={venue.city || t("not_available_short")}
        />
        <InfoRow
          icon={Users}
          label={t("capacity")}
          value={venue.capacity?.toLocaleString() || t("not_available_short")}
        />
      </div>
    </div>
  );
}

// ===== src/components/team/TeamSquadWidget.tsx =====

"use client";

import { useState, useMemo } from "react";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import { Users, Shield, Zap, Goal, UserCircle } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

const PlayerCard = ({ player }: { player: any }) => {
  return (
    <div className="bg-[var(--color-primary)] rounded-lg overflow-hidden group relative transition-all duration-300 transform hover:-translate-y-1 hover:shadow-2xl hover:shadow-[var(--brand-accent)]/20">
      <span className="absolute top-2 right-2 text-4xl font-black text-white/10 group-hover:text-white/20 transition-colors duration-300">
        {player.number || "N/A"}
      </span>

      <div className="flex flex-col items-center p-4">
        <div className="relative w-24 h-24 mb-3">
          <Image
            src={proxyImageUrl(player.photo)}
            alt={player.name}
            layout="fill"
            objectFit="contain"
            className="drop-shadow-lg transition-transform duration-300 group-hover:scale-110"
          />
        </div>
        <h4 className="font-bold text-lg text-white text-center truncate w-full">
          {player.name}
        </h4>
        <p className="text-sm text-text-muted">{player.position}</p>
      </div>

      <div className="bg-black/20 p-2 grid grid-cols-2 gap-2 text-center text-xs">
        <div className="text-text-secondary">
          <strong className="text-white">{player.age}</strong> years
        </div>
        <div className="text-text-secondary truncate">
          <strong className="text-white">{player.nationality}</strong>
        </div>
      </div>
    </div>
  );
};

export default function TeamSquadWidget({ squad }: { squad: any[] }) {
  const [filter, setFilter] = useState("All");
  const { t } = useTranslation();

  const filteredSquad = useMemo(() => {
    if (filter === "All") return squad;
    return squad.filter((p) => p.position === filter);
  }, [squad, filter]);

  const squadSummary = useMemo(() => {
    if (!squad || squad.length === 0) return { count: 0, avgAge: 0 };
    const totalAge = squad.reduce((acc, p) => acc + (p.age || 0), 0);
    return {
      count: squad.length,
      avgAge: (totalAge / squad.length).toFixed(1),
    };
  }, [squad]);

  const filterButtons = [
    { label: t("filter_all"), value: "All", icon: Users },
    {
      label: t("squad_filter_goalkeeper"),
      value: "Goalkeeper",
      icon: UserCircle,
    },
    { label: t("squad_filter_defender"), value: "Defender", icon: Shield },
    { label: t("squad_filter_midfielder"), value: "Midfielder", icon: Zap },
    { label: t("squad_filter_attacker"), value: "Attacker", icon: Goal },
  ];

  return (
    <div className="bg-brand-secondary rounded-lg p-4 md:p-6">
      <div className="flex flex-col sm:flex-row justify-between sm:items-center gap-4 mb-6">
        <h2 className="text-xl font-bold text-white flex items-center gap-2">
          <Users size={22} /> {t("full_squad")}
        </h2>
        <div className="flex items-center gap-4">
          <div className="text-right">
            <p className="text-xs text-text-muted">{t("total_players")}</p>
            <p className="font-bold text-white">{squadSummary.count}</p>
          </div>
          <div className="text-right">
            <p className="text-xs text-text-muted">{t("average_age")}</p>
            <p className="font-bold text-white">{squadSummary.avgAge}</p>
          </div>
        </div>
      </div>

      <div className="flex flex-wrap items-center gap-2 p-1 rounded-lg bg-[var(--color-primary)] mb-6">
        {filterButtons.map(({ label, value, icon: Icon }) => (
          <button
            key={value}
            onClick={() => setFilter(value)}
            className={`flex-1 md:flex-none flex items-center justify-center gap-2 px-3 py-1.5 rounded-md text-sm font-semibold transition-colors ${
              filter === value
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700/50"
            }`}
          >
            <Icon size={16} />
            {label}
          </button>
        ))}
      </div>

      {squad && squad.length > 0 ? (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
          {filteredSquad.map((player) => (
            <PlayerCard key={player.id} player={player} />
          ))}
        </div>
      ) : (
        <p className="text-center py-8 text-text-muted">
          {t("squad_info_unavailable")}
        </p>
      )}
    </div>
  );
}

// ===== src/components/team/TeamTrophiesWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { Trophy } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

const fetchTrophies = async (teamId: number) => {
  const { data } = await axios.get(`/api/team-trophies?team=${teamId}`);
  return data;
};

const Skeleton = () => (
  <div className="bg-brand-secondary p-4 rounded-lg animate-pulse">
    <div className="h-5 w-3/4 mb-4 bg-gray-700 rounded"></div>
    <div className="space-y-3">
      <div className="h-8 w-full bg-gray-600 rounded"></div>
      <div className="h-8 w-full bg-gray-600 rounded"></div>
      <div className="h-8 w-full bg-gray-600 rounded"></div>
    </div>
  </div>
);

export default function TeamTrophiesWidget({ teamId }: { teamId: number }) {
  const { t } = useTranslation();
  const {
    data: trophies,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["teamTrophies", teamId],
    queryFn: () => fetchTrophies(teamId),
    staleTime: 1000 * 60 * 60 * 24,
  });

  if (isLoading) return <Skeleton />;
  if (isError || !trophies || trophies.length === 0) return null;

  return (
    <div className="bg-brand-secondary p-4 rounded-lg">
      <h3 className="text-lg font-bold text-white mb-4">{t("honours")}</h3>
      <div className="space-y-2 max-h-80 overflow-y-auto scrollbar-thin scrollbar-track-transparent scrollbar-thumb-gray-600">
        {trophies.map((trophy: any, index: number) => (
          <div
            key={`${trophy.league}-${trophy.season}-${index}`}
            className="flex items-center gap-3 bg-gray-800/50 p-2 rounded-md"
          >
            <Trophy className="w-5 h-5 text-yellow-500 flex-shrink-0" />
            <div className="flex-1">
              <p className="text-sm font-semibold text-white">
                {trophy.league}
              </p>
              <p className="text-xs text-brand-muted">{trophy.season}</p>
            </div>
            <p className="text-sm font-bold text-brand-light">{trophy.place}</p>
          </div>
        ))}
      </div>
    </div>
  );
}

// ===== src/components/team/index.tsx =====

"use client";

import { useState } from "react";
import AdSlotWidget from "@/components/AdSlotWidget";

import TeamHeader from "./TeamHeader";
import TeamInfoWidget from "./TeamInfoWidget";
import TeamTrophiesWidget from "./TeamTrophiesWidget";
import TeamSquadTab from "./TeamSquadWidget";

import LeagueFixturesWidget from "@/components/league-detail-view/LeagueFixturesWidget";

const TABS = ["Squad", "Fixtures", "Standings"];

export default function TeamDetailView({ teamData }: { teamData: any }) {
  const [activeTab, setActiveTab] = useState(TABS[0]);

  const { teamInfo, squad, fixtures } = teamData;
  const { team, venue } = teamInfo;

  return (
    <div>
      <TeamHeader team={team} countryFlag={fixtures?.[0]?.league?.flag || ""} />

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 items-start">
        <div className="lg:col-span-2 space-y-6">
          <div className="bg-brand-secondary rounded-lg p-2 flex items-center space-x-2">
            {TABS.map((tab) => (
              <button
                key={tab}
                onClick={() => setActiveTab(tab)}
                className={`flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-colors ${
                  activeTab === tab
                    ? "bg-brand-purple text-white"
                    : "text-brand-muted hover:bg-gray-700/50"
                }`}
              >
                {tab}
              </button>
            ))}
          </div>

          <div>
            {activeTab === "Squad" && <TeamSquadTab squad={squad} />}
            {activeTab === "Fixtures" && (

              <LeagueFixturesWidget leagueId={fixtures?.[0]?.league?.id} />
            )}
            {activeTab === "Standings" && (
              <div className="bg-brand-secondary p-8 rounded-lg text-center">
                <p>Team Standings Tab - Coming Soon!</p>
              </div>
            )}
          </div>
        </div>

        <aside className="lg:col-span-1 space-y-6">
          <TeamInfoWidget venue={venue} />
          <TeamTrophiesWidget teamId={team.id} />
          <AdSlotWidget />
        </aside>
      </div>
    </div>
  );
}

// ===== src/config/adSlots.ts =====

export interface AdSlot {
  id: string;
  name: string;
  description: string;
}

export const AD_SLOTS: AdSlot[] = [
  {
    id: "match_sidebar",
    name: "Match Page Sidebar",
    description:
      "Appears in the right sidebar on the individual match detail page.",
  },
  {
    id: "news_sidebar",
    name: "News Article Sidebar",
    description:
      "Appears in the right sidebar on individual news article pages.",
  },
  {
    id: "homepage_left_sidebar",
    name: "Homepage Left Sidebar",
    description:
      "Appears on the left side of the main content on the homepage. Ideal for vertical ads.",
  },
  {
    id: "homepage_right_sidebar",
    name: "Homepage Right Sidebar",
    description:
      "Appears on the right side of the main content on the homepage. Ideal for vertical ads.",
  },
  {
    id: "homepage_header",
    name: "Homepage Header Banner",
    description:
      "A prominent banner at the top of the homepage (under the header).",
  },
  {
    id: "sticky_footer",
    name: "Sticky Footer Banner",
    description:
      "A banner that sticks to the bottom of the screen on all pages. Ideal for landscape ads (e.g., 728x90).",
  },
];

// ===== src/context/CountryContext.tsx =====

"use client";

import { createContext, useState, useContext, ReactNode, Dispatch, SetStateAction } from 'react';
import { Country } from '@/types/api-football';

interface CountryContextType {
  selectedCountry: Country | null;
  setSelectedCountry: Dispatch<SetStateAction<Country | null>>;
}

const CountryContext = createContext<CountryContextType | undefined>(undefined);

export function CountryProvider({ children }: { children: ReactNode }) {
  const [selectedCountry, setSelectedCountry] = useState<Country | null>(null);

  return (
    <CountryContext.Provider value={{ selectedCountry, setSelectedCountry }}>
      {children}
    </CountryContext.Provider>
  );
}

export function useCountry() {
  const context = useContext(CountryContext);
  if (context === undefined) {
    throw new Error('useCountry must be used within a CountryProvider');
  }
  return context;
}

// ===== src/context/LanguageContext.tsx =====

"use client";

import { createContext, useState, useContext, ReactNode, Dispatch, SetStateAction } from 'react';

interface LanguageContextType {
  locale: 'en' | 'tr';
  setLocale: Dispatch<SetStateAction<'en' | 'tr'>>;
}

const LanguageContext = createContext<LanguageContextType | undefined>(undefined);

export function LanguageProvider({ children }: { children: ReactNode }) {

  const [locale, setLocale] = useState<'en' | 'tr'>('tr');

  return (
    <LanguageContext.Provider value={{ locale, setLocale }}>
      {children}
    </LanguageContext.Provider>
  );
}

export function useLanguage() {
  const context = useContext(LanguageContext);
  if (context === undefined) {
    throw new Error('useLanguage must be used within a LanguageProvider');
  }
  return context;
}

// ===== src/context/LeagueContext.tsx =====

"use client";

import { createContext, useContext, useState, ReactNode } from "react";
import { Country, League } from "@/types/api-football";

interface LeagueContextType {
  selectedCountry: Country | null;
  setSelectedCountry: (country: Country | null) => void;
  selectedLeague: League | null;
  setSelectedLeague: (league: League | null) => void;
}

const LeagueContext = createContext<LeagueContextType | undefined>(undefined);

export const LeagueProvider = ({ children }: { children: ReactNode }) => {

  const [selectedCountry, setSelectedCountry] = useState<Country | null>(null);
  const [selectedLeague, setSelectedLeague] = useState<League | null>(null);

  const value = { selectedCountry, setSelectedCountry, selectedLeague, setSelectedLeague };

  return (
    <LeagueContext.Provider value={value}>{children}</LeagueContext.Provider>
  );
};

export const useLeagueContext = (): LeagueContextType => {
  const context = useContext(LeagueContext);
  if (!context) throw new Error("useLeagueContext must be used within a LeagueProvider");
  return context;
};

// ===== src/context/TimeZoneContext.tsx =====

"use client";

import {
  createContext,
  useState,
  useContext,
  useEffect,
  ReactNode,
} from "react";

interface TimeZoneContextType {
  timeZone: string | null;
}

const TimeZoneContext = createContext<TimeZoneContextType | undefined>(
  undefined
);

export function TimeZoneProvider({ children }: { children: ReactNode }) {
  const [timeZone, setTimeZone] = useState<string | null>(null);

  useEffect(() => {

    const detectedTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    setTimeZone(detectedTimeZone);
  }, []);

  return (
    <TimeZoneContext.Provider value={{ timeZone }}>
      {children}
    </TimeZoneContext.Provider>
  );
}

export function useTimeZone() {
  const context = useContext(TimeZoneContext);
  if (context === undefined) {
    throw new Error("useTimeZone must be used within a TimeZoneProvider");
  }
  return context;
}

// ===== src/hooks/useTranslation.ts =====

"use client";

import { useI18n } from "@/lib/i18n/client";

export function useTranslation() {
  const { t, locale } = useI18n();
  return { t, locale };
}

// ===== src/hooks/useVoteStorage.ts =====

"use client";

import { useState, useCallback } from 'react';

const VOTE_STORAGE_KEY = 'matchVotes';

export function useVoteStorage() {

    const getVotes = useCallback((): { [key: number]: string } => {

        if (typeof window === 'undefined') {
            return {};
        }
        try {
            const votes = window.localStorage.getItem(VOTE_STORAGE_KEY);
            return votes ? JSON.parse(votes) : {};
        } catch (error) {

            return {};
        }
    }, []);

    const setVote = useCallback((fixtureId: number, choice: 'home' | 'draw' | 'away') => {
        if (typeof window === 'undefined') {
            return;
        }
        try {
            const allVotes = getVotes();
            allVotes[fixtureId] = choice;
            window.localStorage.setItem(VOTE_STORAGE_KEY, JSON.stringify(allVotes));
        } catch (error) {

        }
    }, [getVotes]);

    const getVoteForFixture = useCallback((fixtureId: number): string | null => {
        return getVotes()[fixtureId] || null;
    }, [getVotes]);

    return { setVote, getVoteForFixture };
}

// ===== src/lib/ai-processing.ts =====

import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle, {
  IExternalNewsArticle,
} from "@/models/ExternalNewsArticle";
import Post, { NewsType, SportsCategory } from "@/models/Post";
import AIJournalist from "@/models/AIJournalist";
import TitleTemplate from "@/models/TitleTemplate";
import { GoogleGenerativeAI } from "@google/generative-ai";
import slugify from "slugify";
import { proxyAndUploadImage } from "./image-processing-server";
import axios from "axios";

const genAI = new GoogleGenerativeAI(
  process.env.NEXT_PUBLIC_GEMINI_API_KEY as string
);
const model = genAI.getGenerativeModel({ model: "gemini-2.5-pro" });

async function generateHumanizedTitle(
  originalTitle: string,
  originalDescription: string,
  journalistName?: string,
  template?: string
): Promise<string> {
  let prompt: string;

  if (template) {
    prompt = `
      You are a title generation assistant. Your ONLY task is to use the provided template and context to generate a final, clean news title in TURKISH.

      TEMPLATE:
      "${template}"

      CONTEXT:
      - {original_title}: "${originalTitle}"
      - {original_description}: "${
        originalDescription || "No description available."
      }"
      - {journalist_name}: "${journalistName || "Fanskor AI"}"

      INSTRUCTIONS:
      1. Replace the placeholders in the TEMPLATE with the values from the CONTEXT.
      2. Output ONLY the final, generated title as a single line of plain text.
      3. Do not add any extra words, explanations, or formatting like quotes or asterisks.

      FINAL TITLE:
    `;
  } else {
    prompt = `
      You are an expert Turkish sports journalist named "${
        journalistName || "Fanskor AI"
      }".
      Your ONLY task is to generate a new, original, and SEO-friendly news title in TURKISH based on the context below.

      GUIDELINES:
      1.  **Language:** The title MUST be in Turkish.
      2.  **Format:** Output MUST be plain text only, on a single line. NO HTML, NO Markdown, NO quotes.
      3.  **Humanize:** Do not just translate. Find a unique, emotional, or analytical angle.

      CONTEXT:
      - Original Title: "${originalTitle}"
      - Original Description: "${originalDescription}"

      YOUR GENERATED TURKISH TITLE:
    `;
  }

  const result = await model.generateContent(prompt);
  const responseText = (await result.response).text().trim();

  return responseText.replace(/[\*#"\n]/g, "");
}

async function generateExpandedContent(
  newTitle: string,
  originalContent: string,
  journalistName?: string,
  journalistTonePrompt?: string,
  highlightEmbedHtml?: string
): Promise<string> {
  const highlightInstruction = highlightEmbedHtml
    ? `
    **HIGHLIGHT EMBED:** A video highlight is provided in the "{highlight_embed_html}" placeholder. You MUST include this placeholder in your response. Place it in a logical position, such as after the introductory paragraph, to visually complement the text. Wrap it in a div like this for proper spacing: <div class="my-6">${highlightEmbedHtml}</div>
    `
    : "";

  const prompt = `
    You are an expert Turkish sports journalist named "${
      journalistName || "Fanskor AI"
    }" and an SEO specialist.
    Your unique journalistic voice and tone should be: ${
      journalistTonePrompt || "Objective and informative."
    }

    Your ONLY task is to expand upon the provided context and generate a comprehensive, 700-word news article formatted in PURE HTML.

    CRITICAL INSTRUCTIONS:
    1.  **HTML ONLY:** Your entire response MUST be valid HTML. Use tags like <h2>, <h3>, <p>, <strong>, and <ul>.
    2.  **NO WRAPPERS:** DO NOT include \`\`\`html, \`\`\`, \`<html>\`, \`<head>\`, or \`<body>\` tags. Your response must start directly with an HTML tag (e.g., <h2>).
    3.  **LANGUAGE:** The entire article must be in Turkish.
    4.  **EXPAND & ANALYZE:** The "Original Content" is a starting point. Your main job is to expand it into a full article. Add background details, analyze the impact, discuss what might happen next, and provide expert commentary. Create a complete narrative.
    5.  **SEO HIERARCHY:** Use the provided "New Turkish Title" as the conceptual H1. Structure the article with multiple <h2> and <h3> tags that use relevant keywords. Make the content rich and valuable for the reader.
    ${highlightInstruction}

    ARTICLE CONTEXT:
    - New Turkish Title: "${newTitle}"
    - Original Content: "${originalContent}"
    - Highlight Embed Code: "${highlightEmbedHtml || "Not available."}"

    YOUR GENERATED HTML ARTICLE:
  `;

  const result = await model.generateContent(prompt);
  return (await result.response)
    .text()
    .trim()
    .replace(/^```(?:html)?\n?|```$/g, "")
    .trim();
}

interface ProcessArticleOptions {
  journalistId?: string;
  titleTemplateId?: string;
  sportsCategory: SportsCategory[];
  newsType: NewsType;
  status: "draft" | "published";
  linkedFixtureId?: number;
  onProgress?: (log: string) => void;
}

export async function processSingleArticle(
  externalArticle: IExternalNewsArticle,
  options: ProcessArticleOptions
): Promise<{ success: boolean; postId?: string; slug?: string }> {
  const { onProgress = () => {} } = options;

  try {
    onProgress("Initializing...");
    await dbConnect();

    if (["processed", "processing"].includes(externalArticle.status)) {
      const message = `Article already processed (Status: ${externalArticle.status}). Skipping.`;
      onProgress(message);
      return {
        success: true,
        postId: externalArticle.processedPostId?.toString(),
      };
    }

    onProgress("Updating article status to 'processing'...");
    externalArticle.status = "processing";
    await externalArticle.save();

    onProgress("Fetching AI Journalist details...");
    const journalist = options.journalistId
      ? await AIJournalist.findById(options.journalistId)
      : null;
    onProgress(`-> Using journalist: ${journalist?.name || "Default AI"}`);

    let titleTemplateContent: string | undefined = undefined;
    if (options.titleTemplateId) {
      onProgress("Fetching title template...");
      const titleTemplate = await TitleTemplate.findById(
        options.titleTemplateId
      );
      if (titleTemplate && titleTemplate.isActive) {
        titleTemplateContent = titleTemplate.template;
        onProgress(`-> Using title template: "${titleTemplate.name}"`);
      } else {
        onProgress(
          `-> Warning: Template not found or inactive. Reverting to dynamic title generation.`
        );
      }
    } else {
      onProgress("No title template selected. Using dynamic generation.");
    }

    let highlightEmbedHtml: string | undefined;
    if (options.newsType === "reviews" && options.linkedFixtureId) {
      onProgress(
        `Fetching highlights for fixture ID: ${options.linkedFixtureId}...`
      );
      try {
        const highlightsApiUrl = `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/api/highlights?fixtureId=${options.linkedFixtureId}`;
        const { data } = await axios.get(highlightsApiUrl);
        const mainHighlight = data?.highlights?.[0];
        if (mainHighlight?.embedUrl) {
          highlightEmbedHtml = `<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; height: auto; border-radius: 8px; margin: 1.5rem 0;"><iframe src="${mainHighlight.embedUrl}" frameborder="0" allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>`;
          onProgress("-> Highlight video found and embed code generated.");
        } else {
          onProgress("-> No highlights found for this fixture.");
        }
      } catch (e) {
        onProgress("-> Could not fetch highlights for this fixture.");
      }
    }

    onProgress("Generating new article title with AI...");
    const newTitle = await generateHumanizedTitle(
      externalArticle.title,
      externalArticle.description || "",
      journalist?.name,
      titleTemplateContent
    );
    if (!newTitle) throw new Error("AI failed to generate a title.");
    onProgress(`-> Generated Title: "${newTitle}"`);

    onProgress("Generating full article content with AI...");
    const newContent = await generateExpandedContent(
      newTitle,
      externalArticle.content ||
        externalArticle.description ||
        "No content provided.",
      journalist?.name,
      journalist?.tonePrompt,
      highlightEmbedHtml
    );
    if (!newContent || !newContent.includes("<p>"))
      throw new Error("AI failed to generate valid HTML content.");
    onProgress(
      `-> Generated content successfully (Length: ${newContent.length}).`
    );

    let featuredImageUrl: string | null = null;
    if (externalArticle.imageUrl) {
      onProgress("Processing and uploading featured image...");
      featuredImageUrl = await proxyAndUploadImage(
        externalArticle.imageUrl,
        newTitle
      );
      onProgress(
        featuredImageUrl
          ? "-> Image uploaded successfully."
          : "-> Image upload failed, continuing without it."
      );
    } else {
      onProgress("No featured image provided, skipping upload.");
    }

    onProgress("Creating post slug and checking for duplicates...");
    const slug = slugify(newTitle, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });
    const existingPost = await Post.findOne({ slug });
    const finalSlug = existingPost
      ? `${slug}-${Date.now().toString().slice(-5)}`
      : slug;
    onProgress(`-> Final slug: "${finalSlug}"`);

    onProgress("Saving new post to database...");
    const plainTextContent = newContent.replace(/<[^>]*>?/gm, "");
    const newPost = new Post({
      title: newTitle,
      content: newContent,
      slug: finalSlug,
      author: journalist?.name || "Fanskor AI",
      featuredImage: featuredImageUrl,
      featuredImageTitle: newTitle,
      featuredImageAltText: newTitle,
      isAIGenerated: true,
      originalExternalArticleId: externalArticle._id,
      metaTitle: `${newTitle} | Haberler`,
      metaDescription: plainTextContent.substring(0, 160) + "...",
      status: options.status,
      sportsCategory: options.sportsCategory,
      newsType: options.newsType,
      linkedFixtureId: options.linkedFixtureId,
    });
    await newPost.save();
    onProgress("-> New post saved successfully.");

    onProgress("Finalizing article status...");
    externalArticle.status = "processed";
    externalArticle.processedPostId = newPost._id;
    await externalArticle.save();

    onProgress(" Generation Complete!");
    return {
      success: true,
      postId: newPost._id.toString(),
      slug: newPost.slug,
    };
  } catch (error: any) {
    const errorMessage = ` ERROR: ${error.message}`;
    onProgress(errorMessage);
    console.error(
      `[AI Processor] Failed to process article ${externalArticle.articleId}:`,
      error
    );
    externalArticle.status = "error";
    await externalArticle.save();
    return { success: false };
  }
}

// ===== src/lib/analytics.ts =====

declare global {
  interface Window {
    gtag: (
      command: "event",
      action: string,
      params: { [key: string]: any }
    ) => void;
  }
}

export const sendGAEvent = (action: string, params: { [key: string]: any }) => {
  if (typeof window.gtag === "function") {
    window.gtag("event", action, params);
  }
};

// ===== src/lib/data/highlightly.ts =====

import axios from "axios";
import { format, subDays } from "date-fns";

const API_BASE_URL = "https://sports.highlightly.net/";
const API_KEY = process.env.NEXT_PUBLIC_HIGHLIGHTLY_API_KEY;

async function request(endpoint: string, params?: object) {
  if (!API_KEY) {
    throw new Error("Highlightly API Key is not configured.");
  }

  try {
    const response = await axios.get(`${API_BASE_URL}/${endpoint}`, {
      params,
      headers: {
        "x-rapidapi-key": API_KEY,
        "x-rapidapi-host": "sports.highlightly.net",
      },
      timeout: 20000,
    });
    return response.data;
  } catch (error: any) {
    if (error.response && error.response.status === 404) {
      return null;
    }
    console.error(
      `[Highlightly Service] Error fetching from '${endpoint}':`,
      error.message
    );
    throw new Error(`Failed to fetch data from the highlights provider.`);
  }
}

export async function getMatchHighlights(params: object) {
  const data = await request("football/highlights", params);
  return data;
}

export async function getHighlightlyEntities(type: "leagues" | "teams") {
  const data = await request(type);
  return data[type] || data || [];
}

export async function getLatestPopularHighlights() {
  const POPULAR_LEAGUE_IDS = [
    2486,
    3337,
    33973,
    52695,
    61205,
    67162,
    75672,
    80778,
    34824,
    68013,
    8443,
    13549,
    11847,
    14400,
    15251,
    10996,
    39079,
    41632,
    56950,
    69715,
  ];
  const allHighlights = [];

  for (const leagueId of POPULAR_LEAGUE_IDS) {
    const params = {
      leagueId,
      season: new Date().getFullYear(),
      limit: 10,
    };

    const result = await request("football/highlights", params);

    if (result && result.data && Array.isArray(result.data)) {
      allHighlights.push(...result.data);
    }

    await new Promise((resolve) => setTimeout(resolve, 200));
  }

  const uniqueHighlights = Array.from(
    new Map(allHighlights.map((item: any) => [item.id, item])).values()
  );

  uniqueHighlights.sort(
    (a: any, b: any) =>
      new Date(b.match.date).getTime() - new Date(a.match.date).getTime()
  );

  return uniqueHighlights.filter((i) => i.type !== "UNVERIFIED").slice(0, 8);
}

// ===== src/lib/data/news.ts =====

import "server-only";
import dbConnect from "@/lib/dbConnect";
import Post, { IPost, SportsCategory } from "@/models/Post";

const DEFAULT_LOCALE = "tr";

interface GetNewsParams {
  locale: string;
  sportsCategory?: SportsCategory;
  excludeSportsCategory?: SportsCategory;
}

export async function getNews(params: GetNewsParams): Promise<IPost[]> {
  const { locale, sportsCategory, excludeSportsCategory } = params;

  try {
    await dbConnect();

    const matchStage: any = { status: "published" };
    if (sportsCategory) {
      matchStage.sportsCategory = { $in: [sportsCategory] };
    }
    if (excludeSportsCategory) {
      matchStage.sportsCategory = { $nin: [excludeSportsCategory] };
    }

    const pipeline = [
      { $match: matchStage },

      {
        $addFields: {
          effectiveGroupId: { $ifNull: ["$translationGroupId", "$_id"] },
        },
      },

      {
        $addFields: {
          langPriority: {
            $cond: {
              if: { $eq: ["$language", locale] },
              then: 1,
              else: {
                $cond: {
                  if: { $eq: ["$language", DEFAULT_LOCALE] },
                  then: 2,
                  else: 3,
                },
              },
            },
          },
        },
      },

      {
        $sort: {
          effectiveGroupId: 1,
          langPriority: 1,
        },
      },

      {
        $group: {
          _id: "$effectiveGroupId",
          document: { $first: "$$ROOT" },
        },
      },

      {
        $replaceRoot: {
          newRoot: "$document",
        },
      },

      {
        $sort: {
          createdAt: -1,
        },
      },
    ];

    const curatedNews = await Post.aggregate(pipeline);

    return JSON.parse(JSON.stringify(curatedNews));
  } catch (error) {

    return [];
  }
}

// ===== src/lib/data/team.ts =====

import axios from 'axios';
import redis from '@/lib/redis';

const CACHE_TTL_SECONDS = 60 * 60 * 12;

export async function fetchTeamDetails(teamId: string) {
    const season = new Date().getFullYear().toString();

    const cacheKey = `team-details:${teamId}:${season}`;

    try {

        const cachedData = await redis.get(cacheKey);
        if (cachedData) {

            return JSON.parse(cachedData);
        }

        const options = (endpoint: string, params: object) => ({
            method: 'GET',
            url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
            params,
            headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
        });

        const [
            teamInfoResponse,
            squadResponse,
            recentFixturesResponse,
            standingsResponse
        ] = await Promise.all([
            axios.request(options('teams', { id: teamId })),
            axios.request(options('players/squads', { team: teamId })),
            axios.request(options('fixtures', { team: teamId, last: 10 })),
            axios.request(options('standings', { team: teamId, season: season })),
        ]);

        if (!teamInfoResponse.data.response || teamInfoResponse.data.response.length === 0) {

            return null;
        }

        const responseData = {
            teamInfo: teamInfoResponse.data.response[0],
            squad: squadResponse.data.response[0]?.players ?? [],
            fixtures: recentFixturesResponse.data.response,
            standings: standingsResponse.data.response,
        };

        await redis.set(cacheKey, JSON.stringify(responseData), "EX", CACHE_TTL_SECONDS);

        return responseData;

    } catch (error) {

        return null;
    }
}

// ===== src/lib/date-formatter.ts =====

import { formatInTimeZone } from "date-fns-tz";

export const formatZonedTime = (
  utcDateString: string | Date,
  timeZone: string,
  formatString: string = "HH:mm"
): string => {
  try {

    return formatInTimeZone(utcDateString, timeZone, formatString);
  } catch (error) {

    return "--:--";
  }
};

// ===== src/lib/dbConnect.ts =====

import mongoose from 'mongoose';

const NEXT_PUBLIC_MONGODB_URI = process.env.NEXT_PUBLIC_MONGODB_URI;

if (!NEXT_PUBLIC_MONGODB_URI) {
  throw new Error(
    'Please define the NEXT_PUBLIC_MONGODB_URI environment variable inside .env.local'
  );
}

let cached = (global as any).mongoose;

if (!cached) {
  cached = (global as any).mongoose = { conn: null, promise: null };
}

async function dbConnect() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
      serverSelectionTimeoutMS: 30000,
      socketTimeoutMS: 45000,
    };

    cached.promise = mongoose.connect(NEXT_PUBLIC_MONGODB_URI!, opts).then((mongoose) => {

      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

export default dbConnect;

// ===== src/lib/ga.ts =====

"use client";

import { sendGAEvent } from "@next/third-parties/google";

interface GAEvent {
  action: string;
  category: string;
  label?: string;
  value?: number;
}

export const trackEvent = ({ action, category, label, value }: GAEvent) => {
  sendGAEvent({ event: action, value: { category, label, value } });
};

// ===== src/lib/generate-league-slug.ts =====

import slugify from "slugify";

export function generateLeagueSlug(
  name: string,
  id: number,
  locale?: string
): any {
  const nameSlug = slugify(name, {
    lower: true,
    strict: true,
    trim: true,
    remove: /[*+~.()'"!:@]/g,
  });

  if (locale) return `/${locale}/football/league/${nameSlug}-${id}`;
  else return `/football/league/${nameSlug}-${id}`;
}

// ===== src/lib/generate-match-slug.ts =====

import slugify from "slugify";

interface Team {
  name: string;
}

export function generateMatchSlug(
  homeTeam: Team,
  awayTeam: Team,
  fixtureId: number
): string {
  const homeName = homeTeam?.name || "team";
  const awayName = awayTeam?.name || "team";

  const homeSlug = slugify(homeName, {
    lower: true,
    strict: true,
    remove: /[*+~.()'"!:@]/g,
  });
  const awaySlug = slugify(awayName, {
    lower: true,
    strict: true,
    remove: /[*+~.()'"!:@]/g,
  });

  return `/football/match/${homeSlug}-vs-${awaySlug}-${fixtureId}`;
}

// ===== src/lib/generate-team-slug.ts =====

import slugify from "slugify";

export const generateTeamSlug = (
  teamName: string,
  teamId: number,
  locale?: string
) => {
  const slug = slugify(teamName, {
    lower: true,
    strict: true,
    remove: /[*+~.()'"!:@]/g,
  });
  if (locale) return `/${locale}/football/team/${slug}-${teamId}`;
  else return `/football/team/${slug}-${teamId}`;
};

// ===== src/lib/hreflang.ts =====

const SUPPORTED_LOCALES = ["tr", "en", "fr", "es", "zu"];
const DEFAULT_LOCALE = "tr";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

export function generateHreflangTags(
  path: string,
  currentLocale: string,
  availableLocales?: string[]
) {

  const cleanPath = path === "/page" || path === "/" ? "" : path;

  const alternates: {
    canonical: string;
    languages: { [key: string]: string };
  } = {
    canonical:
      currentLocale === DEFAULT_LOCALE
        ? `${BASE_URL}${cleanPath}`
        : `${BASE_URL}/${currentLocale}${cleanPath}`,
    languages: {},
  };

  const localesToUse =
    availableLocales && availableLocales.length > 0
      ? availableLocales
      : SUPPORTED_LOCALES;

  localesToUse.forEach((locale) => {
    if (locale === DEFAULT_LOCALE) {
      alternates.languages[locale] = `${BASE_URL}${cleanPath}`;
    } else {
      alternates.languages[locale] = `${BASE_URL}/${locale}${cleanPath}`;
    }
  });

  alternates.languages["x-default"] = `${BASE_URL}${cleanPath}`;

  return alternates;
}

// ===== src/lib/i18n/client.tsx =====

"use client";

import React, { createContext, useContext, ReactNode } from "react";
import "client-only";

type Translations = Record<string, any>;

interface I18nContextType {
  translations: Translations;
  locale: string;
}

const I18nContext = createContext<I18nContextType | undefined>(undefined);

interface I18nProviderClientProps {
  locale: string;
  translations: Translations;
  children: ReactNode;
}

export function I18nProviderClient({
  locale,
  translations,
  children,
}: I18nProviderClientProps) {
  return (
    <I18nContext.Provider value={{ locale, translations }}>
      {children}
    </I18nContext.Provider>
  );
}

export function useI18n() {
  const context = useContext(I18nContext);

  if (context === undefined) {
    throw new Error("useI18n must be used within an I18nProviderClient");
  }

  const { translations, locale } = context;

  const t = (
    key: string,
    params?: { [key: string]: string | number }
  ): string => {
    let translation = translations[key] || key;

    if (params) {
      Object.keys(params).forEach((paramKey) => {
        const regex = new RegExp(`{${paramKey}}`, "g");
        translation = translation.replace(regex, String(params[paramKey]));
      });
    }
    return translation;
  };

  return { t, locale };
}

// ===== src/lib/i18n/i18n.cache.ts =====

import dbConnect from "@/lib/dbConnect";
import Language, { ILanguage } from "@/models/Language";
import path from "path";
import { promises as fs } from "fs";

const LOCALES_DIR = path.join(process.cwd(), "src/locales");

interface CachedLocaleData {
  language: ILanguage;
  translations: Record<string, any>;
}

export class I18nCache {
  private static instance: I18nCache;
  private cache: Map<string, CachedLocaleData> = new Map();
  private isInitialized = false;
  private defaultLocale: string = "tr";

  private constructor() {}

  public static getInstance(): I18nCache {
    if (!I18nCache.instance) {
      I18nCache.instance = new I18nCache();
    }
    return I18nCache.instance;
  }

  public async initialize(): Promise<void> {

    if (this.isInitialized) {
      return;
    }

    await this.loadData();
  }

  private async loadData(): Promise<void> {

    try {
      await dbConnect();
      const activeLanguages = await Language.find({ isActive: true }).lean();
      const newCache = new Map<string, CachedLocaleData>();
      let foundDefault = false;

      for (const lang of activeLanguages) {
        try {
          const filePath = path.join(LOCALES_DIR, `${lang.code}.json`);
          const fileContent = await fs.readFile(filePath, "utf-8");
          const translations = JSON.parse(fileContent);
          newCache.set(lang.code, { language: lang, translations });
          if (lang.isDefault) {
            this.defaultLocale = lang.code;
            foundDefault = true;
          }
        } catch (error) {
          console.error(
            `[I18N_CACHE] Failed to load translations for '${lang.code}'. Skipping.`,
            error
          );
        }
      }

      if (!foundDefault && activeLanguages.length > 0) {
        this.defaultLocale = activeLanguages[0].code;
        console.warn(
          `[I18N_CACHE] No default language set in DB. Falling back to '${this.defaultLocale}'.`
        );
      }

      this.cache = newCache;
      this.isInitialized = true;

    } catch (error) {
      console.error(
        "[I18N_CACHE] CRITICAL: Failed to load any i18n data.",
        error
      );
    }
  }

  public async reload(): Promise<void> {

    this.isInitialized = false;
    await this.initialize();
  }

  public async getLocales(): Promise<string[]> {
    await this.initialize();
    return Array.from(this.cache.keys());
  }

  public async getDefaultLocale(): Promise<string> {
    await this.initialize();
    return this.defaultLocale;
  }

  public async getTranslations(
    locale: string
  ): Promise<Record<string, any> | undefined> {
    await this.initialize();
    return this.cache.get(locale)?.translations;
  }
}

export const i18nCache = I18nCache.getInstance();

// ===== src/lib/i18n/server.ts =====

import "server-only";
import path from "path";
import { promises as fs } from "fs";

const SUPPORTED_LOCALES = ["tr", "en", "fr", "es", "zu"];
const DEFAULT_LOCALE = "tr";
const LOCALES_DIR = path.join(process.cwd(), "src/locales");

const translationsCache = new Map<string, Record<string, any>>();

async function getTranslationsFromFile(
  locale: string
): Promise<Record<string, any>> {

  if (translationsCache.has(locale)) {
    return translationsCache.get(locale)!;
  }

  const filePath = path.join(LOCALES_DIR, `${locale}.json`);

  try {
    const fileContent = await fs.readFile(filePath, "utf-8");
    const translations = JSON.parse(fileContent);
    translationsCache.set(locale, translations);
    return translations;
  } catch (error) {

    return {};
  }
}

export async function getI18n(localeFromParams: string) {
  const validatedLocale = SUPPORTED_LOCALES.includes(localeFromParams)
    ? localeFromParams
    : DEFAULT_LOCALE;

  const translations = await getTranslationsFromFile(validatedLocale);

  return function t(
    key: string,
    params?: { [key: string]: string | number }
  ): string {
    let translation: string = translations[key] || key;

    if (params) {
      Object.keys(params).forEach((paramKey) => {
        const regex = new RegExp(`{${paramKey}}`, "g");
        translation = translation.replace(regex, String(params[paramKey]));
      });
    }
    return translation;
  };
}

// ===== src/lib/image-processing-server.ts =====

import axios from "axios";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import sharp from "sharp";
import crypto from "crypto";
import slugify from "slugify";
import path from "path";

const s3Client = new S3Client({
  region: "auto",
  endpoint: process.env.NEXT_PUBLIC_R2_ENDPOINT as string,
  credentials: {
    accessKeyId: process.env.NEXT_PUBLIC_R2_ACCESS_KEY_ID as string,
    secretAccessKey: process.env.NEXT_PUBLIC_R2_SECRET_ACCESS_KEY as string,
  },
});

const R2_BUCKET_NAME = process.env.NEXT_PUBLIC_R2_BUCKET_NAME as string;
const R2_PUBLIC_URL = process.env.NEXT_PUBLIC_R2_PUBLIC_BUCKET_URL as string;

export async function proxyAndUploadImage(
  imageUrl: string,
  newPostTitle: string
): Promise<string | null> {
  try {

    const imageResponse = await axios.get(imageUrl, {
      responseType: "arraybuffer",
      timeout: 15000,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });

    const inputBuffer = Buffer.from(imageResponse.data, "binary");
    const originalContentType =
      imageResponse.headers["content-type"] || "image/jpeg";

    let finalBuffer: Buffer;
    let finalContentType: string;
    let fileExtension: string;

    if (originalContentType.includes("image/gif")) {

      finalBuffer = inputBuffer;
      finalContentType = "image/gif";
      fileExtension = ".gif";
    } else {

      console.log(
        "[Image Processor] Processing with Sharp (resize & convert to WebP)."
      );
      finalBuffer = await sharp(inputBuffer)
        .resize(1200, 630, { fit: "inside", withoutEnlargement: true })
        .webp({ quality: 80 })
        .toBuffer();
      finalContentType = "image/webp";
      fileExtension = ".webp";
    }

    const slug = slugify(newPostTitle, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });
    const uniqueSuffix = Date.now().toString().slice(-6);
    const newFileName = `fanskor-${slug.slice(
      0,
      50
    )}-${uniqueSuffix}${fileExtension}`;

    const putObjectCommand = new PutObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: newFileName,
      Body: finalBuffer,
      ContentType: finalContentType,
    });
    await s3Client.send(putObjectCommand);

    const r2Url = `${R2_PUBLIC_URL}/${newFileName}`;

    return r2Url;
  } catch (error: any) {
    console.error(
      `[Image Processor]  Failed to process image from URL (${imageUrl}):`,
      error.message
    );
    return null;
  }
}

// ===== src/lib/image-proxy.ts =====

const PLACEHOLDER_IMAGE = "/images/placeholder-logo.svg";

export function proxyImageUrl(url: string | null | undefined): string {

  if (!url || !url.startsWith("http")) {
    return PLACEHOLDER_IMAGE;
  }

  return `/api/image-proxy?url=${encodeURIComponent(url)}`;
}

// ===== src/lib/mongoClient.ts =====

import { MongoClient } from "mongodb";

if (!process.env.NEXT_PUBLIC_MONGODB_URI) {
  throw new Error('Invalid/Missing environment variable: "NEXT_PUBLIC_MONGODB_URI"');
}

const uri = process.env.NEXT_PUBLIC_MONGODB_URI;
const options = {};

let client: MongoClient;
let clientPromise: Promise<MongoClient>;

if (process.env.NODE_ENV === "development") {

  let globalWithMongo = global as typeof globalThis & {
    _mongoClientPromise?: Promise<MongoClient>;
  };

  if (!globalWithMongo._mongoClientPromise) {
    client = new MongoClient(uri, options);
    globalWithMongo._mongoClientPromise = client.connect();

  }
  clientPromise = globalWithMongo._mongoClientPromise;
} else {

  client = new MongoClient(uri, options);
  clientPromise = client.connect();
}

export default clientPromise;

// ===== src/lib/odds-converter.ts =====

export const convertPercentageToOdds = (
  percent: number | undefined | null
): string => {
  if (percent === null || percent === undefined || percent <= 0) {
    return "N/A";
  }

  const safePercent = Math.max(1, Math.min(percent, 99));
  return (100 / safePercent).toFixed(2);
};

// ===== src/lib/prediction-engine.ts =====

export function generatePrediction(
  h2h: any[],
  homeTeamStats: any,
  awayTeamStats: any,
  homeTeamId: number,
  homeTeamRank: number | undefined,
  awayTeamRank: number | undefined,
  matchEvents: any[] | null,
  matchStatus: string
): { home: number; draw: number; away: number } {

  const config = {
    weights: {
      homeAdvantage: 12,
      form: 1.5,
      h2h: 2.5,
      rankDifference: 0.8,
      goalDifference: 6.0,

      liveGoalMomentum: 15,
      liveRedCardPenalty: -20,
    },
    h2hMaxGames: 5,
    drawWeight: 0.85,
  };

  let homeScore = 0;
  let awayScore = 0;

  homeScore += config.weights.homeAdvantage;

  const calculateForm = (formString: string): number => {
    if (!formString) return 0;
    return (
      (formString.match(/W/g) || []).length * 3 +
      (formString.match(/D/g) || []).length * 1
    );
  };
  homeScore += calculateForm(homeTeamStats?.form || "") * config.weights.form;
  awayScore += calculateForm(awayTeamStats?.form || "") * config.weights.form;

  const homeGoalDiff =
    (homeTeamStats?.goals?.for?.average?.total ?? 0) -
    (homeTeamStats?.goals?.against?.average?.total ?? 0);
  const awayGoalDiff =
    (awayTeamStats?.goals?.for?.average?.total ?? 0) -
    (awayTeamStats?.goals?.against?.average?.total ?? 0);
  homeScore += homeGoalDiff * config.weights.goalDifference;
  awayScore += awayGoalDiff * config.weights.goalDifference;

  if (h2h && h2h.length > 0) {
    h2h.slice(0, config.h2hMaxGames).forEach((match) => {
      if (match.teams.home.winner) {
        homeTeamId === match.teams.home.id
          ? (homeScore += config.weights.h2h)
          : (awayScore += config.weights.h2h);
      } else if (match.teams.away.winner) {
        homeTeamId === match.teams.away.id
          ? (homeScore += config.weights.h2h)
          : (awayScore += config.weights.h2h);
      } else {
        homeScore += config.weights.h2h / 2;
        awayScore += config.weights.h2h / 2;
      }
    });
  }

  if (homeTeamRank != null && awayTeamRank != null) {
    const rankDiff = Math.abs(homeTeamRank - awayTeamRank);
    if (homeTeamRank < awayTeamRank) {
      homeScore += rankDiff * config.weights.rankDifference;
    } else if (awayTeamRank < homeTeamRank) {
      awayScore += rankDiff * config.weights.rankDifference;
    }
  }

  if (
    ["1H", "HT", "2H", "ET", "BT", "P", "LIVE"].includes(matchStatus) &&
    matchEvents
  ) {
    console.log(
      `[Prediction Engine] Applying live analysis for match status: ${matchStatus}`
    );
    matchEvents.forEach((event) => {

      if (event.type === "Goal") {
        if (event.team.id === homeTeamId) {
          homeScore += config.weights.liveGoalMomentum;
        } else {
          awayScore += config.weights.liveGoalMomentum;
        }
      }

      if (event.type === "Card" && event.detail === "Red Card") {
        if (event.team.id === homeTeamId) {
          homeScore += config.weights.liveRedCardPenalty;
        } else {
          awayScore += config.weights.liveRedCardPenalty;
        }
      }
    });
  }

  homeScore = Math.max(1, homeScore);
  awayScore = Math.max(1, awayScore);
  const drawScore =
    (homeScore + awayScore) *
    (1 - Math.abs(homeScore - awayScore) / (homeScore + awayScore)) *
    config.drawWeight;
  const totalPoints = homeScore + awayScore + drawScore;

  if (totalPoints <= 1) {
    return { home: 33, draw: 34, away: 33 };
  }

  let homePercent = Math.round((homeScore / totalPoints) * 100);
  let awayPercent = Math.round((awayScore / totalPoints) * 100);
  let drawPercent = 100 - homePercent - awayPercent;

  if (homePercent + awayPercent + drawPercent !== 100) {
    const diff = 100 - (homePercent + awayPercent + drawPercent);
    if (homePercent >= awayPercent && homePercent >= drawPercent)
      homePercent += diff;
    else if (awayPercent >= homePercent && awayPercent >= drawPercent)
      awayPercent += diff;
    else drawPercent += diff;
  }

  return { home: homePercent, draw: drawPercent, away: awayPercent };
}

// ===== src/lib/redis.mock.ts =====

const mockRedisClient = {
  get: async (key: string): Promise<string | null> => {

    return null;
  },
  set: async (
    key: string,
    value: string,
    ...args: any[]
  ): Promise<"OK" | null> => {

    return "OK";
  },

  del: async (key: string): Promise<number> => {

    return 1;
  },

  hgetall: async (key: string): Promise<Record<string, string>> => {

    return {};
  },
  pipeline: () => ({
    hset: () => {

    },
    expire: () => {

    },
    exec: async () => {

      return [];
    },
  }),
};

export default mockRedisClient;

// ===== src/lib/redis.ts =====

import 'dotenv/config';
import Redis from "ioredis";
import "server-only";
import mockRedisClient from "./redis.mock";

declare global {
  var redis: Redis | undefined;
}

let redisClient: Redis | typeof mockRedisClient;

if (process.env.NODE_ENV === 'production') {

  if (!process.env.NEXT_PUBLIC_REDIS_HOST || !process.env.NEXT_PUBLIC_REDIS_PORT || !process.env.NEXT_PUBLIC_REDIS_PASSWORD) {
    throw new Error("Production Redis connection details (REDIS_HOST, REDIS_PORT, REDIS_PASSWORD) are not defined.");
  }

  if (!global.redis) {
    global.redis = new Redis({
      host: process.env.NEXT_PUBLIC_REDIS_HOST,
      port: parseInt(process.env.NEXT_PUBLIC_REDIS_PORT, 10),
      password: process.env.NEXT_PUBLIC_REDIS_PASSWORD,
      enableOfflineQueue: false,
    });

    global.redis.on('connect', () => {

    });

    global.redis.on('error', (err) => {

    });
  }

  redisClient = global.redis;

} else {

  redisClient = mockRedisClient;
}

export default redisClient;

// ===== src/lib/toc.ts =====

import * as cheerio from "cheerio";
import slugify from "slugify";

export interface TocEntry {
  level: "h2" | "h3";
  id: string;
  text: string;
}

export function generateTableOfContents(htmlContent: string): {
  processedHtml: string;
  toc: TocEntry[];
} {
  if (!htmlContent) {
    return { processedHtml: "", toc: [] };
  }

  const $ = cheerio.load(htmlContent);
  const toc: TocEntry[] = [];

  $("h2, h3").each((index, element) => {
    const el = $(element);
    const text = el.text();
    const level = el.is("h2") ? "h2" : "h3";

    const baseId = slugify(text, { lower: true, strict: true });
    let id = baseId;
    let counter = 1;

    while ($(`#${id}`).length > 0) {
      id = `${baseId}-${counter}`;
      counter++;
    }

    el.attr("id", id);

    toc.push({ level, id, text });
  });

  return {
    processedHtml: $.html(),
    toc,
  };
}

// ===== src/middleware.ts =====

import { NextRequest, NextResponse } from "next/server";
import Negotiator from "negotiator";

const I18N_COOKIE_NAME = "NEXT_LOCALE";
const SUPPORTED_LOCALES = ["tr", "en", "fr", "es", "zu", "it"];
const DEFAULT_LOCALE = "tr";

function getLocale(request: NextRequest): string {
  const cookieLocale = request.cookies.get(I18N_COOKIE_NAME)?.value;
  if (cookieLocale && SUPPORTED_LOCALES.includes(cookieLocale)) {
    return cookieLocale;
  }

  const languages = new Negotiator({
    headers: {
      "accept-language": request.headers.get("accept-language") || "",
    },
  }).languages();

  for (const lang of languages) {
    if (SUPPORTED_LOCALES.includes(lang)) return lang;
    const baseLang = lang.split("-")[0];
    if (SUPPORTED_LOCALES.includes(baseLang)) return baseLang;
  }

  return DEFAULT_LOCALE;
}

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  if (
    pathname.startsWith("/admin") ||
    pathname.startsWith("/login") ||
    pathname.startsWith("/api")
  ) {
    return NextResponse.next();
  }

  const pathnameHasLocale = SUPPORTED_LOCALES.some(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  );

  if (pathnameHasLocale) {
    return NextResponse.next();
  }

  const detectedLocale = getLocale(request);
  let response: NextResponse;

  if (detectedLocale === DEFAULT_LOCALE) {
    response = NextResponse.rewrite(
      new URL(`/${DEFAULT_LOCALE}${pathname}`, request.url)
    );
  } else {
    response = NextResponse.redirect(
      new URL(`/${detectedLocale}${pathname}`, request.url)
    );
  }

  response.cookies.set(I18N_COOKIE_NAME, detectedLocale, {
    path: "/",
    maxAge: 60 * 60 * 24 * 365,
  });

  return response;
}

export const config = {
  matcher: [

    "/((?!_next/static|_next/image|assets|favicon.ico|sw.js|.*\\..*).*)",
  ],
};

// ===== src/models/AIJournalist.ts =====

import mongoose, { Schema, Document } from "mongoose";

export interface IAIJournalist extends Document {
  name: string;
  description?: string;
  tonePrompt: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

const AIJournalistSchema: Schema = new Schema(
  {
    name: { type: String, required: true, unique: true, trim: true },
    description: { type: String, trim: true },

    tonePrompt: { type: String, required: true, trim: true },
    isActive: { type: Boolean, default: true },
  },
  {
    timestamps: true,
  }
);

const AIJournalist =
  mongoose.models.AIJournalist ||
  mongoose.model<IAIJournalist>("AIJournalist", AIJournalistSchema);

export default AIJournalist;

// ===== src/models/AIPrompt.ts =====

import mongoose, { Schema, Document } from "mongoose";

export type AIPromptType = "title" | "content" | "prediction_content";

export interface IAIPrompt extends Document {
  name: string;
  type: AIPromptType;
  prompt: string;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}

const AIPromptSchema: Schema = new Schema(
  {
    name: { type: String, required: true, trim: true },
    type: {
      type: String,
      enum: ["title", "content", "prediction_content"],
      required: true,
    },
    prompt: { type: String, required: true },
    description: { type: String, trim: true },
  },
  {
    timestamps: true,
  }
);

AIPromptSchema.index({ name: 1, type: 1 }, { unique: true });

export default (mongoose.models.AIPrompt as mongoose.Model<IAIPrompt>) ||
  mongoose.model<IAIPrompt>("AIPrompt", AIPromptSchema);

// ===== src/models/Banner.ts =====

import mongoose, { Document, Schema, Model } from "mongoose";

export interface IBanner extends Document {
  title: string;
  imageUrl: string;
  linkUrl: string;
  isActive: boolean;
  location: string;
  createdAt: Date;
  updatedAt: Date;
}

const BannerSchema: Schema<IBanner> = new Schema(
  {
    title: {
      type: String,
      required: [true, "Banner title is required."],
      trim: true,
    },
    imageUrl: {
      type: String,
      required: [true, "Image URL is required."],
    },
    linkUrl: {
      type: String,
      required: [true, "Link URL is required."],
    },
    isActive: {
      type: Boolean,
      default: true,
    },

    location: {
      type: String,
      required: [true, "A location must be specified for the banner."],
      index: true,
    },
  },
  {
    timestamps: true,
  }
);

const Banner: Model<IBanner> =
  mongoose.models.Banner || mongoose.model<IBanner>("Banner", BannerSchema);

export default Banner;

// ===== src/models/CasinoPartner.ts =====

import mongoose, { Schema, Document } from "mongoose";

export interface ICasinoPartner extends Document {
  name: string;
  logoUrl: string;
  redirectUrl: string;
  description?: string;
  isFeatured: boolean;
  isActive: boolean;
  order: number;
  createdAt: Date;
  updatedAt: Date;
}

const CasinoPartnerSchema: Schema = new Schema(
  {
    name: { type: String, required: true, unique: true, trim: true },
    logoUrl: { type: String, required: true, trim: true },
    redirectUrl: { type: String, required: true, trim: true },
    description: { type: String, trim: true },
    isFeatured: { type: Boolean, default: false },
    isActive: { type: Boolean, default: true },
    order: { type: Number, default: 0 },
  },
  {
    timestamps: true,
  }
);

const CasinoPartner =
  mongoose.models.CasinoPartner ||
  mongoose.model<ICasinoPartner>("CasinoPartner", CasinoPartnerSchema);

export default CasinoPartner;

// ===== src/models/ExternalNewsArticle.ts =====

import mongoose, { Schema, Document } from "mongoose";

export interface IExternalNewsArticle extends Document {
  articleId: string;
  title: string;
  link: string;
  keywords?: string[];

  creator?: string[];
  video_url?: string | null;
  description?: string | null;
  content?: string | null;
  pubDate: Date;
  imageUrl?: string | null;
  source_id?: string;
  source_priority?: number;
  source_url?: string;
  source_icon?: string | null;
  language?: string;
  country?: string[];
  category?: string[];
  sentiment?: string;
  status: "fetched" | "processing" | "processed" | "skipped" | "error";
  processedPostId?: mongoose.Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const ExternalNewsArticleSchema: Schema = new Schema(
  {
    articleId: { type: String, required: true, unique: true, index: true },
    title: { type: String, required: true },
    link: { type: String, required: true },
    keywords: [{ type: String }],

    creator: [{ type: String }],

    video_url: { type: String },
    description: { type: String },
    content: { type: String },
    pubDate: { type: Date, required: true, index: true },
    imageUrl: { type: String },
    source_id: { type: String },
    source_priority: { type: Number },
    source_url: { type: String },
    source_icon: { type: String },
    language: { type: String },
    country: [{ type: String }],
    category: [{ type: String }],
    sentiment: { type: String },
    status: {
      type: String,
      enum: ["fetched", "processing", "processed", "skipped", "error"],
      default: "fetched",
    },
    processedPostId: { type: Schema.Types.ObjectId, ref: "Post" },
  },
  {
    timestamps: true,
  }
);

const ExternalNewsArticle =
  mongoose.models.ExternalNewsArticle ||
  mongoose.model<IExternalNewsArticle>(
    "ExternalNewsArticle",
    ExternalNewsArticleSchema
  );

export default ExternalNewsArticle;

// ===== src/models/Faq.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

export interface IFaq extends Document {
  question: string;
  answer: string;

  category: string;
  order: number;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

const FaqSchema: Schema<IFaq> = new Schema(
  {
    question: {
      type: String,
      required: [true, "Question is required."],
      trim: true,
      unique: true,
    },
    answer: {
      type: String,
      required: [true, "Answer is required."],
    },

    category: {
      type: String,
      required: [true, "Category is required."],
      trim: true,
      index: true,
      default: "General Questions",
    },
    order: {
      type: Number,
      default: 0,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
  }
);

const Faq: Model<IFaq> =
  mongoose.models.Faq || mongoose.model<IFaq>("Faq", FaqSchema);

export default Faq;

// ===== src/models/Language.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

export interface ILanguage extends Document {
  name: string;
  code: string;
  isActive: boolean;
  isDefault: boolean;
  flagUrl?: string;
  createdAt: Date;
  updatedAt: Date;
}

const LanguageSchema: Schema<ILanguage> = new Schema(
  {
    name: {
      type: String,
      required: [true, "Language name is required."],
      unique: true,
      trim: true,
    },
    code: {
      type: String,
      required: [true, "Language code (e.g., 'en') is required."],
      unique: true,
      trim: true,
      lowercase: true,
      minlength: 2,
      maxlength: 5,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
    isDefault: {
      type: Boolean,
      default: false,
    },
    flagUrl: {
      type: String,
      trim: true,
    },
  },
  {
    timestamps: true,
  }
);

LanguageSchema.pre("save", async function (next) {
  if (this.isModified("isDefault") && this.isDefault) {

    await (this.constructor as Model<ILanguage>).updateMany(
      { _id: { $ne: this._id }, isDefault: true },
      { isDefault: false }
    );
  }
  next();
});

const Language: Model<ILanguage> =
  mongoose.models.Language ||
  mongoose.model<ILanguage>("Language", LanguageSchema);

export default Language;

// ===== src/models/PageContent.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

export interface IPageContent extends Document {
  pageSlug: string;
  title: string;
  content: string;
  createdAt: Date;
  updatedAt: Date;
}

const PageContentSchema: Schema<IPageContent> = new Schema(
  {
    pageSlug: {
      type: String,
      required: true,
      unique: true,
      index: true,
      trim: true,
    },
    title: {
      type: String,
      required: true,
      trim: true,
    },
    content: {
      type: String,
      required: true,
    },
  },
  {
    timestamps: true,
  }
);

const PageContent: Model<IPageContent> =
  mongoose.models.PageContent ||
  mongoose.model<IPageContent>("PageContent", PageContentSchema);

export default PageContent;

// ===== src/models/Post.ts =====

import mongoose, { Schema, Document } from "mongoose";

export type SportsCategory = "football" | "basketball" | "tennis" | "general";
export type NewsType = "news" | "highlights" | "reviews" | "prediction";

export interface IPost extends Document {
  title: string;
  content: string;
  slug: string;
  author: string;
  status: "draft" | "published";
  createdAt: Date;
  updatedAt: Date;
  featuredImage?: string;
  featuredImageTitle?: string;
  featuredImageAltText?: string;
  metaTitle?: string;
  metaDescription?: string;

  language: string;
  translationGroupId: mongoose.Types.ObjectId;

  sportsCategory: SportsCategory[];
  isAIGenerated?: boolean;
  originalExternalArticleId?: mongoose.Types.ObjectId;
  originalFixtureId?: number;
  newsType: NewsType;
  linkedFixtureId?: number;
  linkedLeagueId?: number;
  linkedTeamId?: number;
}

const PostSchema: Schema = new Schema(
  {
    title: { type: String, required: true, trim: true },
    content: { type: String, required: true },
    slug: {
      type: String,
      required: true,
      lowercase: true,
      trim: true,
    },
    author: { type: String, default: "Admin" },
    status: { type: String, enum: ["draft", "published"], default: "draft" },
    featuredImage: { type: String, trim: true },
    featuredImageTitle: { type: String, trim: true },
    featuredImageAltText: { type: String, trim: true },
    metaTitle: { type: String, trim: true },
    metaDescription: { type: String, trim: true },

    language: {
      type: String,
      required: true,
      index: true,
    },
    translationGroupId: {
      type: Schema.Types.ObjectId,
      required: true,
      index: true,
    },

    sportsCategory: {
      type: [
        {
          type: String,
          enum: ["football", "basketball", "tennis", "general"],
        },
      ],
      default: ["general"],
      required: true,
    },
    isAIGenerated: { type: Boolean, default: false },
    originalExternalArticleId: {
      type: Schema.Types.ObjectId,
      ref: "ExternalNewsArticle",
      required: false,
    },
    originalFixtureId: {
      type: Number,
      required: false,
      unique: true,
      sparse: true,
    },
    newsType: {
      type: String,
      enum: ["news", "highlights", "reviews", "prediction"],
      default: "news",
      required: true,
    },
    linkedFixtureId: {
      type: Number,
      required: false,
      index: true,
    },
    linkedLeagueId: {
      type: Number,
      required: false,
      index: true,
    },
    linkedTeamId: {
      type: Number,
      required: false,
      index: true,
    },
  },
  {
    timestamps: true,
  }
);

PostSchema.index({ slug: 1, language: 1 }, { unique: true });

export default (mongoose.models.Post as mongoose.Model<IPost>) ||
  mongoose.model<IPost>("Post", PostSchema);

// ===== src/models/TickerMessage.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

export interface ITickerMessage extends Document {
  message: string;
  language: string;
  translationGroupId: mongoose.Types.ObjectId;
  isActive: boolean;
  order: number;
  createdAt: Date;
  updatedAt: Date;
}

const TickerMessageSchema: Schema<ITickerMessage> = new Schema(
  {
    message: {
      type: String,
      required: [true, "Message content is required."],
      trim: true,
    },
    language: {
      type: String,
      required: [true, "Language is required."],
      index: true,
    },
    translationGroupId: {
      type: Schema.Types.ObjectId,
      required: true,
      index: true,
    },
    isActive: {
      type: Boolean,
      default: true,
      index: true,
    },
    order: {
      type: Number,
      default: 0,
    },
  },
  {
    timestamps: true,
  }
);

const TickerMessage: Model<ITickerMessage> =
  mongoose.models.TickerMessage ||
  mongoose.model<ITickerMessage>("TickerMessage", TickerMessageSchema);

export default TickerMessage;

// ===== src/models/TitleTemplate.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

export interface ITitleTemplate extends Document {
  name: string;
  description?: string;
  template: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

const TitleTemplateSchema: Schema<ITitleTemplate> = new Schema(
  {
    name: {
      type: String,
      required: [true, "Template name is required."],
      unique: true,
      trim: true,
    },
    description: {
      type: String,
      trim: true,
    },
    template: {
      type: String,
      required: [true, "Template content is required."],
      trim: true,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
  }
);

const TitleTemplate: Model<ITitleTemplate> =
  mongoose.models.TitleTemplate ||
  mongoose.model<ITitleTemplate>("TitleTemplate", TitleTemplateSchema);

export default TitleTemplate;

// ===== src/models/User.ts =====

import mongoose, { Schema, models, model } from 'mongoose';

export interface IUser extends mongoose.Document {
  name?: string;
  email: string;
  image?: string;
  password?: string;
  role: 'user' | 'admin';
  favoriteTeams?: number[];
}

const UserSchema = new Schema<IUser>({
  name: String,
  email: {
    type: String,
    unique: true,
    required: true,
  },
  image: String,

  password: {
    type: String,
    select: false,
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user',
  },
  favoriteTeams: {
    type: [Number],
    default: [],
  },
}, { timestamps: true });

const User = models.User || model<IUser>('User', UserSchema);
export default User;

// ===== src/models/Vote.ts =====

import mongoose, { Schema, Document, models, Model } from 'mongoose';

export interface IVote extends Document {
  fixtureId: number;
  homeVotes: number;
  drawVotes: number;
  awayVotes: number;
}

const VoteSchema: Schema = new Schema(
  {
    fixtureId: {
        type: Number,
        required: true,
        unique: true,
        index: true
    },
    homeVotes: { type: Number, default: 0 },
    drawVotes: { type: Number, default: 0 },
    awayVotes: { type: Number, default: 0 },
  },
  {
    timestamps: true,
  }
);

const Vote: Model<IVote> = models.Vote || mongoose.model<IVote>('Vote', VoteSchema);

export default Vote;

// ===== src/services/sports/ISportService.ts =====

export interface ISportService {

  getCompetitions(params: { country?: string; type?: string; fetchAll?: boolean }): Promise<any[]>;

  getFixtures(params: { competitionId?: string; date?: string; season?: string; live?: boolean; teamId?: string }): Promise<any[]>;

  getMatchDetails(matchId: string): Promise<any | null>;

  getTeamDetails(teamId: string): Promise<any | null>;

  getStandings(params: { competitionId: string; season: string }): Promise<any | null>;

}

// ===== src/services/sports/football.service.ts =====

import axios from 'axios';
import { ISportService } from './ISportService';
import { format, addDays } from 'date-fns';

export class FootballApiService implements ISportService {
  private readonly apiKey = process.env.NEXT_PUBLIC_API_FOOTBALL_KEY;
  private readonly apiHost = process.env.NEXT_PUBLIC_API_FOOTBALL_HOST;

  private async request(endpoint: string, params: object) {
    const options = {
      method: 'GET',
      url: `${this.apiHost}/${endpoint}`,
      params,
      headers: { 'x-apisports-key': this.apiKey },
    };
    try {
      const response = await axios.request(options);
      return response.data.response;
    } catch (error) {

      throw new Error(`Failed to fetch data from ${endpoint}.`);
    }
  }

  async getCompetitions(params: { country?: string; type?: string; fetchAll?: boolean }): Promise<any[]> {

    const apiParams: any = { current: 'true' };
    if (params.country) apiParams.country = params.country;
    if (params.type) apiParams.type = params.type;

    let allLeagues = await this.request('leagues', apiParams);

    return allLeagues;
  }

  async getFixtures(params: { competitionId?: string; date?: string; teamId?: string }): Promise<any[]> {

    const apiParams: any = {};
    const season = new Date().getFullYear().toString();

    if (params.competitionId) apiParams.league = params.competitionId;
    if (params.date) apiParams.date = params.date;
    if (params.teamId) {
        apiParams.team = params.teamId;
        apiParams.last = 10;
    } else {

        apiParams.season = season;
        const today = format(new Date(), 'yyyy-MM-dd');
        apiParams.from = today;
        apiParams.to = format(addDays(new Date(), 1), 'yyyy-MM-dd');
    }

    return this.request('fixtures', apiParams);
  }

  async getMatchDetails(matchId: string): Promise<any | null> {

    const [fixture, events, stats, h2h, prediction] = await Promise.all([
        this.request('fixtures', { id: matchId }),
        this.request('fixtures/events', { fixture: matchId }),
        this.request('fixtures/statistics', { fixture: matchId }),
        this.request('fixtures/headtohead', { h2h: `...` }),
        this.request('predictions', { fixture: matchId })
    ]);

    return { fixture: fixture[0], events, statistics: stats,  };
  }

  async getTeamDetails(teamId: string): Promise<any | null> {

      return await this.request('teams', { id: teamId });
  }

  async getStandings(params: { competitionId: string; season: string; }): Promise<any | null> {
      return this.request('standings', { league: params.competitionId, season: params.season });
  }
}

// ===== src/services/sports/index.ts =====

import { ISportService } from './ISportService';
import { FootballApiService } from './football.service';

const services: { [key: string]: ISportService } = {
  football: new FootballApiService(),

};

export function getSportService(sport: string): ISportService {
  const service = services[sport];
  if (!service) {
    throw new Error(`Unsupported sport: ${sport}`);
  }
  return service;
}

// ===== src/services/sportsApi/allsportsApiService.ts =====

export interface ApiSportsTeam {
  id: number;
  name: string;
  logo: string;
  winner?: boolean | null;
}

export interface ApiSportsFixtureStatus {
  long: string;
  short: string;
  elapsed: number | null;
}

export interface ApiSportsLeague {
  id: number;
  name: string;
  type: string;
  logo: string;
  season?: number;
}

export interface ApiSportsGoals {
  home: number | null;
  away: number | null;
}

export interface ApiSportsFixture {
  fixture: {
    id: number;
    referee: string | null;
    timezone: string;
    date: string;
    timestamp: number;
    periods: { first: number | null; second: number | null };
    venue: { id: number; name: string; city: string };
    status: ApiSportsFixtureStatus;
  };
  league: ApiSportsLeague;
  teams: {
    home: ApiSportsTeam;
    away: ApiSportsTeam;
  };
  goals: ApiSportsGoals;
  score: {
    halftime: ApiSportsGoals;
    fulltime: ApiSportsGoals;
    extratime: ApiSportsGoals | null;
    penalty: ApiSportsGoals | null;
  };
  events?: any[];
  statistics?: any[];
  lineups?: any[];
}

export interface ApiSportsTeamStanding {
  rank: number;
  team: ApiSportsTeam;
  points: number;
  goalsDiff: number;
  group: string;
  form: string;
  status: string;
  description: string | null;
  all: {
    played: number;
    win: number;
    draw: number;
    lose: number;
    goals: { for: number; against: number };
  };
  home: {
    played: number;
    win: number;
    draw: number;
    lose: number;
    goals: { for: number; against: number };
  };
  away: {
    played: number;
    win: number;
    draw: number;
    lose: number;
    goals: { for: number; against: number };
  };
  update: string;
}

export interface ApiSportsStandings {
  league: {
    id: number;
    name: string;
    country: string;
    logo: string;
    flag: string;
    season: number;
    standings: ApiSportsTeamStanding[][];
  };
}

export interface CleanOdds {
  home: string | null;
  draw: string | null;
  away: string | null;
  handicap?: string | null;
  over?: string | null;
  under?: string | null;
}

export interface ApiSportsPlayer {
  id: number;
  name: string;
  firstname: string;
  lastname: string;
  age: number;
  birth: {
    date: string;
    place: string;
    country: string;
  };
  nationality: string;
  height: string;
  weight: string;
  injured: boolean;
  photo: string;
}

export interface ApiSportsPlayerStats {
  player: ApiSportsPlayer;
  statistics: {
    team: ApiSportsTeam;
    league: ApiSportsLeague;
    games: {
      appearences: number | null;
      lineups: number | null;
      minutes: number | null;
      number: number | null;
      position: string;
      rating: string | null;
      captain: boolean;
    };
    substitutes: {
      in: number | null;
      out: number | null;
      bench: number | null;
    };
    goals: {
      total: number | null;
      conceded: number | null;
      assists: number | null;
      saves: number | null;
    };
    passes: {
      total: number | null;
      key: number | null;
      accuracy: string | null;
    };
    tackles: {
      total: number | null;
      blocks: number | null;
      interceptions: number | null;
    };
    duels: {
      total: number | null;
      won: number | null;
    };
    dribbles: {
      attempts: number | null;
      success: number | null;
      past: number | null;
    };
    fouls: {
      drawn: number | null;
      committed: number | null;
    };
    cards: {
      yellow: number;
      red: number;
    };
    penalty: {
      won: number | null;
      commited: number | null;
      scored: number | null;
      missed: number | null;
      saved: number | null;
    };
  }[];
}

export interface Country {
  name: string;
  code: string | null;
  flagUrl: string;
}

// ===== src/types/api-football.ts =====

export interface League {
  id: number;
  name: string;
  logoUrl: string;
  countryName: string;
  countryFlagUrl: string,
  type: string,
  href: string;
}

export interface Country {
  name: string;
  code: string | null;
  flagUrl: string;
}

// ===== src/types/global.d.ts =====

import { Mongoose } from 'mongoose';

declare global {
  var mongoose: {
    conn: Mongoose | null;
    promise: Promise<Mongoose> | null;
  };
}

// ===== src/types/next-auth.d.ts =====

import 'next-auth';
import 'next-auth/jwt';

declare module 'next-auth' {

  interface Session {
    user: {
      id: string;
      role: 'user' | 'admin';
    } & DefaultSession['user'];
  }

  interface User {
    role: 'user' | 'admin';
  }
}

declare module 'next-auth/jwt' {

  interface JWT {
    id: string;
    role: 'user' | 'admin';
  }
}

// ===== src/types/translations.d.ts =====

export type TranslationKey =

  | "live"
  | "matches"
  | "yesterday"
  | "today"
  | "tomorrow"
  | "standings"
  | "news"
  | "analytics"
  | "global"
  | "loading"
  | "leagues"
  | "teams"
  | "transfers"
  | "football"
  | "tennis"
  | "basketball"
  | "rugby"
  | "badminton"
  | "cancel"
  | "saving"
  | "previous"
  | "next"
  | "page_of"
  | "actions"
  | "advertisement"

  | "admin_login"
  | "email"
  | "password"
  | "sign_in"
  | "invalid_credentials"
  | "register"
  | "user"
  | "role"
  | "your_profile"
  | "view_account_settings"

  | "admin_dashboard"
  | "welcome_to_admin_area"
  | "manage_users"
  | "view_and_edit_user_roles"
  | "manage_matches"
  | "update_match_details"
  | "view_analytics"
  | "check_site_traffic"
  | "dashboard"
  | "users"
  | "settings"
  | "admin_panel"
  | "sign_out"

  | "create_new_post"
  | "edit_post"
  | "manage_news"
  | "new_post"
  | "back_to_news_list"
  | "loading_post_data"
  | "failed_to_load_post_data"
  | "save_post"
  | "save_changes"
  | "featured_image"
  | "uploading"
  | "upload_a_file"
  | "or_drag_and_drop"
  | "image_upload_formats"
  | "image_title_tooltip"
  | "image_title_placeholder"
  | "image_alt_text_label"
  | "image_alt_text_placeholder"
  | "image_alt_text_description"
  | "title"
  | "content"
  | "created_at"
  | "seo_settings"
  | "meta_title"
  | "meta_title_placeholder"
  | "meta_title_recommendation"
  | "meta_description"
  | "meta_description_placeholder"
  | "meta_description_recommendation"
  | "status"
  | "draft"
  | "published"
  | "latest_news"

  | "match_details"
  | "view_match_details"
  | "finished"
  | "vote_and_see_poll"
  | "hide_panel"
  | "no_matches_for_day"
  | "check_another_day"
  | "match_not_found"
  | "match_not_found_description"
  | "team_not_found"
  | "events"
  | "lineups"
  | "h2h"
  | "statistics"
  | "prediction"
  | "head_to_head"
  | "wins"
  | "draws"
  | "no_previous_encounters"
  | "recent_result"
  | "upcoming_match"
  | "no_matches_live"
  | "live_matches"
  | "info"
  | "fixtures"
  | "top_scorers"
  | "back_to_global_view"
  | "standings_not_applicable_for_cups"
  | "season"
  | "competition_name"
  | "country"
  | "current_season"
  | "season_coverage"
  | "rank_short"
  | "team"
  | "matches_played_short"
  | "wins_short"
  | "draws_short"
  | "losses_short"
  | "goal_difference_short"
  | "points_short"
  | "league_standings"
  | "select_league_for_standings"
  | "next_league"
  | "versus"

  | "popular_leagues"
  | "popular_cups"
  | "popular_teams"

  | "published_by_on"
  | "share_this_article"

  | "total_goals_today"
  | "matches_today"
  | "match_spotlight"
  | "highest_scoring_match"

  | "show_odds"
  | "hide_odds"
  | "exclusive_welcome_offer"
  | "bonus_description"
  | "claim_your_bonus"
  | "gambling_disclaimer"
  | "leagues_description"
  | "teams_description"
  | "news_description"
  | "transfers_description";
