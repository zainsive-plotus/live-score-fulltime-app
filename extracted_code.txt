// ===== src/app/NextAuthProvider.tsx =====

"use client";

import { SessionProvider } from "next-auth/react";

export default function NextAuthProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  return <SessionProvider>{children}</SessionProvider>;
}

// ===== src/app/[locale]/author/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import { notFound } from "next/navigation";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { UserCircle } from "lucide-react";
import AdSlotWidget from "@/components/AdSlotWidget";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import Script from "next/script";
import {
  WithContext,
  AboutPage,
  Organization,
  BreadcrumbList,
} from "schema-dts";

const PAGE_SLUG = "author";
const PAGE_PATH = "/author";
const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

async function getPageContent() {
  try {
    const response = await axios.get(`${BASE_URL}/api/pages/${PAGE_SLUG}`);
    return response.data;
  } catch (error) {
    return null;
  }
}

export async function generateMetadata({
  params: { locale },
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const t = await getI18n(locale);
  const title = t("author_default_page_title");
  const description = t("author_default_page_description");
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, "", locale);

  return {
    title: title,
    description: description,
    alternates: hreflangAlternates,
  };
}

export default async function AuthorPage({
  params: { locale },
}: {
  params: { locale: string };
}) {
  const t = await getI18n(locale);
  const pageContent = await getPageContent();

  if (!pageContent || !pageContent.content) {
    notFound();
  }

  const pageDescription = t("author_default_page_description");

  const jsonLd: WithContext<AboutPage | BreadcrumbList>[] = [
    {
      "@context": "https://schema.org",
      "@type": "AboutPage",
      mainEntity: {
        "@type": "Organization",
        name: "Fan Skor",
        url: BASE_URL,
        logo: `${BASE_URL}/fanskor-transparent.webp`,
      },
      name: pageContent.title,
      description: pageDescription,
      url: `${BASE_URL}/${locale}${PAGE_PATH}`,
    },
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: t("homepage"),
          item: `${BASE_URL}/${locale}`,
        },
        {
          "@type": "ListItem",
          position: 2,
          name: pageContent.title,
        },
      ],
    },
  ];

  return (
    <>
      <Script
        id="author-page-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
          <Sidebar />

          <main className="min-w-0">
            <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
              <div className="flex items-center gap-4 mb-4">
                <div className="p-3 bg-purple-500/10 rounded-lg">
                  <UserCircle className="w-8 h-8 text-purple-400" />
                </div>
                <h1 className="text-4xl font-extrabold text-white">
                  {pageContent.title}
                </h1>
              </div>

              <div
                className="prose prose-invert lg:prose-xl max-w-none text-text-secondary"
                dangerouslySetInnerHTML={{ __html: pageContent.content }}
              />
            </div>
          </main>

          <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
            <RecentNewsWidget />
            <AdSlotWidget location="homepage_right_sidebar" />
          </aside>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/contact-us/page.tsx =====

import type { Metadata } from "next";
import { Mail, Phone, MapPin } from "lucide-react";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import ContactFormClient from "@/components/ContactFormClient";
import AdSlotWidget from "@/components/AdSlotWidget";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import Script from "next/script";
import {
  WithContext,
  ContactPage,
  Organization,
  BreadcrumbList,
  PostalAddress,
} from "schema-dts";

const PAGE_PATH = "/contact-us";
const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

export async function generateMetadata({
  params: { locale },
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const t = await getI18n(locale);
  const pageTitle = t("contact_us_meta_title");
  const pageDescription = t("contact_us_meta_description");
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, "", locale);

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
    openGraph: {
      title: pageTitle,
      description: pageDescription,
      url: `${BASE_URL}${PAGE_PATH}`,
      siteName: "Fan Skor",
      type: "website",
    },
  };
}

export default async function ContactUsPage({
  params: { locale },
}: {
  params: { locale: string };
}) {
  const t = await getI18n(locale);
  const contactPageSeoText = t("contact_us_seo_text");

  const address: PostalAddress = {
    "@type": "PostalAddress",
    streetAddress: "123 Futbol Sokak, Spor Mahallesi",
    addressLocality: "Istanbul",
    postalCode: "34000",
    addressCountry: "TR",
  };

  const jsonLd: WithContext<ContactPage | BreadcrumbList>[] = [
    {
      "@context": "https://schema.org",
      "@type": "ContactPage",
      name: t("contact_us_meta_title"),
      description: t("contact_us_meta_description"),
      url: `${BASE_URL}/${locale}${PAGE_PATH}`,
      mainEntity: {
        "@type": "Organization",
        name: "Fan Skor",
        url: BASE_URL,
        logo: `${BASE_URL}/fanskor-transparent.webp`,
        contactPoint: [
          {
            "@type": "ContactPoint",
            telephone: "+90-555-123-4567",
            contactType: "customer support",
            email: "support@fanskor.com",
            areaServed: "TR",
            availableLanguage: [
              "English",
              "Turkish",
              "Africans",
              "Spanish",
              "French",
              "Italians",
            ],
          },
        ],
        address: address,
      },
    },
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: t("homepage"),
          item: `${BASE_URL}/${locale}`,
        },
        {
          "@type": "ListItem",
          position: 2,
          name: t("contact_us_form_title"),
        },
      ],
    },
  ];

  return (
    <>
      <Script
        id="contact-page-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
          <Sidebar />
          <main className="min-w-0">
            <div className="bg-brand-secondary p-6 rounded-lg shadow-xl mb-8">
              <h1 className="text-3xl font-bold text-white mb-3">
                {t("contact_us_form_title")}
              </h1>
              <p className="text-brand-light text-base leading-relaxed">
                {contactPageSeoText}
              </p>
            </div>
            <div className="grid grid-cols-1 gap-8">
              <ContactFormClient />
              <div className="bg-brand-secondary p-8 rounded-lg shadow-xl">
                <h2 className="text-3xl font-bold text-white mb-6">
                  {t("contact_information_title")}
                </h2>
                <div className="space-y-6 text-brand-light">
                  <div className="flex items-center gap-4">
                    <Mail size={24} className="text-brand-purple" />
                    <div>
                      <h3 className="font-semibold text-white">{t("email")}</h3>
                      <p className="text-brand-muted">support@fanskor.com</p>
                    </div>
                  </div>
                  <div className="flex items-center gap-4">
                    <Phone size={24} className="text-brand-purple" />
                    <div>
                      <h3 className="font-semibold text-white">{t("phone")}</h3>
                      <p className="text-brand-muted">+90 (555) 123 45 67</p>
                    </div>
                  </div>
                  <div className="flex items-center gap-4">
                    <MapPin size={24} className="text-brand-purple" />
                    <div>
                      <h3 className="font-semibold text-white">
                        {t("address")}
                      </h3>
                      <p
                        className="text-brand-muted"
                        dangerouslySetInnerHTML={{
                          __html: t("contact_address_html"),
                        }}
                      ></p>
                    </div>
                  </div>
                  <div className="text-sm pt-4 border-t border-gray-700 text-brand-muted">
                    {t("contact_response_time_info")}
                  </div>
                </div>
              </div>
            </div>
          </main>
          <aside className="lg:col-span-1 space-y-8 min-w-0 mt-8 lg:mt-0">
            <RecentNewsWidget />
            <AdSlotWidget location="homepage_right_sidebar" />
          </aside>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/faq/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { HelpCircle } from "lucide-react";
import AdSlotWidget from "@/components/AdSlotWidget";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import { getI18n } from "@/lib/i18n/server";
import { IFaq } from "@/models/Faq";
import FaqClient from "@/components/FaqClient";
import { generateHreflangTags } from "@/lib/hreflang";
import Script from "next/script";
import { WithContext, FAQPage } from "schema-dts";

const PAGE_PATH = "/faq";
const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

async function fetchFaqs(): Promise<IFaq[]> {
  try {
    const { data } = await axios.get(`${BASE_URL}/api/faqs`);
    return data;
  } catch (error) {

    return [];
  }
}

export async function generateMetadata({
  params: { locale },
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, "", locale);

  return {
    title: t("faq_meta_title"),
    description: t("faq_meta_description"),
    alternates: hreflangAlternates,
  };
}

export default async function FaqPage({
  params: { locale },
}: {
  params: { locale: string };
}) {
  const t = await getI18n(locale);
  const allFaqs = await fetchFaqs();

  const jsonLd: WithContext<FAQPage> = {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    mainEntity: allFaqs.map((faq) => ({
      "@type": "Question",
      name: faq.question,
      acceptedAnswer: {
        "@type": "Answer",
        text: faq.answer,
      },
    })),
  };

  return (
    <>
      <Script
        id="faq-page-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
          <Sidebar />

          <main className="min-w-0 space-y-8">
            <div className="bg-brand-secondary p-6 rounded-lg shadow-xl text-center">
              <HelpCircle className="w-12 h-12 text-[var(--brand-accent)] mx-auto mb-4" />
              <h1 className="text-4xl font-extrabold text-white">
                {t("faq_page_main_title")}
              </h1>
              <p className="text-text-muted mt-2 max-w-2xl mx-auto">
                {t("faq_page_subtitle")}
              </p>
            </div>

            <FaqClient initialFaqs={allFaqs} />
          </main>

          <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
            <RecentNewsWidget />
            <AdSlotWidget location="homepage_right_sidebar" />
          </aside>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/football/league/[...slug]/page.tsx =====

import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { notFound } from "next/navigation";
import type { Metadata } from "next";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import { getLeaguePageData } from "@/lib/data/league";
import { generateStandingsSlug } from "@/lib/generate-standings-slug";

import LeagueHeader from "@/components/league-detail-view/LeagueHeader";
import LeagueStandingsWidget from "@/components/league-detail-view/LeagueStandingsWidget";
import LeagueFixturesWidget from "@/components/league-detail-view/LeagueFixturesWidget";
import LeagueTeamsList from "@/components/league-detail-view/LeagueTeamsList";
import AdSlotWidget from "@/components/AdSlotWidget";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import LeagueDetailWidget from "@/components/directory/LeagueDetailWidget";

import Script from "next/script";
import { WithContext, SportsEvent, BreadcrumbList } from "schema-dts";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

const getLeagueIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

export async function generateMetadata({
  params,
}: {
  params: { slug: string[]; locale: string };
}): Promise<Metadata> {
  const { slug, locale } = params;
  const t = await getI18n(locale);
  const leagueId = getLeagueIdFromSlug(slug[0]);

  const hreflangAlternates = await generateHreflangTags(
    "/football/league",
    slug.join("/"),
    locale
  );

  if (!leagueId) {
    return {
      title: t("not_found_title"),
      alternates: hreflangAlternates,
    };
  }

  const leagueData = await getLeaguePageData(leagueId);

  if (!leagueData) {
    return {
      title: t("not_found_title"),
      alternates: hreflangAlternates,
      robots: { index: false, follow: false },
    };
  }

  const { league, country } = leagueData;

  return {
    title: t("league_page_title", {
      leagueName: league.name,
      countryName: country.name,
    }),
    description: t("league_page_description", {
      leagueName: league.name,
      countryName: country.name,
    }),
    alternates: hreflangAlternates,
  };
}

export default async function LeaguePage({
  params,
}: {
  params: { slug: string[]; locale: string };
}) {
  const { slug, locale } = params;
  const t = await getI18n(locale);
  const leagueId = getLeagueIdFromSlug(slug[0]);
  if (!leagueId) notFound();

  const leagueData = await getLeaguePageData(leagueId);
  if (!leagueData) notFound();

  const { league, country, seasons, standings } = leagueData;
  const currentSeason =
    seasons.find((s: any) => s.current === true)?.year ||
    new Date().getFullYear();

  const standingsSlug = generateStandingsSlug(league.name, league.id);

  const jsonLd: WithContext<SportsEvent | BreadcrumbList>[] = [
    {
      "@context": "https://schema.org",
      "@type": "SportsEvent",
      name: `${league.name} ${currentSeason}/${currentSeason + 1}`,
      sport: "Soccer",
      location: {
        "@type": "Country",
        name: country.name,
      },
      competitor:
        standings?.[0]?.map((teamStanding: any) => ({
          "@type": "SportsTeam",
          name: teamStanding.team.name,
        })) || [],
      description: t("league_page_description", {
        leagueName: league.name,
        countryName: country.name,
      }),
      startDate: seasons.find((s: any) => s.year === currentSeason)?.start,
      endDate: seasons.find((s: any) => s.year === currentSeason)?.end,
    },
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: t("homepage"),
          item: `${BASE_URL}/${locale}`,
        },
        {
          "@type": "ListItem",
          position: 2,
          name: t("leagues"),
          item: `${BASE_URL}/${locale}/football/leagues`,
        },
        {
          "@type": "ListItem",
          position: 3,
          name: league.name,
        },
      ],
    },
  ];

  return (
    <>
      {}
      <Script
        id="league-page-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
          <Sidebar />

          <main className="min-w-0 space-y-8">
            <LeagueHeader
              league={league}
              country={country}
              currentSeason={currentSeason}
            />

            {league.type === "League" && (
              <LeagueStandingsWidget
                initialStandings={leagueData.standings}
                leagueSeasons={seasons
                  .map((s: any) => s.year)
                  .sort((a: number, b: number) => b - a)}
                currentSeason={currentSeason}
                isLoading={false}
                leagueId={league.id}
                leagueSlug={standingsSlug}
              />
            )}

            <LeagueFixturesWidget leagueId={league.id} season={currentSeason} />

            <LeagueTeamsList
              leagueId={league.id}
              season={currentSeason}
              countryName={country.name}
              countryFlag={country.flag}
            />
          </main>

          <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
            <LeagueDetailWidget
              league={leagueData.league}
              leagueStats={leagueData.leagueStats}
              topScorer={leagueData.topScorer}
            />
            <RecentNewsWidget />
            <AdSlotWidget location="homepage_right_sidebar" />
          </aside>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/football/leagues/page.tsx =====

import type { Metadata } from "next";

import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import LeagueListClient from "@/components/LeagueListClient";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import { WithContext, CollectionPage, BreadcrumbList } from "schema-dts";
import Script from "next/script";

const PAGE_PATH = "/football/leagues";
const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";
export const dynamic = "force-dynamic";

export async function generateMetadata({
  params,
}: {
  params: Promise<{ locale: string }>;
}): Promise<Metadata> {
  const { locale } = await params;

  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, "", locale);

  const pageTitle = t("leagues_page_meta_title");
  const pageDescription = t("leagues_page_meta_description");

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
    openGraph: {
      title: pageTitle,
      description: pageDescription,
      url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/${locale}${PAGE_PATH}`,
      siteName: "Fan Skor",
      type: "website",
    },
    twitter: {
      card: "summary_large_image",
      title: pageTitle,
      description: pageDescription,
    },
  };
}

export default async function LeaguesPage({
  params: { locale },
}: {
  params: { locale: string };
}) {

  const t = await getI18n(locale);

  const leaguesPageSeoText = t("leagues_page_seo_text");

  const jsonLd: WithContext<CollectionPage | BreadcrumbList>[] = [
    {
      "@context": "https://schema.org",
      "@type": "CollectionPage",
      name: t("leagues_page_meta_title"),
      description: t("leagues_page_meta_description"),
      url: `${BASE_URL}/${locale}${PAGE_PATH}`,
    },
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: t("homepage"),
          item: `${BASE_URL}/${locale}`,
        },
        {
          "@type": "ListItem",
          position: 2,
          name: t("leagues_and_cups_title"),
        },
      ],
    },
  ];

  return (
    <>
      {" "}
      <Script
        id="leagues-page-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
          <Sidebar />
          <main className="min-w-0">
            <h1 className="text-4xl font-extrabold text-white mb-6">
              {t("leagues_and_cups_title")}
            </h1>
            <p className="italic text-[#a3a3a3] leading-relaxed mb-8">
              {leaguesPageSeoText}
            </p>
            {}
            <LeagueListClient initialAllLeagues={[]} />
            {}
          </main>
          <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
            <RecentNewsWidget />
            <AdSlotWidget location="homepage_right_sidebar" />
          </aside>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/football/match/[...slug]/SidebarContent.tsx =====

"use client";

import dynamic from "next/dynamic";
import {
  AdSlotWidgetSkeleton,
  RecentNewsWidgetSkeleton,
} from "@/components/skeletons/WidgetSkeletons";
import { PredictionWidgetSkeleton } from "@/components/match/MatchPredictionWidget";
import MatchAboutWidget from "@/components/match/MatchAboutWidget";

const LiveOddsWidget = dynamic(
  () => import("@/components/match/LiveOddsWidget"),
  { ssr: false }
);
const LinkedNewsWidget = dynamic(
  () => import("@/components/match/LinkedNewsWidget"),
  { loading: () => <RecentNewsWidgetSkeleton /> }
);
const MatchHighlightsWidget = dynamic(
  () => import("@/components/match/MatchHighlightsWidget")
);

const MatchPredictionWidget = dynamic(
  () => import("@/components/match/MatchPredictionWidget"),
  { loading: () => <PredictionWidgetSkeleton />, ssr: false }
);
const AdSlotWidget = dynamic(() => import("@/components/AdSlotWidget"), {
  loading: () => <AdSlotWidgetSkeleton />,
  ssr: false,
});

interface SidebarContentProps {
  fixtureData: any;
  isLive: boolean;
  aboutMatchTitle: string;
  aboutMatchSeoText: string;
}

export default function SidebarContent({
  fixtureData,
  isLive,
  aboutMatchTitle,
  aboutMatchSeoText,
}: SidebarContentProps) {
  const { fixture, league, teams } = fixtureData;

  return (
    <>
      {isLive && <LiveOddsWidget fixtureId={fixture.id.toString()} />}

      <LinkedNewsWidget fixtureId={fixture.id} />

      <MatchHighlightsWidget
        leagueName={league.name}
        homeTeamName={teams.home.name}
        awayTeamName={teams.away.name}
      />

      <MatchPredictionWidget fixtureId={fixture.id.toString()} />

      <MatchAboutWidget title={aboutMatchTitle} seoText={aboutMatchSeoText} />

      <AdSlotWidget location="match_sidebar" />
    </>
  );
}

// ===== src/app/[locale]/football/match/[...slug]/page.tsx =====

import { Suspense } from "react";
import { notFound } from "next/navigation";
import type { Metadata } from "next";
import { getFixture, getStatistics } from "@/lib/data/match";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import Header from "@/components/Header";
import { MatchHeader } from "@/components/match/MatchHeader";
import TeamFormWidget from "@/components/match/TeamFormWidget";
import MatchH2HWidget from "@/components/match/MatchH2HWidget";
import MatchLineupsWidget from "@/components/match/MatchFormationWidget";
import MatchStatsWidget from "@/components/match/MatchStatsWidget";
import MatchActivityWidget from "@/components/match/MatchActivityWidget";
import SidebarContent from "./SidebarContent";
import {
  AdSlotWidgetSkeleton,
  RecentNewsWidgetSkeleton,
} from "@/components/skeletons/WidgetSkeletons";
import MatchFormationWidget from "@/components/match/MatchFormationWidget";
import StandingsWidget from "@/components/StandingsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import { generateMatchSlug } from "@/lib/generate-match-slug";
import { format, addDays, subDays } from "date-fns";
import { getFixturesByDateRange } from "@/lib/data/fixtures";
import { SUPPORTED_LOCALES } from "@/lib/i18n/config";

export const revalidate = 3600;

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

export async function generateStaticParams() {
  const fromDate = format(subDays(new Date(), 2), "yyyy-MM-dd");
  const toDate = format(addDays(new Date(), 2), "yyyy-MM-dd");
  console.log(
    "[generateStaticParams/Match] Fetching all matches for all locales..."
  );

  const matches = await getFixturesByDateRange(fromDate, toDate);
  console.log(
    `[generateStaticParams/Match] Found ${matches.length} matches to generate.`
  );

  const paths = matches.flatMap((match: any) =>
    SUPPORTED_LOCALES.map((locale) => ({
      locale: locale,
      slug: [
        generateMatchSlug(match.teams.home, match.teams.away, match.fixture.id)
          .split("/")
          .pop(),
      ],
    }))
  );

  console.log(
    `[generateStaticParams/Match] Returning ${paths.length} total paths for Next.js to build.`
  );
  return paths;
}
const getFixtureIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug?.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

export async function generateMetadata({
  params,
}: {
  params: { slug: string[]; locale: string };
}): Promise<Metadata> {
  const { slug, locale } = params;
  const t = await getI18n(locale);
  const fixtureId = getFixtureIdFromSlug(slug[0]);
  const hreflangAlternates = await generateHreflangTags(
    "/football/match",
    slug.join("/"),
    locale
  );

  if (!fixtureId) {
    return {
      title: t("not_found_title"),
      alternates: hreflangAlternates,
    };
  }

  const fixtureData = await getFixture(fixtureId);

  if (!fixtureData) {
    return {
      title: t("not_found_title"),
      alternates: hreflangAlternates,
      robots: { index: false, follow: false },
    };
  }

  const { teams, league } = fixtureData;
  const pageTitle = t("match_page_title", {
    homeTeam: teams.home.name,
    awayTeam: teams.away.name,
    leagueName: league.name,
  });
  const pageDescription = t("match_page_description", {
    homeTeam: teams.home.name,
    awayTeam: teams.away.name,
    leagueName: league.name,
  });

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
  };
}

const TeamFormContentSkeleton = () => (
  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
    <div className="bg-brand-secondary rounded-lg h-[400px] animate-pulse p-4"></div>
    <div className="bg-brand-secondary rounded-lg h-[400px] animate-pulse p-4"></div>
  </div>
);
const H2HContentSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg h-[450px] animate-pulse p-6"></div>
);
const FormationSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg p-4 md:p-6 animate-pulse h-[600px]"></div>
);
const StandingsWidgetSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg h-96 animate-pulse p-6"></div>
);
const SidebarSkeleton = () => (
  <div className="space-y-6">
    <RecentNewsWidgetSkeleton />
    <div className="aspect-video w-full rounded-lg bg-gray-700/50 animate-pulse"></div>
    <div className="bg-brand-secondary rounded-lg h-80 animate-pulse"></div>
    <AdSlotWidgetSkeleton />
  </div>
);

export default async function MatchDetailPage({
  params,
}: {
  params: { slug: string[]; locale: string };
}) {
  const { slug, locale } = params;
  const t = await getI18n(locale);
  const fixtureId = getFixtureIdFromSlug(slug[0]);
  if (!fixtureId) notFound();

  const fixtureData = await getFixture(fixtureId);
  if (!fixtureData) notFound();

  const statistics = await getStatistics(fixtureId);

  const { teams, fixture: fixtureDetails, league } = fixtureData;

  const isLive = ["1H", "HT", "2H", "ET", "BT", "P", "LIVE"].includes(
    fixtureDetails?.status?.short
  );
  const isFinished = ["FT", "AET", "PEN"].includes(
    fixtureDetails?.status?.short
  );

  const h2hSeoDescription = t("match_page_h2h_seo_text", {
    homeTeam: teams.home.name,
    awayTeam: teams.away.name,
  });
  const activitySeoDescription = t("match_page_activity_seo_text", {
    homeTeam: teams.home.name,
    awayTeam: teams.away.name,
  });
  const aboutMatchTitle = t("about_the_match_title", {
    homeTeam: teams.home.name,
    awayTeam: teams.away.name,
  });
  const aboutMatchSeoText = t("match_page_about_seo_text", {
    homeTeam: teams.home.name,
    awayTeam: teams.away.name,
    leagueName: league.name,
  });

  return (
    <>
      <title>
        {t("match_page_title", {
          homeTeam: teams.home.name,
          awayTeam: teams.away.name,
          leagueName: league.name,
        })}
      </title>
      <meta
        name="description"
        content={t("match_page_description", {
          homeTeam: teams.home.name,
          awayTeam: teams.away.name,
          leagueName: league.name,
        })}
      />

      <div className="bg-brand-dark min-h-screen">
        <Header />
        {}
        <div className="container mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-[320px_1fr_320px] gap-8">
          {}
          <aside className="lg:sticky lg:top-6 space-y-6 lg:order-1">
            <Suspense fallback={<StandingsWidgetSkeleton />}>
              <StandingsWidget
                leagueId={league.id}
                season={league.season}
                homeTeamId={teams.home.id}
                awayTeamId={teams.away.id}
                variant="compact"
              />
            </Suspense>
            <AdSlotWidget location="match_sidebar_left" />
          </aside>

          {}
          <main className="space-y-6 min-w-0 order-first lg:order-2">
            <MatchHeader fixture={fixtureData} />

            <Suspense fallback={<TeamFormContentSkeleton />}>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <TeamFormWidget
                  team={teams.home}
                  location="Home"
                  fixtureData={fixtureData}
                />
                <TeamFormWidget
                  team={teams.away}
                  location="Away"
                  fixtureData={fixtureData}
                />
              </div>
            </Suspense>

            <Suspense fallback={<FormationSkeleton />}>
              <MatchFormationWidget fixtureId={fixtureId} />
            </Suspense>

            <MatchLineupsWidget lineups={fixtureData.lineups} />

            <Suspense fallback={<H2HContentSkeleton />}>
              <MatchH2HWidget
                teams={teams}
                currentFixtureId={fixtureId}
                h2hSeoDescription={h2hSeoDescription}
              />
            </Suspense>

            {(isLive || isFinished) && (
              <MatchStatsWidget statistics={statistics || []} teams={teams} />
            )}

            <MatchActivityWidget
              fixtureId={fixtureId}
              isLive={isLive}
              homeTeamId={teams.home.id}
              activitySeoDescription={activitySeoDescription}
            />
          </main>

          {}
          <aside className="space-y-6 lg:sticky lg:top-6 lg:order-3">
            <Suspense fallback={<SidebarSkeleton />}>
              <SidebarContent
                fixtureData={fixtureData}
                isLive={isLive}
                aboutMatchTitle={aboutMatchTitle}
                aboutMatchSeoText={aboutMatchSeoText}
              />
            </Suspense>
          </aside>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/football/news/NewsPageClient.tsx =====

"use client";

import { usePathname, useRouter, useSearchParams } from "next/navigation";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { IPost } from "@/models/Post";
import { useTranslation } from "@/hooks/useTranslation";
import { Info } from "lucide-react";
import Pagination from "@/components/Pagination";
import NewsListItemCompact, {
  NewsListItemCompactSkeleton,
} from "@/components/NewsListItemCompact";

const ITEMS_PER_PAGE = 10;

const fetchFootballNews = async (locale: string, page: number) => {
  const params = new URLSearchParams({
    language: locale,
    page: page.toString(),
    limit: ITEMS_PER_PAGE.toString(),
    sportsCategory: "football",
    newsType: "news",
  });

  const { data } = await axios.get(`/api/posts?${params.toString()}`);
  return data as { posts: IPost[]; pagination: { totalPages: number } };
};

interface NewsPageClientProps {
  initialData: {
    posts: IPost[];
    pagination: { totalPages: number };
  };
}

export default function NewsPageClient({ initialData }: NewsPageClientProps) {
  const { t, locale } = useTranslation();
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  const currentPage = Number(searchParams.get("page")) || 1;

  const { data, isLoading } = useQuery({
    queryKey: ["footballNews", currentPage, locale],
    queryFn: () => fetchFootballNews(locale, currentPage),

    initialData: initialData,

    staleTime: 1000 * 60,
  });

  const handlePageChange = (page: number) => {
    const params = new URLSearchParams(searchParams.toString());
    params.set("page", page.toString());

    router.push(`${pathname}?${params.toString()}`);
  };

  if (isLoading) {
    return (
      <div className="space-y-4">
        {[...Array(ITEMS_PER_PAGE)].map((_, i) => (
          <NewsListItemCompactSkeleton key={i} />
        ))}
      </div>
    );
  }

  if (!data?.posts || data.posts.length === 0) {
    return (
      <div className="text-center py-20 bg-brand-secondary rounded-lg">
        <Info size={32} className="mx-auto text-brand-muted mb-3" />
        <p className="text-xl font-bold text-white">
          {t("no_news_found_title")}
        </p>
        <p className="text-brand-muted mt-2">
          {t("no_football_news_found_subtitle")}
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {data.posts.map((post) => (
        <NewsListItemCompact key={post._id as string} post={post} />
      ))}

      {data.pagination.totalPages > 1 && (
        <div className="pt-4">
          <Pagination
            currentPage={currentPage}
            totalPages={data.pagination.totalPages}
            onPageChange={handlePageChange}
          />
        </div>
      )}
    </div>
  );
}

// ===== src/app/[locale]/football/news/page.tsx =====

import type { Metadata } from "next";
import { IPost } from "@/models/Post";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { Newspaper } from "lucide-react";
import Script from "next/script";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import { Suspense } from "react";
import { getNews } from "@/lib/data/news";
import NewsPageClient from "./NewsPageClient";
import { NewsListItemCompactSkeleton } from "@/components/NewsListItemCompact";

const PAGE_PATH = "/football/news";
const ITEMS_PER_PAGE = 10;

export async function generateMetadata({
  params,
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const { locale } = params;

  const t = await getI18n(locale);

  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, "", locale);

  const pageTitle = t("news_page_meta_title");
  const pageDescription = t("news_page_meta_description");

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
  };
}

const generateInitialJsonLd = (posts: IPost[], t: Function) => {
  if (!posts || posts.length === 0) return null;

  const itemListElement = posts.map((post, index) => {
    const postUrl = `/${post.language}/news/${post.slug}`;
    return {
      "@type": "ListItem",
      position: index + 1,
      item: {
        "@type": "NewsArticle",
        mainEntityOfPage: { "@type": "WebPage", "@id": postUrl },
        headline: post.title,
        image:
          post.featuredImage ||
          `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/og-image.jpg`,
        datePublished: post.createdAt,
        dateModified: post.updatedAt,
        author: { "@type": "Organization", name: "Fan Skor" },
        publisher: {
          "@type": "Organization",
          name: "Fan Skor",
          logo: {
            "@type": "ImageObject",
            url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/fanskor-transparent.webp`,
          },
        },
        description: post.metaDescription,
      },
    };
  });

  return {
    "@context": "https://schema.org",
    "@type": "ItemList",
    name: t("latest_football_news"),
    description: t("latest_football_news_subtitle"),
    itemListElement,
  };
};

export default async function FootballNewsPage({
  params,
  searchParams,
}: {
  params: { locale: string };
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  const { locale } = params;
  const t = await getI18n(locale);

  const currentPage = Number(searchParams?.page || 1);

  const initialData = await getNews({
    locale,
    sportsCategory: "football",
    newsType: "news",
    page: currentPage,
    limit: ITEMS_PER_PAGE,
  });

  const jsonLdData = generateInitialJsonLd(initialData.posts, t);

  return (
    <>
      {jsonLdData && (
        <Script
          id="news-list-jsonld"
          type="application/ld+json"
          dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLdData) }}
        />
      )}
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
          <Sidebar />
          <main className="min-w-0 p-4 lg:p-0 lg:py-6">
            <div className="flex items-center gap-4 mb-8">
              <div className="p-3 bg-brand-purple/10 rounded-lg">
                <Newspaper className="w-8 h-8 text-brand-purple" />
              </div>
              <div>
                <h1 className="text-4xl font-extrabold text-white">
                  {t("latest_football_news")}
                </h1>
                <p className="text-brand-muted">
                  {t("latest_football_news_subtitle")}
                </p>
              </div>
            </div>

            <Suspense
              fallback={
                <div className="space-y-4">
                  <NewsListItemCompactSkeleton />
                  <NewsListItemCompactSkeleton />
                  <NewsListItemCompactSkeleton />
                  <NewsListItemCompactSkeleton />
                </div>
              }
            >
              <NewsPageClient initialData={initialData} />
            </Suspense>
          </main>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/football/standings/[...slug]/StandingsPageClient.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { useSearchParams, useRouter } from "next/navigation";
import axios from "axios";
import { format } from "date-fns";
import { useTranslation } from "@/hooks/useTranslation";
import LeagueStandingsWidget from "@/components/league-detail-view/LeagueStandingsWidget";
import { ListOrdered } from "lucide-react";

interface StandingsData {
  league: {
    id: number;
    name: string;
    logo: string;
    type: string;
    season: number;
    seasons: number[];
    href: string;
    country: string;
  };
  standings: any[][];
  leagueStats: any;
  topScorer: any;
}

interface StandingsPageClientProps {
  initialData: StandingsData;
  leagueId: string;
}

const fetchStandingsData = async (
  leagueId: string,
  season: number
): Promise<StandingsData> => {
  const params = new URLSearchParams({
    league: leagueId,
    season: season.toString(),
  });

  const { data } = await axios.get(`/api/standings?${params.toString()}`);
  return data;
};

export default function StandingsPageClient({
  initialData,
  leagueId,
}: StandingsPageClientProps) {
  const { t } = useTranslation();
  const router = useRouter();
  const searchParams = useSearchParams();

  const getSeasonFromUrl = () => {
    const seasonParam = searchParams.get("season");
    return seasonParam ? parseInt(seasonParam) : initialData.league.season;
  };

  const [selectedSeason, setSelectedSeason] =
    useState<number>(getSeasonFromUrl);

  useEffect(() => {
    setSelectedSeason(getSeasonFromUrl());
  }, [searchParams]);

  const { data: standingsData, isFetching } = useQuery<StandingsData>({
    queryKey: ["standingsDetail", leagueId, selectedSeason],
    queryFn: () => fetchStandingsData(leagueId, selectedSeason),

    placeholderData: (previousData) => previousData,

  });

  const handleSeasonChange = (season: number) => {
    setSelectedSeason(season);
    const current = new URLSearchParams(Array.from(searchParams.entries()));
    current.set("season", season.toString());
    const search = current.toString();
    const query = search ? `?${search}` : "";
    router.push(`${window.location.pathname}${query}`, { scroll: false });
  };

  const displayData = standingsData || initialData;
  const league = displayData.league;
  const seoTitle = t("standings_detail_seo_title", {
    leagueName: league?.name,
    season: selectedSeason,
  });
  const seoDescription = t("standings_detail_seo_description", {
    leagueName: league?.name,
  });

  return (
    <main className="min-w-0 space-y-6">
      <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
        <div className="flex items-center gap-4 mb-3">
          <div className="p-3 bg-brand-purple/10 rounded-lg">
            <ListOrdered className="w-8 h-8 text-brand-purple" />
          </div>
          <div>
            <h1 className="text-3xl font-extrabold text-white">{seoTitle}</h1>
          </div>
        </div>
        <p className="text-brand-muted leading-relaxed">{seoDescription}</p>
      </div>

      <LeagueStandingsWidget
        initialStandings={displayData.standings}
        leagueSeasons={initialData.league?.seasons || []}
        currentSeason={selectedSeason}
        onSeasonChange={handleSeasonChange}
        isLoading={isFetching}
      />
    </main>
  );
}

// ===== src/app/[locale]/football/standings/[...slug]/page.tsx =====

import type { Metadata } from "next";
import { notFound } from "next/navigation";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import axios from "axios";
import AdSlotWidget from "@/components/AdSlotWidget";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import LeagueDetailWidget from "@/components/directory/LeagueDetailWidget";
import { generateStandingsSlug } from "@/lib/generate-standings-slug";
import StandingsPageClient from "./StandingsPageClient";
import Script from "next/script";
import { WithContext, SportsEvent, BreadcrumbList } from "schema-dts";
import { getLeaguesForStandingsSitemap } from "@/lib/data/directory";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

const getLeagueIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

async function getInitialStandingsData(leagueId: string, season: string) {
  try {
    const { data } = await axios.get(
      `${BASE_URL}/api/standings?league=${leagueId}&season=${season}`
    );
    return data;
  } catch (error) {
    return null;
  }
}

export async function generateMetadata({
  params,
  searchParams,
}: {
  params: { slug: string[]; locale: string };
  searchParams: { [key: string]: string | string[] | undefined };
}): Promise<Metadata> {
  const { slug, locale } = params;
  const t = await getI18n(locale);
  const leagueId = getLeagueIdFromSlug(slug[0]);

  if (!leagueId) {
    return { title: t("not_found_title") };
  }

  const season =
    (searchParams?.season as string) || new Date().getFullYear().toString();
  const initialData = await getInitialStandingsData(leagueId, season);

  if (!initialData || !initialData.league) {
    return { title: t("not_found_title") };
  }

  const { league } = initialData;
  const hreflangAlternates = await generateHreflangTags(
    "/football/standings",
    slug.join("/"),
    locale
  );

  const pageTitle = t("standings_detail_page_title", {
    leagueName: league.name,
    season: league.season,
  });
  const pageDescription = t("standings_detail_page_description", {
    leagueName: league.name,
  });

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
  };
}

export default async function LeagueStandingsPage({
  params,
  searchParams,
}: {
  params: { slug: string[]; locale: string };
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  const { slug, locale } = params;
  const t = await getI18n(locale);
  const leagueId = getLeagueIdFromSlug(slug[0]);

  if (!leagueId) {
    notFound();
  }

  const season =
    (searchParams?.season as string) || new Date().getFullYear().toString();
  const initialData = await getInitialStandingsData(leagueId, season);

  if (!initialData || !initialData.league) {
    notFound();
  }

  const { league, standings } = initialData;

  const jsonLd: WithContext<SportsEvent | BreadcrumbList>[] = [
    {
      "@context": "https://schema.org",
      "@type": "SportsEvent",
      name: `${league.name} ${league.season}`,
      sport: "Soccer",
      location: {
        "@type": "Country",
        name: league.country,
      },
      competitor:
        standings?.[0]?.map((teamStanding: any) => ({
          "@type": "SportsTeam",
          name: teamStanding.team.name,
        })) || [],
      description: t("standings_detail_page_description", {
        leagueName: league.name,
      }),
    },
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: t("homepage"),
          item: `${BASE_URL}/${locale}`,
        },
        {
          "@type": "ListItem",
          position: 2,
          name: t("standings_hub_title"),
          item: `${BASE_URL}/${locale}/football/standings`,
        },
        {
          "@type": "ListItem",
          position: 3,
          name: league.name,
        },
      ],
    },
  ];

  return (
    <>
      <Script
        id="standings-detail-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
          <Sidebar />

          <StandingsPageClient initialData={initialData} leagueId={leagueId} />

          <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
            <LeagueDetailWidget
              league={initialData.league}
              leagueStats={initialData.leagueStats}
              topScorer={initialData.topScorer}
            />
            <RecentNewsWidget />
            <AdSlotWidget location="homepage_right_sidebar" />
          </aside>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/football/standings/page.tsx =====

import type { Metadata } from "next";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { ListOrdered } from "lucide-react";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import { League } from "@/types/api-football";
import axios from "axios";
import StandingsHubClient from "@/components/directory/StandingsHubClient";
import { Suspense } from "react";
import { FeaturedLeagueCardSkeleton } from "@/components/directory/FeaturedLeagueCard";

import RecentNewsWidget from "@/components/RecentNewsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import Script from "next/script";
import { WithContext, CollectionPage, BreadcrumbList } from "schema-dts";

const PAGE_PATH = "/football/standings";
const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

async function getStandingsLeagues(): Promise<League[]> {
  try {
    const { data } = await axios.get(
      `${BASE_URL}/api/directory/standings-leagues`
    );
    return data;
  } catch (error) {
    console.error(
      "[Standings Hub Page] Failed to fetch standings leagues:",
      error
    );
    return [];
  }
}

export async function generateMetadata({
  params: { locale },
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, "", locale);

  const pageTitle = t("standings_hub_page_title");
  const pageDescription = t("standings_hub_page_description");

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
  };
}

const StandingsPageSkeleton = () => (
  <div className="space-y-12">
    <div className="h-8 w-1/3 bg-gray-700 rounded-md mb-4"></div>
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {Array.from({ length: 6 }).map((_, i) => (
        <FeaturedLeagueCardSkeleton key={i} />
      ))}
    </div>
  </div>
);

export default async function FootballStandingsHubPage({
  params: { locale },
}: {
  params: { locale: string };
}) {
  const t = await getI18n(locale);
  const leagues = await getStandingsLeagues();

  const jsonLd: WithContext<CollectionPage | BreadcrumbList>[] = [
    {
      "@context": "https://schema.org",
      "@type": "CollectionPage",
      name: t("standings_hub_page_title"),
      description: t("standings_hub_page_description"),
      url: `${BASE_URL}/${locale}${PAGE_PATH}`,
    },
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: t("homepage"),
          item: `${BASE_URL}/${locale}`,
        },
        {
          "@type": "ListItem",
          position: 2,
          name: t("standings_hub_title"),
        },
      ],
    },
  ];

  return (
    <>
      {" "}
      <Script
        id="standings-hub-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        {}
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start">
          <Sidebar />
          <main className="min-w-0 p-4 lg:p-0 lg:py-6">
            <div className="flex items-center gap-4 mb-8">
              <div className="p-3 bg-brand-purple/10 rounded-lg">
                <ListOrdered className="w-8 h-8 text-brand-purple" />
              </div>
              <div>
                <h1 className="text-4xl font-extrabold text-white">
                  {t("standings_hub_title")}
                </h1>
                <p className="text-brand-muted">
                  {t("standings_hub_subtitle")}
                </p>
              </div>
            </div>

            <Suspense fallback={<StandingsPageSkeleton />}>
              <StandingsHubClient leagues={leagues} />
            </Suspense>
          </main>
          {}
          <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
            <RecentNewsWidget />
            <AdSlotWidget location="homepage_right_sidebar" />
          </aside>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/football/team/[...slug]/page.tsx =====

import type { Metadata } from "next";
import { notFound } from "next/navigation";
import dbConnect from "@/lib/dbConnect";
import Team from "@/models/Team";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import { fetchTeamDetails } from "@/lib/data/team";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import TeamHeader from "@/components/team/TeamHeader";
import TeamSquadWidget from "@/components/team/TeamSquadWidget";
import TeamFixturesWidget from "@/components/team/TeamFixturesWidget";
import TeamInfoWidget from "@/components/team/TeamInfoWidget";
import TeamTrophiesWidget from "@/components/team/TeamTrophiesWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import TeamSeoWidget from "@/components/team/TeamSeoWidget";
import Script from "next/script";
import { WithContext, SportsTeam, BreadcrumbList } from "schema-dts";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

const getTeamIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

export async function generateMetadata({
  params,
}: {
  params: { slug: string[]; locale: string };
}): Promise<Metadata> {
  const { slug, locale } = params;
  const t = await getI18n(locale);
  const teamId = getTeamIdFromSlug(slug[0]);

  const hreflangAlternates = await generateHreflangTags(
    "/football/team",
    slug.join("/"),
    locale
  );

  if (!teamId) {
    return {
      title: t("not_found_title"),
      alternates: hreflangAlternates,
    };
  }

  const teamData = await fetchTeamDetails(teamId);
  if (!teamData) {
    return {
      title: t("not_found_title"),
      alternates: hreflangAlternates,
      robots: { index: false, follow: false },
    };
  }

  const { team } = teamData.teamInfo;
  const pageTitle = t("team_page_meta_title", { teamName: team.name });
  const pageDescription = t("team_page_meta_description", {
    teamName: team.name,
  });

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
  };
}

export default async function TeamPage({
  params,
}: {
  params: { slug: string[]; locale: string };
}) {
  const { locale, slug } = params;
  const t = await getI18n(locale);

  const teamId = getTeamIdFromSlug(slug[0]);
  if (!teamId) notFound();

  const teamData = await fetchTeamDetails(teamId);
  if (!teamData) notFound();

  const { teamInfo, squad, fixtures } = teamData;
  const { team, venue } = teamInfo;

  const seoWidgetTitle = t("team_seo_widget_title", { teamName: team.name });
  const seoWidgetText = t("team_page_seo_text", { teamName: team.name });

  const jsonLd: WithContext<SportsTeam | BreadcrumbList>[] = [
    {
      "@context": "https://schema.org",
      "@type": "SportsTeam",
      name: team.name,
      sport: "Soccer",
      logo: team.logo,
      url: `${BASE_URL}/${locale}/football/team/${slug[0]}`,
      location: {
        "@type": "Place",
        address: {
          "@type": "PostalAddress",
          addressLocality: venue.city,
          addressCountry: team.country,
        },
      },
    },
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: t("homepage"),
          item: `${BASE_URL}/${locale}`,
        },
        {
          "@type": "ListItem",
          position: 2,
          name: t("football_teams_title"),
          item: `${BASE_URL}/${locale}/football/teams`,
        },
        {
          "@type": "ListItem",
          position: 3,
          name: team.name,
        },
      ],
    },
  ];

  return (
    <>
      <Script
        id="team-page-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
          <Sidebar />
          <main className="min-w-0 space-y-8">
            <TeamHeader
              team={team}
              countryFlag={teamInfo.team.country && fixtures?.[0]?.league?.flag}
              foundedText={t("founded_in", { year: team.founded })}
            />
            <TeamFixturesWidget fixtures={fixtures} />
            <TeamSquadWidget squad={squad} />
          </main>
          <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
            <TeamInfoWidget venue={venue} />
            <TeamTrophiesWidget teamId={team.id} />
            <TeamSeoWidget title={seoWidgetTitle} seoText={seoWidgetText} />
            <RecentNewsWidget />
            <AdSlotWidget location="match_sidebar" />
          </aside>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/football/teams/[countryName]/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { getI18n } from "@/lib/i18n/server";
import TeamsByCountryClient from "@/components/TeamsByCountryClient";

const apiRequest = async (endpoint: string, params: object) => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };
  try {
    const response = await axios.request(options);
    return response.data.response;
  } catch (error) {

    return [];
  }
};

const fetchTeamsByCountry = async (countryName: string) => {
  const season = new Date().getFullYear();
  const leagues = await apiRequest("leagues", { country: countryName });
  if (!leagues || leagues.length === 0) {
    return [];
  }

  const leagueIds = leagues.map((l: any) => l.league.id);
  const teamPromises = leagueIds.map((id: any) =>
    apiRequest("teams", { league: id, season: season })
  );
  const responses = await Promise.allSettled(teamPromises);

  const allTeamsResponses = responses
    .filter((result) => result.status === "fulfilled" && result.value)
    .flatMap((result) => (result as PromiseFulfilledResult<any>).value);

  const uniqueTeams = Array.from(
    new Map(allTeamsResponses.map((item) => [item.team.id, item])).values()
  );

  uniqueTeams.sort((a, b) => a.team.name.localeCompare(b.team.name));
  return uniqueTeams;
};

export async function generateMetadata({
  params,
}: {
  params: { countryName: string };
}): Promise<Metadata> {
  const countryName = decodeURIComponent(params.countryName);
  const t = await getI18n();
  return {
    title: t("teams_in_country_page_title", { country: countryName }),
    description: t("teams_in_country_page_description", {
      country: countryName,
    }),
  };
}

export default async function TeamsByCountryPage({
  params,
}: {
  params: { countryName: string };
}) {
  const countryName = decodeURIComponent(params.countryName);
  const t = await getI18n();
  const allTeams = await fetchTeamsByCountry(countryName);

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <h1 className="text-4xl font-extrabold text-white mb-6">
            {t("teams_in_country_title", { country: countryName })}
          </h1>

          <TeamsByCountryClient initialTeams={allTeams} />
        </main>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/football/teams/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import TeamListClient from "@/components/TeamListClient";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import { Users } from "lucide-react";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import Script from "next/script";
import { WithContext, CollectionPage, BreadcrumbList } from "schema-dts";

const PAGE_PATH = "/football/teams";
const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";
const ITEMS_PER_PAGE = 21;

const fetchInitialTeams = async () => {
  const publicAppUrl = process.env.NEXT_PUBLIC_PUBLIC_APP_URL;
  if (!publicAppUrl) {
    console.error(
      "[Teams Page Server] NEXT_PUBLIC_PUBLIC_APP_URL is not defined."
    );
    return {
      teams: [],
      pagination: { currentPage: 1, totalPages: 0, totalCount: 0 },
    };
  }

  const apiUrl = `${publicAppUrl}/api/teams/paginated?page=1&limit=${ITEMS_PER_PAGE}`;

  try {
    const { data } = await axios.get(apiUrl, { timeout: 15000 });
    return data;
  } catch (error: any) {
    console.error(
      `[Teams Page Server] Failed to fetch initial teams (${apiUrl}):`,
      error.message
    );
    return {
      teams: [],
      pagination: { currentPage: 1, totalPages: 0, totalCount: 0 },
    };
  }
};

export async function generateMetadata({
  params,
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const { locale } = params;

  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, "", locale);

  const pageTitle = t("teams_page_meta_title");
  const pageDescription = t("teams_page_meta_description");

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
  };
}

export default async function TeamsPage({
  params,
}: {
  params: { locale: string };
}) {
  const { locale } = params;

  const initialData = await fetchInitialTeams();
  const t = await getI18n(locale);

  const seoDescription = t("teams_page_seo_text");

  const jsonLd: WithContext<CollectionPage | BreadcrumbList>[] = [
    {
      "@context": "https://schema.org",
      "@type": "CollectionPage",
      name: t("teams_page_meta_title"),
      description: t("teams_page_meta_description"),
      url: `${BASE_URL}/${locale}${PAGE_PATH}`,
    },
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: t("homepage"),
          item: `${BASE_URL}/${locale}`,
        },
        {
          "@type": "ListItem",
          position: 2,
          name: t("football_teams_title"),
        },
      ],
    },
  ];

  return (
    <>
      <Script
        id="teams-page-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
          <Sidebar />

          <main className="min-w-0">
            <div className="bg-brand-secondary p-6 rounded-lg shadow-xl mb-8">
              <div className="flex items-center gap-4 mb-3">
                <div className="p-3 bg-[var(--brand-accent)]/10 rounded-lg">
                  <Users className="w-8 h-8 text-[var(--brand-accent)]" />
                </div>
                <div>
                  <h1 className="text-4xl font-extrabold text-white">
                    {t("football_teams_title")}
                  </h1>
                  <p className="text-text-muted">
                    {t("football_teams_subtitle")}
                  </p>
                </div>
              </div>
              <p className="italic text-[#a3a3a3] leading-relaxed text-sm mt-4">
                {seoDescription}
              </p>
            </div>

            {}
            <TeamListClient initialData={initialData} />
          </main>

          <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
            <RecentNewsWidget />
            <AdSlotWidget location="homepage_right_sidebar" />
          </aside>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/gdpr/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import { notFound } from "next/navigation";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { DatabaseZap } from "lucide-react";
import AdSlotWidget from "@/components/AdSlotWidget";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";

const PAGE_SLUG = "gdpr";
const PAGE_PATH = "/gdpr";

async function getPageContent() {
  try {
    const response = await axios.get(
      `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/api/pages/${PAGE_SLUG}`
    );
    return response.data;
  } catch (error) {
    return null;
  }
}

export async function generateMetadata({
  params,
}: {
  params: Promise<{ locale: string }>;
}): Promise<Metadata> {
  const { locale } = await params;

  const t = await getI18n(locale);
  const pageContent = await getPageContent();
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, "", locale);

  const title = t("gdpr_default_page_title");

  const description = t("gdpr_default_page_description");

  return {
    title: title,
    description: description,
    alternates: hreflangAlternates,
  };
}

export default async function GdprPage({
  params: { locale },
}: {
  params: { locale: string };
}) {
  const pageContent = await getPageContent();

  if (!pageContent || !pageContent.content) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        <Sidebar />

        <main className="min-w-0">
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
            <div className="flex items-center gap-4 mb-4">
              <div className="p-3 bg-indigo-500/10 rounded-lg">
                <DatabaseZap className="w-8 h-8 text-indigo-400" />
              </div>
              <h1 className="text-4xl font-extrabold text-white">
                {pageContent.title}
              </h1>
            </div>

            <div
              className="prose prose-invert lg:prose-xl max-w-none text-text-secondary"
              dangerouslySetInnerHTML={{ __html: pageContent.content }}
            />
          </div>
        </main>

        <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
          <RecentNewsWidget />
          <AdSlotWidget location="homepage_right_sidebar" />
        </aside>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/highlights/HighlightsPageClient.tsx =====

"use client";

import { Fragment, useEffect } from "react";
import { useInfiniteQuery } from "@tanstack/react-query";
import axios from "axios";
import { useInView } from "react-intersection-observer";
import { Loader2, VideoOff } from "lucide-react";
import HighlightCard, {
  HighlightCardSkeleton,
} from "@/components/HighlightCard";
import { useTranslation } from "@/hooks/useTranslation";

interface Highlight {
  id: string;
  title: string;
  thumbnailUrl: string;
  embedUrl: string;
  source: "Highlightly" | "YouTube";
  publishedAt: string;
}

interface HighlightsApiResponse {
  highlights: Highlight[];
  nextPage: number | null;
}

const fetchHighlights = async ({
  pageParam = 1,
}): Promise<HighlightsApiResponse> => {
  const { data } = await axios.get(
    `/api/highlights/aggregate?page=${pageParam}`
  );
  return data;
};

export default function HighlightsPageClient() {
  const { t } = useTranslation();
  const { ref, inView } = useInView();

  const {
    data,
    isLoading,
    isError,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ["aggregatedHighlights"],
    queryFn: fetchHighlights,
    initialPageParam: 1,
    getNextPageParam: (lastPage) => lastPage.nextPage,
  });

  useEffect(() => {
    if (inView && hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [inView, hasNextPage, isFetchingNextPage, fetchNextPage]);

  if (isLoading) {
    return (
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
        {Array.from({ length: 12 }).map((_, i) => (
          <HighlightCardSkeleton key={i} />
        ))}
      </div>
    );
  }

  if (
    isError ||
    !data?.pages[0]?.highlights ||
    data.pages[0].highlights.length === 0
  ) {
    return (
      <div className="text-center py-20 bg-brand-secondary rounded-lg">
        <VideoOff size={48} className="mx-auto text-brand-muted mb-4" />
        <p className="text-xl font-bold text-white">
          {t("no_highlights_found_title")}
        </p>
        <p className="text-brand-muted mt-2">
          {t("no_highlights_found_subtitle")}
        </p>
      </div>
    );
  }

  return (
    <div>
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
        {data.pages.map((page, i) => (
          <Fragment key={i}>
            {page.highlights.map((highlight) => (
              <HighlightCard key={highlight.id} highlight={highlight} />
            ))}
          </Fragment>
        ))}
      </div>

      <div ref={ref} className="h-20 flex items-center justify-center">
        {isFetchingNextPage ? (
          <div className="flex items-center gap-2 text-brand-muted">
            <Loader2 size={24} className="animate-spin" />
            <span>{t("loading_more")}...</span>
          </div>
        ) : !hasNextPage ? (
          <p className="text-brand-muted">{t("no_more_highlights")}</p>
        ) : null}
      </div>
    </div>
  );
}

// ===== src/app/[locale]/highlights/page.tsx =====

import type { Metadata } from "next";
import { Suspense } from "react";
import { PlayCircle } from "lucide-react";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import HighlightsPageClient from "./HighlightsPageClient";
import { HighlightCardSkeleton } from "@/components/HighlightCard";

const PAGE_PATH = "/highlights";

export async function generateMetadata({
  params: { locale },
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const t = await getI18n(locale);
  const pageTitle = t("highlights_page_meta_title");
  const pageDescription = t("highlights_page_meta_description");
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, "", locale);

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
    openGraph: {
      title: pageTitle,
      description: pageDescription,
      url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/${locale}${PAGE_PATH}`,
      siteName: "Fan Skor",
      type: "website",
    },
  };
}

const PageSkeleton = () => (
  <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
    {Array.from({ length: 12 }).map((_, i) => (
      <HighlightCardSkeleton key={i} />
    ))}
  </div>
);

export default async function HighlightsPage({
  params: { locale },
}: {
  params: { locale: string };
}) {
  const t = await getI18n(locale);

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <div className="flex items-center gap-4 mb-8">
            <div className="p-3 bg-[var(--brand-accent)]/10 rounded-lg">
              <PlayCircle className="w-8 h-8 text-[var(--brand-accent)]" />
            </div>
            <div>
              <h1 className="text-4xl font-extrabold text-white">
                {t("highlights_page_title")}
              </h1>
              <p className="text-brand-muted">
                {t("highlights_page_subtitle")}
              </p>
            </div>
          </div>

          <Suspense fallback={<PageSkeleton />}>
            <HighlightsPageClient />
          </Suspense>
        </main>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/layout.tsx =====

import type { Metadata } from "next";
import "../globals.css";
import Providers from "../providers";
import { LeagueProvider } from "@/context/LeagueContext";
import "slick-carousel/slick/slick.css";
import "slick-carousel/slick/slick-theme.css";
import NextAuthProvider from "../NextAuthProvider";
import { Suspense } from "react";
import StickyFooterAd from "@/components/StickyFooterAd";
import Loading from "./loading";
import Footer from "@/components/Footer";
import { GoogleAnalytics } from "@next/third-parties/google";
import { I18nProviderClient } from "@/lib/i18n/client";
import { TimeZoneProvider } from "@/context/TimeZoneContext";
import { i18nCache } from "@/lib/i18n/i18n.cache";
import Script from "next/script";
import { inter } from "../fonts";

import { SUPPORTED_LOCALES } from "@/lib/i18n/config";

export async function generateStaticParams() {
  return SUPPORTED_LOCALES.map((locale) => ({
    locale,
  }));
}

export default async function LocaleLayout({
  children,
  params,
}: {
  children: React.ReactNode;
  params: { locale: string };
}) {
  const { locale } = await params;
  const translations = (await i18nCache.getTranslations(locale)) || {};

  return (

    <html lang={locale} className={inter.variable}>
      <head>
        {process.env.NEXT_PUBLIC_NODE_ENV === "production" && (
          <Script src="./scripts/relic.js" />
        )}
        <script
          src="https://analytics.ahrefs.com/analytics.js"
          data-key="bUq3rBCRyMMiFSPFiUUAxg"
          async
        ></script>
      </head>
      <body suppressHydrationWarning={true}>
        <Suspense fallback={<Loading />}>
          <NextAuthProvider>
            <Providers>
              <I18nProviderClient locale={locale} translations={translations}>
                <TimeZoneProvider>
                  <LeagueProvider>
                    <main>{children}</main>
                    <StickyFooterAd />
                    <Footer />
                  </LeagueProvider>
                </TimeZoneProvider>
              </I18nProviderClient>
            </Providers>
          </NextAuthProvider>
        </Suspense>
        {process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID && (
          <GoogleAnalytics gaId={process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID} />
        )}
      </body>
    </html>
  );
}

// ===== src/app/[locale]/loading.tsx =====

import LottiePreloader from "@/components/LottiePreloader";

export default function Loading() {
  return (
    <div className="fixed inset-0 z-[100] flex items-center justify-center bg-[#1F1D2B]">
      {}
      <LottiePreloader />
    </div>
  );
}

// ===== src/app/[locale]/news/GeneralNewsClient.tsx =====

"use client";

import { useState, useMemo } from "react";
import { usePathname } from "next/navigation";
import { IPost } from "@/models/Post";
import { useTranslation } from "@/hooks/useTranslation";
import { Info } from "lucide-react";
import Pagination from "@/components/Pagination";
import NewsCard, { NewsCardSkeleton } from "@/components/NewsCard";

const ITEMS_PER_PAGE = 12;

interface GeneralNewsClientProps {
  initialNews: IPost[];
}

export default function GeneralNewsClient({
  initialNews,
}: GeneralNewsClientProps) {
  const { t } = useTranslation();
  const pathname = usePathname();
  const [currentPage, setCurrentPage] = useState(1);

  const { paginatedData, totalPages } = useMemo(() => {
    const newsArray = Array.isArray(initialNews) ? initialNews : [];
    const total = Math.ceil(newsArray.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    return {
      paginatedData: newsArray.slice(startIndex, endIndex),
      totalPages: total,
    };
  }, [initialNews, currentPage]);

  if (!initialNews || initialNews.length === 0) {
    return (
      <div className="text-center py-20 bg-brand-secondary rounded-lg">
        <Info size={32} className="mx-auto text-brand-muted mb-3" />
        <p className="text-xl font-bold text-white">
          {t("no_news_found_title")}
        </p>
        <p className="text-brand-muted mt-2">{t("no_news_found_subtitle")}</p>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      {}
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
        {paginatedData.map((post) => (
          <NewsCard key={post._id as string} post={post} />
        ))}
      </div>

      {}
      {totalPages > 1 && (
        <div className="pt-8">
          <Pagination
            currentPage={currentPage}
            totalPages={totalPages}
            basePath={pathname}
          />
        </div>
      )}
    </div>
  );
}

// ===== src/app/[locale]/news/NewsPageClient.tsx =====

"use client";

import { IPost } from "@/models/Post";
import { useTranslation } from "@/hooks/useTranslation";
import { ArrowRight, Flame, Repeat, Calendar, ExternalLink, Newspaper } from "lucide-react";
import NewsCard from "@/components/NewsCard";
import StyledLink from "@/components/StyledLink";
import NewsListItemCompact from "@/components/NewsListItemCompact";
import Image from "next/image";
import { formatDistanceToNow } from "date-fns";

const RecentNewsCard = ({ post, variant = "grid" }: { post: IPost, variant?: "featured" | "grid" }) => {
  const { t } = useTranslation();
  const placeholderImage = "/images/placeholder-logo.svg";

  const isExternal = !!post.originalSourceUrl;
  const href = `/news/${post.slug}`;

  if (variant === "featured") {
    return (
      <StyledLink
        href={href}
        className="block group relative rounded-xl overflow-hidden text-white shadow-lg shadow-black/30"
      >
        <div className="relative w-full aspect-video md:aspect-[2.4/1]">
          <Image
            src={post.featuredImage || placeholderImage}
            alt={post.title}
            layout="fill"
            objectFit="cover"
            className="transition-transform duration-500 ease-in-out group-hover:scale-105"
            priority
          />
          <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-transparent"></div>
        </div>
        <div className="absolute bottom-0 left-0 p-6 md:p-8">
          {post.newsType === 'recent' && (
            <span className="text-xs font-bold px-2 py-1 rounded-full mb-3 inline-block bg-sky-500/10 text-sky-300">
              {t("latest_from_web")}
            </span>
          )}
          <h2 className="font-extrabold text-2xl md:text-4xl leading-tight line-clamp-2 group-hover:text-brand-purple transition-colors">
            {post.title}
          </h2>
           <div className="flex items-center gap-4 text-sm text-brand-muted mt-3">
            <div className="flex items-center gap-1.5">
              <Calendar size={14} />
              <time dateTime={new Date(post.createdAt).toISOString()}>
                {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}
              </time>
            </div>
             {isExternal && (
                <div className="flex items-center gap-1.5 text-blue-400">
                    <ExternalLink size={14} />
                    <span>{t("read_on_source")}</span>
                </div>
             )}
          </div>
        </div>
      </StyledLink>
    );
  }

  return (
    <StyledLink
      href={href}
      className="block group bg-brand-secondary rounded-xl overflow-hidden transition-all duration-300 hover:-translate-y-1 hover:shadow-xl hover:shadow-brand-purple/20 border border-gray-800/50 hover:border-brand-purple/30"
    >
      <div className="relative w-full aspect-video overflow-hidden">
        <Image
          src={post.featuredImage || placeholderImage}
          alt={post.title}
          layout="fill"
          objectFit="cover"
          className="transition-transform duration-300 group-hover:scale-105"
        />
      </div>
      <div className="p-4 flex flex-col flex-grow">
        {post.newsType === 'recent' && <span className="text-xs font-bold text-sky-300 mb-2">{t("latest_from_web")}</span>}
        <h3 className="font-bold text-white leading-tight text-base line-clamp-3 flex-grow group-hover:text-brand-purple transition-colors">
          {post.title}
        </h3>
        <div className="flex items-center gap-1.5 text-xs text-brand-muted mt-3">
            <Calendar size={12} />
            <time dateTime={new Date(post.createdAt).toISOString()}>
              {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}
            </time>
        </div>
      </div>
    </StyledLink>
  );
};

interface NewsPageClientProps {
  recentNews: IPost[];
  footballNews: IPost[];
  transferNews: IPost[];
}

const SectionHeader = ({ title, href, icon }: { title: string; href: string; icon: React.ReactNode }) => {
    const {t} = useTranslation()
    return (
        <div className="flex justify-between items-center mb-6">
            <h2 className="text-3xl font-bold text-white flex items-center gap-3">
            {icon}
            {title}
            </h2>
            <StyledLink
            href={href}
            className="flex items-center gap-1 text-sm font-semibold text-text-muted transition-colors hover:text-white"
            >
            {t("see_all")}
            <ArrowRight size={16} />
            </StyledLink>
        </div>
    )
};

export default function NewsPageClient({
  recentNews,
  footballNews,
  transferNews,
}: NewsPageClientProps) {
  const { t } = useTranslation();
  const featuredArticle = recentNews?.[0];
  const subFeaturedArticles = recentNews?.slice(1, 5) || [];

  return (
    <div className="space-y-16">
      {}
      {featuredArticle && (
        <section>
          <SectionHeader title={t("recent_news_title")} href="/news/category/recent" icon={<Newspaper className="text-sky-400" />} />
          <RecentNewsCard post={featuredArticle} variant="featured" />
          {subFeaturedArticles.length > 0 && (
            <div className="mt-6 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
              {subFeaturedArticles.map((post) => (
                <RecentNewsCard key={post._id as string} post={post} />
              ))}
            </div>
          )}
        </section>
      )}

      {}
      {footballNews.length > 0 && (
        <section>
          <SectionHeader title={t("football_news_title")} href="/news/category/football" icon={<Flame className="text-amber-400" />} />
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
            {footballNews.map((post) => (
              <NewsCard key={post._id as string} post={post} />
            ))}
          </div>
        </section>
      )}

      {}
      {transferNews.length > 0 && (
        <section>
          <SectionHeader title={t("transfer_news_title")} href="/news/category/transfer" icon={<Repeat className="text-sky-400" />} />
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {transferNews.map((post) => (
                <NewsListItemCompact key={post._id as string} post={post} />
            ))}
          </div>
        </section>
      )}
    </div>
  );
}

// ===== src/app/[locale]/news/[slug]/page.tsx =====

import { notFound, redirect } from "next/navigation";
import dbConnect from "@/lib/dbConnect";
import Post, { IPost, IPostWithTranslations } from "@/models/Post";
import { format } from "date-fns";
import Header from "@/components/Header";
import Image from "next/image";
import SocialShareButtons from "@/components/SocialShareButtons";
import NewsSidebar from "@/components/NewsSidebar";
import type { Metadata } from "next";
import { getI18n } from "@/lib/i18n/server";
import { proxyImageUrl } from "@/lib/image-proxy";
import Script from "next/script";
import { generateHreflangTags } from "@/lib/hreflang";
import { generateTableOfContents } from "@/lib/toc";
import TableOfContents from "@/components/TableOfContents";
import { WithContext, NewsArticle, BreadcrumbList } from "schema-dts";
import StyledLink from "@/components/StyledLink";
import { ExternalLink } from "lucide-react";

export const revalidate = 3600;

const DEFAULT_LOCALE = "tr";
const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

async function getPostAndHandleRedirects(
  slug: string,
  locale: string
): Promise<IPostWithTranslations | null> {
  await dbConnect();

  const postInAnyLanguage = await Post.findOne({
    slug,
    status: "published",
  }).exec();

  if (!postInAnyLanguage) {
    return null;
  }

  if (postInAnyLanguage.language !== locale) {
    const allTranslations = await postInAnyLanguage.getTranslations();
    const correctVersionForLocale = allTranslations.find(
      (p) => p.language === locale
    );

    let redirectUrl = "";
    if (correctVersionForLocale) {
      const path = `/news/${correctVersionForLocale.slug}`;
      redirectUrl = `/${locale}${path}`;
    } else {
      const defaultVersion =
        allTranslations.find((p) => p.language === DEFAULT_LOCALE) ||
        allTranslations[0];
      const path = `/news/${defaultVersion.slug}`;
      redirectUrl =
        defaultVersion.language === DEFAULT_LOCALE
          ? path
          : `/${defaultVersion.language}${path}`;
    }
    redirect(redirectUrl);
  }

  return postInAnyLanguage;
}

export async function generateMetadata({
  params,
}: {
  params: { slug: string; locale: string };
}): Promise<Metadata> {
  const { slug, locale } = params;
  const post = await getPostAndHandleRedirects(slug, locale);

  if (!post) {
    return { title: "Not Found", robots: { index: false, follow: false } };
  }

  const allTranslations = await post.getTranslations();
  const hreflangAlternates = await generateHreflangTags(
    "/news",
    slug,
    locale,
    allTranslations
  );
  const description =
    post.metaDescription ||
    post.content.replace(/<[^>]*>?/gm, "").substring(0, 160);
  const imageUrl = post.featuredImage
    ? proxyImageUrl(post.featuredImage)
    : `${BASE_URL}/og-image.jpg`;

  return {
    title: post.metaTitle || `${post.title}`,
    description: description,
    alternates: hreflangAlternates,
    openGraph: {
      title: post.metaTitle || post.title,
      description: description,
      url: hreflangAlternates.canonical,
      type: "article",
      publishedTime: new Date(post.createdAt).toISOString(),
      modifiedTime: new Date(post.updatedAt).toISOString(),
      authors: [post.author || "Fan Skor"],
      images: [{ url: imageUrl, width: 1200, height: 630, alt: post.title }],
    },
  };
}

export default async function GeneralNewsArticlePage({
  params,
}: {
  params: { slug: string; locale: string };
}) {
  const { slug, locale } = params;
  const post = await getPostAndHandleRedirects(slug, locale);

  if (!post) {
    notFound();
  }

  const t = await getI18n(locale);
  const { processedHtml, toc } = generateTableOfContents(post.content);
  const allTranslations = await post.getTranslations();
  const hreflangAlternates = await generateHreflangTags(
    "/news",
    slug,
    locale,
    allTranslations
  );
  const postUrl = hreflangAlternates.canonical;
  const description =
    post.metaDescription ||
    post.content.replace(/<[^>]*>?/gm, "").substring(0, 160);
  const imageUrl = post.featuredImage || `${BASE_URL}/og-image.jpg`;

  const jsonLd: WithContext<NewsArticle | BreadcrumbList>[] = [
    {
      "@context": "https://schema.org",
      "@type": "NewsArticle",
      mainEntityOfPage: { "@type": "WebPage", "@id": postUrl },
      headline: post.title,
      image: [imageUrl],
      datePublished: new Date(post.createdAt).toISOString(),
      dateModified: new Date(post.updatedAt).toISOString(),
      author: { "@type": "Organization", name: "Fan Skor", url: BASE_URL },
      publisher: {
        "@type": "Organization",
        name: "Fan Skor",
        logo: {
          "@type": "ImageObject",
          url: `${BASE_URL}/fanskor-transparent.webp`,
        },
      },
      description: description,
      articleBody: post.content.replace(/<[^>]*>?/gm, ""),
    },
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: t("homepage"),
          item: `${BASE_URL}/${locale === DEFAULT_LOCALE ? "" : locale}`,
        },
        {
          "@type": "ListItem",
          position: 2,
          name: t("news"),
          item: `${BASE_URL}/${locale === DEFAULT_LOCALE ? "" : locale}/news`,
        },
        { "@type": "ListItem", position: 3, name: post.title },
      ],
    },
  ];

  return (
    <>
      <Script
        id="news-article-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <div className="bg-brand-dark min-h-screen">
        <Header />
        <main className="container mx-auto p-4 md:p-8 grid grid-cols-1 lg:grid-cols-3 gap-8 lg:gap-12 items-start">
          <div className="lg:col-span-2">
            <article className="bg-brand-secondary rounded-lg overflow-hidden">
              {post.featuredImage && (
                <div className="relative w-full aspect-video md:h-[500px]">
                  <Image
                    src={post.featuredImage}
                    alt={post.featuredImageAltText || post.title}
                    title={post.featuredImageTitle || post.title}
                    layout="fill"
                    objectFit="cover"
                    priority
                  />
                </div>
              )}
              <div className="p-4 sm:p-6 md:p-8">
                <h1 className="text-3xl md:text-5xl font-extrabold text-white leading-tight mb-4">
                  {post.title}
                </h1>
                <p className="text-brand-muted mb-6 pb-6 border-b border-gray-700/50">
                  {t("published_by_on", {
                    author: post.author,
                    date: format(new Date(post.createdAt), "MMMM dd, yyyy"),
                  })}
                </p>
                {post.originalSourceUrl && (
                  <StyledLink
                    href={post.originalSourceUrl}
                    isExternal={true}
                    className="inline-flex items-center gap-2 bg-brand-purple text-white font-bold py-3 px-6 rounded-lg hover:opacity-90 transition-opacity my-4"
                  >
                    <ExternalLink size={18} />
                    {t("read_full_story_on_source")}
                  </StyledLink>
                )}
                {toc.length > 0 && <TableOfContents toc={toc} />}
                <div
                  className="prose prose-invert prose-lg lg:prose-xl max-w-none mt-8"
                  dangerouslySetInnerHTML={{ __html: processedHtml }}
                />
                <div className="mt-12 pt-8 border-t border-gray-700/50">
                  <h3 className="text-lg font-bold text-center text-brand-muted mb-4">
                    {t("share_this_article")}
                  </h3>
                  <SocialShareButtons url={postUrl} title={post.title} />
                </div>
              </div>
            </article>
          </div>
          <div className="lg:col-span-1">
            <NewsSidebar />
          </div>
        </main>
      </div>
    </>
  );
}

// ===== src/app/[locale]/news/category/[category]/NewsArchiveClient.tsx =====

"use client";

import { useEffect, Fragment } from "react";
import { useInfiniteQuery } from "@tanstack/react-query";
import { useInView } from "react-intersection-observer";
import axios from "axios";
import { IPost } from "@/models/Post";
import { useTranslation } from "@/hooks/useTranslation";
import { Info, ExternalLink, Calendar, User } from "lucide-react";
import StyledLink from "@/components/StyledLink";
import Image from "next/image";
import { formatDistanceToNow } from "date-fns";
import { NewsListItemCompactSkeleton } from "@/components/NewsListItemCompact";

const ITEMS_PER_PAGE = 10;

const fetchArchiveNews = async (
  locale: string,
  category: string,
  page: number
) => {
  const params = new URLSearchParams({
    language: locale,
    page: page.toString(),
    limit: ITEMS_PER_PAGE.toString(),
  });

  if (category === "football") params.set("sportsCategory", "football");
  if (category === "transfer") params.set("newsType", "transfer");
  if (category === "recent") params.set("newsType", "recent");

  const { data } = await axios.get(`/api/posts?${params.toString()}`);
  return data as {
    posts: IPost[];
    pagination: { totalPages: number; totalCount: number };
  };
};

interface NewsArchiveClientProps {
  initialData: {
    posts: IPost[];
    pagination: { totalPages: number; totalCount: number };
  };
  category: string;
}

const ArchiveNewsItem = ({ item }: { item: IPost }) => {
  const placeholderImage = "/images/placeholder-logo.svg";
  const isExternal = !!item.originalSourceUrl;

  const href = `/news/${item.slug}`;

  return (
    <StyledLink
      href={href}
      className="block group bg-brand-secondary rounded-lg transition-shadow duration-300 hover:shadow-xl hover:shadow-brand-purple/20"
    >
      <div className="flex flex-col sm:flex-row items-center gap-4 md:gap-6 p-4">
        <div className="w-full sm:w-40 md:w-48 flex-shrink-0">
          <div className="relative w-full aspect-video overflow-hidden rounded-md">
            <Image
              src={item.featuredImage || placeholderImage}
              alt={item.title}
              layout="fill"
              objectFit="cover"
              className="transition-transform duration-300 group-hover:scale-105"
            />
          </div>
        </div>
        <div className="flex-1 flex flex-col self-stretch min-w-0">
          <h3 className="font-bold text-white leading-tight text-lg md:text-xl line-clamp-2 mb-2 group-hover:text-brand-purple transition-colors">
            {item.title}
          </h3>
          <p className="hidden md:block text-sm text-brand-light line-clamp-2 mb-3">
            {item.metaDescription || item.content.replace(/<[^>]*>?/gm, "")}
          </p>
          <div className="flex-grow"></div>
          <div className="flex items-center gap-4 text-xs text-brand-muted mt-2">
            <div className="flex items-center gap-1.5" title="Author">
              <User size={12} />
              <span>{item.author}</span>
            </div>
            <div className="flex items-center gap-1.5" title="Publish Date">
              <Calendar size={12} />
              <time dateTime={new Date(item.createdAt).toISOString()}>
                {formatDistanceToNow(new Date(item.createdAt), {
                  addSuffix: true,
                })}
              </time>
            </div>
            {isExternal && (
              <div
                className="flex items-center gap-1.5 text-blue-400"
                title="External Link available"
              >
                <ExternalLink size={12} />
                <span>Source Available</span>
              </div>
            )}
          </div>
        </div>
      </div>
    </StyledLink>
  );
};

export default function NewsArchiveClient({
  initialData,
  category,
}: NewsArchiveClientProps) {
  const { t, locale } = useTranslation();
  const { ref, inView } = useInView();

  const {
    data,
    isLoading,
    isError,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ["archiveNews", category, locale],
    queryFn: ({ pageParam = 1 }) =>
      fetchArchiveNews(locale, category, pageParam),
    initialPageParam: 1,

    getNextPageParam: (lastPage, allPages) => {
      const currentPage = allPages.length;
      const totalPages = lastPage.pagination.totalPages;
      return currentPage < totalPages ? currentPage + 1 : undefined;
    },

    initialData: {
      pages: [initialData],
      pageParams: [1],
    },
  });

  useEffect(() => {
    if (inView && hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [inView, hasNextPage, isFetchingNextPage, fetchNextPage]);

  if (isLoading) {
    return (
      <div className="space-y-4">
        {[...Array(ITEMS_PER_PAGE)].map((_, i) => (
          <NewsListItemCompactSkeleton key={i} />
        ))}
      </div>
    );
  }

  if (isError || !data?.pages[0]?.posts || data.pages[0].posts.length === 0) {
    return (
      <div className="text-center py-20 bg-brand-secondary rounded-lg">
        <Info size={32} className="mx-auto text-brand-muted mb-3" />
        <p className="text-xl font-bold text-white">
          {t("no_news_found_title")}
        </p>
        <p className="text-brand-muted mt-2">
          {t("no_news_in_category_subtitle")}
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {data.pages.map((page, i) => (
        <Fragment key={i}>
          {page.posts.map((item: IPost) => (
            <ArchiveNewsItem key={item._id as string} item={item} />
          ))}
        </Fragment>
      ))}
      <div ref={ref} className="h-10">
        {isFetchingNextPage && (
          <div className="space-y-4 pt-4">
            <NewsListItemCompactSkeleton />
            <NewsListItemCompactSkeleton />
          </div>
        )}
        {!hasNextPage &&
          data.pages[0].pagination.totalCount > ITEMS_PER_PAGE && (
            <p className="text-center text-brand-muted py-4">
              You've reached the end.
            </p>
          )}
      </div>
    </div>
  );
}

// ===== src/app/[locale]/news/category/[category]/page.tsx =====

import type { Metadata } from "next";
import { notFound } from "next/navigation";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { Newspaper } from "lucide-react";
import { getI18n } from "@/lib/i18n/server";
import { Suspense } from "react";
import { getNews } from "@/lib/data/news";
import { NewsListItemCompactSkeleton } from "@/components/NewsListItemCompact";
import NewsArchiveClient from "./NewsArchiveClient";
import { NewsType, SportsCategory } from "@/models/Post";
import { generateHreflangTags } from "@/lib/hreflang";

export const dynamic = "force-dynamic";

const VALID_CATEGORIES = ["football", "transfer", "recent", "news"];
const ITEMS_PER_PAGE = 10;

export async function generateMetadata({
  params: { locale, category },
}: {
  params: { locale: string; category: string };
}): Promise<Metadata> {
  if (!VALID_CATEGORIES.includes(category)) {
    notFound();
  }

  const t = await getI18n(locale);

  let pageTitle = t("news_archive_title");
  if (category === "football") pageTitle = t("football_news_archive_title");
  if (category === "transfer") pageTitle = t("transfer_news_archive_title");
  if (category === "recent") pageTitle = t("recent_news_archive_title");

  const pagePath = `/news/category/${category}`;
  const hreflangAlternates = await generateHreflangTags(
    "/news/category",
    category,
    locale
  );

  return {
    title: pageTitle,
    description: t("news_archive_subtitle"),
    alternates: hreflangAlternates,
  };
}

export default async function NewsCategoryPage({
  params: { locale, category },
  searchParams,
}: {
  params: { locale: string; category: string };
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  const t = await getI18n(locale);

  if (!VALID_CATEGORIES.includes(category)) {
    notFound();
  }

  const currentPage = Number(searchParams?.page || 1);

  const filterOptions: {
    newsType?: NewsType;
    sportsCategory?: SportsCategory;
  } = {};
  if (category === "football") filterOptions.sportsCategory = "football";
  if (category === "transfer") filterOptions.newsType = "transfer";
  if (category === "recent") filterOptions.newsType = "recent";

  const { posts: allNews, pagination } = await getNews({
    locale,
    ...filterOptions,
    page: currentPage,
    limit: ITEMS_PER_PAGE,
  });

  let pageTitle = t("news_archive_title");
  if (category === "football") pageTitle = t("football_news_archive_title");
  if (category === "transfer") pageTitle = t("transfer_news_archive_title");
  if (category === "recent") pageTitle = t("recent_news_archive_title");

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <div className="flex items-center gap-4 mb-8">
            <div className="p-3 bg-brand-purple/10 rounded-lg">
              <Newspaper className="w-8 h-8 text-brand-purple" />
            </div>
            <div>
              <h1 className="text-4xl font-extrabold text-white capitalize">
                {pageTitle}
              </h1>
              <p className="text-brand-muted">{t("news_archive_subtitle")}</p>
            </div>
          </div>

          <Suspense
            fallback={
              <div className="space-y-4">
                <NewsListItemCompactSkeleton />
                <NewsListItemCompactSkeleton />
                <NewsListItemCompactSkeleton />
                <NewsListItemCompactSkeleton />
              </div>
            }
          >
            <NewsArchiveClient
              initialData={{ posts: allNews, pagination }}
              category={category}
            />
          </Suspense>
        </main>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/news/page.tsx =====

import type { Metadata } from "next";
import { IPost } from "@/models/Post";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { Newspaper } from "lucide-react";
import Script from "next/script";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import { Suspense } from "react";
import { getNews } from "@/lib/data/news";
import NewsPageClient from "./NewsPageClient";

const PAGE_PATH = "/news";

export async function generateMetadata({
  params: { locale },
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, "", locale);
  const pageTitle = t("general_news_meta_title");
  const pageDescription = t("general_news_meta_description");

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
  };
}

const generateInitialJsonLd = (posts: IPost[], t: Function) => {
  if (posts.length === 0) return null;

  const itemListElement = posts.map((post, index) => {
    const postUrl = post.originalSourceUrl
      ? post.originalSourceUrl
      : `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/${post.language}/news/${post.slug}`;

    return {
      "@type": "ListItem",
      position: index + 1,
      item: {
        "@type": "NewsArticle",
        mainEntityOfPage: { "@type": "WebPage", "@id": postUrl },
        headline: post.title,
        image:
          post.featuredImage ||
          `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/og-image.jpg`,
        datePublished: post.createdAt,
        dateModified: post.updatedAt,
        author: { "@type": "Organization", name: "Fan Skor" },
        publisher: {
          "@type": "Organization",
          name: "Fan Skor",
          logo: {
            "@type": "ImageObject",
            url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/fanskor-transparent.webp`,
          },
        },
        description: post.metaDescription,
      },
    };
  });

  return {
    "@context": "https://schema.org",
    "@type": "ItemList",
    name: t("latest_news"),
    description: t("latest_news_subtitle"),
    itemListElement,
  };
};

const NewsPageSkeleton = () => (
  <div className="space-y-12 animate-pulse">
    <div className="w-full aspect-video md:aspect-[2.4/1] bg-brand-secondary rounded-xl"></div>
    <div>
      <div className="h-8 w-1/3 bg-gray-700 rounded mb-6"></div>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <div className="aspect-square bg-brand-secondary rounded-xl"></div>
        <div className="aspect-square bg-brand-secondary rounded-xl"></div>
        <div className="aspect-square bg-brand-secondary rounded-xl"></div>
        <div className="aspect-square bg-brand-secondary rounded-xl"></div>
      </div>
    </div>
  </div>
);

export default async function NewsHubPage({
  params,
}: {
  params: { locale: string };
}) {
  const { locale } = params;
  const t = await getI18n(locale);

  const [recentNews, footballNews, transferNews] = await Promise.all([
    getNews({ locale, newsType: "recent", limit: 5 }).then(
      (result) => result.posts
    ),
    getNews({
      locale,
      sportsCategory: "football",
      newsType: "news",
      limit: 8,
    }).then((result) => result.posts),
    getNews({ locale, newsType: "transfer", limit: 4 }).then(
      (result) => result.posts
    ),
  ]);

  const jsonLdData = generateInitialJsonLd(recentNews, t);

  return (
    <>
      {jsonLdData && (
        <Script
          id="news-list-jsonld"
          type="application/ld+json"
          dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLdData) }}
        />
      )}
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
          <Sidebar />
          <main className="min-w-0 p-4 lg:p-0 lg:py-6">
            <div className="flex items-center gap-4 mb-8">
              <div className="p-3 bg-brand-purple/10 rounded-lg">
                <Newspaper className="w-8 h-8 text-brand-purple" />
              </div>
              <div>
                <h1 className="text-4xl font-extrabold text-white">
                  {t("news_hub_title")}
                </h1>
                <p className="text-brand-muted">{t("news_hub_subtitle")}</p>
              </div>
            </div>

            <Suspense fallback={<NewsPageSkeleton />}>
              <NewsPageClient
                recentNews={recentNews}
                footballNews={footballNews}
                transferNews={transferNews}
              />
            </Suspense>
          </main>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/not-found.tsx =====

"use client";

import { Suspense } from 'react';
import Link from 'next/link';
import Header from '@/components/Header';
import { HeaderSkeleton } from '@/components/LayoutSkeletons';
import { Frown } from 'lucide-react';

export default function NotFound() {
  return (
    <div className="min-h-screen flex flex-col">
      <Suspense fallback={<HeaderSkeleton />}>
        <Header />
      </Suspense>

      <main className="flex-1 flex flex-col items-center justify-center text-center p-4">
        <Frown className="w-16 h-16 text-text-muted mb-4" />
        <h1 className="text-4xl font-extrabold text-white">404 - Page Not Found</h1>
        <p className="text-lg text-text-secondary mt-2 mb-6">
          The page you are looking for does not exist or has been moved.
        </p>
        <Link
            href="/"
            className="px-6 py-3 bg-brand-purple text-white font-bold rounded-lg hover:opacity-90 transition-opacity"
        >
          Go back to Homepage
        </Link>
      </main>
    </div>
  )
}

// ===== src/app/[locale]/page.tsx =====

import { Suspense } from "react";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { MainContent } from "@/components/MainContent";
import { SidebarSkeleton } from "@/components/LayoutSkeletons";
import { getI18n } from "@/lib/i18n/server";
import { Metadata } from "next";
import { generateHreflangTags } from "@/lib/hreflang";
import { WithContext, WebSite, Organization } from "schema-dts";
import Script from "next/script";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

interface HomePageProps {
  params: {
    locale: string;
  };
  homepageAboutSeoText?: string;
  sidebarAboutSeoText?: string;
}

const METADATA_BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

export async function generateMetadata({
  params,
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const { locale } = await params;
  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags("/", "", locale);
  const title = t("homepage_meta_title");
  const description = t("homepage_meta_description");

  return {
    metadataBase: new URL(METADATA_BASE_URL),
    alternates: hreflangAlternates,

    icons: {
      icon: [{ url: "/favicon.ico", type: "image/png" }],
      apple: [{ url: "/favicon.ico" }],
    },
    robots: {
      index: true,
      follow: true,
      googleBot: { index: true, follow: true },
    },
    openGraph: {
      title: title,
      description: description,
      url: `${METADATA_BASE_URL}/${locale === "tr" ? "" : locale}`,
      siteName: "Fan Skor",
      images: [
        {
          url: `${METADATA_BASE_URL}/og-image.jpg`,
          width: 1200,
          height: 630,
          alt: t("og_image_alt_text"),
        },
      ],
      locale: locale,
      type: "website",
    },
    twitter: {
      card: "summary_large_image",
      title: title,
      description: description,
      creator: "@fanskor_official",
      images: [`${METADATA_BASE_URL}/twitter-image.jpg`],
    },
  };
}

const jsonLd: WithContext<WebSite | Organization>[] = [
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    name: "Fan Skor",
    url: BASE_URL,
    potentialAction: {
      "@type": "SearchAction",
      target: `${BASE_URL}/search?q={search_term_string}`,
      "query-input": "required name=search_term_string",
    },
  },
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    name: "Fan Skor",
    url: BASE_URL,
    logo: `${BASE_URL}/fanskor-transparent.webp`,
  },
];

export default async function HomePage({
  params,
  homepageAboutSeoText: initialHomepageText,
  sidebarAboutSeoText: initialSidebarText,
}: HomePageProps) {
  const { locale } = await params;

  const t = await getI18n(locale);

  const title = t("homepage_meta_title");
  const description = t("homepage_meta_description");

  const homepageAboutSeoText =
    initialHomepageText || t("homepage_about_seo_text");
  const sidebarAboutSeoText = initialSidebarText || t("sidebar_about_seo_text");

  return (
    <>
      <Script
        id="homepage-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <title>{title}</title>
      <meta name="description" content={description} />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:items-start lg:py-8">
          {}
          <Suspense fallback={<SidebarSkeleton />}>
            <Sidebar />
          </Suspense>

          <main className="min-w-0">
            <MainContent
              sidebarAboutSeoText={sidebarAboutSeoText}
              homepageAboutSeoText={homepageAboutSeoText}
            />
          </main>
        </div>
      </div>
    </>
  );
}

// ===== src/app/[locale]/predictions/PredictionsPageClient.tsx =====

"use client";

import { Fragment, useEffect } from "react";
import { useInfiniteQuery } from "@tanstack/react-query";
import axios from "axios";
import { useInView } from "react-intersection-observer";
import { Loader2, ShieldQuestion } from "lucide-react";
import PredictionCard, {
  PredictionCardSkeleton,
} from "@/components/predictions/PredictionCard";
import { useTranslation } from "@/hooks/useTranslation";

interface EnrichedFixture {
  fixture: any;
  teams: any;
  league: any;
  prediction: {
    home: number;
    draw: number;
    away: number;
  };
  h2h: any[];
  form: {
    home: string | null;
    away: string | null;
  };
}

interface PredictionsApiResponse {
  fixtures: EnrichedFixture[];
  nextPage: number | null;
}

const fetchPredictions = async ({
  pageParam = 1,
}): Promise<PredictionsApiResponse> => {
  const { data } = await axios.get(
    `/api/predictions/upcoming?page=${pageParam}`
  );
  return data;
};

export default function PredictionsPageClient() {
  const { t } = useTranslation();
  const { ref, inView } = useInView({
    threshold: 0.5,
  });

  const {
    data,
    isLoading,
    isError,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ["upcomingPredictions"],
    queryFn: fetchPredictions,
    initialPageParam: 1,
    getNextPageParam: (lastPage) => lastPage.nextPage,
  });

  useEffect(() => {
    if (inView && hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [inView, hasNextPage, isFetchingNextPage, fetchNextPage]);

  if (isLoading) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
        {Array.from({ length: 12 }).map((_, i) => (
          <PredictionCardSkeleton key={i} />
        ))}
      </div>
    );
  }

  if (
    isError ||
    !data?.pages[0]?.fixtures ||
    data.pages[0].fixtures.length === 0
  ) {
    return (
      <div className="text-center py-20 bg-brand-secondary rounded-lg">
        <ShieldQuestion size={48} className="mx-auto text-brand-muted mb-4" />
        <p className="text-xl font-bold text-white">
          {t("no_predictions_found_title")}
        </p>
        <p className="text-brand-muted mt-2">
          {t("no_predictions_found_subtitle")}
        </p>
      </div>
    );
  }

  return (
    <div>
      <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
        {data.pages.map((page, i) => (
          <Fragment key={i}>
            {page.fixtures.map((enrichedFixture) => (
              <PredictionCard
                key={enrichedFixture.fixture.id}
                fixture={enrichedFixture}
              />
            ))}
          </Fragment>
        ))}
      </div>

      <div ref={ref} className="h-20 flex items-center justify-center">
        {isFetchingNextPage && (
          <div className="flex items-center gap-2 text-brand-muted">
            <Loader2 size={24} className="animate-spin" />
            <span>{t("loading_more")}...</span>
          </div>
        )}
        {!isFetchingNextPage &&
          !hasNextPage &&
          data.pages[0].fixtures.length > 0 && (
            <p className="text-brand-muted">{t("no_more_predictions")}</p>
          )}
      </div>
    </div>
  );
}

// ===== src/app/[locale]/predictions/page.tsx =====

import type { Metadata } from "next";
import { Suspense } from "react";
import { BrainCircuit } from "lucide-react";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";
import PredictionsPageClient from "./PredictionsPageClient";
import { PredictionCardSkeleton } from "@/components/predictions/PredictionCard";
import AdSlotWidget from "@/components/AdSlotWidget";
import RecentNewsWidget from "@/components/RecentNewsWidget";

const PAGE_PATH = "/predictions";

export async function generateMetadata({
  params: { locale },
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const t = await getI18n(locale);
  const pageTitle = t("predictions_page_meta_title");
  const pageDescription = t("predictions_page_meta_description");
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, "", locale);

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: hreflangAlternates,
    openGraph: {
      title: pageTitle,
      description: pageDescription,
      url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/${locale}${PAGE_PATH}`,
      siteName: "Fan Skor",
      type: "website",
    },
  };
}

const PageSkeleton = () => (
  <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
    {Array.from({ length: 12 }).map((_, i) => (
      <PredictionCardSkeleton key={i} />
    ))}
  </div>
);

export default async function PredictionsPage({
  params: { locale },
}: {
  params: { locale: string };
}) {
  const t = await getI18n(locale);

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        <Sidebar />
        <main className="min-w-0">
          <div className="flex items-center gap-4 mb-8">
            <div className="p-3 bg-indigo-500/10 rounded-lg">
              <BrainCircuit className="w-8 h-8 text-indigo-400" />
            </div>
            <div>
              <h1 className="text-4xl font-extrabold text-white">
                {t("predictions_page_title")}
              </h1>
              <p className="text-brand-muted">
                {t("predictions_page_subtitle")}
              </p>
            </div>
          </div>

          <Suspense fallback={<PageSkeleton />}>
            <PredictionsPageClient />
          </Suspense>
        </main>
        <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
          <RecentNewsWidget />
          <AdSlotWidget location="homepage_right_sidebar" />
        </aside>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/privacy-policy/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import { notFound } from "next/navigation";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { Shield } from "lucide-react";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";

const PAGE_SLUG = "privacy-policy";
const PAGE_PATH = "/privacy-policy";

async function getPageContent() {
  try {
    const response = await axios.get(
      `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/api/pages/${PAGE_SLUG}`
    );
    return response.data;
  } catch (error) {
    return null;
  }
}

export async function generateMetadata({
  params,
}: {
  params: Promise<{ locale: string }>;
}): Promise<Metadata> {
  const { locale } = await params;

  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, "", locale);

  const title = t("privacy_policy_default_page_title");
  const description = t("privacy_policy_default_page_description");

  return {
    title: title,
    description: description,
    alternates: hreflangAlternates,
  };
}

export default async function PrivacyPolicyPage({
  params,
}: {
  params: Promise<{ locale: string }>;
}) {
  const pageContent = await getPageContent();

  if (!pageContent || !pageContent.content) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        <Sidebar />

        <main className="min-w-0">
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
            <div className="flex items-center gap-4 mb-4">
              <div className="p-3 bg-blue-500/10 rounded-lg">
                <Shield className="w-8 h-8 text-blue-400" />
              </div>
              <h1 className="text-4xl font-extrabold text-white">
                {pageContent.title}
              </h1>
            </div>

            <div
              className="prose prose-invert lg:prose-xl max-w-none text-text-secondary"
              dangerouslySetInnerHTML={{ __html: pageContent.content }}
            />
          </div>
        </main>

        <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
          <RecentNewsWidget />
          <AdSlotWidget location="homepage_right_sidebar" />
        </aside>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/report-abuse/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import { notFound } from "next/navigation";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { AlertTriangle } from "lucide-react";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";

const PAGE_SLUG = "report-abuse";
const PAGE_PATH = "/report-abuse";

async function getPageContent() {
  try {
    const response = await axios.get(
      `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/api/pages/${PAGE_SLUG}`
    );
    return response.data;
  } catch (error) {
    return null;
  }
}

export async function generateMetadata({
  params,
}: {
  params: Promise<{ locale: string }>;
}): Promise<Metadata> {
  const { locale } = await params;

  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, "", locale);

  const title = t("report_abuse_default_page_title");

  const description = t("report_abuse_default_page_description");

  return {
    title: title,
    description: description,
    alternates: hreflangAlternates,
  };
}

export default async function ReportAbusePage({
  params,
}: {
  params: Promise<{ locale: string }>;
}) {
  const pageContent = await getPageContent();

  if (!pageContent || !pageContent.content) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        <Sidebar />

        <main className="min-w-0">
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
            <div className="flex items-center gap-4 mb-4">
              <div className="p-3 bg-red-500/10 rounded-lg">
                <AlertTriangle className="w-8 h-8 text-red-400" />
              </div>
              <h1 className="text-4xl font-extrabold text-white">
                {pageContent.title}
              </h1>
            </div>

            <div
              className="prose prose-invert lg:prose-xl max-w-none text-text-secondary"
              dangerouslySetInnerHTML={{ __html: pageContent.content }}
            />
          </div>
        </main>

        <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
          <RecentNewsWidget />
          <AdSlotWidget location="homepage_right_sidebar" />
        </aside>
      </div>
    </div>
  );
}

// ===== src/app/[locale]/terms-and-conditions/page.tsx =====

import type { Metadata } from "next";
import axios from "axios";
import { notFound } from "next/navigation";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { FileText } from "lucide-react";
import CasinoPartnerWidget from "@/components/CasinoPartnerWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import RecentNewsWidget from "@/components/RecentNewsWidget";
import { getI18n } from "@/lib/i18n/server";
import { generateHreflangTags } from "@/lib/hreflang";

const PAGE_SLUG = "terms-and-conditions";
const PAGE_PATH = "/terms-and-conditions";

async function getPageContent() {
  try {
    const response = await axios.get(
      `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/api/pages/${PAGE_SLUG}`
    );
    return response.data;
  } catch (error) {
    return null;
  }
}

export async function generateMetadata({
  params,
}: {
  params: Promise<{ locale: string }>;
}): Promise<Metadata> {
  const { locale } = await params;

  const t = await getI18n(locale);
  const hreflangAlternates = await generateHreflangTags(PAGE_PATH, "", locale);

  const title = t("terms_and_conditions_default_title");
  const description = t("terms_and_conditions_default_desc");

  return {
    title,
    description,
    alternates: hreflangAlternates,
  };
}

export default async function TermsAndConditionsPage({
  params,
}: {
  params: Promise<{ locale: string }>;
}) {
  const pageContent = await getPageContent();

  if (!pageContent || !pageContent.content) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        <Sidebar />

        <main className="min-w-0">
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
            <div className="flex items-center gap-4 mb-4">
              <div className="p-3 bg-gray-500/10 rounded-lg">
                <FileText className="w-8 h-8 text-gray-400" />
              </div>
              <h1 className="text-4xl font-extrabold text-white">
                {pageContent.title}
              </h1>
            </div>

            <div
              className="prose prose-invert lg:prose-xl max-w-none text-text-secondary"
              dangerouslySetInnerHTML={{ __html: pageContent.content }}
            />
          </div>
        </main>

        <aside className="hidden lg:block lg:col-span-1 space-y-8 min-w-0">
          <RecentNewsWidget />
          <AdSlotWidget location="homepage_right_sidebar" />
        </aside>
      </div>
    </div>
  );
}

// ===== src/app/actions/language.ts =====

"use server";

import { cookies } from "next/headers";

const I18N_COOKIE_NAME = "NEXT_LOCALE";

export async function setLocaleCookie(locale: string) {
  cookies().set(I18N_COOKIE_NAME, locale, {
    path: "/",
    maxAge: 60 * 60 * 24 * 365,
    sameSite: "lax",
    secure: process.env.NODE_ENV === "production",
  });
}

// ===== src/app/admin/ai-journalists/page.tsx =====

"use client";

import { useEffect, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  PlusCircle,
  Edit,
  Trash2,
  User,
  CheckCircle,
  XCircle,
  Loader2,
} from "lucide-react";

interface IAIJournalist {
  _id: string;
  name: string;
  description?: string;
  tonePrompt: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

interface AIJournalistFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  journalist?: IAIJournalist | null;
}

const AIJournalistFormModal: React.FC<AIJournalistFormModalProps> = ({
  isOpen,
  onClose,
  journalist,
}) => {
  const queryClient = useQueryClient();
  const [name, setName] = useState(journalist?.name || "");
  const [description, setDescription] = useState(journalist?.description || "");

  const [tonePrompt, setTonePrompt] = useState(
    journalist?.tonePrompt ||
      "Daima Trke bir ton kullann, esprili yorumlarla ve derinlemesine analitik ve teknik yorumlarla makaleleri ekillendirin."
  );
  const [isActive, setIsActive] = useState(journalist?.isActive ?? true);

  useEffect(() => {

    if (journalist) {
      setName(journalist.name);
      setDescription(journalist.description || "");
      setTonePrompt(journalist.tonePrompt);
      setIsActive(journalist.isActive);
    } else {

      setName("");
      setDescription("");
      setTonePrompt(
        "Daima Trke bir ton kullann, esprili yorumlarla ve derinlemesine analitik ve teknik yorumlarla makaleleri ekillendirin."
      );
      setIsActive(true);
    }
  }, [journalist]);

  const createMutation = useMutation({
    mutationFn: (newJournalist: Partial<IAIJournalist>) =>
      axios.post("/api/admin/ai-journalists", newJournalist),
    onSuccess: () => {
      toast.success("AI Journalist created successfully!");
      queryClient.invalidateQueries({ queryKey: ["aiJournalists"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to create journalist.");
    },
  });

  const updateMutation = useMutation({
    mutationFn: (updatedJournalist: Partial<IAIJournalist>) =>
      axios.put(
        `/api/admin/ai-journalists/${journalist?._id}`,
        updatedJournalist
      ),
    onSuccess: () => {
      toast.success("AI Journalist updated successfully!");
      queryClient.invalidateQueries({ queryKey: ["aiJournalists"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to update journalist.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !tonePrompt.trim()) {
      toast.error("Name and Tone Prompt are required.");
      return;
    }

    const payload = { name, description, tonePrompt, isActive };

    if (journalist) {
      updateMutation.mutate(payload);
    } else {
      createMutation.mutate(payload);
    }
  };

  const isPending = createMutation.isPending || updateMutation.isPending;

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl overflow-hidden">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {journalist ? "Edit AI Journalist" : "Create New AI Journalist"}
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label
              htmlFor="name"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Journalist Name
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
          </div>
          <div>
            <label
              htmlFor="description"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Description (Optional)
            </label>
            <input
              id="description"
              type="text"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              disabled={isPending}
            />
          </div>
          <div>
            <label
              htmlFor="tonePrompt"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Tone Prompt Segment (Turkish Language)
            </label>
            <textarea
              id="tonePrompt"
              value={tonePrompt}
              onChange={(e) => setTonePrompt(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
              rows={6}
              required
              disabled={isPending}
              placeholder="e.g., 'Daima Trke bir ton kullann, esprili yorumlarla ve derinlemesine analitik ve teknik yorumlarla makaleleri ekillendirin.'"
            />
            <p className="text-xs text-brand-muted mt-1">
              Bu istem segmenti, gazetecinin stilini tanmlamak iin ana makale
              oluturma istemine eklenecektir. Makalelerin daima Trke
              oluturulduundan emin olun.
            </p>
          </div>
          <div className="flex items-center">
            <input
              id="isActive"
              type="checkbox"
              checked={isActive}
              onChange={(e) => setIsActive(e.target.checked)}
              className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
              disabled={isPending}
            />
            <label
              htmlFor="isActive"
              className="ml-2 text-sm font-medium text-brand-light"
            >
              Active (Can be used for generation)
            </label>
          </div>
          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
              disabled={isPending}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={isPending}
            >
              {isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {isPending
                ? journalist
                  ? "Updating..."
                  : "Creating..."
                : journalist
                ? "Save Changes"
                : "Create Journalist"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default function AdminAIJournalistsPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingJournalist, setEditingJournalist] =
    useState<IAIJournalist | null>(null);

  const {
    data: journalists,
    isLoading,
    error,
  } = useQuery<IAIJournalist[]>({
    queryKey: ["aiJournalists"],
    queryFn: async () => {
      const { data } = await axios.get("/api/admin/ai-journalists");
      return data;
    },
    staleTime: 1000 * 60 * 5,
  });

  const deleteMutation = useMutation({
    mutationFn: (journalistId: string) =>
      axios.delete(`/api/admin/ai-journalists/${journalistId}`),
    onSuccess: () => {
      toast.success("AI Journalist deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["aiJournalists"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete journalist.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingJournalist(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (journalist: IAIJournalist) => {
    setEditingJournalist(journalist);
    setIsModalOpen(true);
  };

  const handleDelete = (journalistId: string, journalistName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete AI Journalist "${journalistName}"? This action cannot be undone.`
      )
    ) {
      deleteMutation.mutate(journalistId);
    }
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading AI Journalists...</p>;
  if (error)
    return <p className="text-red-400">Failed to load AI Journalists.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <User size={28} /> Manage AI Journalists
        </h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Journalist</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Name</th>
              <th className="p-4">Description</th>
              <th className="p-4">Tone Prompt Preview</th>
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {journalists?.map((journalist) => (
              <tr key={journalist._id} className="border-t border-gray-700/50">
                <td className="p-4 font-medium">{journalist.name}</td>
                <td
                  className="p-4 text-brand-muted text-sm max-w-[200px] truncate"
                  title={journalist.description}
                >
                  {journalist.description || "N/A"}
                </td>
                <td
                  className="p-4 text-brand-muted text-sm max-w-[300px] truncate"
                  title={journalist.tonePrompt}
                >
                  {journalist.tonePrompt}
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      journalist.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {journalist.isActive ? "Active" : "Inactive"}
                  </span>
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <button
                    onClick={() => handleOpenEditModal(journalist)}
                    className="text-blue-400 hover:text-blue-300"
                    title="Edit Journalist"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() =>
                      handleDelete(journalist._id, journalist.name)
                    }
                    className="text-red-400 hover:text-red-300"
                    title="Delete Journalist"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {journalists?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No AI Journalists found. Click "New Journalist" to create one.
          </p>
        )}
      </div>

      <AIJournalistFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        journalist={editingJournalist}
      />
    </div>
  );
}

// ===== src/app/admin/auto-news/PredictionGenerationTab.tsx =====

"use client";

import { useEffect, useState, useMemo } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  Calendar,
  Sparkles,
  RefreshCw,
  Loader2,
  User,
  Info,
  CheckCircle,
  ExternalLink,
  Eye,
} from "lucide-react";
import { format, parseISO } from "date-fns";
import Pagination from "@/components/Pagination";

interface IAIJournalist {
  _id: string;
  name: string;
  description?: string;
  tonePrompt: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

interface UpcomingFixture {
  fixture: {
    id: number;
    date: string;
    timezone: string;
    status: {
      long: string;
      short: string;
      elapsed: number | null;
    };
  };
  league: {
    id: number;
    name: string;
    logo: string;
  };
  teams: {
    home: { id: number; name: string; logo: string };
    away: { id: number; name: string; logo: string };
  };

  processedPostId?: string;
}

interface UpcomingFixturesResponse {
  fixtures: UpcomingFixture[];
  totalCount: number;
  currentPage: number;
  perPage: number;
}

const fetchAIJournalists = async (): Promise<IAIJournalist[]> => {
  const { data } = await axios.get("/api/admin/ai-journalists");
  return data;
};

const fetchUpcomingFixturesForPrediction = async (
  page: number,
  limit: number
): Promise<UpcomingFixturesResponse> => {
  const { data } = await axios.get(
    `/api/admin/upcoming-fixtures-for-prediction?limit=${limit}&skip=${
      (page - 1) * limit
    }`
  );
  return data;
};

const ITEMS_PER_PAGE = 10;

export default function PredictionGenerationTab() {
  const queryClient = useQueryClient();
  const [currentPage, setCurrentPage] = useState(1);
  const [selectedJournalistId, setSelectedJournalistId] = useState<
    string | null
  >(null);

  const [processingFixtureId, setProcessingFixtureId] = useState<number | null>(
    null
  );

  const {
    data: journalists,
    isLoading: isLoadingJournalists,
    error: journalistsError,
  } = useQuery<IAIJournalist[]>({
    queryKey: ["aiJournalists"],
    queryFn: fetchAIJournalists,
    staleTime: 1000 * 60 * 5,
  });

  const {
    data: fixturesData,
    isLoading: isLoadingFixtures,
    error: fixturesError,
    refetch: refetchFixtures,
  } = useQuery<UpcomingFixturesResponse>({
    queryKey: ["upcomingFixturesForPrediction", currentPage, ITEMS_PER_PAGE],
    queryFn: () =>
      fetchUpcomingFixturesForPrediction(currentPage, ITEMS_PER_PAGE),
    staleTime: 1000 * 60,
    placeholderData: (previousData) => previousData,
  });

  useEffect(() => {
    if (journalists && selectedJournalistId === null) {
      const firstActive = journalists.find((j) => j.isActive);
      if (firstActive) {
        setSelectedJournalistId(firstActive._id);
      }
    }
  }, [journalists, selectedJournalistId]);

  const generatePredictionNewsMutation = useMutation({
    mutationFn: (payload: {
      fixtureId: number;
      journalistId: string;
      sportCategory: string;
    }) => axios.post("/api/admin/generate-prediction-news", payload),
    onSuccess: (data) => {
      toast.success(data.data.message || "Prediction news generated!");
      queryClient.invalidateQueries({
        queryKey: ["upcomingFixturesForPrediction"],
      });
      queryClient.invalidateQueries({ queryKey: ["adminPosts"] });
    },
    onError: (err: any) => {
      toast.error(
        err.response?.data?.error || "Failed to generate prediction news."
      );
    },
    onSettled: (data, error, variables) => {

      queryClient.setQueryData(
        ["upcomingFixturesForPrediction", currentPage, ITEMS_PER_PAGE],
        (oldData: UpcomingFixturesResponse | undefined) => {
          if (!oldData) return oldData;
          return {
            ...oldData,
            fixtures: oldData.fixtures.map((f) =>
              f.fixture.id === variables.fixtureId
                ? {
                    ...f,
                    processedPostId: data?.data.postId || f.processedPostId,
                  }
                : f
            ),
          };
        }
      );
      setProcessingFixtureId(null);
    },
  });

  const handleGeneratePrediction = (fixture: UpcomingFixture) => {
    if (!selectedJournalistId) {
      toast.error("Please select an AI Journalist before generating.");
      return;
    }
    setProcessingFixtureId(fixture.fixture.id);
    generatePredictionNewsMutation.mutate({
      fixtureId: fixture.fixture.id,
      journalistId: selectedJournalistId,
      sportCategory: "football",
    });
  };

  const totalPages = fixturesData
    ? Math.ceil(fixturesData.totalCount / ITEMS_PER_PAGE)
    : 0;

  return (
    <div className="bg-brand-secondary p-6 rounded-lg mb-8 shadow-xl">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2">
          <Sparkles size={24} /> Generate Prediction News
        </h2>
        <button
          onClick={() => refetchFixtures()}
          className="flex items-center gap-2 bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed"
          disabled={
            isLoadingFixtures || generatePredictionNewsMutation.isPending
          }
        >
          <RefreshCw
            size={18}
            className={isLoadingFixtures ? "animate-spin" : ""}
          />
          Refresh Matches
        </button>
      </div>

      <div className="flex items-center justify-between gap-4 mb-4">
        {}
        <div className="flex items-center gap-2">
          <User size={18} className="text-brand-muted" />
          <select
            value={selectedJournalistId || ""}
            onChange={(e) => setSelectedJournalistId(e.target.value || null)}
            className="p-2 rounded bg-gray-700 text-white border border-gray-600 text-sm"
            disabled={
              isLoadingJournalists || generatePredictionNewsMutation.isPending
            }
          >
            <option value="">
              {isLoadingJournalists
                ? "Loading Journalists..."
                : "Select AI Journalist"}
            </option>
            {journalists
              ?.filter((j) => j.isActive)
              .map((j) => (
                <option key={j._id} value={j._id}>
                  {j.name}
                </option>
              ))}
          </select>
        </div>
        {}
        <span className="text-brand-muted text-sm ml-auto">
          Total Upcoming Matches: {fixturesData?.totalCount ?? 0}
        </span>
      </div>

      <div className="overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Match</th>
              <th className="p-4">League</th>
              <th className="p-4">Date & Time</th>
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {isLoadingFixtures ? (
              Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
                <tr
                  key={i}
                  className="border-t border-gray-700/50 animate-pulse"
                >
                  <td className="p-4">
                    <div className="h-4 bg-gray-700 rounded w-full"></div>
                  </td>
                  <td className="p-4">
                    <div className="h-4 bg-gray-700 rounded w-3/4"></div>
                  </td>
                  <td className="p-4">
                    <div className="h-4 bg-gray-700 rounded w-1/2"></div>
                  </td>
                  <td className="p-4">
                    <div className="h-4 bg-gray-700 rounded w-1/3"></div>
                  </td>
                  <td className="p-4">
                    <div className="w-10 h-10 bg-gray-700 rounded-full"></div>
                  </td>
                </tr>
              ))
            ) : fixturesData?.fixtures?.length === 0 ? (
              <tr>
                <td colSpan={5} className="p-8 text-center text-brand-muted">
                  No upcoming matches found for prediction.
                </td>
              </tr>
            ) : (
              fixturesData?.fixtures?.map((fixture) => (
                <tr
                  key={fixture.fixture.id}
                  className={`border-t border-gray-700/50 transition-colors
                                ${
                                  processingFixtureId === fixture.fixture.id
                                    ? "bg-brand-dark/50 animate-pulse"
                                    : fixture.processedPostId
                                    ? "bg-green-900/20"
                                    : "hover:bg-gray-800"
                                }`}
                >
                  <td className="p-4 font-medium flex items-center gap-3">
                    <img
                      src={fixture.teams.home.logo}
                      alt={fixture.teams.home.name}
                      className="w-6 h-6"
                    />
                    {fixture.teams.home.name} vs {fixture.teams.away.name}
                    <img
                      src={fixture.teams.away.logo}
                      alt={fixture.teams.away.name}
                      className="w-6 h-6"
                    />
                  </td>
                  <td className="p-4 text-brand-muted text-sm flex items-center gap-2">
                    <img
                      src={fixture.league.logo}
                      alt={fixture.league.name}
                      className="w-4 h-4"
                    />
                    {fixture.league.name}
                  </td>
                  <td className="p-4 text-brand-muted text-sm">
                    {format(
                      parseISO(fixture.fixture.date),
                      "dd MMM yyyy HH:mm"
                    )}
                  </td>
                  <td className="p-4">
                    <span
                      className={`px-2 py-1 text-xs font-semibold rounded-full min-w-[75px] inline-flex justify-center items-center gap-1
                          ${
                            fixture.processedPostId
                              ? "bg-green-500/20 text-green-400"
                              : "bg-blue-500/20 text-blue-400"
                          }`}
                    >
                      {processingFixtureId === fixture.fixture.id ? (
                        <Loader2 size={12} className="animate-spin" />
                      ) : fixture.processedPostId ? (
                        <CheckCircle size={12} />
                      ) : (
                        <Info size={12} />
                      )}
                      {processingFixtureId === fixture.fixture.id
                        ? "Generating..."
                        : fixture.processedPostId
                        ? "Generated"
                        : "Not Generated"}
                    </span>
                  </td>
                  <td className="p-4 flex gap-2 items-center h-full">
                    {fixture.processedPostId ? (
                      <a
                        href={`/admin/news/edit/${fixture.processedPostId}`}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-blue-400 hover:text-blue-300 p-1 rounded-full bg-brand-dark"
                        title="View Generated Post"
                      >
                        <Eye size={18} />
                      </a>
                    ) : (
                      <button
                        onClick={() => handleGeneratePrediction(fixture)}
                        className="text-brand-purple hover:text-brand-purple/80 p-1 rounded-full bg-brand-dark"
                        title="Generate Prediction News"
                        disabled={
                          generatePredictionNewsMutation.isPending ||
                          !selectedJournalistId
                        }
                      >
                        <Sparkles size={18} />
                      </button>
                    )}
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>

      {fixturesData && fixturesData.fixtures.length > 0 && (
        <div className="p-6">
          <Pagination
            currentPage={currentPage}
            totalPages={totalPages}
            onPageChange={setCurrentPage}
          />
        </div>
      )}
    </div>
  );
}

// ===== src/app/admin/auto-news/page.tsx =====

"use client";

import { useState, useMemo, useEffect, useRef } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  DownloadCloud,
  Sparkles,
  RefreshCw,
  Trash2,
  ExternalLink,
  Loader2,
  CheckCircle,
  XCircle,
  FileText,
  SkipForward,
  Bot,
} from "lucide-react";
import { format, parseISO } from "date-fns";
import Image from "next/image";
import Link from "next/link";
import AdminPagination from "@/components/admin/AdminPagination";
import PredictionGenerationTab from "./PredictionGenerationTab";
import { proxyImageUrl } from "@/lib/image-proxy";
import BatchProcessModal from "@/components/admin/BatchProcessModal";

interface IExternalNewsArticle {
  articleId: string;
  title: string;
  link: string;
  pubDate: string;
  imageUrl?: string | null;
  source_icon?: string | null;
  status: "fetched" | "processing" | "processed" | "skipped" | "error";
  processedPostId?: string;
  _id: string;
}
interface ExternalNewsResponse {
  articles: IExternalNewsArticle[];
  totalCount: number;
  currentPage: number;
  perPage: number;
}

const fetchExternalNews = async (
  page: number,
  limit: number,
  statusFilter: string
): Promise<ExternalNewsResponse> => {
  const { data } = await axios.get(
    `/api/admin/external-news?limit=${limit}&skip=${
      (page - 1) * limit
    }&status=${statusFilter}`
  );
  return data;
};

const FetchSummaryModal = ({
  summary,
  onClose,
}: {
  summary: any;
  onClose: () => void;
}) => {
  if (!summary) return null;
  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-md text-center p-8">
        <CheckCircle size={48} className="text-green-400 mx-auto mb-4" />
        <h2 className="text-2xl font-bold text-white mb-2">Fetch Complete!</h2>
        <p className="text-brand-muted mb-6">{summary.message}</p>
        <div className="grid grid-cols-3 gap-4 text-white mb-8">
          <div className="bg-green-500/20 p-4 rounded-lg">
            <p className="text-3xl font-bold">{summary.newArticlesCount}</p>
            <p className="text-sm font-semibold">Saved</p>
          </div>
          <div className="bg-yellow-500/20 p-4 rounded-lg">
            <p className="text-3xl font-bold">{summary.skippedArticlesCount}</p>
            <p className="text-sm font-semibold">Skipped</p>
          </div>
          <div className="bg-red-500/20 p-4 rounded-lg">
            <p className="text-3xl font-bold">
              {summary.failedArticlesCount || 0}
            </p>
            <p className="text-sm font-semibold">Failed</p>
          </div>
        </div>
        <button
          onClick={onClose}
          className="bg-brand-purple text-white font-bold py-2 px-6 rounded-lg hover:opacity-90"
        >
          Close
        </button>
      </div>
    </div>
  );
};

const ProcessSingleModal: React.FC<{
  isOpen: boolean;
  onClose: () => void;
  article: IExternalNewsArticle | null;
}> = ({ isOpen, onClose, article }) => {
  const queryClient = useQueryClient();
  const [logs, setLogs] = useState<string[]>([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [isComplete, setIsComplete] = useState(false);
  const logContainerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (logContainerRef.current) {
      logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
    }
  }, [logs]);

  const processArticle = async () => {
    if (!article) return;
    setIsProcessing(true);
    setIsComplete(false);
    setLogs([]);

    const response = await fetch("/api/admin/process-external-news", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ articleId: article.articleId }),
    });

    if (!response.body) {
      toast.error("Streaming not supported or response body is missing.");
      setIsProcessing(false);
      setIsComplete(true);
      return;
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      const chunk = decoder.decode(value);
      const lines = chunk.split("\n\n");
      lines.forEach((line) => {
        if (line.startsWith("data:")) {
          try {
            const json = JSON.parse(line.substring(5));
            if (json.log) setLogs((prev) => [...prev, json.log]);
          } catch (e) {}
        }
      });
    }
  };

  useEffect(() => {
    if (isOpen) {
      processArticle().finally(() => {
        setIsProcessing(false);
        setIsComplete(true);
        queryClient.invalidateQueries({ queryKey: ["externalNews"] });
        queryClient.invalidateQueries({ queryKey: ["adminCuratedPosts"] });
      });
    }
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl overflow-hidden">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white flex items-center gap-2">
            {isProcessing && <Loader2 className="animate-spin" />}
            {isComplete && <CheckCircle className="text-green-400" />}
            Article Processing Log
          </h2>
          <button onClick={onClose} className="text-brand-muted hover:text-white" disabled={isProcessing}>
            <XCircle size={24} />
          </button>
        </div>
        <div className="p-6">
          <p className="text-brand-light mb-4">
            Processing: <strong className="text-white">"{article?.title}"</strong>
          </p>
          <div ref={logContainerRef} className="bg-brand-dark p-4 rounded-lg h-80 overflow-y-auto font-mono text-sm space-y-2 custom-scrollbar">
            {logs.map((log, index) => (
              <div key={index} className="flex items-start gap-2">
                <span className="text-brand-muted">{">"}</span>
                <span className={log.startsWith("") ? "text-green-400" : log.startsWith("") ? "text-red-400" : "text-brand-light"}>
                  {log}
                </span>
              </div>
            ))}
             {isProcessing && <div className="text-yellow-400 animate-pulse">Processing... please wait, this may take a few minutes.</div>}
             {isComplete && <div className="text-green-400 font-bold mt-2"> All tasks complete. You can now close this window.</div>}
          </div>
        </div>
         <div className="p-6 border-t border-gray-700 flex justify-end">
            <button onClick={onClose} className="bg-brand-purple text-white font-bold py-2 px-6 rounded-lg hover:opacity-90 disabled:opacity-50" disabled={isProcessing}>
                Close
            </button>
        </div>
      </div>
    </div>
  );
};

export default function AdminAutoNewsPage() {
  const queryClient = useQueryClient();

  const [activeTab, setActiveTab] = useState<"external_news" | "prediction_generation">("external_news");
  const [newsQuery, setNewsQuery] = useState("football OR soccer");
  const [newsLanguage, setNewsLanguage] = useState("en");
  const [fetchSummary, setFetchSummary] = useState<any | null>(null);
  const [currentPage, setCurrentPage] = useState(1);
  const [articlesPerPage, setArticlesPerPage] = useState(10);
  const [statusFilter, setStatusFilter] = useState("fetched");
  const [deletingArticleId, setDeletingArticleId] = useState<string | null>(null);
  const [isBatchModalOpen, setIsBatchModalOpen] = useState(false);
  const [isSingleProcessModalOpen, setIsSingleProcessModalOpen] = useState(false);
  const [articleToProcess, setArticleToProcess] = useState<IExternalNewsArticle | null>(null);

  const { data: externalNewsData, isLoading: isLoadingNews } =
    useQuery<ExternalNewsResponse>({
      queryKey: ["externalNews", currentPage, articlesPerPage, statusFilter],
      queryFn: () =>
        fetchExternalNews(currentPage, articlesPerPage, statusFilter),
      enabled: activeTab === "external_news",
      refetchInterval: 15000,
    });

  const fetchedArticlesCount = useMemo(() => {

    const fetchedData = queryClient.getQueryData<ExternalNewsResponse>(["externalNews", 1, 1, "fetched"]);
    return fetchedData?.totalCount ?? 0;
  }, [externalNewsData]);

  const handleOpenProcessSingleModal = (article: IExternalNewsArticle) => {
    setArticleToProcess(article);
    setIsSingleProcessModalOpen(true);
  };

  const fetchNewsMutation = useMutation({
    mutationFn: (payload: { query: string; language: string }) =>
      axios.post("/api/admin/fetch-external-news", payload),
    onSuccess: (data) => {
      setFetchSummary(data.data);
      queryClient.invalidateQueries({ queryKey: ["externalNews"] });
      setCurrentPage(1);
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "Failed to fetch news."),
  });

  const deleteArticleMutation = useMutation({
    mutationFn: (articleId: string) => {
      setDeletingArticleId(articleId);
      return axios.delete(`/api/admin/external-news?articleId=${articleId}`);
    },
    onSuccess: () => {
      toast.success("Article deleted!");
      queryClient.invalidateQueries({ queryKey: ["externalNews"] });
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "Failed to delete article."),
    onSettled: () => setDeletingArticleId(null),
  });

  const handleFetchNews = (e: React.FormEvent) => {
    e.preventDefault();
    fetchNewsMutation.mutate({ query: newsQuery, language: newsLanguage });
  };

  const handleDeleteArticle = (articleId: string, title: string) => {
    if (window.confirm(`Are you sure you want to delete "${title}"?`)) {
      deleteArticleMutation.mutate(articleId);
    }
  };

  const totalPages = externalNewsData
    ? Math.ceil(externalNewsData.totalCount / articlesPerPage)
    : 0;

  const statusInfo = (
    status: IExternalNewsArticle["status"]
  ): { icon: React.ElementType; color: string } => {
    switch (status) {
      case "processed": return { icon: CheckCircle, color: "text-green-400" };
      case "processing": return { icon: Loader2, color: "text-blue-400 animate-spin" };
      case "fetched": return { icon: DownloadCloud, color: "text-yellow-400" };
      case "skipped": return { icon: SkipForward, color: "text-gray-400" };
      case "error": return { icon: XCircle, color: "text-red-400" };
      default: return { icon: AlertCircle, color: "text-gray-400" };
    }
  };

  return (
    <div>
      <FetchSummaryModal
        summary={fetchSummary}
        onClose={() => setFetchSummary(null)}
      />
      {isBatchModalOpen && (
          <BatchProcessModal
              isOpen={isBatchModalOpen}
              onClose={() => setIsBatchModalOpen(false)}
          />
      )}
      {isSingleProcessModalOpen && (
        <ProcessSingleModal
          isOpen={isSingleProcessModalOpen}
          onClose={() => setIsSingleProcessModalOpen(false)}
          article={articleToProcess}
        />
      )}

      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Sparkles size={28} /> Automated Content Engine
        </h1>
      </div>
      <div className="flex border-b border-gray-700 mb-8">
        <button
          onClick={() => setActiveTab("external_news")}
          className={`px-6 py-3 text-lg font-semibold flex items-center gap-2 ${
            activeTab === "external_news"
              ? "text-brand-purple border-b-2 border-brand-purple"
              : "text-brand-muted hover:text-white"
          }`}
        >
          <DownloadCloud size={20} /> Article Automation Log
        </button>
        <button
          onClick={() => setActiveTab("prediction_generation")}
          className={`px-6 py-3 text-lg font-semibold flex items-center gap-2 ${
            activeTab === "prediction_generation"
              ? "text-brand-purple border-b-2 border-brand-purple"
              : "text-brand-muted hover:text-white"
          }`}
        >
          <Sparkles size={20} /> Match Predictions
        </button>
      </div>

      {activeTab === "external_news" && (
        <div className="space-y-8">
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
            <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
              <DownloadCloud size={24} /> Fetch New Articles
            </h2>
            <form
              onSubmit={handleFetchNews}
              className="grid grid-cols-1 md:grid-cols-2 gap-4"
            >
              <div>
                <label htmlFor="newsQuery" className="block text-sm font-medium text-brand-light mb-1">
                  Keywords (qInTitle):
                </label>
                <input type="text" id="newsQuery" value={newsQuery} onChange={(e) => setNewsQuery(e.target.value)}
                  className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                />
              </div>
              <div>
                <label htmlFor="newsLanguage" className="block text-sm font-medium text-brand-light mb-1">
                  Language:
                </label>
                <select id="newsLanguage" value={newsLanguage} onChange={(e) => setNewsLanguage(e.target.value)}
                  className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple">
                  <option value="en">English</option>
                  <option value="tr">Turkish</option>
                </select>
              </div>
              <div className="md:col-span-2 flex justify-end">
                <button type="submit" className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50" disabled={fetchNewsMutation.isPending}>
                  {fetchNewsMutation.isPending ? (<Loader2 size={20} className="animate-spin" />) : (<DownloadCloud size={20} />)}{" "}
                  {fetchNewsMutation.isPending ? "Fetching..." : "Fetch New Articles"}
                </button>
              </div>
            </form>
          </div>
          <div className="bg-brand-secondary rounded-lg overflow-hidden shadow-xl">
            <div className="p-6">
              <div className="flex flex-col md:flex-row items-start md:items-center justify-between gap-4">
                <h2 className="text-2xl font-bold text-white flex items-center gap-2">
                  <FileText size={24} /> Article Processing Queue
                </h2>
                <div className="flex items-center gap-4">
                  <button onClick={() => setIsBatchModalOpen(true)} disabled={fetchedArticlesCount === 0} className="flex items-center gap-2 bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">
                      <Bot size={18} /> Process All ({fetchedArticlesCount})
                  </button>
                  <select
                    value={statusFilter}
                    onChange={(e) => { setStatusFilter(e.target.value); setCurrentPage(1); }}
                    className="p-2 rounded bg-gray-700 text-white border border-gray-600 text-sm">
                    <option value="fetched">Fetched</option>
                    <option value="processing">Processing</option>
                    <option value="processed">Processed</option>
                    <option value="error">Error</option>
                    <option value="">All</option>
                  </select>
                </div>
              </div>
            </div>
            <div className="overflow-x-auto">
              <table className="w-full text-left text-brand-light">
                <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
                  <tr>
                    <th className="p-4">Preview</th>
                    <th className="p-4">Title</th>
                    <th className="p-4">Status</th>
                    <th className="p-4">Fetched At</th>
                    <th className="p-4">Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {isLoadingNews ? (
                    Array.from({ length: 5 }).map((_, i) => (
                      <tr key={i}><td colSpan={5} className="p-4 h-20 animate-pulse"><div className="h-full bg-gray-700 rounded"></div></td></tr>
                    ))
                  ) : externalNewsData?.articles?.length === 0 ? (
                    <tr><td colSpan={5} className="p-8 text-center text-brand-muted">No articles found with this filter.</td></tr>
                  ) : (
                    externalNewsData?.articles.map((article) => {
                      const { icon: StatusIcon, color: statusColor } = statusInfo(article.status);
                      return (
                        <tr key={article._id} className={`border-t border-gray-700/50 transition-colors ${deletingArticleId === article.articleId ? "bg-brand-dark/50 opacity-50" : "hover:bg-gray-800"}`}>
                          <td className="p-4">
                            <Image src={proxyImageUrl(article.imageUrl)} alt={article.title} width={100} height={56} objectFit="cover" className="rounded-md bg-gray-700"/>
                          </td>
                          <td className="p-4 font-medium max-w-sm" title={article.title}>
                            <a href={article.link} target="_blank" rel="noopener noreferrer" className="hover:text-brand-purple transition-colors">
                              {article.title}{" "}<ExternalLink size={12} className="inline-block"/>
                            </a>
                          </td>
                          <td className="p-4">
                            <div className={`flex items-center gap-1.5 font-semibold text-xs ${statusColor}`}>
                              <StatusIcon size={12} />
                              <span className="capitalize">{article.status}</span>
                            </div>
                          </td>
                          <td className="p-4 text-brand-muted text-sm">
                            {format(parseISO(article.pubDate), "dd MMM, HH:mm")}
                          </td>
                          <td className="p-4 flex gap-2 items-center h-full">
                            {article.status === "fetched" && (
                              <button onClick={() => handleOpenProcessSingleModal(article)} className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-3 rounded-lg text-sm hover:opacity-90">
                                <Sparkles size={16} />
                                <span>Generate</span>
                              </button>
                            )}
                            {article.status === "processed" && article.processedPostId && (
                                <Link href={`/admin/curated-news`} className="text-blue-400 hover:text-blue-300 p-2 rounded-full bg-brand-dark" title="View Processed Post">
                                  <ExternalLink size={18} />
                                </Link>
                            )}
                            <button onClick={() => handleDeleteArticle(article.articleId, article.title)} className="text-red-400 hover:text-red-300 p-2 rounded-full bg-brand-dark" title="Delete Article" disabled={deleteArticleMutation.isPending}>
                              {deletingArticleId === article.articleId ? (<Loader2 size={18} className="animate-spin" />) : (<Trash2 size={18} />)}
                            </button>
                          </td>
                        </tr>
                      );
                    })
                  )}
                </tbody>
              </table>
            </div>
            {totalPages > 0 && (
              <div className="p-6 border-t border-gray-700/50">
                <AdminPagination currentPage={currentPage} totalPages={totalPages} onPageChange={setCurrentPage}/>
              </div>
            )}
          </div>
        </div>
      )}

      {activeTab === "prediction_generation" && <PredictionGenerationTab />}
    </div>
  );
}

// ===== src/app/admin/banners/page.tsx =====

"use client";

import { useMemo, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { PlusCircle, Edit, Trash2 } from "lucide-react";
import Image from "next/image";
import { IBanner } from "@/models/Banner";
import BannerFormModal from "@/components/admin/BannerFormModal";
import { AD_SLOTS } from "@/config/adSlots";
import { proxyImageUrl } from "@/lib/image-proxy";

const fetchBanners = async (): Promise<IBanner[]> => {
  const { data } = await axios.get("/api/banners");
  return data;
};

export default function AdminBannersPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingBanner, setEditingBanner] = useState<IBanner | null>(null);

  const locationNameMap = useMemo(
    () => new Map(AD_SLOTS.map((s) => [s.id, s.name])),
    []
  );

  const {
    data: banners,
    isLoading,
    error,
  } = useQuery<IBanner[]>({
    queryKey: ["adminBanners"],
    queryFn: fetchBanners,
  });

  const deleteMutation = useMutation({
    mutationFn: (bannerId: string) => axios.delete(`/api/banners/${bannerId}`),
    onSuccess: () => {
      toast.success("Banner deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["adminBanners"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete banner.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingBanner(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (banner: IBanner) => {
    setEditingBanner(banner);
    setIsModalOpen(true);
  };

  const handleDelete = (bannerId: string) => {
    if (
      window.confirm(
        "Are you sure you want to delete this banner? This action cannot be undone."
      )
    ) {
      deleteMutation.mutate(bannerId);
    }
  };

  if (isLoading) return <p className="text-brand-muted">Loading banners...</p>;
  if (error) return <p className="text-red-400">Failed to load banners.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Manage Ad Banners</h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Banner</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Preview</th>
              <th className="p-4">Title</th>
              <th className="p-4">Location</th> {}
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {banners?.map((banner) => (
              <tr
                key={banner._id as string}
                className="border-t border-gray-700/50"
              >
                <td className="p-4">
                  {}
                  <Image
                    src={banner.imageUrl}
                    alt={banner.title}
                    width={120}
                    height={60}

                    objectFit="contain"
                    className="rounded-md bg-gray-700"
                  />
                </td>
                <td className="p-4 font-medium">{banner.title}</td>
                <td className="p-4 font-semibold text-brand-light">
                  {locationNameMap.get(banner.location) || banner.location}
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      banner.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {banner.isActive ? "Active" : "Inactive"}
                  </span>
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <button
                    onClick={() => handleOpenEditModal(banner)}
                    className="text-blue-400 hover:text-blue-300"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() => handleDelete(banner._id as string)}
                    className="text-red-400 hover:text-red-300"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {banners?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No banners found. Click "New Banner" to create one.
          </p>
        )}
      </div>

      <BannerFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        banner={editingBanner}
      />
    </div>
  );
}

// ===== src/app/admin/casino-partners/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  PlusCircle,
  Edit,
  Trash2,
  Crown,
  Link as LinkIcon,
  ExternalLink,
  Loader2,
  CheckCircle,
  XCircle,
} from "lucide-react";
import Image from "next/image";

interface ICasinoPartner {
  _id: string;
  name: string;
  logoUrl: string;
  redirectUrl: string;
  description?: string;
  isFeatured: boolean;
  isActive: boolean;
  order: number;
  createdAt: string;
  updatedAt: string;
}

interface CasinoPartnerFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  partner?: ICasinoPartner | null;
}

const CasinoPartnerFormModal: React.FC<CasinoPartnerFormModalProps> = ({
  isOpen,
  onClose,
  partner,
}) => {
  const queryClient = useQueryClient();
  const [name, setName] = useState(partner?.name || "");
  const [logoUrl, setLogoUrl] = useState(partner?.logoUrl || "");
  const [redirectUrl, setRedirectUrl] = useState(partner?.redirectUrl || "");
  const [description, setDescription] = useState(partner?.description || "");
  const [isFeatured, setIsFeatured] = useState(partner?.isFeatured ?? false);
  const [isActive, setIsActive] = useState(partner?.isActive ?? true);
  const [order, setOrder] = useState(partner?.order ?? 0);

  useEffect(() => {
    if (partner) {
      setName(partner.name);
      setLogoUrl(partner.logoUrl);
      setRedirectUrl(partner.redirectUrl);
      setDescription(partner.description || "");
      setIsFeatured(partner.isFeatured);
      setIsActive(partner.isActive);
      setOrder(partner.order);
    } else {
      setName("");
      setLogoUrl("");
      setRedirectUrl("");
      setDescription("");
      setIsFeatured(false);
      setIsActive(true);
      setOrder(0);
    }
  }, [partner]);

  const createMutation = useMutation({
    mutationFn: (newPartner: Partial<ICasinoPartner>) =>
      axios.post("/api/admin/casino-partners", newPartner),
    onSuccess: () => {
      toast.success("Casino Partner created successfully!");
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersAdmin"] });
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersPublic"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to create partner.");
    },
  });

  const updateMutation = useMutation({
    mutationFn: (updatedPartner: Partial<ICasinoPartner>) =>
      axios.put(`/api/admin/casino-partners/${partner?._id}`, updatedPartner),
    onSuccess: () => {
      toast.success("Casino Partner updated successfully!");
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersAdmin"] });
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersPublic"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to update partner.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !logoUrl.trim() || !redirectUrl.trim()) {
      toast.error("Name, Logo URL, and Redirect URL are required.");
      return;
    }

    const payload = {
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured,
      isActive,
      order: Number(order),
    };

    if (partner) {
      updateMutation.mutate(payload);
    } else {
      createMutation.mutate(payload);
    }
  };

  const isPending = createMutation.isPending || updateMutation.isPending;

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl overflow-hidden">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {partner ? "Edit Casino Partner" : "Create New Casino Partner"}
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label
              htmlFor="name"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Partner Name
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
          </div>
          <div>
            <label
              htmlFor="logoUrl"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Logo URL
            </label>
            {}
            <input
              id="logoUrl"
              type="url"
              value={logoUrl}
              onChange={(e) => setLogoUrl(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
            {logoUrl && (
              <div className="mt-2 text-center">
                <Image
                  src={logoUrl}
                  alt="Logo Preview"
                  width={80}
                  height={40}
                  objectFit="contain"
                  className="rounded-md bg-gray-800 p-1"

                />
              </div>
            )}
          </div>
          <div>
            <label
              htmlFor="redirectUrl"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Redirect URL (Affiliate Link)
            </label>
            <input
              id="redirectUrl"
              type="url"
              value={redirectUrl}
              onChange={(e) => setRedirectUrl(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
            <p className="text-xs text-brand-muted mt-1">
              This is the link users will be redirected to.
            </p>
          </div>
          <div>
            <label
              htmlFor="description"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Description (Optional)
            </label>
            <textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
              rows={3}
              disabled={isPending}
              placeholder="A short internal description of the partner."
            />
          </div>
          <div className="flex flex-col sm:flex-row sm:items-center sm:gap-4 space-y-3 sm:space-y-0">
            <div className="flex items-center">
              <input
                id="isFeatured"
                type="checkbox"
                checked={isFeatured}
                onChange={(e) => setIsFeatured(e.target.checked)}
                className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
                disabled={isPending}
              />
              <label
                htmlFor="isFeatured"
                className="ml-2 text-sm font-medium text-brand-light"
              >
                Featured (Prominent Styling)
              </label>
            </div>
            <div className="flex items-center">
              <input
                id="isActive"
                type="checkbox"
                checked={isActive}
                onChange={(e) => setIsActive(e.target.checked)}
                className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
                disabled={isPending}
              />
              <label
                htmlFor="isActive"
                className="ml-2 text-sm font-medium text-brand-light"
              >
                Active (Display on site)
              </label>
            </div>
            <div className="flex-grow">
              <label
                htmlFor="order"
                className="block text-sm font-medium text-brand-light mb-1 sm:mb-0"
              >
                Order
              </label>
              <input
                id="order"
                type="number"
                value={order}
                onChange={(e) => setOrder(Number(e.target.value))}
                className="w-20 p-2 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                disabled={isPending}
                min="0"
              />
              <p className="text-xs text-brand-muted mt-1">
                Lower number = higher priority.
              </p>
            </div>
          </div>

          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
              disabled={isPending}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={isPending}
            >
              {isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {isPending
                ? partner
                  ? "Updating..."
                  : "Creating..."
                : partner
                ? "Save Changes"
                : "Create Partner"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default function AdminCasinoPartnersPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingPartner, setEditingPartner] = useState<ICasinoPartner | null>(
    null
  );

  const {
    data: partners,
    isLoading,
    error,
  } = useQuery<ICasinoPartner[]>({
    queryKey: ["casinoPartnersAdmin"],
    queryFn: async () => {
      const { data } = await axios.get("/api/admin/casino-partners");
      return data;
    },
    staleTime: 1000 * 60 * 5,
  });

  const deleteMutation = useMutation({
    mutationFn: (partnerId: string) =>
      axios.delete(`/api/admin/casino-partners/${partnerId}`),
    onSuccess: () => {
      toast.success("Casino Partner deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersAdmin"] });
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersPublic"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete partner.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingPartner(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (partner: ICasinoPartner) => {
    setEditingPartner(partner);
    setIsModalOpen(true);
  };

  const handleDelete = (partnerId: string, partnerName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete Casino Partner "${partnerName}"? This action cannot be undone.`
      )
    ) {
      deleteMutation.mutate(partnerId);
    }
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading Casino Partners...</p>;
  if (error)
    return <p className="text-red-400">Failed to load Casino Partners.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Crown size={28} /> Manage Casino Partners
        </h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Partner</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Logo</th>
              <th className="p-4">Name</th>
              <th className="p-4">Featured</th>
              <th className="p-4">Active</th>
              <th className="p-4">Order</th>
              <th className="p-4">Description</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {partners?.map((partner) => (
              <tr key={partner._id} className="border-t border-gray-700/50">
                <td className="p-4">
                  {partner.logoUrl && (
                    <Image
                      src={partner.logoUrl}
                      alt={partner.name}
                      width={60}
                      height={30}
                      objectFit="contain"
                      className="rounded-md bg-gray-700 p-1"
                    />
                  )}
                </td>
                <td className="p-4 font-medium">{partner.name}</td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      partner.isFeatured
                        ? "bg-yellow-500/20 text-yellow-400"
                        : "bg-gray-600/20 text-gray-400"
                    }`}
                  >
                    {partner.isFeatured ? "Yes" : "No"}
                  </span>
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      partner.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {partner.isActive ? "Yes" : "No"}
                  </span>
                </td>
                <td className="p-4 text-brand-muted">{partner.order}</td>
                <td
                  className="p-4 text-brand-muted text-sm max-w-[200px] truncate"
                  title={partner.description}
                >
                  {partner.description || "N/A"}
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <a
                    href={partner.redirectUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-brand-muted hover:text-white"
                    title="Go to Partner Site"
                  >
                    <ExternalLink size={18} />
                  </a>
                  <button
                    onClick={() => handleOpenEditModal(partner)}
                    className="text-blue-400 hover:text-blue-300"
                    title="Edit Partner"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() => handleDelete(partner._id, partner.name)}
                    className="text-red-400 hover:text-red-300"
                    title="Delete Partner"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {partners?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No Casino Partners found. Click "New Partner" to create one.
          </p>
        )}
      </div>

      <CasinoPartnerFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        partner={editingPartner}
      />
    </div>
  );
}

// ===== src/app/admin/curated-news/page.tsx =====

"use client";

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import { IPost } from "@/models/Post";
import toast from "react-hot-toast";
import { useMemo } from "react";
import { ILanguage } from "@/models/Language";
import TranslationGroupRow from "@/components/admin/TranslationGroupRow";
import { Bot } from "lucide-react";

const fetchCuratedPosts = async (): Promise<IPost[]> => {
  const { data } = await axios.get("/api/admin/posts?newsType=recent");
  return data;
};

const fetchLanguages = async (): Promise<ILanguage[]> => {
  const { data } = await axios.get("/api/admin/languages");
  return data;
};

export default function AdminCuratedNewsPage() {
  const queryClient = useQueryClient();

  const {
    data: posts,
    isLoading: isLoadingPosts,
    error: postsError,
  } = useQuery<IPost[]>({
    queryKey: ["adminCuratedPosts"],
    queryFn: fetchCuratedPosts,
  });

  const { data: languages, isLoading: isLoadingLanguages } = useQuery<
    ILanguage[]
  >({
    queryKey: ["allLanguages"],
    queryFn: fetchLanguages,
  });

  const languageMap = useMemo(() => {
    if (!languages) return new Map<string, ILanguage>();
    return new Map(languages.map((lang) => [lang.code, lang]));
  }, [languages]);

  const groupedPosts = useMemo(() => {
    if (!posts) return [];
    const groups: Record<string, IPost[]> = {};
    posts.forEach((post) => {
      const groupId = (post.translationGroupId || post._id).toString();
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      groups[groupId].push(post);
    });

    return Object.values(groups).sort((a, b) => {
      const dateA = new Date(a[0].createdAt).getTime();
      const dateB = new Date(b[0].createdAt).getTime();
      return dateB - dateA;
    });
  }, [posts]);

  const deleteMutation = useMutation({
    mutationFn: (postId: string) => axios.delete(`/api/posts/${postId}`),
    onSuccess: (_, postId) => {
      queryClient.setQueryData(["adminCuratedPosts"], (oldData: IPost[] | undefined) =>
        oldData ? oldData.filter((post) => post._id !== postId) : []
      );
      toast.success("Post deleted successfully!");
    },
    onError: (error: any) => {
      const message = error.response?.data?.message || "Error deleting post.";
      toast.error(message);
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ["adminCuratedPosts"] });
    },
  });

  const handleDeletePost = (postId: string, title: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete the post "${title}"? This cannot be undone.`
      )
    ) {
      deleteMutation.mutate(postId);
    }
  };

  const isLoading = isLoadingPosts || isLoadingLanguages;

  if (isLoading) return <p className="text-brand-muted">Loading curated news...</p>;
  if (postsError) return <p className="text-red-400">Failed to load curated news.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Bot size={28} /> AI Curated News
        </h1>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-hidden">
        <table className="w-full text-left">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4 w-[140px]">Image</th>
              <th className="p-4">Title & Translations</th>
              <th className="p-4">Status</th>
              <th className="p-4">Created At</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {groupedPosts.map((group) => (
              <TranslationGroupRow
                key={
                  group[0].translationGroupId?.toString() ||
                  group[0]._id.toString()
                }
                group={group}
                languageMap={languageMap}
                onDelete={handleDeletePost}
              />
            ))}
          </tbody>
        </table>

        {posts?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No AI-curated news articles found.
          </p>
        )}
      </div>
    </div>
  );
}

// ===== src/app/admin/dashboard/page.tsx =====

import { getI18n } from "@/lib/i18n/server";

export default async function AdminDashboardPage() {
  const t = await getI18n();

  return (
    <div>
      <h1 className="text-3xl font-bold text-white mb-4">
        {t("admin_dashboard")}
      </h1>
      <p className="text-brand-muted">{t("welcome_to_admin_area")}</p>
      <div className="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6">
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t("manage_users")}</h3>
          <p className="text-sm text-brand-muted mt-2">
            {t("view_and_edit_user_roles")}
          </p>
        </div>
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t("manage_matches")}</h3>
          <p className="text-sm text-brand-muted mt-2">
            {t("update_match_details")}
          </p>
        </div>
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t("view_analytics")}</h3>
          <p className="text-sm text-brand-muted mt-2">
            {t("check_site_traffic")}
          </p>
        </div>
      </div>
    </div>
  );
}

// ===== src/app/admin/faqs/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  PlusCircle,
  Edit,
  Trash2,
  CheckCircle,
  XCircle,
  Loader2,
  HelpCircle,
} from "lucide-react";
import CreatableSelect from "@/components/admin/CreatableSelect";

interface IFaq {
  _id: string;
  question: string;
  answer: string;
  category: string;
  order: number;
  isActive: boolean;
}

const defaultFormState: Omit<IFaq, "_id"> = {
  question: "",
  answer: "",
  category: "General Questions",
  order: 0,
  isActive: true,
};

const FaqFormModal = ({
  isOpen,
  onClose,
  faq,
}: {
  isOpen: boolean;
  onClose: () => void;
  faq: IFaq | null;
}) => {
  const queryClient = useQueryClient();

  const [formData, setFormData] = useState<Omit<IFaq, "_id">>(defaultFormState);

  useEffect(() => {
    if (isOpen) {
      if (faq) {

        setFormData({
          question: faq.question,
          answer: faq.answer,
          category: faq.category,
          order: faq.order,
          isActive: faq.isActive,
        });
      } else {

        setFormData(defaultFormState);
      }
    }
  }, [faq, isOpen]);

  const handleFormChange = (field: keyof typeof formData, value: any) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  const mutation = useMutation({

    mutationFn: (faqData: Omit<IFaq, "_id"> & { _id?: string }) => {
      if (faqData._id) {
        return axios.put("/api/admin/faqs", faqData);
      }
      return axios.post("/api/admin/faqs", faqData);
    },
    onSuccess: () => {
      toast.success(`FAQ ${faq ? "updated" : "created"} successfully!`);
      queryClient.invalidateQueries({ queryKey: ["adminFaqs"] });
      queryClient.invalidateQueries({ queryKey: ["faqCategories"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "An error occurred.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (
      !formData.question.trim() ||
      !formData.answer.trim() ||
      !formData.category.trim()
    ) {
      toast.error("Question, Answer, and Category are required.");
      return;
    }

    const payload = { ...formData, ...(faq && { _id: faq._id }) };
    mutation.mutate(payload);
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {faq ? "Edit FAQ" : "Create New FAQ"}
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">
              Category
            </label>
            <CreatableSelect
              value={formData.category}
              onChange={(value) => handleFormChange("category", value)}
              placeholder="Select or create a category..."
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">
              Question
            </label>
            <input
              type="text"
              value={formData.question}
              onChange={(e) => handleFormChange("question", e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600"
              required
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">
              Answer (HTML allowed)
            </label>
            <textarea
              value={formData.answer}
              onChange={(e) => handleFormChange("answer", e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 resize-y"
              rows={6}
              required
            />
          </div>
          <div className="flex gap-4">
            <div className="flex-1">
              <label className="block text-sm font-medium text-brand-light mb-1">
                Order
              </label>
              <input
                type="number"
                value={formData.order}
                onChange={(e) =>
                  handleFormChange("order", Number(e.target.value))
                }
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600"
              />
            </div>
            <div className="flex items-center pt-6">
              <input
                type="checkbox"
                checked={formData.isActive}
                onChange={(e) => handleFormChange("isActive", e.target.checked)}
                className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded"
              />
              <label className="ml-2 text-sm font-medium text-brand-light">
                Active
              </label>
            </div>
          </div>
          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
              disabled={mutation.isPending}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg disabled:opacity-50 flex items-center gap-2"
              disabled={mutation.isPending}
            >
              {mutation.isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {mutation.isPending ? "Saving..." : "Save FAQ"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default function AdminFaqsPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingFaq, setEditingFaq] = useState<IFaq | null>(null);

  const {
    data: faqs,
    isLoading,
    error,
  } = useQuery<IFaq[]>({
    queryKey: ["adminFaqs"],
    queryFn: () => axios.get("/api/admin/faqs").then((res) => res.data),
  });

  const deleteMutation = useMutation({
    mutationFn: (faqId: string) =>
      axios.delete("/api/admin/faqs", { data: { id: faqId } }),
    onSuccess: () => {
      toast.success("FAQ deleted!");
      queryClient.invalidateQueries({ queryKey: ["adminFaqs"] });
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "Failed to delete FAQ."),
  });

  const handleOpenCreateModal = () => {
    setEditingFaq(null);
    setIsModalOpen(true);
  };
  const handleOpenEditModal = (faq: IFaq) => {
    setEditingFaq(faq);
    setIsModalOpen(true);
  };
  const handleDelete = (faqId: string) => {
    if (window.confirm("Are you sure?")) deleteMutation.mutate(faqId);
  };

  if (isLoading) return <p className="text-brand-muted">Loading FAQs...</p>;
  if (error) return <p className="text-red-400">Failed to load FAQs.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <HelpCircle size={28} /> Manage FAQs
        </h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} /> New FAQ
        </button>
      </div>
      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Order</th>
              <th className="p-4">Category</th>
              <th className="p-4">Question</th>
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {faqs?.map((faq) => (
              <tr key={faq._id} className="border-t border-gray-700/50">
                <td className="p-4 w-20 text-center font-bold">{faq.order}</td>
                <td className="p-4 font-semibold text-brand-muted">
                  {faq.category}
                </td>
                <td className="p-4 font-medium">{faq.question}</td>
                <td className="p-4 w-32">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      faq.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {faq.isActive ? "Active" : "Inactive"}
                  </span>
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <button
                    onClick={() => handleOpenEditModal(faq)}
                    className="text-blue-400 hover:text-blue-300"
                    title="Edit FAQ"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() => handleDelete(faq._id)}
                    className="text-red-400 hover:text-red-300"
                    title="Delete FAQ"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {faqs?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">No FAQs found.</p>
        )}
      </div>
      <FaqFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        faq={editingFaq}
      />
    </div>
  );
}

// ===== src/app/admin/file-manager/page.tsx =====

"use client";

import { useRef, useState, useMemo } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  UploadCloud,
  CheckCircle,
  Link as LinkIcon,
  FileText,
  Download,
  Copy,
  Trash2,
  RefreshCw,
  Loader2,
} from "lucide-react";
import Image from "next/image";

interface UploadedFile {
  name: string;
  url: string;
  type: string;
  size: number;
  lastModified: string | Date;
}

const fetchUploadedFiles = async (): Promise<UploadedFile[]> => {
  const { data } = await axios.get("/api/upload");
  return data;
};

export default function AdminFileManagerPage() {
  const queryClient = useQueryClient();
  const fileInputRef = useRef<HTMLInputElement>(null);

  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [downloadUrl, setDownloadUrl] = useState("");
  const [downloadFileName, setDownloadFileName] = useState("");

  const {
    data: files,
    isLoading: isLoadingFiles,
    error: filesError,
    refetch: refetchFiles,
  } = useQuery<UploadedFile[]>({
    queryKey: ["uploadedFiles"],
    queryFn: fetchUploadedFiles,
    staleTime: 1000 * 60 * 5,
  });

  const sortedFiles = useMemo(() => {
    if (!files) return [];
    return [...files].sort(
      (a, b) =>
        new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime()
    );
  }, [files]);

  const createMutation = (
    mutationFn: (payload: any) => Promise<any>,
    successMessage: string
  ) =>
    useMutation({
      mutationFn,
      onSuccess: (response) => {
        const newFile: UploadedFile = response.data;
        toast.success(successMessage);

        queryClient.setQueryData(
          ["uploadedFiles"],
          (oldData: UploadedFile[] | undefined) => [newFile, ...(oldData || [])]
        );

        setTimeout(() => {
          queryClient.invalidateQueries({ queryKey: ["uploadedFiles"] });
        }, 2500);
      },
      onSettled: () => {

        setSelectedFile(null);
        if (fileInputRef.current) fileInputRef.current.value = "";
        setDownloadUrl("");
        setDownloadFileName("");
      },
      onError: (err: any) => {
        toast.error(err.response?.data?.error || "Operation failed.");
      },
    });

  const uploadMutation = createMutation(
    (formData: FormData) => axios.post("/api/upload", formData),
    "File uploaded successfully!"
  );

  const downloadFromUrlMutation = createMutation(
    (payload: { url: string; fileName?: string }) =>
      axios.post("/api/admin/file-manager/download-from-url", payload),
    "File downloaded from URL and uploaded!"
  );

  const deleteFileMutation = useMutation({
    mutationFn: (fileKey: string) => axios.delete(`/api/upload?key=${fileKey}`),
    onSuccess: (_, fileKey) => {
      toast.success("File deleted successfully!");
      queryClient.setQueryData(
        ["uploadedFiles"],
        (oldData: UploadedFile[] | undefined) =>
          oldData ? oldData.filter((f) => f.name !== fileKey) : []
      );
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete file.");
    },
  });

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setSelectedFile(file);
    } else {
      setSelectedFile(null);
    }
  };

  const handleUpload = (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedFile) {
      toast.error("Please select a file to upload.");
      return;
    }
    const formData = new FormData();
    formData.append("file", selectedFile);
    uploadMutation.mutate(formData);
  };

  const handleDownloadFromUrl = (e: React.FormEvent) => {
    e.preventDefault();
    if (!downloadUrl.trim()) {
      toast.error("Please enter a URL.");
      return;
    }
    downloadFromUrlMutation.mutate({
      url: downloadUrl,
      fileName: downloadFileName.trim() || undefined,
    });
  };

  const handleDeleteFile = (fileKey: string, fileName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete "${fileName}"? This action cannot be undone.`
      )
    ) {
      deleteFileMutation.mutate(fileKey);
    }
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
    toast.success("URL copied to clipboard!");
  };

  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  };

  const isUploading =
    uploadMutation.isPending || downloadFromUrlMutation.isPending;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <FileText size={28} /> File Manager
        </h1>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg mb-8 shadow-xl">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
          <UploadCloud size={24} /> Upload New File
        </h2>
        <form onSubmit={handleUpload} className="space-y-4">
          <div>
            <label
              htmlFor="file-upload"
              className="block text-sm font-medium text-brand-light mb-2"
            >
              Select File
            </label>
            <input
              id="file-upload"
              type="file"
              ref={fileInputRef}
              onChange={handleFileChange}
              className="w-full text-brand-light bg-gray-700 border border-gray-600 rounded-lg p-3 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-brand-purple file:text-white hover:file:opacity-90 cursor-pointer"
              disabled={isUploading}
            />
            {selectedFile && (
              <p className="mt-2 text-sm text-brand-muted">
                Selected: {selectedFile.name} (
                {formatFileSize(selectedFile.size)})
              </p>
            )}
          </div>
          <div className="flex justify-end">
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={!selectedFile || isUploading}
            >
              {uploadMutation.isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {uploadMutation.isPending ? "Uploading..." : "Upload File"}
            </button>
          </div>
        </form>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg mb-8 shadow-xl">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
          <Download size={24} /> Download from URL
        </h2>
        <form onSubmit={handleDownloadFromUrl} className="space-y-4">
          <div>
            <label
              htmlFor="download-url"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              File URL
            </label>
            <input
              id="download-url"
              type="url"
              value={downloadUrl}
              onChange={(e) => setDownloadUrl(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              placeholder="e.g., https://example.com/image.jpg"
              required
              disabled={isUploading}
            />
          </div>
          <div>
            <label
              htmlFor="download-filename"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Optional File Name (on S3)
            </label>
            <input
              id="download-filename"
              type="text"
              value={downloadFileName}
              onChange={(e) => setDownloadFileName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              placeholder="e.g., my-custom-image (extension will be added automatically)"
              disabled={isUploading}
            />
          </div>
          <div className="flex justify-end">
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={!downloadUrl.trim() || isUploading}
            >
              {downloadFromUrlMutation.isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <Download size={18} />
              )}
              {downloadFromUrlMutation.isPending
                ? "Downloading..."
                : "Download & Upload"}
            </button>
          </div>
        </form>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-hidden shadow-xl">
        <div className="p-6">
          <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
            <LinkIcon size={24} /> Uploaded Files
            <button
              onClick={() => refetchFiles()}
              className="ml-auto text-brand-muted hover:text-white flex items-center gap-1 text-sm"
              disabled={isLoadingFiles || deleteFileMutation.isPending}
            >
              <RefreshCw
                size={16}
                className={isLoadingFiles ? "animate-spin" : ""}
              />{" "}
              Refresh
            </button>
          </h2>
        </div>

        {isLoadingFiles ? (
          <p className="text-center p-8 text-brand-muted">
            Loading files from S3...
          </p>
        ) : filesError ? (
          <p className="text-center p-8 text-red-400">
            Failed to load files from S3: {(filesError as Error).message}
          </p>
        ) : !sortedFiles || sortedFiles.length === 0 ? (
          <p className="text-center p-8 text-brand-muted">
            No files uploaded yet.
          </p>
        ) : (
          <div className="overflow-x-auto">
            <table className="w-full text-left text-brand-light">
              <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
                <tr>
                  <th className="p-4">Preview</th>
                  <th className="p-4">File Name</th>
                  <th className="p-4">Type</th>
                  <th className="p-4">Size</th>
                  <th className="p-4">Public URL</th>
                  <th className="p-4">Actions</th>
                </tr>
              </thead>
              <tbody>
                {sortedFiles.map((file) => (
                  <tr key={file.url} className="border-t border-gray-700/50">
                    <td className="p-4">
                      {file.type.startsWith("image/") ? (
                        <Image
                          src={file.url}
                          alt={file.name}
                          width={80}
                          height={45}
                          style={{ objectFit: "contain" }}
                          className="rounded-md bg-gray-700"
                        />
                      ) : (
                        <div className="w-20 h-10 bg-gray-700 flex items-center justify-center text-xs text-brand-muted rounded-md">
                          File
                        </div>
                      )}
                    </td>
                    <td
                      className="p-4 font-medium max-w-xs truncate"
                      title={file.name}
                    >
                      {file.name}
                    </td>
                    <td className="p-4 text-brand-muted text-sm">
                      {file.type.split("/")[1] || file.type}
                    </td>
                    <td className="p-4 text-brand-muted text-sm">
                      {formatFileSize(file.size)}
                    </td>
                    <td className="p-4 max-w-sm truncate">
                      <a
                        href={file.url}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-blue-400 hover:underline text-sm"
                        title={file.url}
                      >
                        {file.url}
                      </a>
                    </td>
                    <td className="p-4 flex gap-2 items-center">
                      <button
                        onClick={() => copyToClipboard(file.url)}
                        className="text-brand-purple hover:text-brand-purple/80 p-1 rounded-full bg-brand-dark"
                        title="Copy URL"
                      >
                        <Copy size={18} />
                      </button>
                      <button
                        onClick={() => handleDeleteFile(file.name, file.name)}
                        className="text-red-400 hover:text-red-300 p-1 rounded-full bg-brand-dark"
                        title="Delete File"
                        disabled={
                          deleteFileMutation.isPending &&
                          deleteFileMutation.variables === file.name
                        }
                      >
                        {deleteFileMutation.isPending &&
                        deleteFileMutation.variables === file.name ? (
                          <Loader2 size={18} className="animate-spin" />
                        ) : (
                          <Trash2 size={18} />
                        )}
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/app/admin/languages/page.tsx =====

"use client";

import { useState, useEffect, useMemo } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { ILanguage } from "@/models/Language";
import {
  PlusCircle,
  Edit,
  Trash2,
  CheckCircle,
  XCircle,
  Loader2,
  Languages,
  Save,
  FileJson,
  UploadCloud,
} from "lucide-react";
import Image from "next/image";

interface LanguageFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  language?: ILanguage | null;
  onSave: () => void;
}

const LanguageFormModal: React.FC<LanguageFormModalProps> = ({
  isOpen,
  onClose,
  language,
  onSave,
}) => {
  const [name, setName] = useState("");
  const [code, setCode] = useState("");
  const [isActive, setIsActive] = useState(true);
  const [flagUrl, setFlagUrl] = useState<string | undefined>(undefined);
  const [isUploading, setIsUploading] = useState(false);

  useEffect(() => {
    if (language) {
      setName(language.name);
      setCode(language.code);
      setIsActive(language.isActive);
      setFlagUrl(language.flagUrl);
    } else {
      setName("");
      setCode("");
      setIsActive(true);
      setFlagUrl(undefined);
    }
  }, [language]);

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setIsUploading(true);
    const formData = new FormData();
    formData.append("file", file);

    try {
      const { data } = await axios.post("/api/upload", formData);
      setFlagUrl(data.url);
      toast.success("Flag uploaded successfully!");
    } catch (error) {
      toast.error("Flag upload failed. Please try again.");
    } finally {
      setIsUploading(false);
    }
  };

  const mutation = useMutation({
    mutationFn: (payload: Partial<ILanguage>) =>
      language?._id
        ? axios.put(`/api/admin/languages/${language._id}`, payload)
        : axios.post("/api/admin/languages", payload),
    onSuccess: () => {
      toast.success(
        `Language ${language ? "updated" : "created"} successfully!`
      );
      onSave();
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to save language.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    mutation.mutate({ name, code, isActive, flagUrl });
  };

  const isMutationPending = mutation.isPending || isUploading;

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-lg">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {language ? "Edit Language" : "Add New Language"}
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label
              htmlFor="name"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Language Name
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white"
              required
              disabled={isMutationPending}
              placeholder="e.g., German"
            />
          </div>
          <div>
            <label
              htmlFor="code"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Language Code (ISO 639-1)
            </label>
            <input
              id="code"
              type="text"
              value={code}
              onChange={(e) => setCode(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white"
              required
              disabled={isMutationPending || !!language}
              placeholder="e.g., de"
            />
            {!!language && (
              <p className="text-xs text-brand-muted mt-1">
                Language code cannot be changed after creation.
              </p>
            )}
          </div>
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">
              Flag Image (Optional)
            </label>
            <div className="mt-2 flex items-center gap-4">
              <div className="w-16 h-12 flex-shrink-0 bg-gray-700 rounded-md flex items-center justify-center">
                {flagUrl ? (
                  <Image
                    src={flagUrl}
                    alt="Flag preview"
                    width={48}
                    height={32}
                    objectFit="contain"
                  />
                ) : (
                  <UploadCloud className="w-8 h-8 text-gray-500" />
                )}
              </div>
              <label
                htmlFor="flag-upload"
                className="relative cursor-pointer bg-gray-600 py-2 px-3 border border-gray-500 rounded-md shadow-sm text-sm leading-4 font-medium text-white hover:bg-gray-700"
              >
                <span>{isUploading ? "Uploading..." : "Upload File"}</span>
                <input
                  id="flag-upload"
                  name="flag-upload"
                  type="file"
                  className="sr-only"
                  onChange={handleImageUpload}
                  disabled={isUploading}
                  accept="image/png, image/jpeg, image/svg+xml, image/webp"
                />
              </label>
            </div>
          </div>
          <div className="flex items-center">
            <input
              id="isActive"
              type="checkbox"
              checked={isActive}
              onChange={(e) => setIsActive(e.target.checked)}
              className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded"
              disabled={isMutationPending}
            />
            <label
              htmlFor="isActive"
              className="ml-2 text-sm font-medium text-brand-light"
            >
              Active (Visible on site)
            </label>
          </div>
          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
              disabled={isMutationPending}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg disabled:opacity-50 flex items-center gap-2"
              disabled={isMutationPending}
            >
              {isMutationPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {isUploading
                ? "Uploading..."
                : mutation.isPending
                ? "Saving..."
                : "Save Language"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default function AdminLanguagesPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingLanguage, setEditingLanguage] = useState<ILanguage | null>(
    null
  );
  const [selectedLocale, setSelectedLocale] = useState("");
  const [translationContent, setTranslationContent] = useState("");

  const { data: languages = [], isLoading: isLoadingLanguages } = useQuery<
    ILanguage[]
  >({
    queryKey: ["languages"],
    queryFn: () => axios.get("/api/admin/languages").then((res) => res.data),
  });

  const { data: defaultLanguageFileContent, isLoading: isLoadingDefaultFile } =
    useQuery<string>({
      queryKey: ["translations", "tr"],
      queryFn: () =>
        axios
          .get("/api/admin/translations?locale=tr")
          .then((res) => JSON.stringify(res.data, null, 2)),
      enabled: true,
      staleTime: Infinity,
    });

  const { refetch: fetchTranslationFile, isFetching: isFetchingFile } =
    useQuery({
      queryKey: ["translations", selectedLocale],
      queryFn: () =>
        axios
          .get(`/api/admin/translations?locale=${selectedLocale}`)
          .then((res) => JSON.stringify(res.data, null, 2)),
      enabled: false,
      onSuccess: (data) => setTranslationContent(data),
      onError: () =>
        toast.error(`Could not load translations for ${selectedLocale}.`),
    });

  useEffect(() => {
    if (selectedLocale) {
      fetchTranslationFile();
    } else {
      setTranslationContent("");
    }
  }, [selectedLocale, fetchTranslationFile]);

  const updateLanguageMutation = useMutation({
    mutationFn: ({
      id,
      payload,
    }: {
      id: string;
      payload: Partial<ILanguage>;
    }) => axios.put(`/api/admin/languages/${id}`, payload),
    onSuccess: () => {
      toast.success("Language status updated!");
      queryClient.invalidateQueries({ queryKey: ["languages"] });
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "Update failed."),
  });

  const deleteLanguageMutation = useMutation({
    mutationFn: (id: string) => axios.delete(`/api/admin/languages/${id}`),
    onSuccess: () => {
      toast.success("Language deleted!");
      queryClient.invalidateQueries({ queryKey: ["languages"] });
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "Deletion failed."),
  });

  const saveTranslationsMutation = useMutation({
    mutationFn: ({ locale, content }: { locale: string; content: string }) =>
      axios.post("/api/admin/translations", { locale, content }),
    onSuccess: () =>
      toast.success(`Translations for '${selectedLocale}' saved!`),
    onError: (err: any) =>
      toast.error(
        err.response?.data?.error || "Save failed. Check JSON format."
      ),
  });

  const handleOpenEditModal = (lang: ILanguage) => {
    setEditingLanguage(lang);
    setIsModalOpen(true);
  };

  const handleDelete = (lang: ILanguage) => {
    if (
      window.confirm(
        `Are you sure you want to delete "${lang.name}"? This will also delete its translation file and cannot be undone.`
      )
    ) {
      deleteLanguageMutation.mutate(lang._id);
    }
  };

  const handleSetDefault = (langId: string) => {
    updateLanguageMutation.mutate({ id: langId, payload: { isDefault: true } });
  };

  const handleSaveTranslations = () => {
    if (!selectedLocale) return;
    saveTranslationsMutation.mutate({
      locale: selectedLocale,
      content: translationContent,
    });
  };

  const activeLanguages = useMemo(
    () => languages.filter((l) => l.isActive),
    [languages]
  );

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Languages size={28} /> Manage Languages
        </h1>
        <button
          onClick={() => {
            setEditingLanguage(null);
            setIsModalOpen(true);
          }}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} /> New Language
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto mb-8">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Language</th>
              <th className="p-4">Code</th>
              <th className="p-4">Status</th>
              <th className="p-4">Default</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {isLoadingLanguages ? (
              <tr>
                <td colSpan={5} className="p-8 text-center text-brand-muted">
                  Loading languages...
                </td>
              </tr>
            ) : (
              languages.map((lang) => (
                <tr key={lang._id} className="border-t border-gray-700/50">
                  <td className="p-4 font-medium">{lang.name}</td>
                  <td className="p-4 text-brand-muted">{lang.code}</td>
                  <td className="p-4">
                    <span
                      className={`px-2 py-1 text-xs font-semibold rounded-full ${
                        lang.isActive
                          ? "bg-green-500/20 text-green-400"
                          : "bg-red-500/20 text-red-400"
                      }`}
                    >
                      {lang.isActive ? "Active" : "Inactive"}
                    </span>
                  </td>
                  <td className="p-4">
                    {lang.isDefault ? (
                      <span className="font-bold text-green-400">Yes</span>
                    ) : (
                      <button
                        onClick={() => handleSetDefault(lang._id)}
                        className="text-xs text-brand-muted hover:text-white"
                        disabled={updateLanguageMutation.isPending}
                      >
                        Set
                      </button>
                    )}
                  </td>
                  <td className="p-4 flex gap-3 items-center h-full">
                    <button
                      onClick={() => handleOpenEditModal(lang)}
                      className="text-blue-400 hover:text-blue-300"
                      title="Edit"
                    >
                      <Edit size={18} />
                    </button>
                    <button
                      onClick={() => handleDelete(lang)}
                      className="text-red-400 hover:text-red-300"
                      title="Delete"
                      disabled={lang.isDefault}
                    >
                      <Trash2 size={18} />
                    </button>
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>

      <div className="bg-brand-secondary rounded-lg p-6">
        <h2 className="text-2xl font-bold text-white mb-4 flex items-center gap-2">
          <FileJson size={24} /> Translation Editor
        </h2>
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div>
            <label className="block text-sm font-medium text-brand-light mb-2">
              1. Select a language to edit
            </label>
            <select
              value={selectedLocale}
              onChange={(e) => setSelectedLocale(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            >
              <option value="">-- Select --</option>
              {activeLanguages.map((l) => (
                <option key={l._id} value={l.code}>
                  {l.name} ({l.code})
                </option>
              ))}
            </select>
            <div className="mt-4">
              <label className="block text-sm font-medium text-brand-light mb-2">
                2. Edit JSON content
              </label>
              <textarea
                value={translationContent}
                onChange={(e) => setTranslationContent(e.target.value)}
                className="w-full h-96 p-3 font-mono text-sm rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
                disabled={!selectedLocale || isFetchingFile}
                placeholder={
                  isFetchingFile
                    ? "Loading..."
                    : "Select a language to load translations."
                }
              />
            </div>
            <button
              onClick={handleSaveTranslations}
              className="mt-4 flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
              disabled={!selectedLocale || saveTranslationsMutation.isPending}
            >
              {saveTranslationsMutation.isPending ? (
                <Loader2 className="animate-spin" size={18} />
              ) : (
                <Save size={18} />
              )}
              Save "{selectedLocale}" Translations
            </button>
          </div>
          <div>
            <label className="block text-sm font-medium text-brand-light mb-2">
              Default Keys Reference (Turkish - read-only)
            </label>
            <textarea
              value={defaultLanguageFileContent || ""}
              readOnly
              className="w-full h-[540px] p-3 font-mono text-sm rounded bg-gray-800/50 text-brand-muted border border-gray-700 resize-none"
              placeholder={
                isLoadingDefaultFile
                  ? "Loading default keys..."
                  : "Default keys could not be loaded."
              }
            />
          </div>
        </div>
      </div>

      <LanguageFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        language={editingLanguage}
        onSave={() =>
          queryClient.invalidateQueries({ queryKey: ["languages"] })
        }
      />
    </div>
  );
}

// ===== src/app/admin/layout.tsx =====

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { redirect } from "next/navigation";
import AdminSidebar from "@/components/admin/AdminSidebar";
import NextAuthProvider from "../NextAuthProvider";
import Providers from "../providers";
import "../globals.css";

export const dynamic = "force-dynamic";

export const metadata = {
  title: "FanSkor Admin Panel",
  description: "Management dashboard for FanSkor.",
  robots: {
    index: false,
    follow: false,
  },
};

export default async function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await getServerSession(authOptions);

  if (!session || session.user.role !== "admin") {
    redirect("/login?error=Forbidden");
  }

  return (
    <NextAuthProvider>
      <Providers>
        <div className="flex min-h-screen bg-brand-dark">
          <AdminSidebar />
          <main className="flex-1 p-8">{children}</main>
        </div>
      </Providers>
    </NextAuthProvider>
  );
}

// ===== src/app/admin/leagues/page.tsx =====

"use client";

import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import Image from "next/image";
import { DownloadCloud, Loader2, Database, Clock, Search } from "lucide-react";
import AdminPagination from "@/components/admin/AdminPagination";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useDebounce } from "@/hooks/useDebounce";

interface ILeague {
  _id: string;
  leagueId: number;
  name: string;
  type: string;
  logoUrl: string;
  countryName: string;
  countryFlagUrl: string | null;
}

interface LeaguesResponse {
  leagues: ILeague[];
  pagination: {
    currentPage: number;
    totalPages: number;
    totalCount: number;
  };
}

const fetchLeagues = async (
  page: number,
  searchQuery: string
): Promise<LeaguesResponse> => {
  const params = new URLSearchParams({
    page: page.toString(),
    limit: "20",
    search: searchQuery,
  });
  const { data } = await axios.get(`/api/admin/leagues?${params.toString()}`);
  return data;
};

const fetchAndStoreLeagues = async (): Promise<{ count: number }> => {
  const { data } = await axios.post("/api/admin/leagues/sync");
  return data;
};

const getLeaguesMetadata = async (): Promise<{
  count: number;
  lastUpdated: string | null;
}> => {
  const { data } = await axios.get("/api/admin/leagues/metadata");
  return data;
};

export default function AdminLeaguesPage() {
  const queryClient = useQueryClient();
  const [currentPage, setCurrentPage] = useState(1);
  const [searchTerm, setSearchTerm] = useState("");
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  const { data: leaguesData, isLoading: isLoadingLeagues } =
    useQuery<LeaguesResponse>({
      queryKey: ["adminLeagues", currentPage, debouncedSearchTerm],
      queryFn: () => fetchLeagues(currentPage, debouncedSearchTerm),
      placeholderData: (previousData) => previousData,
    });

  const {
    data: metadata,
    isLoading: isLoadingMetadata,
    refetch: refetchMetadata,
  } = useQuery({
    queryKey: ["leaguesAdminMetadata"],
    queryFn: getLeaguesMetadata,
  });

  const syncMutation = useMutation({
    mutationFn: fetchAndStoreLeagues,
    onSuccess: (data) => {
      toast.success(`Successfully fetched and stored ${data.count} leagues!`);
      refetchMetadata();
      queryClient.invalidateQueries({ queryKey: ["adminLeagues"] });
    },
    onError: (error: any) => {
      toast.error(
        error.response?.data?.error ||
          "An unexpected error occurred during sync."
      );
    },
  });

  const handleSync = () => {
    if (
      window.confirm(
        "This will update all leagues from the external API. This can take a minute. Are you sure?"
      )
    ) {
      syncMutation.mutate();
    }
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Database size={28} /> Manage Leagues Database
        </h1>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg shadow-xl mb-8 space-y-6">
        <div>
          <h2 className="text-xl font-bold text-white mb-2">
            Sync with External API
          </h2>
          <p className="text-brand-muted text-sm mb-4">
            Click this button to fetch all leagues from the API and update your
            local database.
          </p>
          <button
            onClick={handleSync}
            disabled={syncMutation.isPending}
            className="inline-flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-wait"
          >
            {syncMutation.isPending ? (
              <Loader2 size={20} className="animate-spin" />
            ) : (
              <DownloadCloud size={20} />
            )}
            <span>
              {syncMutation.isPending ? "Syncing..." : "Sync All Leagues"}
            </span>
          </button>
        </div>

        <div className="pt-6 border-t border-gray-700/50">
          <h2 className="text-xl font-bold text-white mb-2">Database Status</h2>
          {isLoadingMetadata ? (
            <div className="h-8 w-2/3 bg-gray-700 rounded-md animate-pulse"></div>
          ) : (
            <div className="flex items-center gap-6 text-brand-light">
              <div className="flex items-center gap-2">
                <Database size={18} />
                <span className="font-semibold">Total:</span>
                <span className="font-bold text-white text-lg">
                  {metadata?.count ?? 0}
                </span>
              </div>
              <div className="flex items-center gap-2">
                <Clock size={18} />
                <span className="font-semibold">Last Updated:</span>
                <span className="font-bold text-white text-lg">
                  {metadata?.lastUpdated
                    ? new Date(metadata.lastUpdated).toLocaleString()
                    : "Never"}
                </span>
              </div>
            </div>
          )}
        </div>
      </div>

      <div className="bg-brand-secondary rounded-lg shadow-xl">
        <div className="p-4 border-b border-gray-700/50">
          <div className="relative">
            <Search
              className="absolute left-3 top-1/2 -translate-y-1/2 text-brand-muted"
              size={20}
            />
            <input
              type="text"
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              placeholder="Search by league or country name..."
              className="w-full bg-gray-800 border border-gray-600 rounded-lg p-2 pl-10 text-white placeholder:text-brand-muted focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
          </div>
        </div>
        <div className="overflow-x-auto">
          <table className="w-full text-left text-brand-light">
            <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
              <tr>
                <th className="p-4">League</th>
                <th className="p-4">Country</th>
                <th className="p-4">Type</th>
                <th className="p-4 text-center">API ID</th>
              </tr>
            </thead>
            <tbody>
              {isLoadingLeagues
                ? Array.from({ length: 10 }).map((_, i) => (
                    <tr key={i} className="border-t border-gray-700/50">
                      <td colSpan={4} className="p-4 h-12 animate-pulse">
                        <div className="h-5 bg-gray-700 rounded"></div>
                      </td>
                    </tr>
                  ))
                : leaguesData?.leagues.map((league) => (
                    <tr
                      key={league._id}
                      className="border-t border-gray-700/50"
                    >
                      <td className="p-4 font-medium flex items-center gap-3">
                        <Image
                          src={proxyImageUrl(league.logoUrl)}
                          alt={league.name}
                          width={28}
                          height={28}
                          className="bg-white rounded-full p-0.5"
                        />
                        <span>{league.name}</span>
                      </td>
                      <td className="p-4 text-brand-muted flex items-center gap-2">
                        {league.countryFlagUrl && (
                          <Image
                            src={proxyImageUrl(league.countryFlagUrl)}
                            alt={league.countryName}
                            width={20}
                            height={15}
                          />
                        )}
                        <span>{league.countryName}</span>
                      </td>
                      <td className="p-4 text-brand-muted">{league.type}</td>
                      <td className="p-4 text-brand-muted text-center font-mono">
                        {league.leagueId}
                      </td>
                    </tr>
                  ))}
            </tbody>
          </table>
        </div>
        {leaguesData && leaguesData.pagination.totalPages > 1 && (
          <div className="p-4 border-t border-gray-700/50">
            <AdminPagination
              currentPage={currentPage}
              totalPages={leaguesData.pagination.totalPages}
              onPageChange={setCurrentPage}
            />
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/app/admin/login/LoginForm.tsx =====

"use client";

import { useState } from "react";
import { signIn } from "next-auth/react";
import { useRouter, useSearchParams } from "next/navigation";

export default function LoginForm() {
  const router = useRouter();
  const searchParams = useSearchParams();

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState(() => {
    const err = searchParams.get("error");
    if (err === "Forbidden") {
      return "Access Denied. You must be an administrator.";
    }
    return err || "";
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    const result = await signIn("credentials", {
      redirect: false,
      email,
      password,
    });

    if (result?.error) {
      setError("Invalid credentials. Please try again.");
    } else if (result?.ok) {
      const callbackUrl = searchParams.get("callbackUrl") || "/admin/dashboard";
      router.push(callbackUrl);
    }
  };

  return (
    <form
      onSubmit={handleSubmit}
      className="p-8 rounded-lg shadow-lg bg-brand-secondary w-full max-w-sm"
    >
      <h1 className="text-2xl font-bold mb-6 text-center text-white">
        Admin Login
      </h1>
      {error && (
        <p className="bg-red-500/20 text-red-400 p-3 rounded mb-4 text-sm">
          {error}
        </p>
      )}
      <div className="space-y-4">
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="Email"
          required
          className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 placeholder:text-brand-muted focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-brand-secondary focus:ring-brand-purple"
        />
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="Password"
          required
          className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 placeholder:text-brand-muted focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-brand-secondary focus:ring-brand-purple"
        />
      </div>
      <button
        type="submit"
        className="w-full mt-6 bg-brand-purple text-white font-bold py-3 rounded-lg hover:opacity-90 transition-opacity focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-brand-secondary focus:ring-brand-purple"
      >
        Sign In
      </button>
    </form>
  );
}

// ===== src/app/admin/login/page.tsx =====

import { Suspense } from "react";
import LoginForm from "./LoginForm";

const LoginFormSkeleton = () => (
  <div className="p-8 rounded-lg shadow-lg bg-brand-secondary w-full max-w-sm animate-pulse">
    <div className="h-8 w-3/4 mx-auto rounded-md bg-gray-700 mb-6"></div>
    <div className="space-y-4">
      <div className="h-12 w-full rounded bg-gray-700"></div>
      <div className="h-12 w-full rounded bg-gray-700"></div>
    </div>
    <div className="h-12 w-full mt-6 rounded-lg bg-brand-purple/50"></div>
  </div>
);

export default function LoginPage() {
  return (

    <div className="flex items-center justify-center min-h-screen bg-brand-dark">
      <Suspense fallback={<LoginFormSkeleton />}>
        <LoginForm />
      </Suspense>
    </div>
  );
}

// ===== src/app/admin/news/create/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { useMutation, useQuery } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import Link from "@/components/StyledLink";
import Image from "next/image";
import { UploadCloud, XCircle, Save, Loader2 } from "lucide-react";
import RichTextEditor from "@/components/admin/RichTextEditor";
import { SportsCategory, NewsType } from "@/models/Post";
import { ILanguage } from "@/models/Language";
import slugify from "slugify";

const fetchActiveLanguages = async (): Promise<ILanguage[]> => {
  const { data } = await axios.get("/api/admin/languages?active=true");
  return data;
};

const availableSportsCategories: { id: SportsCategory; label: string }[] = [
  { id: "football", label: "Football" },
  { id: "basketball", label: "Basketball" },
  { id: "tennis", label: "Tennis" },
  { id: "general", label: "General" },
];

const availableNewsTypes: { id: NewsType; label: string }[] = [
  { id: "news", label: "General News" },
  { id: "recent", label: "Recent News (AI Curated)" },
  { id: "highlights", label: "Highlights" },
  { id: "reviews", label: "Match Review" },
  { id: "prediction", label: "Prediction/Analysis" },
  { id: "transfer", label: "Transfer" },
];

export default function CreateNewsPostPage() {
  const router = useRouter();
  const searchParams = useSearchParams();

  const [language, setLanguage] = useState("");
  const [translationGroupId, setTranslationGroupId] = useState<
    string | undefined
  >(undefined);
  const [title, setTitle] = useState("");
  const [slug, setSlug] = useState("");
  const [isSlugManuallyEdited, setIsSlugManuallyEdited] = useState(false);
  const [content, setContent] = useState("");
  const [status, setStatus] = useState<"draft" | "published">("draft");
  const [metaTitle, setMetaTitle] = useState("");
  const [metaDescription, setMetaDescription] = useState("");
  const [featuredImage, setFeaturedImage] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [imageTitle, setImageTitle] = useState("");
  const [imageAltText, setImageAltText] = useState("");
  const [selectedSportsCategories, setSelectedSportsCategories] = useState<
    SportsCategory[]
  >(["general"]);
  const [newsType, setNewsType] = useState<NewsType>("news");
  const [linkedFixtureId, setLinkedFixtureId] = useState("");
  const [linkedLeagueId, setLinkedLeagueId] = useState("");
  const [linkedTeamId, setLinkedTeamId] = useState("");

  const { data: languages, isLoading: isLoadingLanguages } = useQuery<
    ILanguage[]
  >({
    queryKey: ["activeLanguages"],
    queryFn: fetchActiveLanguages,
  });

  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newTitle = e.target.value;
    setTitle(newTitle);
    if (!isSlugManuallyEdited) {
      const newSlug = slugify(newTitle, {
        lower: true,
        strict: true,
        remove: /[*+~.()'"!:@]/g,
      });
      setSlug(newSlug);

      setMetaTitle(newTitle);
    }
  };

  const handleSlugChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setIsSlugManuallyEdited(true);
    setSlug(e.target.value);
  };

  useEffect(() => {
    const fromGroupId = searchParams.get("from");
    const langCode = searchParams.get("lang");
    const fromTitle = searchParams.get("title");
    const fromImage = searchParams.get("image");
    const fromCategories = searchParams.get("categories");

    if (fromGroupId && langCode && fromTitle) {
      setTranslationGroupId(fromGroupId);
      setLanguage(langCode);
      setTitle(fromTitle);
      const newSlug = slugify(fromTitle, {
        lower: true,
        strict: true,
        remove: /[*+~.()'"!:@]/g,
      });
      setSlug(newSlug);
      setMetaTitle(fromTitle);

      if (fromImage) setFeaturedImage(fromImage);
      if (fromCategories)
        setSelectedSportsCategories(
          fromCategories.split(",") as SportsCategory[]
        );

      toast.success(`Creating new translation for "${langCode.toUpperCase()}"`);
    }
  }, [searchParams]);

  const handleSportsCategoryChange = (category: SportsCategory) => {
    setSelectedSportsCategories((prev) => {
      if (prev.includes(category)) {
        return prev.length > 1 ? prev.filter((c) => c !== category) : prev;
      }
      return [...prev, category];
    });
  };

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    setIsUploading(true);
    const formData = new FormData();
    formData.append("file", file);
    try {
      const { data } = await axios.post("/api/upload", formData);
      setFeaturedImage(data.url);
      toast.success("Image uploaded!");
    } catch (error) {
      toast.error("Image upload failed.");
    } finally {
      setIsUploading(false);
    }
  };

  const createPostMutation = useMutation({
    mutationFn: (newPost: any) => axios.post("/api/posts", newPost),
    onSuccess: () => {
      toast.success("Post created successfully!");
      router.push("/admin/news");
      router.refresh();
    },
    onError: (error: any) =>
      toast.error(error.response?.data?.error || "Failed to create post."),
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!title.trim() || !content.trim() || !language) {
      toast.error("Title, Content, and Language are required.");
      return;
    }
    createPostMutation.mutate({
      title,
      slug,
      content,
      status,
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle: imageTitle,
      featuredImageAltText: imageAltText,
      sportsCategory: selectedSportsCategories,
      newsType,
      linkedFixtureId: linkedFixtureId ? Number(linkedFixtureId) : undefined,
      linkedLeagueId: linkedLeagueId ? Number(linkedLeagueId) : undefined,
      linkedTeamId: linkedTeamId ? Number(linkedTeamId) : undefined,
      language,
      translationGroupId,
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">
          {translationGroupId ? "Create New Translation" : "Create New Post"}
        </h1>
        <div className="flex gap-4">
          <Link
            href="/admin/news"
            className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
          >
            Cancel
          </Link>
          <button
            type="submit"
            disabled={createPostMutation.isPending || isUploading}
            className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 flex items-center gap-2"
          >
            {createPostMutation.isPending ? (
              <Loader2 size={18} className="animate-spin" />
            ) : (
              <Save size={18} />
            )}
            {createPostMutation.isPending ? "Saving..." : "Save Post"}
          </button>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 items-start">
        <div className="lg:col-span-2 space-y-6">
          <div className="bg-brand-secondary p-6 rounded-lg space-y-6">
            <div>
              <label
                htmlFor="title"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                Title
              </label>
              <input
                id="title"
                type="text"
                value={title}
                onChange={handleTitleChange}
                required
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
            </div>
            <div>
              <label
                htmlFor="slug"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                URL Slug
              </label>
              <input
                id="slug"
                type="text"
                value={slug}
                onChange={handleSlugChange}
                required
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
            </div>
          </div>
          <div className="bg-brand-secondary rounded-lg">
            <div className="p-6 border-b border-gray-700 sticky top-0 bg-brand-secondary z-10">
              <label className="text-lg font-semibold text-white">
                Content
              </label>
            </div>
            <div className="p-6">
              <RichTextEditor value={content} onChange={setContent} />
            </div>
          </div>
        </div>

        <aside className="lg:col-span-1 space-y-6 lg:sticky top-8">
          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">Publishing</h3>
            <div>
              <label
                htmlFor="status"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                Status
              </label>
              <select
                id="status"
                value={status}
                onChange={(e) =>
                  setStatus(e.target.value as "draft" | "published")
                }
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              >
                <option value="draft">Draft</option>
                <option value="published">Published</option>
              </select>
            </div>
            <div>
              <label
                htmlFor="language"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                Language
              </label>
              <select
                id="language"
                value={language}
                onChange={(e) => setLanguage(e.target.value)}
                required
                disabled={isLoadingLanguages || !!translationGroupId}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 disabled:bg-gray-700/50 disabled:cursor-not-allowed"
              >
                <option value="" disabled>
                  {isLoadingLanguages ? "Loading..." : "Select..."}
                </option>
                {languages?.map((lang) => (
                  <option key={lang._id} value={lang.code}>
                    {lang.name}
                  </option>
                ))}
              </select>
            </div>
          </div>

          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">Categorization</h3>
            <div>
              <label className="block text-sm font-medium text-brand-light mb-2">
                Sports Categories
              </label>
              <div className="space-y-2">
                {availableSportsCategories.map((category) => (
                  <div key={category.id} className="flex items-center">
                    <input
                      id={`category-${category.id}`}
                      type="checkbox"
                      checked={selectedSportsCategories.includes(category.id)}
                      onChange={() => handleSportsCategoryChange(category.id)}
                      className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded"
                    />
                    <label
                      htmlFor={`category-${category.id}`}
                      className="ml-3 text-sm font-medium text-brand-light"
                    >
                      {category.label}
                    </label>
                  </div>
                ))}
              </div>
            </div>
            <div>
              <label
                htmlFor="newsType"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                News Type
              </label>
              <select
                id="newsType"
                value={newsType}
                onChange={(e) => setNewsType(e.target.value as NewsType)}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              >
                {availableNewsTypes.map((type) => (
                  <option key={type.id} value={type.id}>
                    {type.label}
                  </option>
                ))}
              </select>
            </div>
          </div>

          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">Featured Image</h3>
            <div className="mt-2 flex justify-center rounded-lg border border-dashed border-gray-600 px-4 py-6">
              {featuredImage ? (
                <div className="relative group w-full h-32">
                  <Image
                    src={featuredImage}
                    alt="Featured preview"
                    layout="fill"
                    objectFit="contain"
                  />
                  <button
                    type="button"
                    onClick={() => setFeaturedImage(null)}
                    className="absolute top-1 right-1 bg-red-600 rounded-full p-0.5 text-white opacity-0 group-hover:opacity-100"
                  >
                    <XCircle size={16} />
                  </button>
                </div>
              ) : (
                <div className="text-center">
                  <UploadCloud className="mx-auto h-10 w-10 text-gray-500" />
                  <div className="mt-2 flex text-sm text-gray-400">
                    <label
                      htmlFor="file-upload"
                      className="relative cursor-pointer rounded-md font-semibold text-brand-purple hover:text-brand-purple/80"
                    >
                      <span>{isUploading ? "Uploading..." : "Upload"}</span>
                      <input
                        id="file-upload"
                        name="file-upload"
                        type="file"
                        className="sr-only"
                        onChange={handleImageUpload}
                        disabled={isUploading}
                        accept="image/*"
                      />
                    </label>
                    <p className="pl-1">or drag and drop</p>
                  </div>
                  <p className="text-xs text-gray-500">
                    PNG, JPG, WEBP up to 5MB
                  </p>
                </div>
              )}
            </div>
            <div>
              <label
                htmlFor="imageTitle"
                className="block text-sm font-medium text-brand-light mb-1"
              >
                Image Title
              </label>
              <input
                id="imageTitle"
                type="text"
                value={imageTitle}
                onChange={(e) => setImageTitle(e.target.value)}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              />
            </div>
            <div>
              <label
                htmlFor="imageAltText"
                className="block text-sm font-medium text-brand-light mb-1"
              >
                Image Alt Text
              </label>
              <input
                id="imageAltText"
                type="text"
                value={imageAltText}
                onChange={(e) => setImageAltText(e.target.value)}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              />
            </div>
          </div>

          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">SEO & Linking</h3>
            <div>
              <label
                htmlFor="metaTitle"
                className="block text-sm font-medium text-brand-light mb-1"
              >
                Meta Title
              </label>
              <input
                id="metaTitle"
                type="text"
                value={metaTitle}
                onChange={(e) => setMetaTitle(e.target.value)}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              />
            </div>
            <div>
              <label
                htmlFor="metaDescription"
                className="block text-sm font-medium text-brand-light mb-1"
              >
                Meta Description
              </label>
              <textarea
                id="metaDescription"
                value={metaDescription}
                onChange={(e) => setMetaDescription(e.target.value)}
                rows={3}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              ></textarea>
            </div>
            <div className="grid grid-cols-1 gap-2 pt-2 border-t border-gray-700/50">
              <div>
                <label
                  htmlFor="linkedFixtureId"
                  className="block text-xs font-medium text-brand-light mb-1"
                >
                  Linked Fixture ID
                </label>
                <input
                  id="linkedFixtureId"
                  type="number"
                  value={linkedFixtureId}
                  onChange={(e) => setLinkedFixtureId(e.target.value)}
                  className="w-full p-2 text-sm rounded bg-gray-700 text-white border border-gray-600"
                />
              </div>
              <div>
                <label
                  htmlFor="linkedLeagueId"
                  className="block text-xs font-medium text-brand-light mb-1"
                >
                  Linked League ID
                </label>
                <input
                  id="linkedLeagueId"
                  type="number"
                  value={linkedLeagueId}
                  onChange={(e) => setLinkedLeagueId(e.target.value)}
                  className="w-full p-2 text-sm rounded bg-gray-700 text-white border border-gray-600"
                />
              </div>
              <div>
                <label
                  htmlFor="linkedTeamId"
                  className="block text-xs font-medium text-brand-light mb-1"
                >
                  Linked Team ID
                </label>
                <input
                  id="linkedTeamId"
                  type="number"
                  value={linkedTeamId}
                  onChange={(e) => setLinkedTeamId(e.target.value)}
                  className="w-full p-2 text-sm rounded bg-gray-700 text-white border border-gray-600"
                />
              </div>
            </div>
          </div>
        </aside>
      </div>
    </form>
  );
}

// ===== src/app/admin/news/edit/[postId]/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useRouter, useParams } from "next/navigation";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import Image from "next/image";
import slugify from "slugify";

import StyledLink from "@/components/StyledLink";
import RichTextEditor from "@/components/admin/RichTextEditor";
import TranslationsWidget from "@/components/admin/TranslationsWidget";

import { UploadCloud, XCircle, Save, Loader2 } from "lucide-react";

import { IPost, SportsCategory, NewsType } from "@/models/Post";

const availableSportsCategories: { id: SportsCategory; label: string }[] = [
  { id: "football", label: "Football" },
  { id: "basketball", label: "Basketball" },
  { id: "tennis", label: "Tennis" },
  { id: "general", label: "General" },
];

const availableNewsTypes: { id: NewsType; label: string }[] = [
  { id: "news", label: "General News" },
  { id: "recent", label: "Recent News (AI Curated)" },
  { id: "highlights", label: "Highlights" },
  { id: "reviews", label: "Match Review" },
  { id: "prediction", label: "Prediction/Analysis" },
  { id: "transfer", label: "Transfer" },
];

const fetchPost = async (postId: string): Promise<IPost> => {
  const { data } = await axios.get(`/api/posts/${postId}`);
  return data;
};

export default function EditNewsPostPage() {
  const router = useRouter();
  const params = useParams();
  const queryClient = useQueryClient();
  const postId = params.postId as string;

  const [title, setTitle] = useState("");
  const [slug, setSlug] = useState("");
  const [isSlugManuallyEdited, setIsSlugManuallyEdited] = useState(true);
  const [content, setContent] = useState("");
  const [status, setStatus] = useState<"draft" | "published">("draft");
  const [metaTitle, setMetaTitle] = useState("");
  const [metaDescription, setMetaDescription] = useState("");
  const [featuredImage, setFeaturedImage] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [imageTitle, setImageTitle] = useState("");
  const [imageAltText, setImageAltText] = useState("");
  const [selectedSportsCategories, setSelectedSportsCategories] = useState<
    SportsCategory[]
  >([]);
  const [newsType, setNewsType] = useState<NewsType>("news");
  const [linkedFixtureId, setLinkedFixtureId] = useState("");
  const [linkedLeagueId, setLinkedLeagueId] = useState("");
  const [linkedTeamId, setLinkedTeamId] = useState("");
  const [language, setLanguage] = useState("");
  const [translationGroupId, setTranslationGroupId] = useState("");

  const {
    data: postData,
    isLoading,
    isError,
  } = useQuery<IPost>({
    queryKey: ["post", postId],
    queryFn: () => fetchPost(postId),
    enabled: !!postId,
  });

  useEffect(() => {
    if (postData) {
      setTitle(postData.title || "");
      setSlug(postData.slug || "");
      setContent(postData.content || "");
      setStatus(postData.status || "draft");
      setMetaTitle(postData.metaTitle || "");
      setMetaDescription(postData.metaDescription || "");
      setFeaturedImage(postData.featuredImage || null);
      setImageTitle(postData.featuredImageTitle || "");
      setImageAltText(postData.featuredImageAltText || "");
      setSelectedSportsCategories(
        Array.isArray(postData.sportsCategory) &&
          postData.sportsCategory.length > 0
          ? postData.sportsCategory
          : ["general"]
      );
      setNewsType(postData.newsType || "news");
      setLinkedFixtureId(postData.linkedFixtureId?.toString() || "");
      setLinkedLeagueId(postData.linkedLeagueId?.toString() || "");
      setLinkedTeamId(postData.linkedTeamId?.toString() || "");
      setLanguage(postData.language || "");
      setTranslationGroupId(postData.translationGroupId?.toString() || "");
      setIsSlugManuallyEdited(true);
    }
  }, [postData]);

  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newTitle = e.target.value;
    setTitle(newTitle);
    if (!isSlugManuallyEdited) {
      setSlug(
        slugify(newTitle, {
          lower: true,
          strict: true,
          remove: /[*+~.()'"!:@]/g,
        })
      );
    }
  };

  const handleSlugChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setIsSlugManuallyEdited(true);
    setSlug(e.target.value);
  };

  const handleSportsCategoryChange = (category: SportsCategory) => {
    setSelectedSportsCategories((prev) => {
      if (prev.includes(category)) {
        return prev.length > 1 ? prev.filter((c) => c !== category) : prev;
      }
      return [...prev, category];
    });
  };

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    setIsUploading(true);
    const formData = new FormData();
    formData.append("file", file);
    try {
      const { data } = await axios.post("/api/upload", formData);
      setFeaturedImage(data.url);
      toast.success("Image uploaded!");
    } catch (error) {
      toast.error("Image upload failed.");
    } finally {
      setIsUploading(false);
    }
  };

  const updatePostMutation = useMutation({
    mutationFn: (updatedPost: Partial<IPost> & { slug?: string }) =>
      axios.put(`/api/posts/${postId}`, updatedPost),
    onSuccess: () => {
      toast.success("Post updated successfully!");
      queryClient.invalidateQueries({ queryKey: ["adminPosts"] });
      queryClient.invalidateQueries({ queryKey: ["post", postId] });
      router.push("/admin/news");
    },
    onError: (error: any) => {
      if (error.response && error.response.data && error.response.data.error) {
        toast.error(`Error: ${error.response.data.error}`);
      } else {
        toast.error("An unexpected error occurred while saving the post.");
      }
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!title.trim() || !content.trim()) {
      toast.error("Title and content cannot be empty.");
      return;
    }
    updatePostMutation.mutate({
      title,
      slug,
      content,
      status,
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle: imageTitle,
      featuredImageAltText: imageAltText,
      sportsCategory: selectedSportsCategories,
      newsType,
      linkedFixtureId: linkedFixtureId ? Number(linkedFixtureId) : undefined,
      linkedLeagueId: linkedLeagueId ? Number(linkedLeagueId) : undefined,
      linkedTeamId: linkedTeamId ? Number(linkedTeamId) : undefined,
    });
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading post data...</p>;
  if (isError) return <p className="text-red-400">Failed to load post data.</p>;

  return (
    <form onSubmit={handleSubmit}>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Edit Post</h1>
        <div className="flex gap-4">
          <StyledLink
            href="/admin/news"
            className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
          >
            Cancel
          </StyledLink>
          <button
            type="submit"
            disabled={updatePostMutation.isPending || isUploading}
            className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 flex items-center gap-2"
          >
            {updatePostMutation.isPending ? (
              <Loader2 size={18} className="animate-spin" />
            ) : (
              <Save size={18} />
            )}
            {updatePostMutation.isPending ? "Saving..." : "Save Changes"}
          </button>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 items-start">
        <div className="lg:col-span-2 space-y-6">
          <div className="bg-brand-secondary p-6 rounded-lg space-y-6">
            <div>
              <label
                htmlFor="title"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                Title
              </label>
              <input
                id="title"
                type="text"
                value={title}
                onChange={handleTitleChange}
                required
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
            </div>
            <div>
              <label
                htmlFor="slug"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                URL Slug
              </label>
              <input
                id="slug"
                type="text"
                value={slug}
                onChange={handleSlugChange}
                required
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
            </div>
          </div>
          <div className="bg-brand-secondary rounded-lg">
            <div className="p-6 border-b border-gray-700 sticky top-0 bg-brand-secondary z-10">
              <label className="text-lg font-semibold text-white">
                Content
              </label>
            </div>
            <div className="p-6">
              {postData && (
                <RichTextEditor value={content} onChange={setContent} />
              )}
            </div>
          </div>
        </div>

        <aside className="lg:col-span-1 space-y-6 lg:sticky top-8">
          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">Publishing</h3>
            <div>
              <label
                htmlFor="status"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                Status
              </label>
              <select
                id="status"
                value={status}
                onChange={(e) =>
                  setStatus(e.target.value as "draft" | "published")
                }
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              >
                <option value="draft">Draft</option>
                <option value="published">Published</option>
              </select>
            </div>
            <div>
              <label className="block text-sm font-medium text-brand-light mb-2">
                Language
              </label>
              <input
                type="text"
                value={language.toUpperCase()}
                readOnly
                disabled
                className="w-full p-2 rounded bg-gray-700/50 text-brand-muted border border-gray-600 cursor-not-allowed"
              />
            </div>
          </div>

          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">Categorization</h3>
            <div>
              <label className="block text-sm font-medium text-brand-light mb-2">
                Sports Categories
              </label>
              <div className="space-y-2">
                {availableSportsCategories.map((category) => (
                  <div key={category.id} className="flex items-center">
                    <input
                      id={`category-${category.id}`}
                      type="checkbox"
                      checked={selectedSportsCategories.includes(category.id)}
                      onChange={() => handleSportsCategoryChange(category.id)}
                      className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded"
                    />
                    <label
                      htmlFor={`category-${category.id}`}
                      className="ml-3 text-sm font-medium text-brand-light"
                    >
                      {category.label}
                    </label>
                  </div>
                ))}
              </div>
            </div>
            <div>
              <label
                htmlFor="newsType"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                News Type
              </label>
              <select
                id="newsType"
                value={newsType}
                onChange={(e) => setNewsType(e.target.value as NewsType)}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              >
                {availableNewsTypes.map((type) => (
                  <option key={type.id} value={type.id}>
                    {type.label}
                  </option>
                ))}
              </select>
            </div>
          </div>

          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">Featured Image</h3>
            <div className="mt-2 flex justify-center rounded-lg border border-dashed border-gray-600 px-4 py-6">
              {featuredImage ? (
                <div className="relative group w-full h-32">
                  <Image
                    src={featuredImage}
                    alt="Featured preview"
                    layout="fill"
                    objectFit="contain"
                  />
                  <button
                    type="button"
                    onClick={() => setFeaturedImage(null)}
                    className="absolute top-1 right-1 bg-red-600 rounded-full p-0.5 text-white opacity-0 group-hover:opacity-100"
                  >
                    <XCircle size={16} />
                  </button>
                </div>
              ) : (
                <div className="text-center">
                  <UploadCloud className="mx-auto h-10 w-10 text-gray-500" />
                  <div className="mt-2 flex text-sm text-gray-400">
                    <label
                      htmlFor="file-upload"
                      className="relative cursor-pointer rounded-md font-semibold text-brand-purple hover:text-brand-purple/80"
                    >
                      <span>{isUploading ? "Uploading..." : "Upload"}</span>
                      <input
                        id="file-upload"
                        name="file-upload"
                        type="file"
                        className="sr-only"
                        onChange={handleImageUpload}
                        disabled={isUploading}
                        accept="image/*"
                      />
                    </label>
                    <p className="pl-1">or drag and drop</p>
                  </div>
                  <p className="text-xs text-gray-500">
                    PNG, JPG, WEBP up to 5MB
                  </p>
                </div>
              )}
            </div>
            <div>
              <label
                htmlFor="imageTitle"
                className="block text-sm font-medium text-brand-light mb-1"
              >
                Image Title
              </label>
              <input
                id="imageTitle"
                type="text"
                value={imageTitle}
                onChange={(e) => setImageTitle(e.target.value)}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              />
            </div>
            <div>
              <label
                htmlFor="imageAltText"
                className="block text-sm font-medium text-brand-light mb-1"
              >
                Image Alt Text
              </label>
              <input
                id="imageAltText"
                type="text"
                value={imageAltText}
                onChange={(e) => setImageAltText(e.target.value)}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              />
            </div>
          </div>

          <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
            <h3 className="text-lg font-semibold text-white">SEO & Linking</h3>
            <div>
              <label
                htmlFor="metaTitle"
                className="block text-sm font-medium text-brand-light mb-1"
              >
                Meta Title
              </label>
              <input
                id="metaTitle"
                type="text"
                value={metaTitle}
                onChange={(e) => setMetaTitle(e.target.value)}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              />
            </div>
            <div>
              <label
                htmlFor="metaDescription"
                className="block text-sm font-medium text-brand-light mb-1"
              >
                Meta Description
              </label>
              <textarea
                id="metaDescription"
                value={metaDescription}
                onChange={(e) => setMetaDescription(e.target.value)}
                rows={3}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
              ></textarea>
            </div>
            <div className="grid grid-cols-1 gap-2 pt-2 border-t border-gray-700/50">
              <div>
                <label
                  htmlFor="linkedFixtureId"
                  className="block text-xs font-medium text-brand-light mb-1"
                >
                  Linked Fixture ID
                </label>
                <input
                  id="linkedFixtureId"
                  type="number"
                  value={linkedFixtureId}
                  onChange={(e) => setLinkedFixtureId(e.target.value)}
                  className="w-full p-2 text-sm rounded bg-gray-700 text-white border border-gray-600"
                />
              </div>
              <div>
                <label
                  htmlFor="linkedLeagueId"
                  className="block text-xs font-medium text-brand-light mb-1"
                >
                  Linked League ID
                </label>
                <input
                  id="linkedLeagueId"
                  type="number"
                  value={linkedLeagueId}
                  onChange={(e) => setLinkedLeagueId(e.target.value)}
                  className="w-full p-2 text-sm rounded bg-gray-700 text-white border border-gray-600"
                />
              </div>
              <div>
                <label
                  htmlFor="linkedTeamId"
                  className="block text-xs font-medium text-brand-light mb-1"
                >
                  Linked Team ID
                </label>
                <input
                  id="linkedTeamId"
                  type="number"
                  value={linkedTeamId}
                  onChange={(e) => setLinkedTeamId(e.target.value)}
                  className="w-full p-2 text-sm rounded bg-gray-700 text-white border border-gray-600"
                />
              </div>
            </div>
          </div>

          {translationGroupId && (
            <TranslationsWidget
              translationGroupId={translationGroupId}
              currentPostLanguage={language}
              currentPostTitle={title}
            />
          )}
        </aside>
      </div>
    </form>
  );
}

// ===== src/app/admin/news/page.tsx =====

"use client";

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import Link from "@/components/StyledLink";
import { PlusCircle } from "lucide-react";
import { IPost } from "@/models/Post";
import toast from "react-hot-toast";
import { useMemo } from "react";
import { ILanguage } from "@/models/Language";
import TranslationGroupRow from "@/components/admin/TranslationGroupRow";

const fetchAdminPosts = async (): Promise<IPost[]> => {
  const { data } = await axios.get("/api/admin/posts");
  return data;
};

const fetchLanguages = async (): Promise<ILanguage[]> => {
  const { data } = await axios.get("/api/admin/languages");
  return data;
};

export default function AdminNewsPage() {
  const queryClient = useQueryClient();

  const {
    data: posts,
    isLoading: isLoadingPosts,
    error: postsError,
  } = useQuery<IPost[]>({
    queryKey: ["adminPosts"],
    queryFn: fetchAdminPosts,
  });

  const { data: languages, isLoading: isLoadingLanguages } = useQuery<
    ILanguage[]
  >({
    queryKey: ["allLanguages"],
    queryFn: fetchLanguages,
  });

  const languageMap = useMemo(() => {
    if (!languages) return new Map<string, ILanguage>();
    return new Map(languages.map((lang) => [lang.code, lang]));
  }, [languages]);

  const groupedPosts = useMemo(() => {
    if (!posts) return [];
    const groups: Record<string, IPost[]> = {};
    posts.forEach((post) => {
      const groupId = (post.translationGroupId || post._id).toString();
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      groups[groupId].push(post);
    });

    return Object.values(groups).sort((a, b) => {
      const dateA = new Date(
        a.sort(
          (x, y) =>
            new Date(y.createdAt).getTime() - new Date(x.createdAt).getTime()
        )[0].createdAt
      ).getTime();
      const dateB = new Date(
        b.sort(
          (x, y) =>
            new Date(y.createdAt).getTime() - new Date(x.createdAt).getTime()
        )[0].createdAt
      ).getTime();
      return dateB - dateA;
    });
  }, [posts]);

  const deleteMutation = useMutation({
    mutationFn: (postId: string) => axios.delete(`/api/posts/${postId}`),
    onSuccess: (_, postId) => {

      queryClient.setQueryData(["adminPosts"], (oldData: IPost[] | undefined) =>
        oldData ? oldData.filter((post) => post._id !== postId) : []
      );
      toast.success("Post deleted successfully!");
    },
    onError: (error: any) => {
      const message = error.response?.data?.message || "Error deleting post.";
      toast.error(message);
    },
    onSettled: () => {

      queryClient.invalidateQueries({ queryKey: ["adminPosts"] });
    },
  });

  const handleDeletePost = (postId: string, title: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete the post "${title}"? This cannot be undone.`
      )
    ) {
      deleteMutation.mutate(postId);
    }
  };

  const isLoading = isLoadingPosts || isLoadingLanguages;

  if (isLoading) return <p className="text-brand-muted">Loading posts...</p>;
  if (postsError) return <p className="text-red-400">Failed to load posts.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Manage News</h1>
        <Link
          href="/admin/news/create"
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 transition-opacity"
        >
          <PlusCircle size={20} />
          <span>New Post</span>
        </Link>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-hidden">
        <table className="w-full text-left">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4 w-[140px]">Preview</th>
              <th className="p-4">Title & Language</th>
              <th className="p-4">Status</th>
              <th className="p-4">Created At</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {groupedPosts.map((group) => (
              <TranslationGroupRow
                key={
                  group[0].translationGroupId?.toString() ||
                  group[0]._id.toString()
                }
                group={group}
                languageMap={languageMap}
                onDelete={handleDeletePost}
              />
            ))}
          </tbody>
        </table>

        {posts?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No news posts found.
          </p>
        )}
      </div>
    </div>
  );
}

// ===== src/app/admin/pages/author/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { Loader2, Save, UserCircle } from "lucide-react";
import RichTextEditor from "@/components/admin/RichTextEditor";

const PAGE_SLUG = "author";

interface PageContentData {
  title: string;
  content: string;
}

const fetchPageContent = async (slug: string): Promise<PageContentData> => {
  const { data } = await axios.get(`/api/admin/pages/${slug}`);
  return data;
};

export default function EditAuthorPage() {
  const queryClient = useQueryClient();
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");

  const { data, isLoading, error } = useQuery<PageContentData>({
    queryKey: ["pageContent", PAGE_SLUG],
    queryFn: () => fetchPageContent(PAGE_SLUG),
  });

  useEffect(() => {
    if (data) {
      setTitle(data.title || "About the Author");
      setContent(data.content || "");
    }
  }, [data]);

  const mutation = useMutation({
    mutationFn: (pageData: PageContentData) =>
      axios.post(`/api/admin/pages/${PAGE_SLUG}`, pageData),
    onSuccess: () => {
      toast.success("Author page content saved successfully!");
      queryClient.invalidateQueries({ queryKey: ["pageContent", PAGE_SLUG] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to save content.");
    },
  });

  const handleSave = () => {
    if (!title.trim() || !content.trim()) {
      toast.error("Title and Content cannot be empty.");
      return;
    }
    mutation.mutate({ title, content });
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading page content...</p>;
  if (error) return <p className="text-red-400">Failed to load content.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <UserCircle size={28} /> Edit 'Author' Page
        </h1>
        <button
          onClick={handleSave}
          disabled={mutation.isPending}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
        >
          {mutation.isPending ? (
            <Loader2 size={20} className="animate-spin" />
          ) : (
            <Save size={20} />
          )}
          <span>{mutation.isPending ? "Saving..." : "Save Changes"}</span>
        </button>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg space-y-6">
        <div>
          <label
            htmlFor="pageTitle"
            className="block text-sm font-medium text-brand-light mb-2"
          >
            Page Title
          </label>
          <input
            id="pageTitle"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">
            Page Content
          </label>
          {data && <RichTextEditor value={content} onChange={setContent} />}
        </div>
      </div>
    </div>
  );
}

// ===== src/app/admin/pages/gdpr/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { Loader2, Save, DatabaseZap } from "lucide-react";
import RichTextEditor from "@/components/admin/RichTextEditor";

const PAGE_SLUG = "gdpr";

interface PageContentData {
  title: string;
  content: string;
}

const fetchPageContent = async (slug: string): Promise<PageContentData> => {
  const { data } = await axios.get(`/api/admin/pages/${slug}`);
  return data;
};

export default function EditGdprPage() {
  const queryClient = useQueryClient();
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");

  const { data, isLoading, error } = useQuery<PageContentData>({
    queryKey: ["pageContent", PAGE_SLUG],
    queryFn: () => fetchPageContent(PAGE_SLUG),
  });

  useEffect(() => {
    if (data) {
      setTitle(data.title || "GDPR & Data Protection");
      setContent(data.content || "");
    }
  }, [data]);

  const mutation = useMutation({
    mutationFn: (pageData: PageContentData) =>
      axios.post(`/api/admin/pages/${PAGE_SLUG}`, pageData),
    onSuccess: () => {
      toast.success("GDPR page content saved successfully!");
      queryClient.invalidateQueries({ queryKey: ["pageContent", PAGE_SLUG] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to save content.");
    },
  });

  const handleSave = () => {
    if (!title.trim() || !content.trim()) {
      toast.error("Title and Content cannot be empty.");
      return;
    }
    mutation.mutate({ title, content });
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading page content...</p>;
  if (error) return <p className="text-red-400">Failed to load content.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <DatabaseZap size={28} /> Edit 'GDPR' Page
        </h1>
        <button
          onClick={handleSave}
          disabled={mutation.isPending}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
        >
          {mutation.isPending ? (
            <Loader2 size={20} className="animate-spin" />
          ) : (
            <Save size={20} />
          )}
          <span>{mutation.isPending ? "Saving..." : "Save Changes"}</span>
        </button>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg space-y-6">
        <div>
          <label
            htmlFor="pageTitle"
            className="block text-sm font-medium text-brand-light mb-2"
          >
            Page Title
          </label>
          <input
            id="pageTitle"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">
            Page Content
          </label>
          {data && <RichTextEditor value={content} onChange={setContent} />}
        </div>
      </div>
    </div>
  );
}

// ===== src/app/admin/pages/privacy-policy/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { Loader2, Save, Shield } from "lucide-react";
import RichTextEditor from "@/components/admin/RichTextEditor";

const PAGE_SLUG = "privacy-policy";

interface PageContentData {
  title: string;
  content: string;
}

const fetchPageContent = async (slug: string): Promise<PageContentData> => {
  const { data } = await axios.get(`/api/admin/pages/${slug}`);
  return data;
};

export default function EditPrivacyPolicyPage() {
  const queryClient = useQueryClient();
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");

  const { data, isLoading, error } = useQuery<PageContentData>({
    queryKey: ["pageContent", PAGE_SLUG],
    queryFn: () => fetchPageContent(PAGE_SLUG),
  });

  useEffect(() => {
    if (data) {
      setTitle(data.title || "Privacy Policy");
      setContent(data.content || "");
    }
  }, [data]);

  const mutation = useMutation({
    mutationFn: (pageData: PageContentData) =>
      axios.post(`/api/admin/pages/${PAGE_SLUG}`, pageData),
    onSuccess: () => {
      toast.success("Privacy Policy content saved successfully!");
      queryClient.invalidateQueries({ queryKey: ["pageContent", PAGE_SLUG] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to save content.");
    },
  });

  const handleSave = () => {
    if (!title.trim() || !content.trim()) {
      toast.error("Title and Content cannot be empty.");
      return;
    }
    mutation.mutate({ title, content });
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading page content...</p>;
  if (error) return <p className="text-red-400">Failed to load content.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Shield size={28} /> Edit 'Privacy Policy' Page
        </h1>
        <button
          onClick={handleSave}
          disabled={mutation.isPending}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
        >
          {mutation.isPending ? (
            <Loader2 size={20} className="animate-spin" />
          ) : (
            <Save size={20} />
          )}
          <span>{mutation.isPending ? "Saving..." : "Save Changes"}</span>
        </button>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg space-y-6">
        <div>
          <label
            htmlFor="pageTitle"
            className="block text-sm font-medium text-brand-light mb-2"
          >
            Page Title
          </label>
          <input
            id="pageTitle"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">
            Page Content
          </label>
          {data && <RichTextEditor value={content} onChange={setContent} />}
        </div>
      </div>
    </div>
  );
}

// ===== src/app/admin/pages/report-abuse/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { Loader2, Save, AlertTriangle } from "lucide-react";
import RichTextEditor from "@/components/admin/RichTextEditor";

const PAGE_SLUG = "report-abuse";

interface PageContentData {
  title: string;
  content: string;
}

const fetchPageContent = async (slug: string): Promise<PageContentData> => {
  const { data } = await axios.get(`/api/admin/pages/${slug}`);
  return data;
};

export default function EditReportAbusePage() {
  const queryClient = useQueryClient();
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");

  const { data, isLoading, error } = useQuery<PageContentData>({
    queryKey: ["pageContent", PAGE_SLUG],
    queryFn: () => fetchPageContent(PAGE_SLUG),
  });

  useEffect(() => {
    if (data) {
      setTitle(data.title || "Report Abuse");
      setContent(data.content || "");
    }
  }, [data]);

  const mutation = useMutation({
    mutationFn: (pageData: PageContentData) =>
      axios.post(`/api/admin/pages/${PAGE_SLUG}`, pageData),
    onSuccess: () => {
      toast.success("Page content saved successfully!");
      queryClient.invalidateQueries({ queryKey: ["pageContent", PAGE_SLUG] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to save content.");
    },
  });

  const handleSave = () => {
    if (!title.trim() || !content.trim()) {
      toast.error("Title and Content cannot be empty.");
      return;
    }
    mutation.mutate({ title, content });
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading page content...</p>;
  if (error) return <p className="text-red-400">Failed to load content.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <AlertTriangle size={28} /> Edit 'Report Abuse' Page
        </h1>
        <button
          onClick={handleSave}
          disabled={mutation.isPending}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
        >
          {mutation.isPending ? (
            <Loader2 size={20} className="animate-spin" />
          ) : (
            <Save size={20} />
          )}
          <span>{mutation.isPending ? "Saving..." : "Save Changes"}</span>
        </button>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg space-y-6">
        <div>
          <label
            htmlFor="pageTitle"
            className="block text-sm font-medium text-brand-light mb-2"
          >
            Page Title
          </label>
          <input
            id="pageTitle"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">
            Page Content
          </label>
          {}
          {data && <RichTextEditor value={content} onChange={setContent} />}
        </div>
      </div>
    </div>
  );
}

// ===== src/app/admin/pages/terms-and-conditions/page.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { Loader2, Save, FileText } from "lucide-react";
import RichTextEditor from "@/components/admin/RichTextEditor";

const PAGE_SLUG = "terms-and-conditions";

interface PageContentData {
  title: string;
  content: string;
}

const fetchPageContent = async (slug: string): Promise<PageContentData> => {
  const { data } = await axios.get(`/api/admin/pages/${slug}`);
  return data;
};

export default function EditTermsAndConditionsPage() {
  const queryClient = useQueryClient();
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");

  const { data, isLoading, error } = useQuery<PageContentData>({
    queryKey: ["pageContent", PAGE_SLUG],
    queryFn: () => fetchPageContent(PAGE_SLUG),
  });

  useEffect(() => {
    if (data) {
      setTitle(data.title || "Terms and Conditions");
      setContent(data.content || "");
    }
  }, [data]);

  const mutation = useMutation({
    mutationFn: (pageData: PageContentData) =>
      axios.post(`/api/admin/pages/${PAGE_SLUG}`, pageData),
    onSuccess: () => {
      toast.success("Terms and Conditions saved successfully!");
      queryClient.invalidateQueries({ queryKey: ["pageContent", PAGE_SLUG] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to save content.");
    },
  });

  const handleSave = () => {
    if (!title.trim() || !content.trim()) {
      toast.error("Title and Content cannot be empty.");
      return;
    }
    mutation.mutate({ title, content });
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading page content...</p>;
  if (error) return <p className="text-red-400">Failed to load content.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <FileText size={28} /> Edit 'Terms and Conditions' Page
        </h1>
        <button
          onClick={handleSave}
          disabled={mutation.isPending}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
        >
          {mutation.isPending ? (
            <Loader2 size={20} className="animate-spin" />
          ) : (
            <Save size={20} />
          )}
          <span>{mutation.isPending ? "Saving..." : "Save Changes"}</span>
        </button>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg space-y-6">
        <div>
          <label
            htmlFor="pageTitle"
            className="block text-sm font-medium text-brand-light mb-2"
          >
            Page Title
          </label>
          <input
            id="pageTitle"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">
            Page Content
          </label>
          {data && <RichTextEditor value={content} onChange={setContent} />}
        </div>
      </div>
    </div>
  );
}

// ===== src/app/admin/predictions/page.tsx =====

"use client";

import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import Image from "next/image";
import {
  DownloadCloud,
  Loader2,
  Database,
  Clock,
  Trash2,
  TrendingUp,
} from "lucide-react";
import AdminPagination from "@/components/admin/AdminPagination";
import { proxyImageUrl } from "@/lib/image-proxy";
import { format } from "date-fns";

interface IPrediction {
  _id: string;
  fixtureId: number;
  fixtureDate: string;
  teams: {
    home: { name: string; logo: string };
    away: { name: string; logo: string };
  };
  league: { name: string };
  prediction: { home: number; draw: number; away: number };
}

interface PredictionsResponse {
  predictions: IPrediction[];
  pagination: {
    currentPage: number;
    totalPages: number;
    totalCount: number;
  };
}

const fetchPredictions = async (page: number): Promise<PredictionsResponse> => {
  const params = new URLSearchParams({ page: page.toString(), limit: "15" });
  const { data } = await axios.get(
    `/api/admin/predictions?${params.toString()}`
  );
  return data;
};

const syncPredictions = async (
  days: number
): Promise<{ message: string; newPredictions: number; skipped: number }> => {
  const { data } = await axios.post("/api/admin/predictions/sync", { days });
  return data;
};

const getPredictionsMetadata = async (): Promise<{
  count: number;
  lastUpdated: string | null;
}> => {
  const { data } = await axios.get("/api/admin/predictions/metadata");
  return data;
};

const clearPredictions = async (): Promise<{ message: string }> => {
  const { data } = await axios.delete("/api/admin/predictions/clear");
  return data;
};

export default function AdminPredictionsPage() {
  const queryClient = useQueryClient();
  const [currentPage, setCurrentPage] = useState(1);
  const [syncDays, setSyncDays] = useState(7);

  const { data: predictionsData, isLoading: isLoadingPredictions } =
    useQuery<PredictionsResponse>({
      queryKey: ["adminPredictions", currentPage],
      queryFn: () => fetchPredictions(currentPage),
      placeholderData: (previousData) => previousData,
    });

  const {
    data: metadata,
    isLoading: isLoadingMetadata,
    refetch: refetchMetadata,
  } = useQuery({
    queryKey: ["predictionsAdminMetadata"],
    queryFn: getPredictionsMetadata,
  });

  const syncMutation = useMutation({
    mutationFn: () => syncPredictions(syncDays),
    onSuccess: (data) => {
      toast.success(data.message);
      refetchMetadata();
      queryClient.invalidateQueries({ queryKey: ["adminPredictions"] });
    },
    onError: (error: any) =>
      toast.error(error.response?.data?.error || "Sync failed."),
  });

  const clearMutation = useMutation({
    mutationFn: clearPredictions,
    onSuccess: (data) => {
      toast.success(data.message);
      refetchMetadata();
      queryClient.invalidateQueries({ queryKey: ["adminPredictions"] });
    },
    onError: (error: any) =>
      toast.error(error.response?.data?.error || "Clear operation failed."),
  });

  const handleSync = () => {
    if (
      window.confirm(
        `This will fetch and generate predictions for the next ${syncDays} days. This may take several minutes. Are you sure?`
      )
    ) {
      syncMutation.mutate();
    }
  };

  const handleClear = () => {
    if (
      window.confirm(
        "Are you sure you want to delete ALL generated predictions? This action cannot be undone."
      )
    ) {
      clearMutation.mutate();
    }
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <TrendingUp size={28} /> Manage Predictions
        </h1>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg shadow-xl mb-8 space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          <div>
            <h2 className="text-xl font-bold text-white mb-2">
              Sync Upcoming Predictions
            </h2>
            <p className="text-brand-muted text-sm mb-4">
              Fetch upcoming matches and generate predictions. Already generated
              predictions for upcoming matches will be skipped.
            </p>
            <div className="flex items-center gap-4">
              <button
                onClick={handleSync}
                disabled={syncMutation.isPending}
                className="inline-flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-wait"
              >
                {syncMutation.isPending ? (
                  <Loader2 size={20} className="animate-spin" />
                ) : (
                  <DownloadCloud size={20} />
                )}
                <span>
                  {syncMutation.isPending ? "Syncing..." : "Run Sync"}
                </span>
              </button>
              <div className="flex items-center gap-2">
                <input
                  type="number"
                  value={syncDays}
                  onChange={(e) => setSyncDays(Number(e.target.value))}
                  min="1"
                  max="7"
                  className="w-20 p-2 rounded bg-gray-700 text-white border border-gray-600"
                />
                <label className="text-sm font-medium text-brand-light">
                  Days
                </label>
              </div>
            </div>
          </div>
          <div className="md:border-l border-gray-700/50 md:pl-8">
            <h2 className="text-xl font-bold text-white mb-2">
              Database Actions
            </h2>
            <p className="text-brand-muted text-sm mb-4">
              Manage the predictions collection in the database.
            </p>
            <button
              onClick={handleClear}
              disabled={clearMutation.isPending}
              className="inline-flex items-center gap-2 bg-red-800 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-900 disabled:opacity-50 disabled:cursor-wait"
            >
              {clearMutation.isPending ? (
                <Loader2 size={20} className="animate-spin" />
              ) : (
                <Trash2 size={20} />
              )}
              <span>
                {clearMutation.isPending
                  ? "Clearing..."
                  : "Clear All Predictions"}
              </span>
            </button>
          </div>
        </div>

        <div className="pt-6 border-t border-gray-700/50">
          <h2 className="text-xl font-bold text-white mb-2">Database Status</h2>
          {isLoadingMetadata ? (
            <div className="h-8 w-2/3 bg-gray-700 rounded-md animate-pulse"></div>
          ) : (
            <div className="flex items-center gap-6 text-brand-light">
              <div className="flex items-center gap-2">
                <Database size={18} />
                <span className="font-semibold">Total Predictions:</span>
                <span className="font-bold text-white text-lg">
                  {metadata?.count ?? 0}
                </span>
              </div>
              <div className="flex items-center gap-2">
                <Clock size={18} />
                <span className="font-semibold">Last Updated:</span>
                <span className="font-bold text-white text-lg">
                  {metadata?.lastUpdated
                    ? new Date(metadata.lastUpdated).toLocaleString()
                    : "Never"}
                </span>
              </div>
            </div>
          )}
        </div>
      </div>

      <div className="bg-brand-secondary rounded-lg shadow-xl">
        <div className="overflow-x-auto">
          <table className="w-full text-left text-brand-light">
            <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
              <tr>
                <th className="p-4">Match</th>
                <th className="p-4">League</th>
                <th className="p-4">Date</th>
                <th className="p-4 text-center">Home %</th>
                <th className="p-4 text-center">Draw %</th>
                <th className="p-4 text-center">Away %</th>
              </tr>
            </thead>
            <tbody>
              {isLoadingPredictions
                ? Array.from({ length: 10 }).map((_, i) => (
                    <tr key={i} className="border-t border-gray-700/50">
                      <td colSpan={6} className="p-4 h-12 animate-pulse">
                        <div className="h-5 bg-gray-700 rounded"></div>
                      </td>
                    </tr>
                  ))
                : predictionsData?.predictions.map((p) => (
                    <tr key={p._id} className="border-t border-gray-700/50">
                      <td className="p-4 font-medium flex items-center gap-3">
                        <Image
                          src={proxyImageUrl(p.teams.home.logo)}
                          alt={p.teams.home.name}
                          width={24}
                          height={24}
                          className="bg-white rounded-full p-0.5"
                        />
                        <span>
                          {p.teams.home.name} vs {p.teams.away.name}
                        </span>
                        <Image
                          src={proxyImageUrl(p.teams.away.logo)}
                          alt={p.teams.away.name}
                          width={24}
                          height={24}
                          className="bg-white rounded-full p-0.5"
                        />
                      </td>
                      <td className="p-4 text-brand-muted text-sm">
                        {p.league.name}
                      </td>
                      <td className="p-4 text-brand-muted text-sm">
                        {format(new Date(p.fixtureDate), "dd MMM yyyy, HH:mm")}
                      </td>
                      <td className="p-4 text-center font-bold text-green-400">
                        {p.prediction.home}%
                      </td>
                      <td className="p-4 text-center font-bold text-yellow-400">
                        {p.prediction.draw}%
                      </td>
                      <td className="p-4 text-center font-bold text-blue-400">
                        {p.prediction.away}%
                      </td>
                    </tr>
                  ))}
            </tbody>
          </table>
        </div>
        {predictionsData && predictionsData.pagination.totalPages > 1 && (
          <div className="p-4 border-t border-gray-700/50">
            <AdminPagination
              currentPage={currentPage}
              totalPages={predictionsData.pagination.totalPages}
              onPageChange={setCurrentPage}
            />
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/app/admin/teams/page.tsx =====

"use client";

import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import Image from "next/image";
import {
  DownloadCloud,
  Loader2,
  Database,
  Clock,
  Search,
  Users,
} from "lucide-react";
import AdminPagination from "@/components/admin/AdminPagination";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useDebounce } from "@/hooks/useDebounce";

interface ITeam {
  _id: string;
  teamId: number;
  name: string;
  logoUrl: string;
  country: string;
  founded: number | null;
  venueName: string | null;
  venueCity: string | null;
}

interface TeamsResponse {
  teams: ITeam[];
  pagination: {
    currentPage: number;
    totalPages: number;
    totalCount: number;
  };
}

const fetchTeams = async (
  page: number,
  searchQuery: string
): Promise<TeamsResponse> => {
  const params = new URLSearchParams({
    page: page.toString(),
    limit: "20",
    search: searchQuery,
  });
  const { data } = await axios.get(`/api/admin/teams?${params.toString()}`);
  return data;
};

const fetchAndStoreTeams = async (): Promise<{ count: number }> => {
  const { data } = await axios.post("/api/admin/teams/sync");
  return data;
};

const getTeamsMetadata = async (): Promise<{
  count: number;
  lastUpdated: string | null;
}> => {
  const { data } = await axios.get("/api/admin/teams/metadata");
  return data;
};

export default function AdminTeamsPage() {
  const queryClient = useQueryClient();
  const [currentPage, setCurrentPage] = useState(1);
  const [searchTerm, setSearchTerm] = useState("");
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  const { data: teamsData, isLoading: isLoadingTeams } =
    useQuery<TeamsResponse>({
      queryKey: ["adminTeams", currentPage, debouncedSearchTerm],
      queryFn: () => fetchTeams(currentPage, debouncedSearchTerm),
      placeholderData: (previousData) => previousData,
    });

  const {
    data: metadata,
    isLoading: isLoadingMetadata,
    refetch: refetchMetadata,
  } = useQuery({
    queryKey: ["teamsAdminMetadata"],
    queryFn: getTeamsMetadata,
  });

  const syncMutation = useMutation({
    mutationFn: fetchAndStoreTeams,
    onSuccess: (data) => {
      toast.success(`Successfully fetched and stored ${data.count} teams!`);
      refetchMetadata();
      queryClient.invalidateQueries({ queryKey: ["adminTeams"] });
    },
    onError: (error: any) => {
      toast.error(
        error.response?.data?.error ||
          "An unexpected error occurred during sync."
      );
    },
  });

  const handleSync = () => {
    if (
      window.confirm(
        "This will update all teams from the external API based on your leagues. This can take several minutes. Are you sure?"
      )
    ) {
      syncMutation.mutate();
    }
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Users size={28} /> Manage Teams Database
        </h1>
      </div>

      <div className="bg-brand-secondary p-6 rounded-lg shadow-xl mb-8 space-y-6">
        <div>
          <h2 className="text-xl font-bold text-white mb-2">
            Sync with External API
          </h2>
          <p className="text-brand-muted text-sm mb-4">
            Click this button to fetch all teams for the current season based on
            the leagues in your database.
          </p>
          <button
            onClick={handleSync}
            disabled={syncMutation.isPending}
            className="inline-flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-wait"
          >
            {syncMutation.isPending ? (
              <Loader2 size={20} className="animate-spin" />
            ) : (
              <DownloadCloud size={20} />
            )}
            <span>
              {syncMutation.isPending ? "Syncing..." : "Sync All Teams"}
            </span>
          </button>
        </div>

        <div className="pt-6 border-t border-gray-700/50">
          <h2 className="text-xl font-bold text-white mb-2">Database Status</h2>
          {isLoadingMetadata ? (
            <div className="h-8 w-2/3 bg-gray-700 rounded-md animate-pulse"></div>
          ) : (
            <div className="flex items-center gap-6 text-brand-light">
              <div className="flex items-center gap-2">
                <Database size={18} />
                <span className="font-semibold">Total Teams:</span>
                <span className="font-bold text-white text-lg">
                  {metadata?.count ?? 0}
                </span>
              </div>
              <div className="flex items-center gap-2">
                <Clock size={18} />
                <span className="font-semibold">Last Updated:</span>
                <span className="font-bold text-white text-lg">
                  {metadata?.lastUpdated
                    ? new Date(metadata.lastUpdated).toLocaleString()
                    : "Never"}
                </span>
              </div>
            </div>
          )}
        </div>
      </div>

      <div className="bg-brand-secondary rounded-lg shadow-xl">
        <div className="p-4 border-b border-gray-700/50">
          <div className="relative">
            <Search
              className="absolute left-3 top-1/2 -translate-y-1/2 text-brand-muted"
              size={20}
            />
            <input
              type="text"
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              placeholder="Search by team name or country..."
              className="w-full bg-gray-800 border border-gray-600 rounded-lg p-2 pl-10 text-white placeholder:text-brand-muted focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
          </div>
        </div>
        <div className="overflow-x-auto">
          <table className="w-full text-left text-brand-light">
            <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
              <tr>
                <th className="p-4">Team</th>
                <th className="p-4">Country</th>
                <th className="p-4">Venue</th>
                <th className="p-4 text-center">Founded</th>
              </tr>
            </thead>
            <tbody>
              {isLoadingTeams
                ? Array.from({ length: 10 }).map((_, i) => (
                    <tr key={i} className="border-t border-gray-700/50">
                      <td colSpan={4} className="p-4 h-12 animate-pulse">
                        <div className="h-5 bg-gray-700 rounded"></div>
                      </td>
                    </tr>
                  ))
                : teamsData?.teams.map((team) => (
                    <tr key={team._id} className="border-t border-gray-700/50">
                      <td className="p-4 font-medium flex items-center gap-3">
                        <Image
                          src={proxyImageUrl(team.logoUrl)}
                          alt={team.name}
                          width={28}
                          height={28}
                          className="bg-white rounded-full p-0.5"
                        />
                        <span>{team.name}</span>
                      </td>
                      <td className="p-4 text-brand-muted">{team.country}</td>
                      <td className="p-4 text-brand-muted">
                        {team.venueName || "N/A"}
                      </td>
                      <td className="p-4 text-brand-muted text-center">
                        {team.founded || "-"}
                      </td>
                    </tr>
                  ))}
            </tbody>
          </table>
        </div>
        {teamsData && teamsData.pagination.totalPages > 1 && (
          <div className="p-4 border-t border-gray-700/50">
            <AdminPagination
              currentPage={currentPage}
              totalPages={teamsData.pagination.totalPages}
              onPageChange={setCurrentPage}
            />
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/app/admin/ticker-messages/page.tsx =====

"use client";

import { useState, useMemo } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { PlusCircle, Megaphone, Info } from "lucide-react";
import { ITickerMessage } from "@/models/TickerMessage";
import { ILanguage } from "@/models/Language";
import {TickerFormModal} from "@/components/admin/TickerFormModal";
import TickerTranslationGroupRow from "@/components/admin/TickerTranslationGroupRow";

const fetchActiveLanguages = async (): Promise<ILanguage[]> => {
  const { data } = await axios.get("/api/admin/languages?active=true");
  return data;
};

const fetchTickerMessages = async (): Promise<ITickerMessage[]> => {
  const { data } = await axios.get("/api/admin/ticker-messages");
  return data;
};

export default function AdminTickerMessagesPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingMessage, setEditingMessage] = useState<ITickerMessage | null>(null);

  const { data: messages, isLoading: isLoadingMessages } = useQuery<ITickerMessage[]>({
    queryKey: ["tickerMessagesAdmin"],
    queryFn: fetchTickerMessages,
  });

  const { data: languages, isLoading: isLoadingLanguages } = useQuery<ILanguage[]>({
    queryKey: ["activeLanguages"],
    queryFn: fetchActiveLanguages,
  });

  const groupedMessages = useMemo(() => {
    if (!messages) return [];
    const groups: Record<string, ITickerMessage[]> = {};
    messages.forEach((msg) => {

      const groupId = (msg.translationGroupId ?? msg._id).toString();
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      groups[groupId].push(msg);
    });
    return Object.values(groups).sort(
      (a, b) => new Date(b[0].createdAt).getTime() - new Date(a[0].createdAt).getTime()
    );
  }, [messages]);

  const deleteMutation = useMutation({
    mutationFn: (messageId: string) => axios.delete("/api/admin/ticker-messages", { data: { id: messageId } }),
    onSuccess: () => {
      toast.success("Message deleted!");
      queryClient.invalidateQueries({ queryKey: ["tickerMessagesAdmin"] });
    },
    onError: (err: any) => toast.error(err.response?.data?.error || "Failed to delete message."),
  });

  const handleOpenCreateModal = () => {
    setEditingMessage(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (message: ITickerMessage) => {
    setEditingMessage(message);
    setIsModalOpen(true);
  };

  const isLoading = isLoadingMessages || isLoadingLanguages;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Megaphone size={28} /> Manage Ticker Messages
        </h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} /> New Message
        </button>
      </div>
      <div className="bg-brand-secondary rounded-lg overflow-hidden">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4 w-20">Order</th>
              <th className="p-4">Message Content</th>
              <th className="p-4">Translations</th>
              <th className="p-4 text-center">Status</th>
              <th className="p-4 text-center">Actions</th>
            </tr>
          </thead>
          <tbody>
            {isLoading ? (
              <tr><td colSpan={5} className="p-8 text-center text-brand-muted">Loading...</td></tr>
            ) : groupedMessages.length > 0 && languages ? (
              groupedMessages.map((group) => (
                <TickerTranslationGroupRow
                  key={group[0].translationGroupId?.toString() || group[0]._id.toString()}
                  group={group}
                  allActiveLanguages={languages}
                  onDelete={(id) => deleteMutation.mutate(id)}
                  onEdit={(message) => handleOpenEditModal(message)}
                />
              ))
            ) : (
                <tr>
                    <td colSpan={5} className="text-center p-8 text-brand-muted">
                        <Info size={24} className="mx-auto mb-2" />
                        No messages found. Click "New Message" to create one.
                    </td>
                </tr>
            )}
          </tbody>
        </table>
      </div>
      <TickerFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        message={editingMessage}
      />
    </div>
  );
}

// ===== src/app/admin/title-templates/page.tsx =====

"use client";

import { useEffect, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  PlusCircle,
  Edit,
  Trash2,
  FileText,
  CheckCircle,
  XCircle,
  Loader2,
} from "lucide-react";
import { ITitleTemplate } from "@/models/TitleTemplate";

interface TitleTemplateFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  template?: ITitleTemplate | null;
}

const TitleTemplateFormModal: React.FC<TitleTemplateFormModalProps> = ({
  isOpen,
  onClose,
  template,
}) => {
  const queryClient = useQueryClient();
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const [templateContent, setTemplateContent] = useState("");
  const [isActive, setIsActive] = useState(true);

  useEffect(() => {
    if (template) {
      setName(template.name);
      setDescription(template.description || "");
      setTemplateContent(template.template);
      setIsActive(template.isActive);
    } else {
      setName("");
      setDescription("");
      setTemplateContent("");
      setIsActive(true);
    }
  }, [template]);

  const mutation = useMutation({
    mutationFn: (payload: Partial<ITitleTemplate>) =>
      template?._id
        ? axios.put(`/api/admin/title-templates/${template._id}`, payload)
        : axios.post("/api/admin/title-templates", payload),
    onSuccess: () => {
      toast.success(
        `Title Template ${template ? "updated" : "created"} successfully!`
      );
      queryClient.invalidateQueries({ queryKey: ["titleTemplates"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to save the template.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !templateContent.trim()) {
      toast.error("Name and Template Content are required.");
      return;
    }
    mutation.mutate({
      name,
      description,
      template: templateContent,
      isActive,
    });
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {template ? "Edit Title Template" : "Create New Title Template"}
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label
              htmlFor="name"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Template Name
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={mutation.isPending}
            />
          </div>
          <div>
            <label
              htmlFor="description"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Description (Optional)
            </label>
            <input
              id="description"
              type="text"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              disabled={mutation.isPending}
            />
          </div>
          <div>
            <label
              htmlFor="templateContent"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Template Content
            </label>
            <textarea
              id="templateContent"
              value={templateContent}
              onChange={(e) => setTemplateContent(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
              rows={4}
              required
              disabled={mutation.isPending}
              placeholder="e.g., {original_title} hakknda ok gelimeler!"
            />
            <p className="text-xs text-brand-muted mt-1">
              Available placeholders: <code>{`{original_title}`}</code>,{" "}
              <code>{`{original_description}`}</code>,{" "}
              <code>{`{journalist_name}`}</code>.
            </p>
          </div>
          <div className="flex items-center">
            <input
              id="isActive"
              type="checkbox"
              checked={isActive}
              onChange={(e) => setIsActive(e.target.checked)}
              className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
              disabled={mutation.isPending}
            />
            <label
              htmlFor="isActive"
              className="ml-2 text-sm font-medium text-brand-light"
            >
              Active (Available for selection in generation modal)
            </label>
          </div>
          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              disabled={mutation.isPending}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={mutation.isPending}
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
            >
              {mutation.isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {mutation.isPending ? "Saving..." : "Save Template"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default function AdminTitleTemplatesPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingTemplate, setEditingTemplate] = useState<ITitleTemplate | null>(
    null
  );

  const {
    data: templates,
    isLoading,
    error,
  } = useQuery<ITitleTemplate[]>({
    queryKey: ["titleTemplates"],
    queryFn: async () => {
      const { data } = await axios.get("/api/admin/title-templates");
      return data;
    },
  });

  const deleteMutation = useMutation({
    mutationFn: (templateId: string) =>
      axios.delete(`/api/admin/title-templates/${templateId}`),
    onSuccess: () => {
      toast.success("Template deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["titleTemplates"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete template.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingTemplate(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (template: ITitleTemplate) => {
    setEditingTemplate(template);
    setIsModalOpen(true);
  };

  const handleDelete = (templateId: string, templateName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete template "${templateName}"?`
      )
    ) {
      deleteMutation.mutate(templateId);
    }
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading templates...</p>;
  if (error) return <p className="text-red-400">Failed to load templates.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <FileText size={28} /> Manage Title Templates
        </h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Template</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Name</th>
              <th className="p-4">Template Preview</th>
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {templates?.map((template) => (
              <tr key={template._id} className="border-t border-gray-700/50">
                <td className="p-4 font-medium">{template.name}</td>
                <td
                  className="p-4 text-brand-muted text-sm max-w-xl truncate font-mono"
                  title={template.template}
                >
                  {template.template}
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      template.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {template.isActive ? "Active" : "Inactive"}
                  </span>
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <button
                    onClick={() => handleOpenEditModal(template)}
                    className="text-blue-400 hover:text-blue-300"
                    title="Edit Template"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() => handleDelete(template._id, template.name)}
                    className="text-red-400 hover:text-red-300"
                    title="Delete Template"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {templates?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No templates found. Click "New Template" to create one.
          </p>
        )}
      </div>

      <TitleTemplateFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        template={editingTemplate}
      />
    </div>
  );
}

// ===== src/app/admin/translations/page.tsx =====

"use client";

import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { ITranslation } from "@/models/Translation";
import { ILanguage } from "@/models/Language";
import { FileJson, PlusCircle } from "lucide-react";
import TranslationsTable from "@/components/admin/translations/TranslationsTable";
import AddTranslationModal from "@/components/admin/translations/AddTranslationModal";
import EditTranslationModal from "@/components/admin/translations/EditTranslationModal";

const fetchTranslations = async (): Promise<ITranslation[]> => {
  const { data } = await axios.get("/api/admin/translations/manage");
  return data;
};

const fetchActiveLanguages = async (): Promise<ILanguage[]> => {
  const { data } = await axios.get("/api/admin/languages?active=true");
  return data;
};

export default function AdminTranslationsPage() {
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [editingTranslation, setEditingTranslation] =
    useState<ITranslation | null>(null);
  const [searchTerm, setSearchTerm] = useState("");
  const [groupFilter, setGroupFilter] = useState("all");

  const {
    data: translations,
    isLoading: isLoadingTranslations,
    error: translationsError,
  } = useQuery<ITranslation[]>({
    queryKey: ["allTranslations"],
    queryFn: fetchTranslations,
  });

  const {
    data: languages,
    isLoading: isLoadingLanguages,
    error: languagesError,
  } = useQuery<ILanguage[]>({
    queryKey: ["activeLanguages"],
    queryFn: fetchActiveLanguages,
  });

  const handleOpenEditModal = (translation: ITranslation) => {
    setEditingTranslation(translation);
    setIsEditModalOpen(true);
  };

  const translationGroups = [
    "all",
    ...Array.from(new Set(translations?.map((t) => t.group) || [])).sort(),
  ];

  const filteredTranslations = translations?.filter((t) => {
    const matchesGroup = groupFilter === "all" || t.group === groupFilter;
    const englishTranslation =
      t.translations["en" as keyof typeof t.translations] || "";
    const matchesSearch =
      searchTerm.length === 0 ||
      t.key.toLowerCase().includes(searchTerm.toLowerCase()) ||
      englishTranslation.toLowerCase().includes(searchTerm.toLowerCase());
    return matchesGroup && matchesSearch;
  });

  const isLoading = isLoadingTranslations || isLoadingLanguages;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <FileJson size={28} /> Manage Translations
        </h1>
        <button
          onClick={() => setIsAddModalOpen(true)}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          New Key
        </button>
      </div>

      <div className="bg-brand-secondary p-4 rounded-lg mb-6 flex flex-col md:flex-row gap-4">
        <input
          type="text"
          placeholder="Search key or English text..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="flex-grow p-2 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
        />
        <select
          value={groupFilter}
          onChange={(e) => setGroupFilter(e.target.value)}
          className="p-2 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
        >
          {translationGroups.map((group) => (
            <option key={group} value={group}>
              {group.charAt(0).toUpperCase() + group.slice(1)}
            </option>
          ))}
        </select>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-hidden">
        <TranslationsTable
          translations={filteredTranslations || []}
          languages={languages || []}
          isLoading={isLoading}
          error={translationsError || languagesError}
          onEdit={handleOpenEditModal}
        />
      </div>

      {isAddModalOpen && (
        <AddTranslationModal
          isOpen={isAddModalOpen}
          onClose={() => setIsAddModalOpen(false)}
          languages={languages || []}
          existingKeys={translations?.map((t) => t.key) || []}
        />
      )}

      {isEditModalOpen && editingTranslation && (
        <EditTranslationModal
          isOpen={isEditModalOpen}
          onClose={() => setIsEditModalOpen(false)}
          translation={editingTranslation}
          languages={languages || []}
        />
      )}
    </div>
  );
}

// ===== src/app/api/active-leagues/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import { format, addDays } from "date-fns";

const LEAGUES_TO_CHECK = [
  39,
  140,
  135,
  78,
  61,
  2,
  3,
  88,
  94,
  253,
  45,
  48,
  71,
  62,
  144,
  203,
  197,
  218,
];

export async function GET() {
  const today = format(new Date(), "yyyy-MM-dd");
  const nextSevenDays = format(addDays(new Date(), 7), "yyyy-MM-dd");

  const options = (leagueId: number) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: {
      league: leagueId,
      season: new Date().getFullYear().toString(),
      from: today,
      to: nextSevenDays,
    },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {

    const fixtureChecks = LEAGUES_TO_CHECK.map((id) =>
      axios.request(options(id)).then((response) => ({
        leagueId: id,
        hasFixtures: response.data.results > 0,
      }))
    );

    const results = await Promise.allSettled(fixtureChecks);

    const activeLeagueIds = results
      .filter(
        (result) => result.status === "fulfilled" && result.value.hasFixtures
      )
      .map(
        (result) =>
          (result as PromiseFulfilledResult<{ leagueId: number }>).value
            .leagueId
      );

    return NextResponse.json(activeLeagueIds);
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to determine active leagues." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/ai-journalists/[journalistId]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import AIJournalist, { IAIJournalist } from "@/models/AIJournalist";

interface Params {
  params: { journalistId: string };
}

export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { journalistId } = params;
    const journalist = await AIJournalist.findById(journalistId).lean();

    if (!journalist) {
      return NextResponse.json(
        { error: "AI Journalist not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(journalist, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error fetching AI Journalist ${params.journalistId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching AI Journalist." },
      { status: 500 }
    );
  }
}

export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { journalistId } = params;
    const body: Partial<IAIJournalist> = await request.json();
    const { name, description, tonePrompt, isActive } = body;

    if (!name || !tonePrompt) {
      return NextResponse.json(
        { error: "Name and Tone Prompt are required." },
        { status: 400 }
      );
    }

    const updatedJournalist = await AIJournalist.findByIdAndUpdate(
      journalistId,
      { name, description, tonePrompt, isActive },
      { new: true, runValidators: true }
    );

    if (!updatedJournalist) {
      return NextResponse.json(
        { error: "AI Journalist not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(updatedJournalist, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error updating AI Journalist ${params.journalistId}:`,
      error.message
    );
    if (error.code === 11000) {

      return NextResponse.json(
        { error: "Journalist with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error updating AI Journalist." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { journalistId } = params;
    const deletedJournalist = await AIJournalist.findByIdAndDelete(
      journalistId
    );

    if (!deletedJournalist) {
      return NextResponse.json(
        { error: "AI Journalist not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { message: "AI Journalist deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      `Error deleting AI Journalist ${params.journalistId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error deleting AI Journalist." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/ai-journalists/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import AIJournalist, { IAIJournalist } from "@/models/AIJournalist";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const journalists = await AIJournalist.find({}).sort({ name: 1 }).lean();
    return NextResponse.json(journalists, { status: 200 });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error fetching AI Journalists." },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body: Partial<IAIJournalist> = await request.json();
    const { name, description, tonePrompt, isActive } = body;

    if (!name || !tonePrompt) {
      return NextResponse.json(
        { error: "Name and Tone Prompt are required." },
        { status: 400 }
      );
    }

    const newJournalist = new AIJournalist({
      name,
      description,
      tonePrompt,
      isActive: isActive !== undefined ? isActive : true,
    });

    await newJournalist.save();
    return NextResponse.json(newJournalist, { status: 201 });
  } catch (error: any) {

    if (error.code === 11000) {

      return NextResponse.json(
        { error: "Journalist with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error creating AI Journalist." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/ai-prompt/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import AIPrompt, { IAIPrompt, AIPromptType } from "@/models/AIPrompt";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { searchParams } = new URL(request.url);
    const name = searchParams.get("name");
    const type = searchParams.get("type") as AIPromptType;

    if (!name || !type) {
      return NextResponse.json(
        { error: "Prompt name and type are required." },
        { status: 400 }
      );
    }

    const prompt = await AIPrompt.findOne({ name, type }).lean();

    if (!prompt) {
      return NextResponse.json(
        { error: `Prompt '${name}' of type '${type}' not found.` },
        { status: 404 }
      );
    }

    return NextResponse.json(prompt, { status: 200 });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error fetching AI Prompt." },
      { status: 500 }
    );
  }
}

export async function PUT(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body: { id: string; description?: string; prompt: string } =
      await request.json();
    const { id, description, prompt } = body;

    if (!id || !prompt) {
      return NextResponse.json(
        { error: "Prompt ID and content are required for update." },
        { status: 400 }
      );
    }

    const updatedPrompt = await AIPrompt.findByIdAndUpdate(
      id,
      { description, prompt },
      { new: true, runValidators: true }
    );

    if (!updatedPrompt) {
      return NextResponse.json(
        { error: "AI Prompt not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(updatedPrompt, { status: 200 });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error updating AI Prompt." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/casino-partners/[partnerId]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import CasinoPartner, { ICasinoPartner } from "@/models/CasinoPartner";

interface Params {
  params: { partnerId: string };
}

export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { partnerId } = params;
    const partner = await CasinoPartner.findById(partnerId).lean();

    if (!partner) {
      return NextResponse.json(
        { error: "Casino Partner not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(partner, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error fetching Casino Partner ${params.partnerId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching Casino Partner." },
      { status: 500 }
    );
  }
}

export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { partnerId } = params;
    const body: Partial<ICasinoPartner> = await request.json();
    const {
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured,
      isActive,
      order,
    } = body;

    if (!name || !logoUrl || !redirectUrl) {
      return NextResponse.json(
        { error: "Name, Logo URL, and Redirect URL are required." },
        { status: 400 }
      );
    }

    const updatedPartner = await CasinoPartner.findByIdAndUpdate(
      partnerId,
      { name, logoUrl, redirectUrl, description, isFeatured, isActive, order },
      { new: true, runValidators: true }
    );

    if (!updatedPartner) {
      return NextResponse.json(
        { error: "Casino Partner not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(updatedPartner, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error updating Casino Partner ${params.partnerId}:`,
      error.message
    );
    if (error.code === 11000) {

      return NextResponse.json(
        { error: "Partner with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error updating Casino Partner." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { partnerId } = params;
    const deletedPartner = await CasinoPartner.findByIdAndDelete(partnerId);

    if (!deletedPartner) {
      return NextResponse.json(
        { error: "Casino Partner not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { message: "Casino Partner deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      `Error deleting Casino Partner ${params.partnerId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error deleting Casino Partner." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/casino-partners/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import CasinoPartner, { ICasinoPartner } from "@/models/CasinoPartner";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {

    const partners = await CasinoPartner.find({})
      .sort({ order: 1, createdAt: -1 })
      .lean();
    return NextResponse.json(partners, { status: 200 });
  } catch (error: any) {
    :", error.message);
    return NextResponse.json(
      { error: "Server error fetching Casino Partners." },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body: Partial<ICasinoPartner> = await request.json();
    const {
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured,
      isActive,
      order,
    } = body;

    if (!name || !logoUrl || !redirectUrl) {
      return NextResponse.json(
        { error: "Name, Logo URL, and Redirect URL are required." },
        { status: 400 }
      );
    }

    const newPartner = new CasinoPartner({
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured: isFeatured !== undefined ? isFeatured : false,
      isActive: isActive !== undefined ? isActive : true,
      order: order !== undefined ? order : 0,
    });

    await newPartner.save();
    return NextResponse.json(newPartner, { status: 201 });
  } catch (error: any) {

    if (error.code === 11000) {

      return NextResponse.json(
        { error: "Partner with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error creating Casino Partner." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/external-news/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle from "@/models/ExternalNewsArticle";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();

    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get("limit") || "10");
    const skip = parseInt(searchParams.get("skip") || "0");
    const status = searchParams.get("status");

    const query: { status?: string } = {};
    if (status) {
      query.status = status;
    }

    const [articles, totalCount] = await Promise.all([
      ExternalNewsArticle.find(query)
        .sort({ pubDate: -1 })
        .skip(skip)
        .limit(limit)
        .lean(),
      ExternalNewsArticle.countDocuments(query),
    ]);

    return NextResponse.json({
      articles,
      totalCount,
      currentPage: Math.floor(skip / limit) + 1,
      perPage: limit,
    });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error fetching external news articles." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const { searchParams } = new URL(request.url);
    const articleId = searchParams.get("articleId");

    if (!articleId) {
      return NextResponse.json(
        { error: "Article ID is required." },
        { status: 400 }
      );
    }

    await dbConnect();

    const deletedArticle = await ExternalNewsArticle.findOneAndDelete({
      articleId,
    });

    if (!deletedArticle) {
      return NextResponse.json(
        { error: "Article not found." },
        { status: 404 }
      );
    }

    return NextResponse.json({ message: "Article deleted successfully." });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error deleting article." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/faqs/categories/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Faq from "@/models/Faq";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();

    const categories = await Faq.distinct("category");

    const sortedCategories = categories.filter(Boolean).sort();

    return NextResponse.json(sortedCategories);
  } catch (error) {

    return NextResponse.json(
      { error: "Server error fetching categories." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/faqs/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Faq, { IFaq } from "@/models/Faq";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  const faqs = await Faq.find({}).sort({ category: 1, order: 1, createdAt: 1 });
  return NextResponse.json(faqs);
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();
    const body: Partial<IFaq> = await request.json();
    const newFaq = new Faq(body);
    await newFaq.save();
    return NextResponse.json(newFaq, { status: 201 });
  } catch (error: any) {

    return NextResponse.json(
      { error: error.message || "Failed to create FAQ." },
      { status: 400 }
    );
  }
}

export async function PUT(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();
    const body: IFaq = await request.json();

    const { _id, question, answer, category, order, isActive } = body;

    if (!_id) {
      return NextResponse.json(
        { error: "FAQ ID is required for update." },
        { status: 400 }
      );
    }

    const updatedFaq = await Faq.findByIdAndUpdate(
      _id,
      { question, answer, category, order, isActive },
      { new: true, runValidators: true }
    );

    if (!updatedFaq) {
      return NextResponse.json({ error: "FAQ not found." }, { status: 404 });
    }

    return NextResponse.json(updatedFaq);
  } catch (error: any) {

    return NextResponse.json(
      { error: error.message || "Failed to update FAQ." },
      { status: 400 }
    );
  }
}

export async function DELETE(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();
    const { id } = await request.json();

    if (!id) {
      return NextResponse.json(
        { error: "FAQ ID is required for deletion." },
        { status: 400 }
      );
    }

    const deletedFaq = await Faq.findByIdAndDelete(id);

    if (!deletedFaq) {
      return NextResponse.json({ error: "FAQ not found." }, { status: 404 });
    }

    return NextResponse.json({ message: "FAQ deleted successfully." });
  } catch (error: any) {

    return NextResponse.json(
      { error: error.message || "Failed to delete FAQ." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/fetch-external-news/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle from "@/models/ExternalNewsArticle";
import axios from "axios";

interface NewsDataItem {
  article_id: string;
  title: string;
  link: string;
  keywords?: string[] | null;

  creator?: string | string[] | null;
  video_url?: string | null;
  description?: string | null;
  content?: string | null;
  pubDate: string;
  image_url?: string | null;
  source_id?: string;
  source_priority?: number;
  source_url?: string;
  source_icon?: string | null;
  language?: string;
  country?: string[];
  category?: string[];
  sentiment?: string;
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { query, language, country, category } = await request.json();

    const newsDataApiKey = process.env.NEXT_PUBLIC_NEWSDATA_IO_API_KEY;
    if (!newsDataApiKey) {
      return NextResponse.json(
        { error: "Server configuration error: News API key missing." },
        { status: 500 }
      );
    }

    const apiUrl = "https://newsdata.io/api/1/news";
    const params: Record<string, string | number> = {
      apikey: newsDataApiKey,
      qInTitle: query || "football OR soccer",
      language: language || "en",
    };
    if (country && country.length > 0) params.country = country.join(",");
    if (category && category.length > 0) params.category = category.join(",");

    const response = await axios.get(apiUrl, { params });
    const newsItems: NewsDataItem[] = response.data.results || [];

    let newArticlesCount = 0;
    let skippedArticlesCount = 0;
    let failedArticlesCount = 0;

    const processingPromises = newsItems.map(async (item) => {
      try {
        const existingArticle = await ExternalNewsArticle.findOne({
          articleId: item.article_id,
        });
        if (existingArticle) {
          return { status: "skipped" };
        }

        let creatorArray: string[] = [];
        if (item.creator) {
          creatorArray = Array.isArray(item.creator)
            ? item.creator
            : [item.creator];
        }

        const newArticle = new ExternalNewsArticle({
          articleId: item.article_id,
          title: item.title,
          link: item.link,
          creator: creatorArray,
          description: item.description,
          content: item.content,
          pubDate: new Date(item.pubDate),
          imageUrl: item.image_url,

          language: item.language,
          country: item.country || [],
          category: item.category || [],
          status: "fetched",
        });

        await newArticle.save();
        return { status: "saved" };
      } catch (saveError: any) {
        console.error(
          `[Fetch External News] Error saving article ${item.article_id}:`,
          saveError.message
        );
        return { status: "failed" };
      }
    });

    const results = await Promise.allSettled(processingPromises);

    results.forEach((result) => {
      if (result.status === "fulfilled") {
        if (result.value.status === "saved") newArticlesCount++;
        if (result.value.status === "skipped") skippedArticlesCount++;
        if (result.value.status === "failed") failedArticlesCount++;
      } else {
        failedArticlesCount++;
      }
    });

    return NextResponse.json(
      {
        message: `Fetch complete. Saved: ${newArticlesCount}. Skipped: ${skippedArticlesCount}. Failed: ${failedArticlesCount}.`,
        newArticlesCount,
        skippedArticlesCount,
        failedArticlesCount,
      },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      "[Fetch External News] Critical error fetching from newsdata.io:",
      error.message
    );
    if (axios.isAxiosError(error)) {
      return NextResponse.json(
        {
          error: `Failed to fetch news from external API: ${
            error.response?.data?.results?.message || error.message
          }`,
        },
        { status: error.response?.status || 500 }
      );
    }
    return NextResponse.json(
      { error: "Server error fetching external news." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/file-manager/download-from-url/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import axios from "axios";
import crypto from "crypto";
import path from "path";
import slugify from "slugify";
import { promises as fs } from "fs";

const UPLOAD_DIR = path.join(process.cwd(), "public/uploads");

const ensureUploadDirExists = async () => {
  try {
    await fs.mkdir(UPLOAD_DIR, { recursive: true });
  } catch (error) {

    throw new Error("Could not create upload directory on the server.");
  }
};

const generateFileName = (bytes = 32) =>
  crypto.randomBytes(bytes).toString("hex");

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const {
      url,
      fileName: providedFileName,
    }: { url: string; fileName?: string } = await request.json();

    if (!url) {
      return NextResponse.json({ error: "URL is required." }, { status: 400 });
    }

    console.log(
      `[File Manager - Download URL] Attempting to download from URL: ${url}`
    );

    const response = await axios.get(url, {
      responseType: "arraybuffer",
      timeout: 30000,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });

    const fileBuffer = Buffer.from(response.data, "binary");
    const contentType =
      response.headers["content-type"] || "application/octet-stream";
    const contentLength = response.headers["content-length"]
      ? parseInt(response.headers["content-length"])
      : fileBuffer.length;

    if (contentLength === 0) {
      throw new Error("Downloaded file is empty.");
    }
    if (contentLength > 20 * 1024 * 1024) {

      throw new Error("File size exceeds 20MB limit for direct download.");
    }

    let fileExtension = "";
    const mimeMap: { [key: string]: string } = {
      "image/jpeg": ".jpg",
      "image/png": ".png",
      "image/gif": ".gif",
      "image/webp": ".webp",
      "application/pdf": ".pdf",

    };
    fileExtension =
      mimeMap[contentType.toLowerCase()] ||
      path.extname(new URL(url).pathname) ||
      "";

    const uniqueBaseName = generateFileName();
    const finalFileName = providedFileName
      ? `${slugify(providedFileName, {
          lower: true,
          strict: true,
        })}${fileExtension}`
      : `${uniqueBaseName}${fileExtension}`;

    const filePath = path.join(UPLOAD_DIR, finalFileName);
    await ensureUploadDirExists();
    await fs.writeFile(filePath, fileBuffer);

    const publicUrl = `/uploads/${finalFileName}`;
    console.log(
      `[File Manager - Download URL] File successfully saved locally: ${publicUrl}`
    );

    return NextResponse.json({
      message: "File downloaded and saved successfully",
      url: publicUrl,
      name: finalFileName,
      type: contentType,
      size: contentLength,
    });
  } catch (error: any) {
    console.error(
      `[File Manager - Download URL] Failed to download or save from URL: ${error.message}`,
      "\nFull Error:",
      error
    );
    let errorMessage = "Failed to download and upload file from URL.";
    let clientStatus = 500;

    if (axios.isAxiosError(error)) {
      if (error.response) {
        errorMessage = `External URL error: Status ${error.response.status} - ${error.response.statusText}`;
        clientStatus = error.response.status;
      } else if (error.request) {
        errorMessage = `Network error: Could not reach external URL.`;
        clientStatus = 502;
      } else {
        errorMessage = `Request setup error: ${error.message}`;
      }
    } else if (error instanceof Error) {
      errorMessage = error.message;
      if (errorMessage.includes("File size exceeds")) clientStatus = 413;
      if (errorMessage.includes("Downloaded file is empty")) clientStatus = 400;
    }

    return NextResponse.json({ error: errorMessage }, { status: clientStatus });
  }
}

// ===== src/app/api/admin/generate-prediction-news/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post from "@/models/Post";
import AIJournalist from "@/models/AIJournalist";
import axios from "axios";
import { proxyAndUploadImage } from "@/lib/image-processing-server";
import slugify from "slugify";
import OpenAI from "openai";

const openai = new OpenAI({
  apiKey: process.env.NEXT_PUBLIC_OPENAI_API_KEY,
});

async function getFixtureData(fixtureId: number) {
  const options = (endpoint: string, params: object) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  const fixtureResponse = await axios.request(
    options("fixtures", { id: fixtureId })
  );
  const fixtureData = fixtureResponse.data.response[0];
  if (!fixtureData) {
    throw new Error(`Fixture data not found for ID: ${fixtureId}`);
  }

  const { home, away } = fixtureData.teams;
  const [h2hRes, homeFormRes, awayFormRes] = await Promise.all([
    axios.request(
      options("fixtures/headtohead", { h2h: `${home.id}-${away.id}` })
    ),
    axios.request(options("fixtures", { team: home.id, last: 5 })),
    axios.request(options("fixtures", { team: away.id, last: 5 })),
  ]);

  return {
    ...fixtureData,
    h2h: h2hRes.data.response,
    homeForm: homeFormRes.data.response
      .map((m: any) =>
        m.teams.home.winner ? "W" : m.teams.away.winner ? "L" : "D"
      )
      .join(""),
    awayForm: awayFormRes.data.response
      .map((m: any) =>
        m.teams.away.winner ? "W" : m.teams.home.winner ? "L" : "D"
      )
      .join(""),
  };
}

async function generatePredictionTitle(
  homeTeamName: string,
  awayTeamName: string,
  leagueName: string,
  journalistTonePrompt?: string
): Promise<string> {
  const prompt = `
    You are an expert sports journalist. Your ONLY task is to generate a new, original, SEO-friendly title in TURKISH for a news article about the upcoming match: ${homeTeamName} vs ${awayTeamName} in the ${leagueName}.

    Your journalistic voice and tone should be: ${journalistTonePrompt || "Objective and informative."}

    The new title MUST be highly distinct, capture a fresh angle, and be plain text only with no markdown or quotes.

    Generated Title:
  `;

  const response = await openai.chat.completions.create({
    model: "gpt-4o",
    messages: [{ role: "user", content: prompt }],
    temperature: 0.8,
  });

  const title = response.choices[0]?.message?.content?.trim().replace(/["*]/g, "");
  if (!title) {
    throw new Error("OpenAI failed to generate a prediction title.");
  }
  return title;
}

async function generatePredictionContent(
  predictionData: any,
  journalistTonePrompt?: string
): Promise<string> {
  const prompt = `
    You are an expert sports journalist and a charismatic storyteller. Your task is to transform the provided raw match data into a compelling, conversational, and humanized narrative in **PURE HTML** and **TURKISH**. Your writing should be engaging, insightful, and optimized for readability and SEO.

    Your unique journalistic voice and tone should be: ${journalistTonePrompt || "Objective and informative."}

    **CRITICAL INSTRUCTIONS:**
    1.  **HTML ONLY:** Your entire response **MUST** be pure, valid HTML. Use tags like \`<h2>\`, \`<h3>\`, \`<p>\`, \`<strong>\`, \`<em>\`, \`<ul>\`, and \`<li>\`.
    2.  **NO MARKDOWN:** **ABSOLUTELY NO MARKDOWN SYNTAX** like \`#\` or \`*\` is allowed.
    3.  **NO PREAMBLE:** Your response must start directly with an HTML tag (e.g., \`<h2>\`). Do not write "Here is the article...".
    4.  **LANGUAGE & TONE:** The entire article **MUST** be in Turkish. Adopt a conversational, authoritative, and engaging tone.

    **ARTICLE STRUCTURE (Example Flow):**
    1.  **Etkileyici Giri (Engaging Intro):** Start with a hook.
    2.  **Takmlarn Form Durumu (Team Form):** Analyze the recent form of both teams.
    3.  **Gemiin zleri: H2H Analizi (H2H Analysis):** Discuss past encounters.
    4.  **Man Anahtar Oyuncular (Key Players):** Identify key players.
    5.  **Fanskor'un Gznden Man Kaderi (Fanskor's Prediction):** State the prediction clearly.

    **Provided Match Data (use this to write the article):**
    \`\`\`json
    {
        "league_name": "${predictionData.league.name}",
        "home_team_name": "${predictionData.teams.home.name}",
        "away_team_name": "${predictionData.teams.away.name}",
        "h2h_results_count": ${predictionData.h2h.length},
        "home_form_string": "${predictionData.homeForm}",
        "away_form_string": "${predictionData.awayForm}"
    }
    \`\`\`

    Your Generated HTML Article (Must start with \`<h2>\`):
  `;

  const response = await openai.chat.completions.create({
    model: "gpt-4o",
    messages: [{ role: "user", content: prompt }],
    temperature: 0.7,
  });

  const content = response.choices[0]?.message?.content?.trim().replace(/^```(?:html)?\n?|```$/g, "").trim();
  if (!content || !content.includes("<p>")) {
    throw new Error("OpenAI failed to generate valid prediction content.");
  }
  return content;
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }
  await dbConnect();

  try {
    const {
      fixtureId,
      journalistId,
      sportsCategory = "football",
    } = await request.json();

    if (!fixtureId || !journalistId) {
      return NextResponse.json(
        { error: "Fixture ID and Journalist ID are required." },
        { status: 400 }
      );
    }

    const existingPost = await Post.findOne({ originalFixtureId: fixtureId });
    if (existingPost) {
      return NextResponse.json(
        {
          message: "Prediction post already exists.",
          postId: existingPost._id,
        },
        { status: 200 }
      );
    }

    const journalist = await AIJournalist.findById(journalistId);
    if (!journalist) {
        throw new Error(`Journalist with ID ${journalistId} not found.`);
    }

    const fixtureData = await getFixtureData(fixtureId);
    const { teams, league } = fixtureData;

    const newPostTitle = await generatePredictionTitle(
      teams.home.name,
      teams.away.name,
      league.name,
      journalist.tonePrompt
    );
    const predictionContent = await generatePredictionContent(
      fixtureData,
      journalist.tonePrompt
    );

    const featuredImageUrl = await proxyAndUploadImage(
      teams.home.logo || teams.away.logo,
      `${teams.home.name}-vs-${teams.away.name}-prediction`
    );

    const postSlug = slugify(newPostTitle, {
      lower: true,
      strict: true,
    });
    const existingSlug = await Post.findOne({ slug: postSlug, language: 'tr' });
    const finalSlug = existingSlug
      ? `${postSlug}-${Date.now().toString().slice(-5)}`
      : postSlug;

    const plainTextContent = predictionContent.replace(/<[^>]*>?/gm, "");

    const newPost = new Post({
      title: newPostTitle,
      content: predictionContent,
      slug: finalSlug,
      status: "draft",
      author: journalist.name,
      isAIGenerated: true,
      sportsCategory: [sportsCategory],
      newsType: "prediction",
      language: 'tr',
      linkedFixtureId: fixtureId,
      linkedLeagueId: league.id,
      featuredImage: featuredImageUrl,
      featuredImageTitle: `${teams.home.name} vs ${teams.away.name} Prediction`,
      featuredImageAltText: `${teams.home.name} vs ${teams.away.name} match prediction`,
      metaTitle: `${newPostTitle} | Ma Tahmini`,
      metaDescription: plainTextContent.substring(0, 160) + "...",
      originalFixtureId: fixtureId,
    });

    await newPost.save();

    return NextResponse.json(
      {
        message: "Prediction news generated successfully!",
        postId: newPost._id,
      },
      { status: 201 }
    );
  } catch (error: any) {
    console.error(
      `[Generate Prediction] Critical error: ${error.message}`,
      error
    );
    return NextResponse.json(
      { error: "Server error generating prediction news." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/i18n-cache/invalidate/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { i18nCache } from "@/lib/i18n/i18n.cache";

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {

    await i18nCache.reload();

    return NextResponse.json(
      {
        success: true,
        message: "i18n cache has been successfully invalidated and reloaded.",
        loadedLocales: i18nCache.getLocales(),
        defaultLocale: i18nCache.getDefaultLocale(),
      },
      { status: 200 }
    );
  } catch (error: any) {

    return NextResponse.json(
      {
        success: false,
        error: "Failed to invalidate cache due to a server error.",
      },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/languages/[languageId]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Language, { ILanguage } from "@/models/Language";
import path from "path";
import { promises as fs } from "fs";

const LOCALES_DIR = path.join(process.cwd(), "src/locales");

interface Params {
  params: { languageId: string };
}

export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { languageId } = params;
  await dbConnect();

  try {
    const body: Partial<ILanguage> = await request.json();

    delete (body as any).code;

    if (body.isDefault) {
      const language = await Language.findById(languageId);
      if (!language) {
        return NextResponse.json(
          { error: "Language not found." },
          { status: 404 }
        );
      }
      Object.assign(language, body);
      await language.save();
      const updatedLanguage = language.toObject();
      console.log(
        `[I18N_CACHE] Invalidation needed. Language default status changed.`
      );
      return NextResponse.json(updatedLanguage, { status: 200 });
    }

    const updatedLanguage = await Language.findByIdAndUpdate(languageId, body, {
      new: true,
      runValidators: true,
    });

    if (!updatedLanguage) {
      return NextResponse.json(
        { error: "Language not found." },
        { status: 404 }
      );
    }

    console.log(
      `[I18N_CACHE] Invalidation needed. Language '${updatedLanguage.code}' was updated.`
    );
    return NextResponse.json(updatedLanguage, { status: 200 });
  } catch (error: any) {

    if (error.code === 11000) {
      return NextResponse.json(
        { error: "Language name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error updating language." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { languageId } = params;
  await dbConnect();

  try {
    const languageToDelete = await Language.findById(languageId);

    if (!languageToDelete) {
      return NextResponse.json(
        { error: "Language not found." },
        { status: 404 }
      );
    }

    if (languageToDelete.isDefault) {
      return NextResponse.json(
        { error: "Cannot delete the default language." },
        { status: 400 }
      );
    }

    await Language.findByIdAndDelete(languageId);

    const filePath = path.join(LOCALES_DIR, `${languageToDelete.code}.json`);
    try {
      await fs.unlink(filePath);
    } catch (fileError: any) {

      if (fileError.code !== "ENOENT") {

      }
    }

    console.log(
      `[I18N_CACHE] Invalidation needed. Language '${languageToDelete.code}' was deleted.`
    );
    return NextResponse.json(
      { message: "Language deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error deleting language." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/languages/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Language from "@/models/Language";
import path from "path";
import { promises as fs } from "fs";

const LOCALES_DIR = path.join(process.cwd(), "src/locales");

const ensureLocalesDirExists = async () => {
  try {
    await fs.mkdir(LOCALES_DIR, { recursive: true });
  } catch (error) {

    throw new Error(
      "Server configuration error: Could not access locales directory."
    );
  }
};

export async function GET(request: Request) {

  await dbConnect();

  try {
    const session = await getServerSession(authOptions);
    const isAdmin = session?.user?.role === "admin";

    const query = isAdmin ? {} : { isActive: true };

    const languages = await Language.find(query).sort({ name: 1 });
    return NextResponse.json(languages, { status: 200 });
  } catch (error: any) {
    console.error(
      "[API/admin/languages] Error fetching languages:",
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching languages." },
      { status: 500 }
    );
  }
}
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body = await request.json();
    const { name, code, isDefault, isActive, flagUrl } = body;

    if (!name || !code) {
      return NextResponse.json(
        { error: "Name and code are required." },
        { status: 400 }
      );
    }

    const newLanguage = new Language({
      name,
      code,
      isDefault,
      isActive,
      flagUrl,
    });
    await newLanguage.save();

    await ensureLocalesDirExists();
    const filePath = path.join(LOCALES_DIR, `${code}.json`);
    await fs.writeFile(filePath, JSON.stringify({}, null, 2), "utf-8");

    console.log(
      `[I18N_CACHE] Invalidation needed. Language '${code}' was added.`
    );

    return NextResponse.json(newLanguage, { status: 201 });
  } catch (error: any) {

    if (error.code === 11000) {
      return NextResponse.json(
        { error: `Language with code or name already exists.` },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error creating language." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/leagues/metadata/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import League from "@/models/League";

export async function GET() {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();

    const [count, latestLeague] = await Promise.all([
      League.countDocuments(),
      League.findOne().sort({ updatedAt: -1 }).lean(),
    ]);

    return NextResponse.json({
      count,
      lastUpdated: latestLeague ? latestLeague.updatedAt : null,
    });
  } catch (error: any) {
    console.error(
      "[API/admin/leagues/metadata] Error fetching metadata:",
      error
    );
    return NextResponse.json(
      { error: "Server error fetching league metadata." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/leagues/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import League from "@/models/League";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "20");
    const searchQuery = searchParams.get("search") || "";

    const skip = (page - 1) * limit;

    const query: any = {};
    if (searchQuery) {

      const regex = new RegExp(searchQuery, "i");
      query.$or = [
        { name: { $regex: regex } },
        { countryName: { $regex: regex } },
      ];
    }

    const [leagues, totalCount] = await Promise.all([
      League.find(query)
        .sort({ countryName: 1, name: 1 })
        .skip(skip)
        .limit(limit)
        .lean(),
      League.countDocuments(query),
    ]);

    const totalPages = Math.ceil(totalCount / limit);

    return NextResponse.json({
      leagues,
      pagination: {
        currentPage: page,
        totalPages,
        totalCount,
      },
    });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error fetching leagues." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/leagues/sync/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import League from "@/models/League";
import axios from "axios";
import redis from "@/lib/redis";

const fetchAllExternalLeagues = async () => {
  try {
    const options = {
      method: "GET",
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/leagues`,
      headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    };
    const response = await axios.request(options);
    return response.data.response;
  } catch (error) {
    console.error(
      "[API/admin/leagues/sync] Failed to fetch from external API:",
      error
    );
    throw new Error("Failed to fetch leagues from the external API.");
  }
};

export async function POST() {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();

    const externalLeagues = await fetchAllExternalLeagues();
    console.log(
      `Fetched ${externalLeagues.length} leagues from the external API.`
    );

    const bulkOps = externalLeagues.map((item: any) => {
      const { league, country, seasons } = item;
      const leagueData = {
        leagueId: league.id,
        name: league.name,
        type: league.type,
        logoUrl: league.logo,
        countryName: country.name,
        countryCode: country.code,
        countryFlagUrl: country.flag,
        seasons: seasons.map((s: any) => ({
          year: s.year,
          start: s.start,
          end: s.end,
          current: s.current,
        })),
      };

      return {
        updateOne: {
          filter: { leagueId: league.id },
          update: { $set: leagueData },
          upsert: true,
        },
      };
    });

    if (bulkOps.length > 0) {

      const result = await League.bulkWrite(bulkOps);

      if (redis && typeof redis.keys === "function") {
        const redisKeys = await redis.keys("leagues:db:*");
        if (redisKeys && redisKeys.length > 0) {
          await redis.del(...redisKeys);
          console.log(
            `Invalidated ${redisKeys.length} league-related Redis caches.`
          );
        }
      } else {
        console.warn(
          "[API/admin/leagues/sync] Redis client does not support .keys() method. Skipping cache invalidation."
        );
      }

      const count = result.upsertedCount + result.modifiedCount;
      return NextResponse.json({
        message: "Leagues synchronized successfully!",
        count,
      });
    }

    return NextResponse.json({
      message: "No leagues to synchronize.",
      count: 0,
    });
  } catch (error: any) {
    console.error(
      "[API/admin/leagues/sync] Error during synchronization:",
      error
    );
    return NextResponse.json(
      { error: "Server error during league synchronization." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/pages/[pageSlug]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import PageContent from "@/models/PageContent";

interface Params {
  params: { pageSlug: string };
}

export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { pageSlug } = params;
  await dbConnect();

  const pageContent = await PageContent.findOne({ pageSlug });

  if (!pageContent) {
    return NextResponse.json({
      pageSlug,
      title: "",
      content: "",
    });
  }

  return NextResponse.json(pageContent);
}

export async function POST(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { pageSlug } = params;
  try {
    const body = await request.json();
    const { title, content } = body;

    if (!title || !content) {
      return NextResponse.json(
        { error: "Title and content are required." },
        { status: 400 }
      );
    }

    await dbConnect();

    const updatedContent = await PageContent.findOneAndUpdate(
      { pageSlug },
      { title, content },
      {
        new: true,
        upsert: true,
        runValidators: true,
      }
    );

    return NextResponse.json(updatedContent, { status: 200 });
  } catch (error: any) {
    console.error(
      `[API/admin/pages] POST Error for slug "${pageSlug}":`,
      error
    );
    return NextResponse.json(
      { error: error.message || "Failed to save page content." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/posts/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post, { NewsType } from "@/models/Post";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();

    const { searchParams } = new URL(request.url);
    const newsType = searchParams.get("newsType") as NewsType | null;

    const query: { newsType?: NewsType } = {};

    if (newsType) {
      query.newsType = newsType;
    }

    const posts = await Post.find(query).sort({ createdAt: -1 }).lean();

    return NextResponse.json(posts);
  } catch (error) {
    console.error(
      "[API/admin/posts GET] Server error fetching posts for admin:",
      error
    );
    return NextResponse.json(
      { error: "Server error fetching posts" },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/posts/translations/[groupId]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post from "@/models/Post";

interface Params {
  params: { groupId: string };
}

export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  const { groupId } = params;

  if (!groupId) {
    return NextResponse.json(
      { error: "Translation Group ID is required." },
      { status: 400 }
    );
  }

  try {

    const translations = await Post.find({ translationGroupId: groupId })
      .select("title slug language _id createdAt")
      .lean();

    return NextResponse.json(translations, { status: 200 });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error fetching translations." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/predictions/[...action]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Prediction from "@/models/Prediction";

interface Params {
  params: { action: string[] };
}

export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const action = params.action[0];

  try {
    await dbConnect();

    if (action === "metadata") {
      const [count, latestPrediction] = await Promise.all([
        Prediction.countDocuments(),
        Prediction.findOne().sort({ updatedAt: -1 }).lean(),
      ]);
      return NextResponse.json({
        count,
        lastUpdated: latestPrediction ? latestPrediction.updatedAt : null,
      });
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "15");
    const skip = (page - 1) * limit;

    const [predictions, totalCount] = await Promise.all([
      Prediction.find({})
        .sort({ fixtureDate: 1 })
        .skip(skip)
        .limit(limit)
        .lean(),
      Prediction.countDocuments({}),
    ]);

    const totalPages = Math.ceil(totalCount / limit);

    return NextResponse.json({
      predictions,
      pagination: { currentPage: page, totalPages, totalCount },
    });
  } catch (error: any) {

    return NextResponse.json(
      { error: `Server error during action: ${action}.` },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const action = params.action[0];
  if (action !== "clear") {
    return NextResponse.json({ error: "Invalid action." }, { status: 400 });
  }

  try {
    await dbConnect();
    await Prediction.deleteMany({});
    return NextResponse.json({
      message: "All predictions have been cleared successfully.",
    });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error while clearing predictions." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/predictions/sync/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Prediction from "@/models/Prediction";
import axios from "axios";
import { format, addDays } from "date-fns";
import { calculateCustomPrediction } from "@/lib/prediction-engine";
import { getH2H, getTeamStats, getStandings } from "@/lib/data/match";

const apiRequest = async (endpoint: string, params: object) => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    timeout: 8000,
  };
  try {
    const response = await axios.request(options);
    return response.data.response;
  } catch (error) {
    console.error(
      `[Prediction Sync] API request failed for ${endpoint}:`,
      error
    );
    return [];
  }
};

const getFormFromFixtures = (fixtures: any[], teamId: number): string => {
  if (!fixtures || fixtures.length === 0) return "";
  return fixtures
    .map((match: any) => {
      if (match.teams.home.winner)
        return match.teams.home.id === teamId ? "W" : "L";
      if (match.teams.away.winner)
        return match.teams.away.id === teamId ? "W" : "L";
      return "D";
    })
    .join("");
};

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();
    const { days = 7 } = await request.json();

    const datePromises = [];
    for (let i = 0; i < days; i++) {
      const date = format(addDays(new Date(), i), "yyyy-MM-dd");
      datePromises.push(apiRequest("fixtures", { date }));
    }

    const responses = await Promise.all(datePromises);
    const allFixtures = responses.flat();
    const upcomingFixtures = allFixtures.filter(
      (f: any) => f.fixture.status.short === "NS"
    );

    const existingFixtureIds = new Set(
      (
        await Prediction.find({
          fixtureId: { $in: upcomingFixtures.map((f) => f.fixture.id) },
        })
          .select("fixtureId")
          .lean()
      ).map((p) => p.fixtureId)
    );

    const fixturesToProcess = upcomingFixtures.filter(
      (f) => !existingFixtureIds.has(f.fixture.id)
    );

    let processedCount = 0;
    const bulkOps = [];

    for (const fixture of fixturesToProcess) {
      const { league, teams, fixture: fixtureDetails } = fixture;
      const { home, away } = teams;

      try {
        const [
          h2h,
          homeTeamStats,
          awayTeamStats,
          standingsResponse,
          homeLast10,
          awayLast10,
        ] = await Promise.all([
          getH2H(home.id, away.id),
          getTeamStats(league.id, league.season, home.id),
          getTeamStats(league.id, league.season, away.id),
          getStandings(league.id, league.season),
          apiRequest("fixtures", { team: home.id, last: 10 }),
          apiRequest("fixtures", { team: away.id, last: 10 }),
        ]);

        if (!homeTeamStats || !awayTeamStats) continue;

        const flatStandings =
          standingsResponse?.[0]?.league?.standings?.flat() || [];
        const homeTeamRank = flatStandings.find(
          (s: any) => s.team.id === home.id
        )?.rank;
        const awayTeamRank = flatStandings.find(
          (s: any) => s.team.id === away.id
        )?.rank;

        const prediction = calculateCustomPrediction(
          h2h,
          homeTeamStats,
          awayTeamStats,
          home.id,
          homeTeamRank,
          awayTeamRank,
          null,
          fixtureDetails.status.short
        );

        const predictionDocument = {
          fixtureId: fixtureDetails.id,
          fixtureDate: new Date(fixtureDetails.date),
          status: fixtureDetails.status.short,
          teams: {
            home: { id: home.id, name: home.name, logo: home.logo },
            away: { id: away.id, name: away.name, logo: away.logo },
          },
          league: { id: league.id, name: league.name, logo: league.logo },
          prediction,
          h2h: h2h || [],
          form: {
            home: getFormFromFixtures(homeLast10, home.id),
            away: getFormFromFixtures(awayLast10, away.id),
          },
        };

        bulkOps.push({
          updateOne: {
            filter: { fixtureId: fixtureDetails.id },
            update: { $set: predictionDocument },
            upsert: true,
          },
        });
        processedCount++;
      } catch (error) {
        console.error(
          `[Prediction Sync] Failed to process fixture ${fixture.fixture.id}:`,
          error
        );
      }
      await new Promise((resolve) => setTimeout(resolve, 250));
    }

    if (bulkOps.length > 0) {
      await Prediction.bulkWrite(bulkOps);
    }

    return NextResponse.json({
      message: `Sync complete. Processed ${processedCount} new predictions.`,
      newPredictions: processedCount,
      skipped: upcomingFixtures.length - fixturesToProcess.length,
    });
  } catch (error) {

    return NextResponse.json(
      { error: "Server error during prediction sync." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/process-external-news/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle from "@/models/ExternalNewsArticle";
import { processSingleArticle } from "@/lib/ai-processing";

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const body = await request.json();

  const { articleId } = body;

  if (!articleId) {
    return NextResponse.json(
      { error: "External Article ID is required." },
      { status: 400 }
    );
  }

  try {
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder();
        const sendEvent = (log: string, eventType: string = "LOG") => {
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify({ event: eventType, data: log, log })}\n\n`)
          );
        };

        try {
          await dbConnect();

          const articleToProcess = await ExternalNewsArticle.findOne({ articleId: articleId });

          if (!articleToProcess) {
            throw new Error(`External news article with ID '${articleId}' not found in the database.`);
          }

          const result = await processSingleArticle(articleToProcess, {
            onProgress: (log: string) => sendEvent(log),
          });

          if (result.success) {
            sendEvent("Article and translations created successfully.", "SUCCESS");
          } else {
            throw new Error("Article processing failed. Check server logs for details.");
          }

        } catch (error: any) {

          sendEvent(`A critical error occurred: ${error.message}`, "ERROR");
        } finally {
          controller.close();
        }
      },
    });

    return new Response(stream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      },
    });
  } catch (error: any) {

    return NextResponse.json(
      { error: "An unexpected server error occurred." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/teams/metadata/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Team from "@/models/Team";

export async function GET() {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();

    const [count, latestTeam] = await Promise.all([
      Team.countDocuments(),
      Team.findOne().sort({ updatedAt: -1 }).lean(),
    ]);

    return NextResponse.json({
      count,
      lastUpdated: latestTeam ? latestTeam.updatedAt : null,
    });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error fetching team metadata." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/teams/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Team from "@/models/Team";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "20");
    const searchQuery = searchParams.get("search") || "";

    const skip = (page - 1) * limit;

    const query: any = {};
    if (searchQuery) {
      const regex = new RegExp(searchQuery, "i");
      query.$or = [{ name: { $regex: regex } }, { country: { $regex: regex } }];
    }

    const [teams, totalCount] = await Promise.all([
      Team.find(query)
        .sort({ country: 1, name: 1 })
        .skip(skip)
        .limit(limit)
        .lean(),
      Team.countDocuments(query),
    ]);

    const totalPages = Math.ceil(totalCount / limit);

    return NextResponse.json({
      teams,
      pagination: {
        currentPage: page,
        totalPages,
        totalCount,
      },
    });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error fetching teams." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/teams/sync/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import League from "@/models/League";
import Team from "@/models/Team";
import axios from "axios";
import redis from "@/lib/redis";

const fetchTeamsForLeague = async (leagueId: number, season: number) => {
  try {
    const options = {
      method: "GET",
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
      params: { league: leagueId, season },
      headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
      timeout: 10000,
    };
    const response = await axios.request(options);
    return response.data.response;
  } catch (error) {
    console.error(
      `[Teams Sync] Failed to fetch teams for league ${leagueId}:`,
      error
    );
    return [];
  }
};

export async function POST() {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();
    const season = new Date().getFullYear();

    const allLeagues = await League.find({}).select("leagueId").lean();
    const leagueIds = allLeagues.map((l) => l.leagueId);
    console.log(
      `[Teams Sync] Found ${leagueIds.length} leagues to process for season ${season}.`
    );

    let allTeamsFromApi = [];
    for (let i = 0; i < leagueIds.length; i++) {
      const leagueId = leagueIds[i];
      console.log(
        `[Teams Sync] Fetching teams for league ${i + 1}/${
          leagueIds.length
        } (ID: ${leagueId})...`
      );
      const teams = await fetchTeamsForLeague(leagueId, season);
      allTeamsFromApi.push(...teams);

      await new Promise((resolve) => setTimeout(resolve, 300));
    }

    console.log(
      `[Teams Sync] Fetched a total of ${allTeamsFromApi.length} team entries from the API (duplicates will be merged).`
    );
    const uniqueTeams = Array.from(
      new Map(allTeamsFromApi.map((item) => [item.team.id, item])).values()
    );
    console.log(
      `[Teams Sync] Found ${uniqueTeams.length} unique teams to process.`
    );

    const bulkOps = uniqueTeams.map((item: any) => {
      const { team, venue } = item;
      const teamData = {
        teamId: team.id,
        name: team.name,
        code: team.code,
        country: team.country,
        founded: team.founded,
        national: team.national,
        logoUrl: team.logo,
        venueId: venue.id,
        venueName: venue.name,
        venueAddress: venue.address,
        venueCity: venue.city,
        venueCapacity: venue.capacity,
        venueSurface: venue.surface,
        venueImageUrl: venue.image,
      };

      return {
        updateOne: {
          filter: { teamId: team.id },
          update: { $set: teamData },
          upsert: true,
        },
      };
    });

    if (bulkOps.length > 0) {
      console.log(
        `[Teams Sync] Performing bulk write operation for ${bulkOps.length} teams...`
      );
      const result = await Team.bulkWrite(bulkOps);
      console.log(
        `[Teams Sync] Bulk write complete. Upserted: ${result.upsertedCount}, Modified: ${result.modifiedCount}.`
      );

      const redisKeys = await redis.keys("teams:*");
      if (redisKeys.length > 0) {
        await redis.del(...redisKeys);
        console.log(
          `[Teams Sync] Invalidated ${redisKeys.length} team-related Redis caches.`
        );
      }

      const count = result.upsertedCount + result.modifiedCount;
      return NextResponse.json({
        message: `Teams synchronized successfully! Processed ${count} teams.`,
        count,
      });
    }

    return NextResponse.json({ message: "No teams to synchronize.", count: 0 });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error during team synchronization." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/ticker-messages/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import TickerMessage from "@/models/TickerMessage";
import redis from "@/lib/redis";
import mongoose from "mongoose";

const CACHE_KEY_PREFIX = "ticker-messages:active:";

const invalidateCache = async (locale: string) => {
  await redis.del(`${CACHE_KEY_PREFIX}${locale}`);
};

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();
  const messages = await TickerMessage.find({}).sort({ order: 1, createdAt: -1 });
  return NextResponse.json(messages);
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body = await request.json();
    await dbConnect();

    const newMessage = new TickerMessage(body);

    if (!body.translationGroupId) {
      newMessage.translationGroupId = new mongoose.Types.ObjectId();
    }

    await newMessage.save();
    await invalidateCache(newMessage.language);
    return NextResponse.json(newMessage, { status: 201 });
  } catch (error: any) {

    if (error instanceof mongoose.Error.ValidationError) {
        return NextResponse.json({ error: error.message }, { status: 400 });
    }
    return NextResponse.json({ error: "Failed to create message." }, { status: 500 });
  }
}

export async function PUT(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body = await request.json();
    const { _id, ...updateData } = body;
    await dbConnect();
    const updatedMessage = await TickerMessage.findByIdAndUpdate(_id, updateData, { new: true, runValidators: true });
    if (!updatedMessage) {
      return NextResponse.json({ error: "Message not found" }, { status: 404 });
    }
    await invalidateCache(updatedMessage.language);
    return NextResponse.json(updatedMessage);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}

export async function DELETE(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const { id } = await request.json();
    await dbConnect();
    const deletedMessage = await TickerMessage.findByIdAndDelete(id);
    if (!deletedMessage) {
      return NextResponse.json({ error: "Message not found" }, { status: 404 });
    }
    await invalidateCache(deletedMessage.language);
    return NextResponse.json({ message: "Message deleted successfully" });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// ===== src/app/api/admin/ticker-messages/translate/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import TickerMessage from "@/models/TickerMessage";
import Language from "@/models/Language";
import redis from "@/lib/redis";
import OpenAI from "openai";

const openai = new OpenAI({
  apiKey: process.env.NEXT_PUBLIC_OPENAI_API_KEY,
});

const CACHE_KEY_PREFIX = "ticker-messages:active:";

async function translateText(text: string, sourceLang: string, targetLang: string): Promise<string> {
  const prompt = `Translate the following text from ${sourceLang} to ${targetLang}. Return ONLY the translated text, without any quotes, labels, or extra formatting.

Text to translate: "${text}"`;

  const response = await openai.chat.completions.create({
    model: "gpt-4o",
    messages: [{ role: "user", content: prompt }],
    temperature: 0.2,
  });

  const translatedText = response.choices[0]?.message?.content?.trim().replace(/["']/g, "");
  if (!translatedText) {
    throw new Error(`OpenAI failed to translate ticker message to ${targetLang}.`);
  }
  return translatedText;
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const { sourceMessageId } = await request.json();
    if (!sourceMessageId) {
      return NextResponse.json({ error: "Source Message ID is required" }, { status: 400 });
    }

    await dbConnect();

    const sourceMessage = await TickerMessage.findById(sourceMessageId);

    if (!sourceMessage) {
      return NextResponse.json({ error: "Source message not found" }, { status: 404 });
    }

    if (!sourceMessage.translationGroupId) {
      sourceMessage.translationGroupId = sourceMessage._id;
      await sourceMessage.save();
    }
    const groupId = sourceMessage.translationGroupId;

    const [allLanguages, existingTranslations] = await Promise.all([
      Language.find({ isActive: true }).lean(),
      TickerMessage.find({ translationGroupId: groupId }).lean(),
    ]);

    const sourceLangDetails = allLanguages.find(lang => lang.code === (sourceMessage.language ?? 'en') );
    if (!sourceLangDetails) {
        return NextResponse.json({ error: `Source language code '${sourceMessage.language}' could not be found in the database.` }, { status: 400 });
    }

    const existingLangCodes = new Set(existingTranslations.map(t => t.language));
    const targetLanguages = allLanguages.filter(lang => !existingLangCodes.has(lang.code));

    if (targetLanguages.length === 0) {
      return NextResponse.json({ message: "All active languages are already translated." });
    }

    let translatedCount = 0;
    const translationPromises = targetLanguages.map(async (targetLang) => {
      const translatedText = await translateText(sourceMessage.message, sourceLangDetails.name, targetLang.name);

      const newMessage = new TickerMessage({
        message: translatedText,
        language: targetLang.code,
        translationGroupId: groupId,
        isActive: sourceMessage.isActive,
        order: sourceMessage.order,
      });

      await newMessage.save();
      if (redis.del) {
        await redis.del(`${CACHE_KEY_PREFIX}${targetLang.code}`);
      }
      translatedCount++;
    });

    await Promise.allSettled(translationPromises);

    return NextResponse.json({ message: `Successfully created ${translatedCount} new translation(s).` });

  } catch (error: any) {

    return NextResponse.json({ error: "Failed to generate translations." }, { status: 500 });
  }
}

// ===== src/app/api/admin/title-templates/[templateId]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import TitleTemplate, { ITitleTemplate } from "@/models/TitleTemplate";

interface Params {
  params: { templateId: string };
}

export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { templateId } = params;
    const template = await TitleTemplate.findById(templateId).lean();

    if (!template) {
      return NextResponse.json(
        { error: "Title Template not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(template, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error fetching Title Template ${params.templateId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching Title Template." },
      { status: 500 }
    );
  }
}

export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { templateId } = params;
    const body: Partial<ITitleTemplate> = await request.json();
    const { name, description, template, isActive } = body;

    if (!name || !template) {
      return NextResponse.json(
        { error: "Name and Template content are required." },
        { status: 400 }
      );
    }

    const updatedTemplate = await TitleTemplate.findByIdAndUpdate(
      templateId,
      { name, description, template, isActive },
      { new: true, runValidators: true }
    );

    if (!updatedTemplate) {
      return NextResponse.json(
        { error: "Title Template not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(updatedTemplate, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error updating Title Template ${params.templateId}:`,
      error.message
    );
    if (error.code === 11000) {
      return NextResponse.json(
        { error: "A template with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error updating Title Template." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { templateId } = params;
    const deletedTemplate = await TitleTemplate.findByIdAndDelete(templateId);

    if (!deletedTemplate) {
      return NextResponse.json(
        { error: "Title Template not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { message: "Title Template deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      `Error deleting Title Template ${params.templateId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error deleting Title Template." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/title-templates/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import TitleTemplate, { ITitleTemplate } from "@/models/TitleTemplate";

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {

    const { searchParams } = new URL(request.url);
    if (searchParams.get("active") !== "true") {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }
  }

  await dbConnect();

  try {
    const { searchParams } = new URL(request.url);
    const activeOnly = searchParams.get("active") === "true";

    const query = activeOnly ? { isActive: true } : {};

    const templates = await TitleTemplate.find(query).sort({ name: 1 }).lean();
    return NextResponse.json(templates, { status: 200 });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error fetching Title Templates." },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body: Partial<ITitleTemplate> = await request.json();
    const { name, description, template, isActive } = body;

    if (!name || !template) {
      return NextResponse.json(
        { error: "Name and Template content are required." },
        { status: 400 }
      );
    }

    const newTemplate = new TitleTemplate({
      name,
      description,
      template,
      isActive: isActive !== undefined ? isActive : true,
    });

    await newTemplate.save();
    return NextResponse.json(newTemplate, { status: 201 });
  } catch (error: any) {
    if (error.code === 11000) {
      return NextResponse.json(
        { error: "A template with this name already exists." },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { error: "Server error creating Title Template." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/translations/ai-translate/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import OpenAI from "openai";
import Language from "@/models/Language";

const openai = new OpenAI({
  apiKey: process.env.NEXT_PUBLIC_OPENAI_API_KEY,
});

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const {
      text,
      targetLangCodes,
    }: { text: string; targetLangCodes: string[] } = await request.json();

    if (!text) {
      return NextResponse.json(
        { error: "Text to translate is required." },
        { status: 400 }
      );
    }
    if (!Array.isArray(targetLangCodes) || targetLangCodes.length === 0) {
      return NextResponse.json(
        { error: "An array of target language codes is required." },
        { status: 400 }
      );
    }

    const languages = await Language.find({
      code: { $in: targetLangCodes },
    }).lean();
    const langMap = new Map(languages.map((lang) => [lang.code, lang.name]));

    const targetLanguagesString = targetLangCodes
      .map((code) => langMap.get(code) || code)
      .join(", ");

    const prompt = `
      You are an expert translator specializing in sports and web application UI terminology.
      Translate the following English text into multiple languages.

      **Source Text (English):**
      "${text}"

      **Target Languages:**
      ${targetLanguagesString}

      **Instructions:**
      1.  Provide translations for ALL target languages requested.
      2.  Your response MUST be a single, valid JSON object.
      3.  The keys of the JSON object must be the language codes (e.g., "tr", "es").
      4.  The values must be the translated strings.
      5.  Maintain the original meaning, tone, and any placeholders like {variable}.
      6.  Do NOT include any explanations, markdown, or text outside of the JSON object.
    `;

    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [{ role: "user", content: prompt }],
      temperature: 0.3,
      response_format: { type: "json_object" },
    });

    const content = response.choices[0]?.message?.content;
    if (!content) {
      throw new Error("OpenAI response was empty.");
    }

    const translations = JSON.parse(content);

    const finalTranslations: { [key: string]: string } = {};
    targetLangCodes.forEach((code) => {
      finalTranslations[code] = translations[code] || "";
    });

    return NextResponse.json(finalTranslations, { status: 200 });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Failed to generate AI translations." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/translations/manage/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Translation, { ITranslation } from "@/models/Translation";
import { i18nCache } from "@/lib/i18n/i18n.cache";

const invalidateAndRespond = async (data: any, status: number) => {

  i18nCache.reload().catch((err) => {

  });
  return NextResponse.json(data, { status });
};

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    await dbConnect();

    const translations = await Translation.find({})
      .sort({ group: 1, key: 1 })
      .lean();
    return NextResponse.json(translations, { status: 200 });
  } catch (error) {

    return NextResponse.json(
      { error: "Server error fetching translations." },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body = await request.json();
    const { key, group, description, translations } = body;

    if (!key || !group || !translations || !translations.en) {
      return NextResponse.json(
        {
          error: "Key, group, and a default English translation are required.",
        },
        { status: 400 }
      );
    }

    await dbConnect();

    const newTranslation = new Translation({
      key,
      group,
      description,
      translations,
    });
    await newTranslation.save();

    return invalidateAndRespond(newTranslation, 201);
  } catch (error: any) {
    if (error.code === 11000) {
      return NextResponse.json(
        { error: "A translation with this key already exists." },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { error: "Server error creating translation." },
      { status: 500 }
    );
  }
}

export async function PUT(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body: ITranslation = await request.json();
    const { _id, translations, description, group } = body;

    if (!_id || !translations) {
      return NextResponse.json(
        { error: "Translation ID and translations object are required." },
        { status: 400 }
      );
    }

    await dbConnect();
    const updatedTranslation = await Translation.findByIdAndUpdate(
      _id,
      { translations, description, group },
      { new: true, runValidators: true }
    );

    if (!updatedTranslation) {
      return NextResponse.json(
        { error: "Translation not found." },
        { status: 404 }
      );
    }

    return invalidateAndRespond(updatedTranslation, 200);
  } catch (error) {

    return NextResponse.json(
      { error: "Server error updating translation." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const { id } = await request.json();
    if (!id) {
      return NextResponse.json(
        { error: "Translation ID is required for deletion." },
        { status: 400 }
      );
    }

    await dbConnect();
    const deleted = await Translation.findByIdAndDelete(id);

    if (!deleted) {
      return NextResponse.json(
        { error: "Translation not found." },
        { status: 404 }
      );
    }

    return invalidateAndRespond(
      { message: "Translation deleted successfully." },
      200
    );
  } catch (error) {

    return NextResponse.json(
      { error: "Server error deleting translation." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/translations/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import path from "path";
import { promises as fs } from "fs";
import { i18nCache } from "@/lib/i18n/i18n.cache";
const LOCALES_DIR = path.join(process.cwd(), "src/locales");

export async function GET(request: Request) {

  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { searchParams } = new URL(request.url);
  const locale = searchParams.get("locale");

  if (!locale) {
    return NextResponse.json(
      { error: "Locale parameter is required." },
      { status: 400 }
    );
  }

  try {
    const filePath = path.join(LOCALES_DIR, `${locale}.json`);
    const fileContent = await fs.readFile(filePath, "utf-8");
    return NextResponse.json(JSON.parse(fileContent), { status: 200 });
  } catch (error: any) {
    if (error.code === "ENOENT") {
      return NextResponse.json(
        { error: `Translation file for locale '${locale}' not found.` },
        { status: 404 }
      );
    }
    console.error(
      `Error reading translation file for locale '${locale}':`,
      error
    );
    return NextResponse.json(
      { error: "Server error reading translation file." },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const { locale, content } = await request.json();

    if (!locale || content === undefined) {
      return NextResponse.json(
        { error: "Locale and content are required." },
        { status: 400 }
      );
    }

    let parsedContent;
    try {
      parsedContent =
        typeof content === "string" ? JSON.parse(content) : content;
    } catch (e) {
      return NextResponse.json(
        { error: "Invalid JSON content provided." },
        { status: 400 }
      );
    }

    const filePath = path.join(LOCALES_DIR, `${locale}.json`);
    await fs.writeFile(
      filePath,
      JSON.stringify(parsedContent, null, 2),
      "utf-8"
    );

    await i18nCache.reload();
    console.log(
      `[I18N_CACHE] Reload triggered by update to '${locale}' translations.`
    );

    return NextResponse.json(
      { message: `Translations for '${locale}' saved successfully.` },
      { status: 200 }
    );
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error saving translation file." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/admin/upcoming-fixtures-for-prediction/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post from "@/models/Post";
import axios from "axios";
import { format, addDays } from "date-fns";

const LEAGUES_TO_PREDICT = new Set([

  39, 140, 135, 78, 61,

  2, 3, 848,

  88, 94, 203, 197, 218, 144,

  253, 262, 71, 128,

  45, 143, 137, 81,

  98, 292, 179,

  11, 13, 4,
]);

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  const { searchParams } = new URL(request.url);
  const limit = parseInt(searchParams.get("limit") || "10");
  const skip = parseInt(searchParams.get("skip") || "0");

  const datePromises = [];
  for (let i = 0; i < 7; i++) {
    const date = format(addDays(new Date(), i), "yyyy-MM-dd");
    const apiOptions = {
      method: "GET",
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
      params: { date: date, timezone: "Europe/Istanbul" },
      headers: {
        "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
      },
    };
    datePromises.push(axios.request(apiOptions));
  }

  try {
    const responses = await Promise.allSettled(datePromises);

    const allFetchedFixtures: any[] = responses
      .filter(
        (result) => result.status === "fulfilled" && result.value.data.response
      )
      .flatMap(
        (result) => (result as PromiseFulfilledResult<any>).value.data.response
      );

    console.log(
      `[API/upcoming-fixtures] Fetched a total of ${allFetchedFixtures.length} fixtures from the API across the next 7 days.`
    );

    const finishedOrCancelledStatuses = new Set([
      "FT",
      "AET",
      "PEN",
      "PST",
      "CANC",
      "ABD",
      "AWD",
      "WO",
    ]);

    const upcomingFixtures = allFetchedFixtures.filter(
      (fixture) =>

        LEAGUES_TO_PREDICT.has(fixture.league.id) &&

        !finishedOrCancelledStatuses.has(fixture.fixture.status.short) &&

        fixture.fixture &&
        fixture.fixture.id &&
        fixture.teams?.home &&
        fixture.teams?.away
    );

    console.log(
      `[API/upcoming-fixtures] Filtered down to ${upcomingFixtures.length} valid upcoming fixtures from our target leagues.`
    );

    const fixtureIds = upcomingFixtures.map((f) => f.fixture.id);
    const processedPredictions = await Post.find({
      sport: "prediction",
      originalFixtureId: { $in: fixtureIds },
    })
      .select("originalFixtureId _id")
      .lean();

    const processedMap = new Map(
      processedPredictions.map((post) => [post.originalFixtureId, post._id])
    );

    const enhancedFixtures = upcomingFixtures.map((fixture) => ({
      ...fixture,
      processedPostId:
        processedMap.get(fixture.fixture.id)?.toString() || undefined,
    }));

    enhancedFixtures.sort((a, b) => {
      const dateA = new Date(a.fixture.date).getTime();
      const dateB = new Date(b.fixture.date).getTime();
      return dateA - dateB;
    });

    const paginatedFixtures = enhancedFixtures.slice(skip, skip + limit);

    return NextResponse.json(
      {
        fixtures: paginatedFixtures,
        totalCount: enhancedFixtures.length,
        currentPage: Math.floor(skip / limit) + 1,
        perPage: limit,
      },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      "[API/admin/upcoming-fixtures-for-prediction] Error fetching upcoming fixtures:",
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching upcoming fixtures for prediction." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/auth/[...nextauth]/route.ts =====

import NextAuth, { NextAuthOptions } from "next-auth";
import { MongoDBAdapter } from "@auth/mongodb-adapter";
import clientPromise from "@/lib/mongoClient";
import GoogleProvider from "next-auth/providers/google";
import CredentialsProvider from "next-auth/providers/credentials";
import dbConnect from "@/lib/dbConnect";
import User, { IUser } from "@/models/User";
import bcrypt from "bcrypt";

export const authOptions: NextAuthOptions = {
  adapter: MongoDBAdapter(clientPromise),

  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
    CredentialsProvider({
      name: "Credentials",
      credentials: {},
      async authorize(credentials: any) {
        if (!credentials?.email || !credentials.password) {
          throw new Error("Please enter an email and password");
        }

        await dbConnect();

        const user = await User.findOne({ email: credentials.email }).select(
          "+password"
        );

        if (!user || !user.password) {
          throw new Error("Invalid credentials");
        }

        const isPasswordCorrect = await bcrypt.compare(
          credentials.password,
          user.password
        );

        if (!isPasswordCorrect) {
          throw new Error("Invalid credentials");
        }

        return user;
      },
    }),
  ],

  session: { strategy: "jwt" },

  callbacks: {
    jwt: async ({ token, user }) => {
      if (user) {
        const u = user as IUser;
        token.role = u.role;
        token.id = u.id as string;
      }
      return token;
    },

    session: async ({ session, token }) => {
      if (session?.user) {
        session.user.role = token.role as "user" | "admin";
        session.user.id = token.id as string;
      }
      return session;
    },
  },

  pages: { signIn: "/login" },

  secret: process.env.NEXT_PUBLIC_NEXTAUTH_SECRET,
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };

// ===== src/app/api/banners/[bannerId]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Banner, { IBanner } from "@/models/Banner";

interface Params {
  params: { bannerId: string };
}

export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { bannerId } = params;
  try {
    const body: Partial<IBanner> = await request.json();

    const { title, imageUrl, linkUrl, isActive, location } = body;

    await dbConnect();

    const updatedBanner = await Banner.findByIdAndUpdate(
      bannerId,
      {

        title,
        imageUrl,
        linkUrl,
        isActive,
        location,
      },
      { new: true, runValidators: true }
    );

    if (!updatedBanner) {
      return NextResponse.json({ error: "Banner not found" }, { status: 404 });
    }

    return NextResponse.json(updatedBanner);
  } catch (error) {

    return NextResponse.json(
      { error: "Server error updating banner" },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { bannerId } = params;
  try {
    await dbConnect();
    const deletedBanner = await Banner.findByIdAndDelete(bannerId);
    if (!deletedBanner) {
      return NextResponse.json({ error: "Banner not found" }, { status: 404 });
    }
    return NextResponse.json({ message: "Banner deleted successfully" });
  } catch (error) {
    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}

// ===== src/app/api/banners/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Banner, { IBanner } from "@/models/Banner";

export async function GET(request: Request) {

  const { searchParams } = new URL(request.url);
  const activeOnly = searchParams.get("active") === "true";
  const location = searchParams.get("location");

  const query: { isActive?: boolean; location?: string } = {};
  if (activeOnly) {
    query.isActive = true;
  }
  if (location) {
    query.location = location;
  }

  try {
    await dbConnect();
    const banners = await Banner.find(query).sort({ createdAt: -1 });
    return NextResponse.json(banners);
  } catch (error) {

    return NextResponse.json(
      { error: "Server error fetching banners" },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body: Partial<IBanner> = await request.json();

    console.log(
      "[API/Banners] Received POST request with body:",
      JSON.stringify(body, null, 2)
    );

    const { title, imageUrl, linkUrl, isActive, location } = body;

    if (!title || !imageUrl || !linkUrl || !location) {
      console.error(
        "[API/Banners] Validation failed. Missing required fields."
      );
      return NextResponse.json(
        { error: "Title, Image URL, Link URL, and Location are required" },
        { status: 400 }
      );
    }

    await dbConnect();

    const newBanner = new Banner({
      title,
      imageUrl,
      linkUrl,
      isActive,
      location,
    });

    await newBanner.save();

    return NextResponse.json(newBanner, { status: 201 });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error creating banner" },
      { status: 500 }
    );
  }
}

// ===== src/app/api/batch-predictions/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";

import { calculateCustomPrediction } from "@/lib/prediction-engine";
import { convertPercentageToOdds } from "@/lib/odds-converter";

type FanskorOdds = {
  home: string;
  draw: string;
  away: string;
};

const apiRequest = async (
  endpoint: string,
  params: object
): Promise<any | null> => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    timeout: 8000,
  };
  try {
    const response = await axios.request(options);
    return response.data.response;
  } catch (error: any) {
    console.error(
      `[API-Football Sub-Request Error] Endpoint: '${endpoint}', Params: ${JSON.stringify(
        params
      )}, Error: ${error.message}`
    );
    return null;
  }
};

export async function POST(request: Request) {
  try {
    const { fixtureIds }: { fixtureIds: number[] } = await request.json();

    if (!Array.isArray(fixtureIds) || fixtureIds.length === 0) {
      return NextResponse.json(
        { error: "An array of fixture IDs is required." },
        { status: 400 }
      );
    }

    const fixtures: any[] | null = await apiRequest("fixtures", {
      ids: fixtureIds.join("-"),
    });

    if (!fixtures || fixtures.length === 0) {
      return NextResponse.json({});
    }

    const dataPromises = fixtures.map(async (fixture) => {
      const { teams, league, fixture: fixtureDetails } = fixture;
      const [homeTeamStats, awayTeamStats, h2h, standings] = await Promise.all([
        apiRequest("teams/statistics", {
          league: league.id,
          season: league.season,
          team: teams.home.id,
        }),
        apiRequest("teams/statistics", {
          league: league.id,
          season: league.season,
          team: teams.away.id,
        }),
        apiRequest("fixtures/headtohead", {
          h2h: `${teams.home.id}-${teams.away.id}`,
        }),
        apiRequest("standings", { league: league.id, season: league.season }),
      ]);

      if (!homeTeamStats || !awayTeamStats) {
        return { fixtureId: fixtureDetails.id, predictionData: null };
      }

      const leagueStandings = standings?.[0]?.league?.standings?.[0] || [];
      const homeTeamRank = leagueStandings.find(
        (s: any) => s.team.id === teams.home.id
      )?.rank;
      const awayTeamRank = leagueStandings.find(
        (s: any) => s.team.id === teams.away.id
      )?.rank;

      return {
        fixtureId: fixtureDetails.id,
        predictionData: {
          h2h,
          homeTeamStats,
          awayTeamStats,
          homeTeamId: teams.home.id,
          homeTeamRank,
          awayTeamRank,
          matchStatus: fixtureDetails.status.short,
        },
      };
    });

    const settledResults = await Promise.allSettled(dataPromises);
    const oddsMap: Record<number, FanskorOdds> = {};

    settledResults.forEach((result) => {
      if (result.status === "fulfilled" && result.value?.predictionData) {
        const { fixtureId, predictionData } = result.value;
        try {

          const predictionResult = calculateCustomPrediction(
            predictionData.h2h,
            predictionData.homeTeamStats,
            predictionData.awayTeamStats,
            predictionData.homeTeamId,
            predictionData.homeTeamRank,
            predictionData.awayTeamRank,
            null,
            predictionData.matchStatus
          );

          oddsMap[fixtureId] = {
            home: convertPercentageToOdds(predictionResult.home),
            draw: convertPercentageToOdds(predictionResult.draw),
            away: convertPercentageToOdds(predictionResult.away),
          };
        } catch (engineError: any) {
          console.error(
            `[Prediction Engine Error] for fixture ${fixtureId}: ${engineError.message}`
          );
        }
      } else if (result.status === "rejected") {
        console.error(
          `[Batch Predictions] Data promise failed for a fixture:`,
          result.reason
        );
      }
    });

    console.log(
      `[Batch Predictions] Successfully generated odds for ${
        Object.keys(oddsMap).length
      } fixtures using the standardized engine.`
    );
    return NextResponse.json(oddsMap);
  } catch (error) {
    console.error(
      "[Batch Predictions] Critical unhandled error in POST handler:",
      error
    );
    return NextResponse.json(
      {
        error:
          "Failed to generate batch predictions due to a critical server error.",
      },
      { status: 500 }
    );
  }
}

// ===== src/app/api/casino-partners/route.ts =====

import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import CasinoPartner from "@/models/CasinoPartner";

export async function GET(request: Request) {
  await dbConnect();

  try {
    const { searchParams } = new URL(request.url);
    const featuredOnly = searchParams.get("featured") === "true";

    const query: { isActive: boolean; isFeatured?: boolean } = {
      isActive: true,
    };
    if (featuredOnly) {
      query.isFeatured = true;
    }

    const partners = await CasinoPartner.aggregate([
      { $match: query },
      { $addFields: { __rand: { $rand: {} } } },
      { $sort: { order: 1, isFeatured: -1, __rand: 1 } },
      { $project: { __rand: 0 } },
      { $limit: 10 },
    ]);

    return NextResponse.json(partners, { status: 200 });
  } catch (error: any) {
    :", error.message);
    return NextResponse.json(
      { error: "Server error fetching Casino Partners." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/contact/route.ts =====

import { NextResponse } from "next/server";
import nodemailer from "nodemailer";

interface ContactFormData {
  name: string;
  email: string;
  subject: string;
  message: string;
}

export async function POST(request: Request) {
  const {
    NEXT_PUBLIC_SMTP_HOST,
    NEXT_PUBLIC_SMTP_PORT,
    NEXT_PUBLIC_SMTP_USER,
    NEXT_PUBLIC_SMTP_PASS,
    NEXT_PUBLIC_CONTACT_FORM_RECIPIENT,
  } = process.env;

  if (
    !NEXT_PUBLIC_SMTP_HOST ||
    !NEXT_PUBLIC_SMTP_PORT ||
    !NEXT_PUBLIC_SMTP_USER ||
    !NEXT_PUBLIC_SMTP_PASS ||
    !NEXT_PUBLIC_CONTACT_FORM_RECIPIENT
  ) {

    return NextResponse.json(
      { error: "Server configuration error." },
      { status: 500 }
    );
  }

  try {
    const { name, email, subject, message }: ContactFormData =
      await request.json();

    if (!name || !email || !subject || !message) {
      return NextResponse.json(
        { error: "All fields are required." },
        { status: 400 }
      );
    }
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return NextResponse.json(
        { error: "Please enter a valid email address." },
        { status: 400 }
      );
    }

    const transporter = nodemailer.createTransport({
      host: NEXT_PUBLIC_SMTP_HOST,
      port: Number(NEXT_PUBLIC_SMTP_PORT),
      secure: true,
      auth: {
        user: NEXT_PUBLIC_SMTP_USER,
        pass: NEXT_PUBLIC_SMTP_PASS,
      },

      tls: {
        ciphers: "SSLv3",
        rejectUnauthorized: true,
      },
    });

    const mailOptions = {

      from: `"${name} via FanSkor" <${NEXT_PUBLIC_SMTP_USER}>`,
      to: NEXT_PUBLIC_CONTACT_FORM_RECIPIENT,
      replyTo: email,
      subject: `New FanSkor Contact: ${subject}`,
      text: `
        New Contact Form Submission
        -----------------------------
        Name: ${name}
        Email: ${email}
        Subject: ${subject}
        -----------------------------
        Message:
        ${message}
      `,
      html: `
        <div style="font-family: Arial, sans-serif; font-size: 16px; color: #333;">
          <h2 style="color: #1a1a1a;">New Contact Form Submission</h2>
          <p style="margin-bottom: 20px;">You have a new message from the FanSkor website.</p>
          <table style="width: 100%; border-collapse: collapse;">
            <tr style="border-bottom: 1px solid #eee;">
              <td style="padding: 8px; width: 100px;"><strong>Name:</strong></td>
              <td style="padding: 8px;">${name}</td>
            </tr>
            <tr style="border-bottom: 1px solid #eee;">
              <td style="padding: 8px;"><strong>Email:</strong></td>
              <td style="padding: 8px;"><a href="mailto:${email}">${email}</a></td>
            </tr>
            <tr style="border-bottom: 1px solid #eee;">
              <td style="padding: 8px;"><strong>Subject:</strong></td>
              <td style="padding: 8px;">${subject}</td>
            </tr>
          </table>
          <h3 style="color: #1a1a1a; margin-top: 20px;">Message:</h3>
          <div style="background-color: #f5f5f5; border: 1px solid #ddd; padding: 15px; border-radius: 5px; white-space: pre-wrap; line-height: 1.5;">${message}</div>
        </div>
      `,
    };

    const info = await transporter.sendMail(mailOptions);

    return NextResponse.json(
      { message: "Your message has been sent successfully!" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      "[Contact API] A detailed error occurred during email sending:",
      error
    );

    const errorMessage =
      error.response || error.message || "An unknown error occurred.";
    return NextResponse.json(
      { error: `Failed to send email. Server responded with: ${errorMessage}` },
      { status: 500 }
    );
  }
}

// ===== src/app/api/countries/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';
import { Country } from '@/types/api-football';

export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/countries`,
    headers: {

      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);

    const transformedCountries: Country[] = response.data.response

      .filter((country: any) => country.name && country.code && country.flag)

      .map((country: any) => ({
        name: country.name,
        code: country.code,
        flagUrl: country.flag,
      }));

    transformedCountries.sort((a, b) => a.name.localeCompare(b.name));

    return NextResponse.json(transformedCountries);

  } catch (error) {

    return NextResponse.json(
      { error: 'Failed to fetch country data.' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/country-stats/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";

const POPULAR_LEAGUE_IDS = [
  39, 140, 135, 78, 61, 88, 94, 253, 2, 3, 45, 48, 71, 62, 144, 203, 197, 218,
];
const season = new Date().getFullYear();

export async function GET() {
  const options = (leagueId: number) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
    params: { league: leagueId, season: season },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    const teamPromises = POPULAR_LEAGUE_IDS.map((id) =>
      axios.request(options(id))
    );
    const responses = await Promise.allSettled(teamPromises);

    const allTeamsResponses = responses
      .filter(
        (result) => result.status === "fulfilled" && result.value.data.response
      )
      .flatMap(
        (result) => (result as PromiseFulfilledResult<any>).value.data.response
      );

    const uniqueTeams = Array.from(
      new Map(allTeamsResponses.map((item) => [item.team.id, item])).values()
    );

    const countryTeamCounts: { [key: string]: number } = {};
    uniqueTeams.forEach((item) => {
      const countryName = item.team.country;
      if (countryName) {
        if (!countryTeamCounts[countryName]) {
          countryTeamCounts[countryName] = 0;
        }
        countryTeamCounts[countryName]++;
      }
    });

    return NextResponse.json(countryTeamCounts);
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to fetch country statistics." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/cron/process-all-news/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle from "@/models/ExternalNewsArticle";
import { processSingleArticle } from "@/lib/ai-processing";

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder();
        const sendEvent = (log: string, eventType: string = "LOG") => {
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify({ event: eventType, data: log })}\n\n`)
          );
        };

        try {
          await dbConnect();
          const articlesToProcess = await ExternalNewsArticle.find({
            status: "fetched",
          }).sort({ pubDate: -1 });

          if (articlesToProcess.length === 0) {
            sendEvent("No new articles in the queue to process.", "COMPLETE");
            controller.close();
            return;
          }

          sendEvent(`Starting batch process for ${articlesToProcess.length} articles...`);

          let successCount = 0;
          let failureCount = 0;

          for (let i = 0; i < articlesToProcess.length; i++) {
            const article = articlesToProcess[i];
            sendEvent(`[${i + 1}/${articlesToProcess.length}] Processing: "${article.title}"`);

            const result = await processSingleArticle(article);

            if (result.success) {
              successCount++;
              sendEvent(` Success: "${article.title}" processed.`);
            } else {
              failureCount++;
              sendEvent(` Failed: "${article.title}". See server logs for details.`);
            }
          }

          sendEvent(`Batch complete. Processed: ${successCount}, Failed: ${failureCount}.`, "COMPLETE");

        } catch (error: any) {

          sendEvent(`A critical error occurred: ${error.message}`, "ERROR");
        } finally {
          controller.close();
        }
      },
    });

    return new Response(stream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      },
    });
  } catch (error: any) {

    return NextResponse.json(
      { error: "An unexpected server error occurred." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/cron/process-news-batch/route.ts =====

import { NextResponse } from "next/server";
import { headers } from "next/headers";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle from "@/models/ExternalNewsArticle";
import { processSingleArticle } from "@/lib/ai-processing";

const BATCH_SIZE = 1;

export async function GET(request: Request) {
  const headersList = headers();
  const authHeader = headersList.get("authorization");

  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return new Response("Unauthorized", { status: 401 });
  }

  console.log(
    "[CRON] Authorized request received. Starting automated news processing."
  );

  try {
    await dbConnect();

    const articlesToProcess = await ExternalNewsArticle.find({
      status: "fetched",
    })
      .sort({ pubDate: -1 })
      .limit(BATCH_SIZE);

    if (articlesToProcess.length === 0) {

      return NextResponse.json({ message: "No new articles to process." });
    }

    console.log(
      `[CRON] Found ${articlesToProcess.length} article(s) to process.`
    );
    let successCount = 0;
    let failureCount = 0;

    for (const article of articlesToProcess) {

      const result = await processSingleArticle(article);
      if (result.success) {
        successCount++;

      } else {
        failureCount++;

      }
    }

    const report = {
      message: "CRON job completed.",
      processed: successCount,
      failed: failureCount,
      total: articlesToProcess.length,
    };

    return NextResponse.json(report);
  } catch (error: any) {
    console.error(
      "[CRON] A critical error occurred during the batch processing job:",
      error
    );
    return NextResponse.json(
      { error: "Internal Server Error during CRON job." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/directory/countries/route.ts =====

import { NextResponse, NextRequest } from "next/server";
import axios from "axios";

export async function GET(request: NextRequest) {
  try {

    const protocol = request.headers.get("x-forwarded-proto") || "http";
    const host = request.headers.get("host");

    const internalApiUrl = `${protocol}://${host}/api/leagues?fetchAll=true`;

    const leaguesResponse = await axios.get(internalApiUrl);
    const allLeagues = leaguesResponse.data;

    if (!allLeagues || allLeagues.length === 0) {
      return NextResponse.json([]);
    }

    const leagueCounts: { [key: string]: number } = {};
    allLeagues.forEach((league: any) => {
      if (league.countryName) {
        leagueCounts[league.countryName] =
          (leagueCounts[league.countryName] || 0) + 1;
      }
    });

    const countriesResponse = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/countries`,
      {
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );

    const allCountries = countriesResponse.data.response;

    let enrichedCountries = allCountries
      .map((country: any) => ({
        name: country.name,
        code: country.code,
        flagUrl: country.flag,
        leagueCount: leagueCounts[country.name] || 0,
      }))
      .filter(
        (country: any) =>
          country.leagueCount > 0 &&
          country.name &&
          country.code &&
          country.flagUrl
      );

    enrichedCountries.sort((a, b) => a.name.localeCompare(b.name));

    return NextResponse.json(enrichedCountries);
  } catch (error) {

    if (axios.isAxiosError(error)) {

    }
    return NextResponse.json(
      { error: "Failed to build country directory." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/directory/standings-leagues/route.ts =====

import { NextResponse } from "next/server";
import { getLeaguesForStandingsSitemap } from "@/lib/data/directory";
import redis from "@/lib/redis";
import { generateStandingsSlug } from "@/lib/generate-standings-slug";

const CACHE_KEY = `leagues:directory:standings`;
const CACHE_TTL_SECONDS = 60 * 60 * 24;

export async function GET() {
  try {
    const cachedData = await redis.get(CACHE_KEY);
    if (cachedData) {
      return NextResponse.json(JSON.parse(cachedData));
    }

    const leagues = await getLeaguesForStandingsSitemap();

    const transformedData = leagues.map((league: any) => ({
      ...league,
      href: `/football/standings/${generateStandingsSlug(
        league.name,
        league.id
      )}`,
    }));

    if (transformedData.length > 0) {
      await redis.set(
        CACHE_KEY,
        JSON.stringify(transformedData),
        "EX",
        CACHE_TTL_SECONDS
      );
    }

    return NextResponse.json(transformedData);
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to fetch directory of leagues with standings." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/directory/teams/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';
import redis from '@/lib/redis';

const POPULAR_LEAGUE_IDS = [
  39, 140, 135, 78, 61, 88, 94, 253, 2,
];
const season = new Date().getFullYear();
const CACHE_KEY = `teams:popular:${season}`;
const CACHE_TTL_SECONDS = 60 * 60 * 24;

export async function GET() {
  try {

    const cachedData = await redis.get(CACHE_KEY);
    if (cachedData) {

      return NextResponse.json(JSON.parse(cachedData));
    }

    const options = (leagueId: number) => ({
      method: 'GET',
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
      params: { league: leagueId, season: season },
      headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    });

    const teamPromises = POPULAR_LEAGUE_IDS.map(id => axios.request(options(id)));
    const responses = await Promise.allSettled(teamPromises);

    const allTeamsResponses = responses
      .filter(result => result.status === 'fulfilled' && result.value.data.response)
      .flatMap(result => (result as PromiseFulfilledResult<any>).value.data.response);

    const uniqueTeams = Array.from(new Map(allTeamsResponses.map(item => [item.team.id, item])).values());

    uniqueTeams.sort((a, b) => a.team.name.localeCompare(b.team.name));

    if (uniqueTeams.length > 0) {
      await redis.set(CACHE_KEY, JSON.stringify(uniqueTeams), "EX", CACHE_TTL_SECONDS);

    }

    return NextResponse.json(uniqueTeams);

  } catch (error) {

    return NextResponse.json(
      { error: 'Failed to fetch teams data.' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/faqs/route.ts =====

import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import Faq from "@/models/Faq";

export async function GET() {
  try {
    await dbConnect();

    const faqs = await Faq.find({ isActive: true })
      .sort({ category: 1, order: 1 })
      .lean();

    return NextResponse.json(faqs);
  } catch (error) {

    return NextResponse.json(
      { error: "Server error fetching FAQs." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/find-live-matches/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: { live: 'all' },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);

    return NextResponse.json(response.data.response);
  } catch (error) {

    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src/app/api/fixtures/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import { format, addDays } from "date-fns";
import { leagueIdToPriorityMap } from "@/config/topLeaguesConfig";
import { getFixturesByDateRange } from "@/lib/data/fixtures";

const STATUS_MAP: Record<string, string[]> = {
  all: [],
  live: ["1H", "HT", "2H", "ET", "P", "LIVE"],
  finished: ["FT", "AET", "PEN"],
  scheduled: ["NS", "TBD", "PST"],
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get("league");
  const date = searchParams.get("date");
  const season = searchParams.get("season");
  const from = searchParams.get("from");
  const to = searchParams.get("to");

  const groupByLeague = searchParams.get("groupByLeague") === "true";
  const status = searchParams.get("status") || "all";
  const page = parseInt(searchParams.get("page") || "0", 10);
  const limit = parseInt(searchParams.get("limit") || "0", 10);

  const axiosOptions = (params: object) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params,
    headers: {
      "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  });

  try {
    if (from && to) {

      const fixtures = await getFixturesByDateRange(from, to);
      return NextResponse.json(fixtures);
    }

    if (groupByLeague) {
      const fetchDate = date || format(new Date(), "yyyy-MM-dd");
      const allFixtures = (
        await axios.request(axiosOptions({ date: fetchDate }))
      ).data.response;

      const statusFilter = STATUS_MAP[status] || [];
      const matchesToGroup =
        statusFilter.length > 0
          ? allFixtures.filter((m: any) =>
              statusFilter.includes(m.fixture.status.short)
            )
          : allFixtures;

      const groupedMatches = matchesToGroup.reduce((acc: any, match: any) => {
        const groupKey = match.league.id;
        if (!acc[groupKey]) {
          acc[groupKey] = {
            leagueInfo: {
              id: match.league.id,
              name: match.league.name,
              logo: match.league.logo,
              country: match.league.country,
              flag: match.league.flag,
            },
            matches: [],
          };
        }
        acc[groupKey].matches.push(match);
        return acc;
      }, {});

      const leagueEntries = Object.values(groupedMatches);

      leagueEntries.sort((a: any, b: any) => {
        const priorityA =
          leagueIdToPriorityMap.get(a.leagueInfo.id.toString()) || 999;
        const priorityB =
          leagueIdToPriorityMap.get(b.leagueInfo.id.toString()) || 999;

        if (priorityA !== priorityB) {
          return priorityA - priorityB;
        }
        if (a.leagueInfo.country !== b.leagueInfo.country) {
          return a.leagueInfo.country.localeCompare(b.leagueInfo.country);
        }
        return a.leagueInfo.name.localeCompare(b.leagueInfo.name);
      });

      if (limit > 0 && page > 0) {
        const totalLeagues = leagueEntries.length;
        const totalPages = Math.ceil(totalLeagues / limit);
        const startIndex = (page - 1) * limit;
        const endIndex = startIndex + limit;
        const paginatedLeagueGroups = leagueEntries.slice(startIndex, endIndex);

        return NextResponse.json({
          paginatedLeagueGroups,
          pagination: { currentPage: page, totalPages, totalLeagues },
        });
      } else {
        return NextResponse.json({ leagueGroups: leagueEntries });
      }
    }

    let matchesData: any[] = [];

    if (leagueId && season) {
      const response = await axios.request(
        axiosOptions({ league: leagueId, season: season })
      );
      matchesData = response.data.response.sort(
        (a: any, b: any) =>
          new Date(a.fixture.date).getTime() -
          new Date(b.fixture.date).getTime()
      );
    } else if (leagueId && date) {
      const response = await axios.request(
        axiosOptions({
          league: leagueId,
          season: new Date(date).getFullYear().toString(),
          date: date,
        })
      );
      matchesData = response.data.response;
    } else if (leagueId) {
      const today = format(new Date(), "yyyy-MM-dd");
      const nextSevenDays = format(addDays(new Date(), 7), "yyyy-MM-dd");
      const response = await axios.request(
        axiosOptions({
          league: leagueId,
          season: new Date().getFullYear().toString(),
          from: today,
          to: nextSevenDays,
        })
      );
      matchesData = response.data.response;
    } else if (date) {
      const response = await axios.request(axiosOptions({ date: date }));
      matchesData = response.data.response;
    } else {
      const todayStr = format(new Date(), "yyyy-MM-dd");
      const tomorrowStr = format(addDays(new Date(), 1), "yyyy-MM-dd");
      const [liveResponse, todayResponse, tomorrowResponse] = await Promise.all(
        [
          axios.request(axiosOptions({ live: "all" })),
          axios.request(axiosOptions({ date: todayStr })),
          axios.request(axiosOptions({ date: tomorrowStr })),
        ]
      );
      const allMatches = [
        ...liveResponse.data.response,
        ...todayResponse.data.response,
        ...tomorrowResponse.data.response,
      ];
      matchesData = Array.from(
        new Map(allMatches.map((m) => [m.fixture.id, m])).values()
      );
    }

    return NextResponse.json(matchesData);
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to fetch fixture data." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/global-live/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,

    params: { live: 'all' },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);

    return NextResponse.json(response.data.response);
  } catch (error) {

    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src/app/api/h2h/route.ts =====

import { NextResponse } from "next/server";
import { getH2H } from "@/lib/data/match";
import redis from "@/lib/redis";

const CACHE_TTL_SECONDS = 60 * 60 * 6;

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const homeTeamId = searchParams.get("home");
  const awayTeamId = searchParams.get("away");

  if (!homeTeamId || !awayTeamId) {
    return NextResponse.json(
      { error: "home and away team IDs are required parameters" },
      { status: 400 }
    );
  }

  const sortedIds = [homeTeamId, awayTeamId].sort();
  const cacheKey = `h2h:${sortedIds[0]}-${sortedIds[1]}`;

  try {
    const cachedData = await redis.get(cacheKey);
    if (cachedData) {
      return NextResponse.json(JSON.parse(cachedData));
    }

    const h2hData = await getH2H(Number(homeTeamId), Number(awayTeamId));

    if (!h2hData) {
      await redis.set(
        cacheKey,
        JSON.stringify([]),
        "EX",
        CACHE_TTL_SECONDS / 2
      );
      return NextResponse.json([]);
    }

    await redis.set(cacheKey, JSON.stringify(h2hData), "EX", CACHE_TTL_SECONDS);

    return NextResponse.json(h2hData);
  } catch (error: any) {
    console.error(
      `[API/h2h] Failed to get H2H for ${homeTeamId} vs ${awayTeamId}:`,
      error.message
    );

    return NextResponse.json([]);
  }
}

// ===== src/app/api/highlights/aggregate/route.ts =====

import { NextResponse } from "next/server";
import { getLatestPopularHighlights } from "@/lib/data/highlightly";

interface Highlight {
  id: string;
  title: string;
  thumbnailUrl: string;
  embedUrl: string;
  source: "Highlightly";
  publishedAt: string;
}

const fetchHighlights = async (): Promise<Highlight[]> => {
  try {
    const highlights = await getLatestPopularHighlights();
    if (!highlights || highlights.length === 0) {
      return [];
    }

    return highlights.map((item: any) => ({
      id: `hl-${item.id}`,
      title: item.title,
      thumbnailUrl: item.thumbnail,
      embedUrl: item.embedUrl,
      source: "Highlightly",
      publishedAt: item.match.date,
    }));
  } catch (error) {
    console.error(
      "[Aggregate Highlights] Error fetching from Highlightly service:",
      error
    );
    return [];
  }
};

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "12");

    const allHighlights = await fetchHighlights();

    const sortedHighlights = allHighlights.sort(
      (a, b) =>
        new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime()
    );

    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedHighlights = sortedHighlights.slice(startIndex, endIndex);

    const hasNextPage = endIndex < sortedHighlights.length;

    return NextResponse.json({
      highlights: paginatedHighlights,
      nextPage: hasNextPage ? page + 1 : null,
      total: sortedHighlights.length,
    });
  } catch (error) {
    console.error(
      "[Highlights Aggregate API] A critical error occurred:",
      error
    );
    return NextResponse.json(
      { error: "Failed to aggregate highlights." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/highlights/latest/route.ts =====

import { NextResponse } from "next/server";
import { getLatestPopularHighlights } from "@/lib/data/highlightly";

export async function GET(request: Request) {
  try {

    const validHighlights = await getLatestPopularHighlights();

    if (!validHighlights || validHighlights.length === 0) {
      return NextResponse.json({ highlights: [] }, { status: 200 });
    }

    const headers = new Headers();
    headers.set(
      "Cache-control",
      "public, s-maxage=300, stale-while-revalidate=600"
    );

    return NextResponse.json(
      { highlights: validHighlights },
      { status: 200, headers }
    );
  } catch (error: any) {
    console.error(
      `[API/highlights/latest] Error fetching latest highlights:`,
      error.message
    );
    return NextResponse.json(
      { error: "Failed to fetch latest highlights from the provider." },
      { status: 502 }
    );
  }
}

// ===== src/app/api/highlights/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import { getMatchHighlights } from "@/lib/data/highlightly";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get("fixtureId");

  if (!fixtureId) {
    return NextResponse.json(
      { error: "Fixture ID is required" },
      { status: 400 }
    );
  }

  try {

    const sportsApiUrl = `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures?id=${fixtureId}`;
    const sportsApiResponse = await axios.get(sportsApiUrl, {
      headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    });

    const fixtureData = sportsApiResponse.data.response[0];
    if (!fixtureData) {
      return NextResponse.json(
        { error: "Fixture data not found." },
        { status: 404 }
      );
    }

    const { league, teams } = fixtureData;

    const highlightlyParams = {
      leagueName: league.name,
      homeTeamName: teams.home.name,
      awayTeamName: teams.away.name,
      limit: 40,
    };

    const highlightsData = await getMatchHighlights(highlightlyParams);

    const headers = new Headers();
    headers.set(
      "Cache-Control",
      "public, s-maxage=600, stale-while-revalidate=1200"
    );

    let finalData = { highlights: highlightsData.data ?? [] };

    return NextResponse.json(finalData, { status: 200, headers });
  } catch (error: any) {
    console.error(
      `[API/highlights] Error processing highlights for fixture ${fixtureId}:`,
      error.message
    );

    return NextResponse.json(
      { error: "Failed to fetch highlights from the provider." },
      { status: 502 }
    );
  }
}

// ===== src/app/api/image-proxy/route.ts =====

import { NextRequest, NextResponse } from "next/server";
import redis from "@/lib/redis";

const CACHE_TTL_SECONDS = 60 * 60 * 24 * 7;

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const imageUrl = searchParams.get("url");

  if (!imageUrl) {
    return NextResponse.json(
      { error: "Image URL is required" },
      { status: 400 }
    );
  }

  const cacheKey = `image:${imageUrl}`;

  try {

    const cachedData = await redis.hgetall(cacheKey);

    if (cachedData && cachedData.buffer && cachedData.contentType) {

      const imageBuffer = Buffer.from(cachedData.buffer, 'binary');

      return new NextResponse(imageBuffer, {
        status: 200,
        headers: {
          "Content-Type": cachedData.contentType,
          "Cache-Control": "public, max-age=604800, immutable",
          "X-Cache-Status": "HIT",
        },
      });
    }

    const response = await fetch(imageUrl, {
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });

    if (!response.ok) {
      throw new Error(`Upstream fetch failed with status ${response.status}`);
    }

    const imageBuffer = Buffer.from(await response.arrayBuffer());
    const contentType = response.headers.get("content-type") || "image/png";

    const pipeline = redis.pipeline();
    pipeline.hset(cacheKey, {
        buffer: imageBuffer.toString('binary'),
        contentType: contentType,
    });
    pipeline.expire(cacheKey, CACHE_TTL_SECONDS);
    await pipeline.exec();

    return new NextResponse(imageBuffer, {
      status: 200,
      headers: {
        "Content-Type": contentType,
        "Cache-Control": "public, max-age=604800, immutable",
        "X-Cache-Status": "MISS",
      },
    });

  } catch (error: any) {

    return NextResponse.redirect(new URL("/images/placeholder-logo.svg", request.url));
  }
}

// ===== src/app/api/leagues/route.ts =====

import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import League from "@/models/League";
import { generateLeagueSlug } from "@/lib/generate-league-slug";
import redis from "@/lib/redis";

const POPULAR_LEAGUE_IDS = new Set([39, 140, 135, 78, 61, 88, 94, 253, 203]);
const POPULAR_CUP_IDS = new Set([2, 3, 531, 45, 9, 11]);
const CACHE_TTL_SECONDS = 60 * 60 * 6;

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);

  const fetchAll = searchParams.get("fetchAll") === "true";

  if (fetchAll) {

    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "15");
    const searchQuery = searchParams.get("search") || "";
    const type = searchParams.get("type");

    const skip = (page - 1) * limit;
    const cacheKey = `leagues:db:paginated:p${page}:l${limit}:q${searchQuery}:t${
      type || "all"
    }`;

    try {
      const cachedData = await redis.get(cacheKey);
      if (cachedData) {
        return NextResponse.json(JSON.parse(cachedData));
      }

      await dbConnect();
      const query: any = {};
      if (type && type !== "all") {
        query.type = type.charAt(0).toUpperCase() + type.slice(1);
      }
      if (searchQuery) {
        const regex = new RegExp(searchQuery, "i");
        query.$or = [
          { name: { $regex: regex } },
          { countryName: { $regex: regex } },
        ];
      }

      const [leaguesFromDB, totalCount] = await Promise.all([
        League.find(query).sort({ name: 1 }).skip(skip).limit(limit).lean(),
        League.countDocuments(query),
      ]);

      const totalPages = Math.ceil(totalCount / limit);
      const transformedData = leaguesFromDB.map((league) => ({
        id: league.leagueId,
        name: league.name,
        logoUrl: league.logoUrl,
        countryName: league.countryName,
        countryFlagUrl: league.countryFlagUrl,
        type: league.type,
        href: generateLeagueSlug(league.name, league.leagueId),
      }));

      const responseData = {
        leagues: transformedData,
        pagination: { currentPage: page, totalPages, totalCount },
      };
      await redis.set(
        cacheKey,
        JSON.stringify(responseData),
        "EX",
        CACHE_TTL_SECONDS
      );
      return NextResponse.json(responseData);
    } catch (error) {

      return NextResponse.json(
        { error: "Failed to fetch league data." },
        { status: 500 }
      );
    }
  } else {

    const country = searchParams.get("country");
    const type = searchParams.get("type");

    let cacheIdentifier = country
      ? country.toLowerCase().replace(/\s/g, "-")
      : "popular";
    const cacheKey = `leagues:db:non-paginated:${cacheIdentifier}:${
      type || "all"
    }`;

    try {
      const cachedData = await redis.get(cacheKey);
      if (cachedData) {
        return NextResponse.json(JSON.parse(cachedData));
      }

      await dbConnect();
      const query: any = {};
      if (country) {
        query.countryName = country;
      }
      if (type) {
        query.type = type.charAt(0).toUpperCase() + type.slice(1);
      }
      if (!country) {
        const popularIds =
          type === "cup"
            ? Array.from(POPULAR_CUP_IDS)
            : Array.from(POPULAR_LEAGUE_IDS);
        query.leagueId = { $in: popularIds };
      }

      const leaguesFromDB = await League.find(query).sort({ name: 1 }).lean();
      const transformedData = leaguesFromDB.map((league) => ({
        id: league.leagueId,
        name: league.name,
        logoUrl: league.logoUrl,
        countryName: league.countryName,
        countryFlagUrl: league.countryFlagUrl,
        type: league.type,
        href: generateLeagueSlug(league.name, league.leagueId),
      }));

      await redis.set(
        cacheKey,
        JSON.stringify(transformedData),
        "EX",
        CACHE_TTL_SECONDS
      );
      return NextResponse.json(transformedData);
    } catch (error) {
      console.error(
        `[API/leagues] Error fetching non-paginated leagues:`,
        error
      );
      return NextResponse.json(
        { error: "Failed to fetch league data." },
        { status: 500 }
      );
    }
  }

}

// ===== src/app/api/lineups/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import redis from "@/lib/redis";

const CACHE_TTL_LIVE = 60 * 5;
const CACHE_TTL_FINISHED = 60 * 60 * 24 * 7;

const apiRequest = async (endpoint: string, params: object) => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };
  try {
    const response = await axios.request(options);
    return response.data.response;
  } catch (error) {

    return null;
  }
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get("fixtureId");

  if (!fixtureId) {
    return NextResponse.json(
      { error: "fixtureId is a required parameter" },
      { status: 400 }
    );
  }

  const cacheKey = `lineups:${fixtureId}`;

  try {
    const cachedData = await redis.get(cacheKey);
    if (cachedData) {
      return NextResponse.json(JSON.parse(cachedData));
    }

    const lineupsData = await apiRequest("fixtures/lineups", {
      fixture: fixtureId,
    });

    const fixtureData = await apiRequest("fixtures", { id: fixtureId });
    const isFinished = ["FT", "AET", "PEN"].includes(
      fixtureData?.[0]?.fixture?.status?.short
    );

    const ttl = isFinished ? CACHE_TTL_FINISHED : CACHE_TTL_LIVE;

    await redis.set(cacheKey, JSON.stringify(lineupsData || []), "EX", ttl);

    return NextResponse.json(lineupsData || []);
  } catch (error: any) {
    console.error(
      `[API/lineups] A critical error occurred for fixture ${fixtureId}:`,
      error.message
    );
    return NextResponse.json([], { status: 200 });
  }
}

// ===== src/app/api/live-matches/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');

  if (!leagueId) {
    return NextResponse.json({ error: 'League ID is required' }, { status: 400 });
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: {
      league: leagueId,
      live: 'all',
    },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);

    return NextResponse.json(response.data.response);
  } catch (error) {

    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src/app/api/live-odds/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET() {

    const options = {
        method: 'GET',
        url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds/live`,
        params: { bet: '1' },
        headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    };

    try {
        const response = await axios.request(options);

        if (!response.data.response || response.data.response.length === 0) {
            return NextResponse.json({}, { status: 200 });
        }

        const liveOddsObject = response.data.response.reduce((acc: any, fixtureData: any) => {
            const fixtureId = fixtureData.fixture.id;
            const bookmaker = fixtureData.bookmakers?.[0];
            const matchWinnerBet = bookmaker?.bets.find((bet: any) => bet.id === 1);

            if (matchWinnerBet) {
                const odds = matchWinnerBet.values.reduce((oddAcc: any, curr: any) => {
                    if (curr.value === 'Home') oddAcc.home = curr.odd;
                    if (curr.value === 'Draw') oddAcc.draw = curr.odd;
                    if (curr.value === 'Away') oddAcc.away = curr.odd;
                    return oddAcc;
                }, {});
                acc[fixtureId] = odds;
            }
            return acc;
        }, {});

        return NextResponse.json(liveOddsObject, { status: 200 });

    } catch (error) {

        return NextResponse.json(
            { error: 'Failed to fetch live odds data from the provider.' },
            { status: 500 }
        );
    }
}

// ===== src/app/api/live-odds-by-fixture/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";

const extractMainOdds = (odds: any[], betId: number, valueKeys: string[]) => {
  const betData = odds.find((o) => o.id === betId);
  if (!betData) return null;

  let targetValues = betData.values.find((v: any) => v.main === true)
    ? betData.values.filter((v: any) => v.main === true)
    : betData.values;

  const result: { [key: string]: string | null } = {};
  valueKeys.forEach((key) => {
    result[key.toLowerCase()] =
      targetValues.find((v: any) => v.value === key)?.odd || null;
  });

  result.handicap = targetValues[0]?.handicap || null;

  const hasValues = Object.values(result).some(
    (v) => v !== null && v !== undefined
  );
  return hasValues ? result : null;
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get("fixture");

  if (!fixtureId) {
    return NextResponse.json(
      { error: "Fixture ID is required" },
      { status: 400 }
    );
  }

  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds/live`,
    params: { fixture: fixtureId },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };

  try {
    const response = await axios.request(options);
    const liveData = response.data.response[0];

    if (!liveData || !liveData.odds) {
      return NextResponse.json(null);
    }

    const odds = liveData.odds;

    const curatedOdds = {
      asianHandicap: extractMainOdds(odds, 33, ["Home", "Away"]),
      overUnder: extractMainOdds(odds, 36, ["Over", "Under"]),
      matchCorners: extractMainOdds(odds, 20, ["Over", "Under"]),
      nextGoal: extractMainOdds(odds, 85, ["1", "No goal", "2"]),
    };

    return NextResponse.json(curatedOdds);
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to fetch live odds" },
      { status: 500 }
    );
  }
}

// ===== src/app/api/match-details/route.ts =====

import { NextResponse } from "next/server";
import redis from "@/lib/redis";
import { getFixture, getStatistics } from "@/lib/data/match";

const CACHE_TTL_LIVE = 60;
const CACHE_TTL_FINISHED = 60 * 60 * 24 * 7;
const CACHE_TTL_UPCOMING = 60 * 15;

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get("fixture");
  const locale = searchParams.get("locale") || "tr";

  if (!fixtureId) {
    return NextResponse.json(
      { error: "Fixture ID is required" },
      { status: 400 }
    );
  }

  const cacheKey = `match-details-core-v9:${fixtureId}:${locale}`;

  try {
    const cachedData = await redis.get(cacheKey);
    if (cachedData) {
      return NextResponse.json(JSON.parse(cachedData));
    }

    const fixtureData = await getFixture(fixtureId);
    if (!fixtureData) {
      return NextResponse.json({ error: "Fixture not found" }, { status: 404 });
    }

    const { fixture } = fixtureData;

    const settledPromises = await Promise.allSettled([
      getStatistics(fixtureId),
    ]);

    const getValue = (result: PromiseSettledResult<any>, fallback: any) => {
      if (result.status === "fulfilled") return result.value;
      console.error(
        `[API/match-details] A sub-request failed for fixture ${fixtureId}:`,
        result.reason
      );
      return fallback;
    };

    const statistics = getValue(settledPromises[0], []);

    if (fixtureData.lineups) {
      delete fixtureData.lineups;
    }

    const responseData = {
      fixture: fixtureData,
      statistics,
    };

    const status = fixture.status.short;
    let ttl = CACHE_TTL_UPCOMING;
    if (["1H", "HT", "2H", "ET", "P", "LIVE"].includes(status)) {
      ttl = CACHE_TTL_LIVE;
    } else if (["FT", "AET", "PEN"].includes(status)) {
      ttl = CACHE_TTL_FINISHED;
    }

    await redis.set(cacheKey, JSON.stringify(responseData), "EX", ttl);

    return NextResponse.json(responseData);
  } catch (error: any) {
    console.error(
      `[API /match-details] A critical error occurred for fixture ${fixtureId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Failed to fetch core match details." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/match-highlights/route.ts =====

import { NextResponse } from "next/server";
import { getMatchHighlights } from "@/lib/data/highlightly";
import redis from "@/lib/redis";

const CACHE_TTL_SECONDS = 60 * 60 * 2;

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueName = searchParams.get("leagueName");
  const homeTeamName = searchParams.get("homeTeamName");
  const awayTeamName = searchParams.get("awayTeamName");

  if (!leagueName || !homeTeamName || !awayTeamName) {
    return NextResponse.json(
      { error: "leagueName, homeTeamName, and awayTeamName are required" },
      { status: 400 }
    );
  }

  const cacheKey =
    `highlights:${leagueName}:${homeTeamName}:${awayTeamName}`.replace(
      /\s+/g,
      "-"
    );

  try {
    const cachedData = await redis.get(cacheKey);
    if (cachedData) {
      return NextResponse.json(JSON.parse(cachedData));
    }

    const highlightsData = await getMatchHighlights({
      leagueName,
      homeTeamName,
      awayTeamName,
      limit: 10,
    });

    const highlights = highlightsData?.data ?? [];

    await redis.set(
      cacheKey,
      JSON.stringify(highlights),
      "EX",
      CACHE_TTL_SECONDS
    );

    return NextResponse.json(highlights);
  } catch (error: any) {
    console.error(
      `[API/match-highlights] Failed to get highlights:`,
      error.message
    );
    return NextResponse.json(
      { error: "Failed to fetch highlights from the provider." },
      { status: 502 }
    );
  }
}

// ===== src/app/api/match-prediction/route.ts =====

import { NextResponse } from "next/server";
import {
  getFixture,
  getH2H,
  getTeamStats,
  getStandings,
  getBookmakerOdds,
} from "@/lib/data/match";
import { calculateCustomPrediction } from "@/lib/prediction-engine";
import redis from "@/lib/redis";

const STALE_CACHE_TTL_SECONDS = 60 * 60 * 24 * 3;

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get("fixtureId");

  if (!fixtureId) {
    return NextResponse.json(
      { error: "Fixture ID is required" },
      { status: 400 }
    );
  }

  const cacheKey = `prediction-data-v3:${fixtureId}`;

  try {

    const fixtureData = await getFixture(fixtureId);
    if (!fixtureData) {
      throw new Error(`Fixture not found for ID: ${fixtureId}`);
    }

    const { league, teams } = fixtureData;
    const { home, away } = teams;

    const results = await Promise.allSettled([
      getH2H(home.id, away.id),
      getTeamStats(league.id, league.season, home.id),
      getTeamStats(league.id, league.season, away.id),
      getStandings(league.id, league.season),
      getBookmakerOdds(fixtureId),
    ]);

    const getValue = (result: PromiseSettledResult<any>, fallback: any) => {
      if (result.status === "fulfilled") return result.value;

      console.warn(
        `[API/match-prediction] A sub-request failed for fixture ${fixtureId}:`,
        result.reason
      );
      return fallback;
    };

    const h2h = getValue(results[0], []);
    const homeTeamStats = getValue(results[1], null);
    const awayTeamStats = getValue(results[2], null);
    const standingsResponse = getValue(results[3], []);
    const bookmakerOdds = getValue(results[4], []);

    const flatStandings =
      standingsResponse?.[0]?.league?.standings?.flat() || [];
    const homeTeamRank = flatStandings.find(
      (s: any) => s.team.id === home.id
    )?.rank;
    const awayTeamRank = flatStandings.find(
      (s: any) => s.team.id === away.id
    )?.rank;

    const customPrediction = calculateCustomPrediction(
      h2h,
      homeTeamStats,
      awayTeamStats,
      home.id,
      homeTeamRank,
      awayTeamRank,
      null,
      fixtureData.fixture.status.short
    );

    const responseData = {
      customPrediction,
      bookmakerOdds: bookmakerOdds?.[0]?.bookmakers ?? [],
      teams,
    };

    await redis.set(
      cacheKey,
      JSON.stringify(responseData),
      "EX",
      STALE_CACHE_TTL_SECONDS
    );

    console.log(
      `[API/match-prediction]  Successfully served FRESH data for fixture ${fixtureId}`
    );
    return NextResponse.json(responseData);
  } catch (error: any) {

    console.error(
      `[API/match-prediction] LIVE FETCH FAILED for fixture ${fixtureId}: ${error.message}. Attempting to serve stale data...`
    );

    try {
      const cachedData = await redis.get(cacheKey);
      if (cachedData) {
        console.log(
          `[API/match-prediction]  Successfully served STALE data for fixture ${fixtureId}`
        );
        return NextResponse.json(JSON.parse(cachedData));
      } else {
        console.error(
          `[API/match-prediction]  No stale data in cache for fixture ${fixtureId}. Data is truly unavailable.`
        );
        return NextResponse.json(null, { status: 200 });
      }
    } catch (cacheError: any) {
      console.error(
        `[API/match-prediction]  CRITICAL: Redis lookup failed during fallback for fixture ${fixtureId}:`,
        cacheError.message
      );
      return NextResponse.json(null, { status: 200 });
    }
  }
}

// ===== src/app/api/odds/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);
    const fixtureId = searchParams.get('fixture');

    if (!fixtureId) {
        return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
    }

    const options = {
        method: 'GET',
        url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds`,
        params: {
            fixture: fixtureId,
            bookmaker: '8',
            bet: '1'
        },
        headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    };

    try {

        const response = await axios.request(options);

        if (!response.data.response || response.data.response.length === 0) {

            return NextResponse.json(null, { status: 200 });
        }

        const bookmaker = response.data.response[0].bookmakers[0];

        const matchWinnerBet = bookmaker.bets.find((bet: any) => bet.id === 1);

        if (!matchWinnerBet || !matchWinnerBet.values) {

            return NextResponse.json(null, { status: 200 });
        }

        const odds = matchWinnerBet.values.reduce((acc: any, curr: any) => {
            if (curr.value === 'Home') acc.home = curr.odd;
            if (curr.value === 'Draw') acc.draw = curr.odd;
            if (curr.value === 'Away') acc.away = curr.odd;
            return acc;
        }, {});

        return NextResponse.json(odds, { status: 200 });

    } catch (error) {

        return NextResponse.json(
            { error: 'Failed to fetch odds data from the provider.' },
            { status: 500 }
        );
    }
}

// ===== src/app/api/pages/[pageSlug]/route.ts =====

import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import PageContent from "@/models/PageContent";

interface Params {
  params: Promise<{ pageSlug: string }>;
}

export async function GET(request: Request, { params }: Params) {
  try {
    const { pageSlug } = await params;
    if (!pageSlug) {
      return NextResponse.json(
        { error: "Page slug is required." },
        { status: 400 }
      );
    }

    await dbConnect();

    const pageContent = await PageContent.findOne({ pageSlug }).lean();

    if (!pageContent) {
      return NextResponse.json(
        { error: "Page content not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(pageContent);
  } catch (error) {
    console.error(
      `[API/pages] Error fetching page content for slug "${
        (await params).pageSlug
      }":`,
      error
    );
    return NextResponse.json(
      { error: "Server error fetching page content." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/posts/[postId]/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post, { IPost } from "@/models/Post";
import slugify from "slugify";

interface Params {
  params: { postId: string };
}

export async function GET(request: Request, { params }: Params) {

  const { postId } = params;
  try {
    await dbConnect();
    const post = await Post.findById(postId);
    if (!post) {
      return NextResponse.json({ error: "Post not found" }, { status: 404 });
    }
    return NextResponse.json(post);
  } catch (error) {

    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}

export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { postId } = params;
  try {
    const body: Partial<IPost> & { slug?: string } = await request.json();
    const { title, slug, content } = body;

    if (!title || !content) {
      return NextResponse.json(
        { error: "Title and content are required." },
        { status: 400 }
      );
    }

    await dbConnect();

    const existingPost = await Post.findById(postId);
    if (!existingPost) {
      return NextResponse.json({ error: "Post not found" }, { status: 404 });
    }

    const finalSlug = slugify(slug || title, { lower: true, strict: true });

    const slugExists = await Post.findOne({
      slug: finalSlug,
      language: existingPost.language,
      _id: { $ne: postId },
    });

    if (slugExists) {
      return NextResponse.json(
        {
          error: `The slug '${finalSlug}' is already in use by another post in this language.`,
        },
        { status: 409 }
      );
    }

    const updatedPost = await Post.findByIdAndUpdate(
      postId,
      { ...body, slug: finalSlug },
      { new: true, runValidators: true }
    );

    return NextResponse.json(updatedPost);
  } catch (error: any) {

    if (error.code === 11000) {
      return NextResponse.json(
        {
          error:
            "This slug is already in use for this language. Please choose a unique slug.",
        },
        { status: 409 }
      );
    }
    if (error.name === "ValidationError") {
      return NextResponse.json({ error: error.message }, { status: 400 });
    }

    return NextResponse.json(
      { error: "An unexpected server error occurred while updating the post." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, { params }: Params) {

  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { postId } = params;
  try {
    await dbConnect();
    const deletedPost = await Post.findByIdAndDelete(postId);
    if (!deletedPost) {
      return NextResponse.json({ error: "Post not found" }, { status: 404 });
    }
    return NextResponse.json({ message: "Post deleted successfully" });
  } catch (error) {

    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}

// ===== src/app/api/posts/route.ts =====

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post, { IPost, NewsType, SportsCategory } from "@/models/Post";
import { getNews } from "@/lib/data/news";
import slugify from "slugify";
import mongoose from "mongoose";

const DEFAULT_LOCALE = "tr";

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const locale = searchParams.get("language") || DEFAULT_LOCALE;
    const sportsCategory = searchParams.get(
      "sportsCategory"
    ) as SportsCategory | null;
    const newsType = searchParams.get("newsType") as NewsType | null;
    const pageParam = searchParams.get("page");
    const limitParam = searchParams.get("limit");

    const fixtureIdParam = searchParams.get("linkedFixtureId");

    const page = pageParam ? parseInt(pageParam, 10) : 1;
    const limit = limitParam ? parseInt(limitParam, 10) : 10;

    const linkedFixtureId = fixtureIdParam
      ? parseInt(fixtureIdParam, 10)
      : undefined;

    const { posts, pagination } = await getNews({
      locale,
      sportsCategory: sportsCategory || undefined,
      newsType: newsType || undefined,
      page,
      limit,
      linkedFixtureId,
    });

    return NextResponse.json({ posts, pagination });
  } catch (error) {

    return NextResponse.json(
      { error: "Server error fetching posts" },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body: Partial<IPost> & {
      language: string;
      translationGroupId?: string;
      slug?: string;
    } = await request.json();
    const { title, slug, content, language } = body;

    if (!title || !content || !language) {
      return NextResponse.json(
        { error: "Title, content, and language are required" },
        { status: 400 }
      );
    }

    await dbConnect();

    const finalSlug = slugify(slug || title, { lower: true, strict: true });

    const slugExists = await Post.findOne({ slug: finalSlug, language });
    if (slugExists) {
      return NextResponse.json(
        {
          error: `A post with the slug '${finalSlug}' already exists in this language.`,
        },
        { status: 409 }
      );
    }

    const newPost = new Post({
      ...body,
      slug: finalSlug,
      author: session.user.name || "Admin",
      translationGroupId: body.translationGroupId
        ? new mongoose.Types.ObjectId(body.translationGroupId)
        : new mongoose.Types.ObjectId(),
    });

    await newPost.save();
    return NextResponse.json(newPost, { status: 201 });
  } catch (error: any) {

    if (error.code === 11000) {
      return NextResponse.json(
        {
          error:
            "This slug is already in use for this language. Please choose a unique slug.",
        },
        { status: 409 }
      );
    }
    if (error.name === "ValidationError") {
      return NextResponse.json({ error: error.message }, { status: 400 });
    }

    return NextResponse.json(
      { error: "An unexpected server error occurred while creating the post." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/predictions/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get('fixture');

  if (!fixtureId) {
    return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/predictions`,
    params: { fixture: fixtureId },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    if (!response.data.response || response.data.response.length === 0) {
      return NextResponse.json({ error: 'No prediction available.' }, { status: 404 });
    }

    const predictionData = response.data.response[0];

    const transformedPrediction = {
      teams: {
        home: {
          id: predictionData.teams.home.id,
          name: predictionData.teams.home.name,
          logo: predictionData.teams.home.logo,
        },
        away: {
          id: predictionData.teams.away.id,
          name: predictionData.teams.away.name,
          logo: predictionData.teams.away.logo,
        }
      },
      percent: {
        home: parseInt(predictionData.predictions.percent.home.replace('%', '')),
        draw: parseInt(predictionData.predictions.percent.draw.replace('%', '')),
        away: parseInt(predictionData.predictions.percent.away.replace('%', '')),
      }
    };

    return NextResponse.json(transformedPrediction);

  } catch (error) {

    return NextResponse.json({ error: 'Failed to fetch prediction data.' }, { status: 500 });
  }
}

// ===== src/app/api/predictions/upcoming/route.ts =====

import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import Prediction from "@/models/Prediction";
import { format } from "date-fns";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get("page") || "1");
  const limit = parseInt(searchParams.get("limit") || "12");
  const skip = (page - 1) * limit;

  try {
    await dbConnect();

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const [predictions, totalCount] = await Promise.all([
      Prediction.find({ fixtureDate: { $gte: today } })
        .sort({ fixtureDate: 1 })
        .skip(skip)
        .limit(limit)
        .lean(),
      Prediction.countDocuments({ fixtureDate: { $gte: today } }),
    ]);

    const formattedFixtures = predictions.map((p) => ({
      fixture: {
        id: p.fixtureId,
        date: p.fixtureDate,
        status: { short: p.status },
      },
      ...p,
    }));

    const hasNextPage = skip + limit < totalCount;

    return NextResponse.json({
      fixtures: formattedFixtures,
      nextPage: hasNextPage ? page + 1 : null,
    });
  } catch (error) {
    console.error(
      "[API/predictions/upcoming] Error fetching pre-generated predictions:",
      error
    );
    return NextResponse.json(
      { error: "Failed to fetch upcoming predictions." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/recent-news/route.ts =====

import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import RecentNews, { IRecentNews } from "@/models/RecentNews";

const DEFAULT_LOCALE = "tr";

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const locale = searchParams.get("locale") || DEFAULT_LOCALE;
    const limitParam = searchParams.get("limit");
    const limit = limitParam ? parseInt(limitParam, 10) : 10;

    await dbConnect();

    const pipeline = [
      { $match: { language: { $exists: true } } },
      {
        $addFields: {
          effectiveGroupId: { $ifNull: ["$translationGroupId", "$_id"] },
        },
      },
      {
        $addFields: {
          langPriority: {
            $cond: {
              if: { $eq: ["$language", locale] },
              then: 1,
              else: {
                $cond: {
                  if: { $eq: ["$language", DEFAULT_LOCALE] },
                  then: 2,
                  else: 3,
                },
              },
            },
          },
        },
      },
      { $sort: { effectiveGroupId: 1, langPriority: 1 } },
      {
        $group: {
          _id: "$effectiveGroupId",
          document: { $first: "$$ROOT" },
        },
      },
      { $replaceRoot: { newRoot: "$document" } },
      { $sort: { createdAt: -1 } },
      { $limit: limit },
    ];

    const recentNewsItems: IRecentNews[] = await RecentNews.aggregate(pipeline);

    return NextResponse.json(recentNewsItems);
  } catch (error) {

    return NextResponse.json(
      { error: "Server error fetching recent news" },
      { status: 500 }
    );
  }
}

// ===== src/app/api/search/fixtures/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import { format, addDays } from "date-fns";

const apiRequest = async (endpoint: string, params: object): Promise<any[]> => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    timeout: 8000,
  };
  try {
    const response = await axios.request(options);
    return response.data.response;
  } catch (error: any) {
    console.error(
      `[API Search Helper] Error fetching '${endpoint}' with params ${JSON.stringify(
        params
      )}:`,
      error.message
    );
    return [];
  }
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get("q");

  if (!query || query.length < 3) {
    return NextResponse.json(
      { error: "A search query with at least 3 characters is required." },
      { status: 400 }
    );
  }

  const season = new Date().getFullYear().toString();
  const fromDate = format(new Date(), "yyyy-MM-dd");
  const toDate = format(addDays(new Date(), 30), "yyyy-MM-dd");

  try {

    const [teamResults, leagueResults] = await Promise.all([
      apiRequest("teams", { search: query }),
      apiRequest("leagues", { search: query }),
    ]);

    const teamIds = teamResults.map((t: any) => t.team.id);
    const leagueIds = leagueResults.map((l: any) => l.league.id);

    if (teamIds.length === 0 && leagueIds.length === 0) {

      return NextResponse.json([]);
    }

    const fixturePromises: Promise<any[]>[] = [];

    teamIds.forEach((teamId) => {
      fixturePromises.push(
        apiRequest("fixtures", {
          team: teamId,
          season: season,
          from: fromDate,
          to: toDate,
        })
      );
    });

    leagueIds.forEach((leagueId) => {
      fixturePromises.push(
        apiRequest("fixtures", {
          league: leagueId,
          season: season,
          from: fromDate,
          to: toDate,
        })
      );
    });

    const allFixtureResponses = await Promise.all(fixturePromises);
    const allFixtures = allFixtureResponses.flat();

    const uniqueFixtures = Array.from(
      new Map(allFixtures.map((m) => [m.fixture.id, m])).values()
    );

    uniqueFixtures.sort((a, b) => a.fixture.timestamp - b.fixture.timestamp);

    return NextResponse.json(uniqueFixtures);
  } catch (error: any) {
    console.error(
      `[API Search] Critical error for query "${query}":`,
      error.message
    );
    return NextResponse.json(
      { error: "Failed to fetch search results." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/search/global/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import { generateLeagueSlug } from "@/lib/generate-league-slug";
import { generateTeamSlug } from "@/lib/generate-team-slug";

const apiRequest = async (endpoint: string, params: object): Promise<any[]> => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    timeout: 5000,
  };
  try {
    const response = await axios.request(options);
    return response.data.response;
  } catch (error) {

    return [];
  }
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get("q");

  if (!query || query.length < 3) {
    return NextResponse.json(
      { error: "A search query of at least 3 characters is required." },
      { status: 400 }
    );
  }

  try {
    const [teamResults, leagueResults] = await Promise.all([
      apiRequest("teams", { search: query }),
      apiRequest("leagues", { search: query }),
    ]);

    const teams = teamResults.slice(0, 5).map((t: any) => ({
      id: t.team.id,
      name: t.team.name,
      logo: t.team.logo,
      country: t.team.country,
      href: generateTeamSlug(t.team.name, t.team.id),
    }));

    const leagues = leagueResults.slice(0, 5).map((l: any) => ({
      id: l.league.id,
      name: l.league.name,
      logo: l.league.logo,
      country: l.country.name,
      href: generateLeagueSlug(l.league.name, l.league.id),
    }));

    return NextResponse.json({ teams, leagues });
  } catch (error) {
    console.error(
      `[Global Search API] Critical error for query "${query}":`,
      error
    );
    return NextResponse.json(
      { error: "Failed to fetch search results." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/sports/[sport]/fixtures/route.ts =====

import { NextResponse } from 'next/server';
import { getSportService } from '@/services/sports';

export async function GET(
  request: Request,
  { params }: { params: { sport: string } }
) {
  const { searchParams } = new URL(request.url);
  const sport = params.sport;

  const queryParams: { [key: string]: any } = {};
  searchParams.forEach((value, key) => {
    queryParams[key] = value;
  });

  try {

    const sportService = getSportService(sport);

    const fixtures = await sportService.getFixtures(queryParams);

    return NextResponse.json(fixtures);

  } catch (error: any) {

    return NextResponse.json(
      { error: `Failed to fetch fixture data for ${sport}.` },
      { status: 500 }
    );
  }
}

// ===== src/app/api/standings/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import { generateLeagueSlug } from "@/lib/generate-league-slug";
import redis from "@/lib/redis";

const CACHE_TTL_SECONDS = 60 * 60 * 2;

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get("league");
  const season =
    searchParams.get("season") || new Date().getFullYear().toString();
  const date = searchParams.get("date");

  if (!leagueId) {
    return NextResponse.json(
      { error: "League ID is required" },
      { status: 400 }
    );
  }

  const cacheKey = `standings:detailed:${leagueId}:${season}:${
    date || "latest"
  }`;

  try {
    const cachedData = await redis.get(cacheKey);
    if (cachedData) {
      return NextResponse.json(JSON.parse(cachedData));
    }

    const options = (endpoint: string, params: object) => ({
      method: "GET",
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
      params,
      headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    });

    const standingsParams: { league: string; season: string; date?: string } = {
      league: leagueId,
      season: season,
    };
    if (date) {
      standingsParams.date = date;
    }

    const [standingsResponse, topScorersResponse, leagueDetailsResponse] =
      await Promise.all([
        axios.request(options("standings", standingsParams)),
        axios.request(
          options("players/topscorers", { league: leagueId, season: season })
        ),
        axios.request(options("leagues", { id: leagueId })),
      ]);

    if (
      !standingsResponse.data.response ||
      standingsResponse.data.response.length === 0
    ) {
      const emptyResponse = {
        league: null,
        standings: [],
        leagueStats: null,
        topScorer: null,
      };
      await redis.set(
        cacheKey,
        JSON.stringify(emptyResponse),
        "EX",
        CACHE_TTL_SECONDS
      );
      return NextResponse.json(emptyResponse);
    }

    const data = standingsResponse.data.response[0];
    const topScorer = topScorersResponse.data.response?.[0] || null;
    const leagueDetails = leagueDetailsResponse.data.response?.[0] || {};

    const allStandings = data.league.standings.flat();
    const totalMatchesPlayed =
      allStandings.reduce(
        (sum: number, team: any) => sum + team.all.played,
        0
      ) / 2;
    const totalGoalsScored = allStandings.reduce(
      (sum: number, team: any) => sum + team.all.goals.for,
      0
    );
    const avgGoalsPerMatch =
      totalMatchesPlayed > 0
        ? (totalGoalsScored / totalMatchesPlayed).toFixed(2)
        : "0.00";

    const leagueStats = {
      totalGoals: totalGoalsScored,
      avgGoals: avgGoalsPerMatch,
      totalMatches: Math.floor(totalMatchesPlayed),
    };

    const transformedData = {
      league: {
        id: data.league.id,
        name: data.league.name,
        country: data.league.country,
        logo: data.league.logo,
        type: data.league.type,
        season: data.league.season,
        seasons: leagueDetails.seasons
          ?.map((s: any) => s.year)
          .sort((a: number, b: number) => b - a) || [season],
        href: generateLeagueSlug(data.league.name, data.league.id),
      },
      standings: data.league.standings,
      leagueStats,
      topScorer,
    };

    await redis.set(
      cacheKey,
      JSON.stringify(transformedData),
      "EX",
      CACHE_TTL_SECONDS
    );

    return NextResponse.json(transformedData);
  } catch (error) {
    console.error(
      `[API/standings] Error for league ${leagueId} season ${season}:`,
      error
    );
    return NextResponse.json(
      { error: "Failed to fetch standings data" },
      { status: 500 }
    );
  }
}

// ===== src/app/api/team-details/route.ts =====

import { NextResponse } from "next/server";
import { getTeamStats } from "@/lib/data/match";
import redis from "@/lib/redis";

const CACHE_TTL_SECONDS = 60 * 60 * 6;

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const teamId = searchParams.get("team");
  const leagueId = searchParams.get("league");
  const season = searchParams.get("season");

  if (!teamId || !leagueId || !season) {
    return NextResponse.json(
      { error: "team, league, and season are required parameters" },
      { status: 400 }
    );
  }

  const cacheKey = `team-stats:${teamId}:${leagueId}:${season}`;

  try {
    const cachedData = await redis.get(cacheKey);
    if (cachedData) {
      return NextResponse.json(JSON.parse(cachedData));
    }

    const teamStats = await getTeamStats(
      Number(leagueId),
      Number(season),
      Number(teamId)
    );

    if (!teamStats) {

      await redis.set(
        cacheKey,
        JSON.stringify(null),
        "EX",
        CACHE_TTL_SECONDS / 2
      );
      return NextResponse.json(null, { status: 404 });
    }

    await redis.set(
      cacheKey,
      JSON.stringify(teamStats),
      "EX",
      CACHE_TTL_SECONDS
    );

    return NextResponse.json(teamStats);
  } catch (error: any) {
    console.error(
      `[API/team-details] Failed to get stats for team ${teamId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Failed to fetch team statistics." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/team-form-data/route.ts =====

import { NextResponse } from "next/server";
import { getTeamStats } from "@/lib/data/match";
import redis from "@/lib/redis";

const CACHE_TTL_SECONDS = 60 * 60 * 6;

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const teamId = searchParams.get("teamId");
  const leagueId = searchParams.get("leagueId");
  const season = searchParams.get("season");

  if (!teamId || !leagueId || !season) {
    return NextResponse.json(
      { error: "teamId, leagueId, and season are required" },
      { status: 400 }
    );
  }

  const cacheKey = `team-form-data:${teamId}:${leagueId}:${season}`;

  try {
    const cachedData = await redis.get(cacheKey);
    if (cachedData) {
      return NextResponse.json(JSON.parse(cachedData));
    }

    const teamStats = await getTeamStats(
      Number(leagueId),
      Number(season),
      Number(teamId)
    );

    const responseData = teamStats || null;

    await redis.set(
      cacheKey,
      JSON.stringify(responseData),
      "EX",
      CACHE_TTL_SECONDS
    );

    return NextResponse.json(responseData);
  } catch (error: any) {
    console.error(
      `[API/team-form-data] Failed to get data for team ${teamId}:`,
      error.message
    );

    return NextResponse.json(null, { status: 200 });
  }
}

// ===== src/app/api/team-trophies/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const teamId = searchParams.get("team");

  if (!teamId) {
    return NextResponse.json({ error: "Team ID is required" }, { status: 400 });
  }

  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/trophies`,
    params: { team: teamId },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };

  try {
    const response = await axios.request(options);

    const sortedTrophies = response.data.response.sort((a: any, b: any) => {
      const seasonB = parseInt(b.season.split("-")[0]);
      const seasonA = parseInt(a.season.split("-")[0]);
      return seasonB - seasonA;
    });
    return NextResponse.json(sortedTrophies);
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to fetch trophies" },
      { status: 500 }
    );
  }
}

// ===== src/app/api/teams/paginated/route.ts =====

import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import Team from "@/models/Team";

export async function GET(request: Request) {
  try {
    await dbConnect();

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "21");
    const searchQuery = searchParams.get("search") || "";

    const skip = (page - 1) * limit;

    const query: any = {};
    if (searchQuery.length >= 3) {
      const regex = new RegExp(searchQuery, "i");
      query.$or = [
        { name: { $regex: regex } },
        { country: { $regex: regex } },
        { venueName: { $regex: regex } },
        { venueCity: { $regex: regex } },
      ];
    }

    const [teams, totalCount] = await Promise.all([
      Team.find(query)
        .sort({ country: 1, name: 1 })
        .skip(skip)
        .limit(limit)
        .lean(),
      Team.countDocuments(query),
    ]);

    const formattedTeams = teams.map((team) => ({
      team: {
        id: team.teamId,
        name: team.name,
        logo: team.logoUrl,
        country: team.country,
        founded: team.founded,
      },
      venue: {
        name: team.venueName,
        city: team.venueCity,
      },
    }));

    const totalPages = Math.ceil(totalCount / limit);

    return NextResponse.json({
      teams: formattedTeams,
      pagination: {
        currentPage: page,
        totalPages,
        totalCount,
      },
    });
  } catch (error: any) {

    return NextResponse.json(
      { error: "Server error fetching paginated teams." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/teams/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');
  const season = searchParams.get('season');

  if (!leagueId || !season) {
    return NextResponse.json(
      { error: 'League ID and season are required' },
      { status: 400 }
    );
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
    params: {
      league: leagueId,
      season: season,
    },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);

    return NextResponse.json(response.data.response);

  } catch (error) {

    return NextResponse.json(
      { error: 'Failed to fetch teams data.' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/teams-by-country/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";

const season = new Date().getFullYear();

const apiRequest = async (endpoint: string, params: object) => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };
  const response = await axios.request(options);
  return response.data.response;
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const country = searchParams.get("country");

  if (!country) {
    return NextResponse.json(
      { error: "Country parameter is required" },
      { status: 400 }
    );
  }

  try {

    const leagues = await apiRequest("leagues", { country: country });
    if (!leagues || leagues.length === 0) {

      return NextResponse.json({ teams: [], count: 0 });
    }

    const leagueIds = leagues.map((l: any) => l.league.id);

    const teamPromises = leagueIds.map((id: any) =>
      apiRequest("teams", { league: id, season: season })
    );
    const responses = await Promise.allSettled(teamPromises);

    const allTeamsResponses = responses
      .filter((result) => result.status === "fulfilled" && result.value)
      .flatMap((result) => (result as PromiseFulfilledResult<any>).value);

    const uniqueTeams = Array.from(
      new Map(allTeamsResponses.map((item) => [item.team.id, item])).values()
    );

    uniqueTeams.sort((a, b) => a.team.name.localeCompare(b.team.name));

    return NextResponse.json({
      teams: uniqueTeams,
      count: uniqueTeams.length,
    });
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to fetch teams data for this country." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/ticker-messages/route.ts =====

import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import TickerMessage, { ITickerMessage } from "@/models/TickerMessage";
import Post from "@/models/Post";
import redis from "@/lib/redis";

const CACHE_TTL_SECONDS = 60 * 5;
const DEFAULT_LOCALE = "tr";

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const locale = searchParams.get("locale") || DEFAULT_LOCALE;

    const cacheKey = `ticker-messages:active:${locale}`;

    const cachedData = await redis.get(cacheKey);
    if (cachedData) {
      return NextResponse.json(JSON.parse(cachedData));
    }

    await dbConnect();

    const customMessages = await TickerMessage.find({
      isActive: true,
      language: locale,
    }).sort({
      order: 1,
      createdAt: -1,
    }).lean();

    if (customMessages && customMessages.length > 0) {
      await redis.set(
        cacheKey,
        JSON.stringify(customMessages),
        "EX",
        CACHE_TTL_SECONDS
      );
      return NextResponse.json(customMessages);
    }

    const recentNews = await Post.find({
      status: "published",
      language: locale,
      sportsCategory: { $in: ["general"] },
    })
    .sort({ createdAt: -1 })
    .limit(5)
    .lean();

    const newsAsTickerMessages = recentNews.map((post, index) => ({
      _id: post._id,
      message: post.title,
      language: post.language,
      isActive: true,
      order: index,

      href: `/news/${post.slug}`,
    }));

    if (newsAsTickerMessages.length > 0) {
        await redis.set(
            cacheKey,
            JSON.stringify(newsAsTickerMessages),
            "EX",
            CACHE_TTL_SECONDS
        );
    }

    return NextResponse.json(newsAsTickerMessages);

  } catch (error) {

    return NextResponse.json(
      { error: "Server error fetching ticker messages" },
      { status: 500 }
    );
  }
}

// ===== src/app/api/top-scorers/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';
import redis from '@/lib/redis';

const CACHE_TTL_SECONDS = 60 * 60 * 6;

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');
  const season = searchParams.get('season');

  if (!leagueId || !season) {
    return NextResponse.json(
      { error: 'League ID and season are required' },
      { status: 400 }
    );
  }

  const cacheKey = `top-scorers:${leagueId}:${season}`;

  try {

    const cachedData = await redis.get(cacheKey);
    if (cachedData) {

      return NextResponse.json(JSON.parse(cachedData));
    }

    const options = {
      method: 'GET',
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/players/topscorers`,
      params: {
        league: leagueId,
        season: season,
      },
      headers: {
        'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
      },
    };

    const response = await axios.request(options);
    const topScorers = response.data.response;

    if (topScorers && topScorers.length > 0) {
        await redis.set(cacheKey, JSON.stringify(topScorers), "EX", CACHE_TTL_SECONDS);

    }

    return NextResponse.json(topScorers);

  } catch (error) {

    return NextResponse.json(
      { error: 'Failed to fetch top scorers data.' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/upcoming-matches/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';
import { format, subDays, addDays } from 'date-fns';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');

  if (!leagueId) {

    return NextResponse.json({ error: 'League ID is required' }, { status: 400 });
  }

  const season = new Date().getFullYear().toString();
  const today = format(new Date(), 'yyyy-MM-dd');
  const nextSevenDays = format(addDays(new Date(), 7), 'yyyy-MM-dd');

  const options = (params: object) => ({
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params,
    headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {

    const upcomingResponse = await axios.request(options({
      league: leagueId,
      season: season,
      from: today,
      to: nextSevenDays,
    }));

    let matches = upcomingResponse.data.response;

    if (matches.length === 0) {

      const finishedResponse = await axios.request(options({
        league: leagueId,
        season: season,
        last: 5,
        status: 'FT',
      }));
      matches = finishedResponse.data.response;
    }

    return NextResponse.json(matches);

  } catch (error) {

    return NextResponse.json({ error: 'Failed to fetch match data' }, { status: 500 });
  }
}

// ===== src/app/api/upload/route.ts =====

import { NextResponse } from "next/server";
import {
  S3Client,
  PutObjectCommand,
  ListObjectsV2Command,
  DeleteObjectCommand,
} from "@aws-sdk/client-s3";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import sharp from "sharp";
import path from "path";
import slugify from "slugify";

const s3Client = new S3Client({
  region: "auto",
  endpoint: process.env.NEXT_PUBLIC_R2_ENDPOINT as string,
  credentials: {
    accessKeyId: process.env.NEXT_PUBLIC_R2_ACCESS_KEY_ID as string,
    secretAccessKey: process.env.NEXT_PUBLIC_R2_SECRET_ACCESS_KEY as string,
  },
});

const R2_BUCKET_NAME = process.env.NEXT_PUBLIC_R2_BUCKET_NAME as string;
const R2_PUBLIC_URL = process.env.NEXT_PUBLIC_R2_PUBLIC_BUCKET_URL as string;

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const listObjectsCommand = new ListObjectsV2Command({
      Bucket: R2_BUCKET_NAME,
      MaxKeys: 1000,
    });

    const { Contents } = await s3Client.send(listObjectsCommand);

    const files =
      Contents?.map((item) => {
        const key = item.Key || "unknown";
        const fileExtension = path.extname(key).toLowerCase();
        let mimeType = "application/octet-stream";

        if (fileExtension === ".png") mimeType = "image/png";
        else if (fileExtension === ".jpg" || fileExtension === ".jpeg")
          mimeType = "image/jpeg";
        else if (fileExtension === ".gif") mimeType = "image/gif";
        else if (fileExtension === ".webp") mimeType = "image/webp";

        return {
          name: key,
          url: `${R2_PUBLIC_URL}/${key}`,
          size: item.Size || 0,
          lastModified: item.LastModified,
          type: mimeType,
        };
      }) || [];

    files.sort(
      (a, b) =>
        (b.lastModified?.getTime() || 0) - (a.lastModified?.getTime() || 0)
    );

    return NextResponse.json(files, { status: 200 });
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to list files from Cloudflare R2." },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const formData = await request.formData();
    const file = formData.get("file") as File;
    const uploadType = formData.get("uploadType") as string | null;

    if (!file) {
      return NextResponse.json({ error: "No file provided." }, { status: 400 });
    }

    let finalBuffer: Buffer;
    let finalContentType: string;
    let finalFileExtension: string;

    const inputBuffer = Buffer.from(await file.arrayBuffer());
    let sharpInstance = sharp(inputBuffer);

    if (uploadType === "banner") {
      sharpInstance = sharpInstance.resize(1200, 1200, {
        fit: "inside",
        withoutEnlargement: true,
      });
    } else {
      sharpInstance = sharpInstance.resize(1200, 630, {
        fit: "inside",
        withoutEnlargement: true,
      });
    }

    if (file.type === "image/png") {
      finalBuffer = await sharpInstance.png({ quality: 80 }).toBuffer();
      finalContentType = "image/png";
      finalFileExtension = ".png";
    } else if (file.type === "image/jpeg") {
      finalBuffer = await sharpInstance.jpeg({ quality: 80 }).toBuffer();
      finalContentType = "image/jpeg";
      finalFileExtension = ".jpg";
    } else if (file.type === "image/gif") {
      finalBuffer = inputBuffer;
      finalContentType = "image/gif";
      finalFileExtension = ".gif";
    } else {
      finalBuffer = await sharpInstance.webp({ quality: 80 }).toBuffer();
      finalContentType = "image/webp";
      finalFileExtension = ".webp";
    }

    const originalFilename = file.name;
    const extension = path.extname(originalFilename);
    const basename = path.basename(originalFilename, extension);
    const slug = slugify(basename, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });
    const uniqueSuffix = Date.now().toString().slice(-6);
    const newFileName = `fanskor-${slug}-${uniqueSuffix}${finalFileExtension}`;

    const putObjectCommand = new PutObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: newFileName,
      Body: finalBuffer,
      ContentType: finalContentType,
    });

    await s3Client.send(putObjectCommand);
    const publicUrl = `${R2_PUBLIC_URL}/${newFileName}`;

    return NextResponse.json({
      message: "File uploaded successfully",
      url: publicUrl,
      name: newFileName,
      type: finalContentType,
      size: finalBuffer.length,
      lastModified: new Date().toISOString(),
    });
  } catch (error) {

    return NextResponse.json(
      { error: "Failed to upload image to Cloudflare R2." },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { searchParams } = new URL(request.url);
  const fileKey = searchParams.get("key");

  if (!fileKey) {
    return NextResponse.json(
      { error: "File key is required for deletion." },
      { status: 400 }
    );
  }

  try {
    const deleteObjectCommand = new DeleteObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: fileKey,
    });

    await s3Client.send(deleteObjectCommand);

    return NextResponse.json(
      { message: "File deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {

    if (error.name === "NoSuchKey") {
      return NextResponse.json(
        { error: "File not found on Cloudflare R2." },
        { status: 404 }
      );
    }
    return NextResponse.json(
      { error: error.message || "Failed to delete file from Cloudflare R2." },
      { status: 500 }
    );
  }
}

// ===== src/app/api/votes/route.ts =====

import { NextResponse } from 'next/server';
import dbConnect from '@/lib/dbConnect';
import Vote from '@/models/Vote';

export async function GET(request: Request) {

    const { searchParams } = new URL(request.url);
    const fixtureId = searchParams.get('fixture');

    if (!fixtureId) {
        return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
    }

    try {
        await dbConnect();
        const votes = await Vote.findOne({ fixtureId: Number(fixtureId) });

        if (!votes) {

            return NextResponse.json({ homeVotes: 0, drawVotes: 0, awayVotes: 0 });
        }

        return NextResponse.json(votes);
    } catch (error) {

        return NextResponse.json({ error: 'Server error fetching votes' }, { status: 500 });
    }
}

export async function POST(request: Request) {
    const { fixtureId, vote } = await request.json();

    if (!fixtureId || !['home', 'draw', 'away'].includes(vote)) {
        return NextResponse.json({ error: 'Valid fixtureId and vote type are required' }, { status: 400 });
    }

    try {
        await dbConnect();

        const updatedVote = await Vote.findOneAndUpdate(
            { fixtureId: Number(fixtureId) },
            { $inc: { [`${vote}Votes`]: 1 } },
            {
                upsert: true,
                new: true
            }
        );

        return NextResponse.json(updatedVote);
    } catch (error) {
        return NextResponse.json({ error: 'Server error submitting vote' }, { status: 500 });
    }
}

// ===== src/app/fonts.ts =====

import { Inter } from "next/font/google";

export const inter = Inter({
  subsets: ["latin"],
  display: "swap",
  variable: "--font-sans",
});

// ===== src/app/globals.css =====

@font-face {
  font-display: swap;
  font-family: "Inter";
  font-style: normal;
  font-weight: 400;
  src: url("../../public/fonts/inter-v19-latin-regular.woff2") format("woff2");
}

@font-face {
  font-display: swap;
  font-family: "Inter";
  font-style: normal;
  font-weight: 500;
  src: url("../../public/fonts/inter-v19-latin-500.woff2") format("woff2");
}

@font-face {
  font-display: swap;
  font-family: "Inter";
  font-style: normal;
  font-weight: 600;
  src: url("../../public/fonts/inter-v19-latin-600.woff2") format("woff2");
}

@font-face {
  font-display: swap;
  font-family: "Inter";
  font-style: normal;
  font-weight: 700;
  src: url("../../public/fonts/inter-v19-latin-700.woff2") format("woff2");
}

@font-face {
  font-display: swap;
  font-family: "Inter";
  font-style: normal;
  font-weight: 800;
  src: url("../../public/fonts/inter-v19-latin-800.woff2") format("woff2");
}

@import "tailwindcss";

@tailwind base;
@tailwind components;
@tailwind utilities;

@import "nprogress/nprogress.css";
@import "slick-carousel/slick/slick.css";
@import "slick-carousel/slick/slick-theme.css";

html {
  font-size: 87.5%;
}

@layer base {
  :root {
    --brand-dark: #1f1d2b;
    --brand-secondary: #252837;
    --brand-purple: #8b5cf6;
    --brand-accent: #ed5c19;
    --brand-live: #ef4444;

    --background: var(--brand-dark);
    --foreground: #ffffff;

    --text-primary: #ffffff;
    --text-secondary: #e0e0e0;
    --text-muted: #9e9e9e;
  }
}

@keyframes ring {
  0% {
    transform: rotate(0);
  }
  10% {
    transform: rotate(14deg);
  }
  20% {
    transform: rotate(-8deg);
  }
  30% {
    transform: rotate(14deg);
  }
  40% {
    transform: rotate(-4deg);
  }
  50% {
    transform: rotate(10deg);
  }
  60% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(0);
  }
}

.animate-ring {
  transform-origin: top center;
  animation: ring 2s ease-in-out infinite;
}

body {
  background-color: var(--background);
  color: var(--text-primary);
  font-family: var(--font-sans);
}

.prose {
  --tw-prose-body: theme("colors.slate.300");
  --tw-prose-invert-body: theme("colors.slate.300");
}

.prose p {
  line-height: 1.75;
}

.prose h2 {
  color: #ffffff;
  font-size: 1.875rem;
  font-weight: 700;
  margin-top: 2.5em;
  margin-bottom: 1.25em;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid #4a5568;
  line-height: 1.3;
}

.prose h3 {
  color: #e2e8f0;
  font-size: 1.5rem;
  font-weight: 600;
  margin-top: 2em;
  margin-bottom: 1em;
  line-height: 1.4;
}

.prose strong {
  color: #ffffff;
}
.prose em {
  color: #e2e8f0;
}
.prose ul,
.prose ol {
  list-style-position: outside;
  padding-left: 1.5em;
}
.prose ul > li,
.prose ol > li {
  padding-left: 0.5em;
  margin-top: 0.75em;
}
.prose ul > li::marker {
  color: var(--brand-accent);
}
.prose a {
  color: var(--brand-accent);
  text-decoration: none;
  transition: all 0.2s ease-in-out;
  font-weight: 500;
}
.prose a:hover {
  text-decoration: underline;
  color: #ffffff;
  background-color: var(--brand-accent);
  padding: 0.1em 0.2em;
  border-radius: 0.25rem;
}

.prose blockquote {
  position: relative;
  font-style: italic;
  color: #cbd5e1;
  padding: 1rem 1.5rem 1rem 3rem;
  border-left: none;
  background-color: rgba(71, 85, 105, 0.1);
  border-radius: 0.5rem;
  margin-top: 2em;
  margin-bottom: 2em;
}
.prose blockquote::before {
  content: "";
  position: absolute;
  left: 0.75rem;
  top: 0.5rem;
  font-size: 3rem;
  line-height: 1;
  color: var(--brand-accent);
  font-family: Georgia, serif;
}
.prose blockquote p {
  margin: 0;
}

.prose blockquote {
  position: relative;
  font-style: italic;
  color: #cbd5e1;
  padding: 1rem 1.5rem 1rem 3rem;
  border-left: 4px solid var(--brand-accent);
  background-color: rgba(71, 85, 105, 0.1);
  border-radius: 0.5rem;
  margin-top: 2em;
  margin-bottom: 2em;
}
.prose blockquote::before {
  content: "";
  position: absolute;
  left: 0.75rem;
  top: 0.5rem;
  font-size: 3rem;
  line-height: 1;
  color: var(--brand-accent);
  font-family: Georgia, serif;
  opacity: 0.5;
}
.prose blockquote p {
  margin: 0;
}
.prose blockquote p:not(:first-of-type) {
  margin-top: 1em;
}

:root {
  --color-background: #020202;
  --color-primary: #1a1a1a;
  --color-secondary: #2a2a2a;

  --text-primary: #fffffd;
  --text-secondary: #e0e0e0;
  --text-muted: #9e9e9e;

  --brand-accent: #ed5c19;
  --brand-live: #ef4444;
  --brand-yellow: #fbbf24;
}

body {
  background-color: var(--color-background);
  color: var(--text-primary);
  font-family: var(--font-sans);
}

.custom-scrollbar {
  overflow-y: auto;
  scroll-behavior: smooth;

  scrollbar-width: thin;
  scrollbar-color: #393f47 transparent;
}

.custom-scrollbar::-webkit-scrollbar {
  width: 8px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background-color: #f3f4f6;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background-color: #1f2937;
  border-radius: 10px;
}
.bg-brand-secondary {
  background-color: var(--tw-color-brand-secondary);
}

.slick-dots li.slick-active div {
  background-color: #8b5cf6 !important;
}

@keyframes breathing-glow {
  0%,
  100% {
    box-shadow: 0 0 10px 0px rgba(52, 211, 153, 0.4);
    transform: scale(1);
  }
  50% {
    box-shadow: 0 0 25px 5px rgba(52, 211, 153, 0.7);
    transform: scale(1.05);
  }
}

.animate-breathing-glow {
  animation: breathing-glow 2.5s ease-in-out infinite;
}

.tiptap > * + * {
  margin-top: 0.75em;
}

.tiptap ul,
.tiptap ol {
  padding: 0 1rem;
}

.tiptap h1,
.tiptap h2,
.tiptap h3,
.tiptap h4,
.tiptap h5,
.tiptap h6 {
  line-height: 1.1;
}

.tiptap code {
  background-color: rgba(255, 255, 255, 0.1);
  color: #a1a1aa;
  padding: 0.2rem 0.4rem;
  border-radius: 0.25rem;
  font-size: 0.9em;
}

.tiptap pre {
  background: #18181b;
  color: #fff;
  font-family: "JetBrainsMono", "Courier New", Courier, monospace;
  padding: 0.75rem 1rem;
  border-radius: 0.5rem;
}

.tiptap pre code {
  color: inherit;
  padding: 0;
  background: none;
  font-size: 0.8rem;
}

.tiptap img {
  max-width: 100%;
  height: auto;
}

.tiptap blockquote {
  padding-left: 1rem;
  border-left: 2px solid rgba(255, 255, 255, 0.2);
}

.tiptap hr {
  border: none;
  border-top: 2px solid rgba(255, 255, 255, 0.2);
  margin: 2rem 0;
}

.slick-dots li.slick-active div {
  background-color: #8b5cf6;
}

#nprogress .bar {
  background: var(--brand-accent) !important;
  height: 3px !important;
}
#nprogress .peg {
  box-shadow: 0 0 10px var(--brand-accent), 0 0 5px var(--brand-accent) !important;
}

.bg-brand-secondary {
  background-color: var(--color-primary);
}
.text-brand-light {
  color: var(--text-primary);
}
.text-brand-muted {
  color: var(--text-muted);
}

@keyframes fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.animate-fade-in {
  animation: fade-in 0.3s ease-out forwards;
}

// ===== src/app/providers.tsx =====

"use client";

import ProgressBar from "@/components/ProgressBar";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { useState } from "react";
import { Toaster } from "react-hot-toast";

export default function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>
      {}
      <div suppressHydrationWarning={true}>
        <Toaster
          position="top-right"
          toastOptions={{
            style: {
              background: "#333",
              color: "#fff",
            },
          }}
        />
      </div>
      <ProgressBar />
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}

// ===== src/app/sitemap-leagues.xml/route.ts =====

import { getAllLeaguesForSitemap } from "@/lib/data/leagues";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

const SUPPORTED_LOCALES = ["tr", "en", "fr", "es", "zu"];
const DEFAULT_LOCALE = "tr";

type SitemapEntry = {
  url: string;
  lastModified?: string | Date;
  changeFrequency?: "daily" | "weekly" | "monthly";
  priority?: number;
};

const getPath = (path: string, locale: string) => {
  if (locale === DEFAULT_LOCALE) return path;
  return `/${locale}${path}`;
};

const generateXml = (entries: SitemapEntry[]) =>
  `<?xml version="1.0" encoding="UTF-8"?>
     <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
       ${entries
         .map(
           (entry) => `
         <url>
           <loc>${entry.url}</loc>
           <lastmod>${new Date(
             entry.lastModified || new Date()
           ).toISOString()}</lastmod>
           <changefreq>${entry.changeFrequency}</changefreq>
           <priority>${entry.priority}</priority>
         </url>
       `
         )
         .join("")}
     </urlset>`;

export async function GET() {
  try {

    const leagues = await getAllLeaguesForSitemap();

    const sitemapEntries: SitemapEntry[] = leagues.flatMap((league: any) =>
      SUPPORTED_LOCALES.map((locale) => ({

        url: `${BASE_URL}${getPath(league.slug, locale)}`,
        lastModified: new Date(),
        changeFrequency: "weekly",
        priority: 0.7,
      }))
    );

    const xml = generateXml(sitemapEntries);

    return new Response(xml, {
      headers: {
        "Content-Type": "application/xml",
      },
    });
  } catch (error) {

    return new Response("Error generating sitemap.", { status: 500 });
  }
}

// ===== src/app/sitemap-matches.xml/route.ts =====

import axios from "axios";
import slugify from "slugify";
import { format, subDays, addDays } from "date-fns";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

const SUPPORTED_LOCALES = ["tr", "en", "fr", "es", "zu"];
const DEFAULT_LOCALE = "tr";

type SitemapEntry = {
  url: string;
  lastModified?: string | Date;
  changeFrequency?: "daily" | "weekly" | "monthly";
  priority?: number;
};

const getPath = (path: string, locale: string) => {
  if (locale === DEFAULT_LOCALE) return path;
  return `/${locale}${path}`;
};

const generateMatchSlug = (
  homeName: string,
  awayName: string,
  fixtureId: number
): string => {
  const slugifyPart = (str: string) =>
    slugify(str, { lower: true, strict: true, remove: /[*+~.()'"!:@]/g });
  return `/football/match/${slugifyPart(homeName)}-vs-${slugifyPart(
    awayName
  )}-${fixtureId}`;
};

const generateXml = (entries: SitemapEntry[]) =>
  `<?xml version="1.0" encoding="UTF-8"?>
     <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
       ${entries
         .map(
           (entry) => `
         <url>
           <loc>${entry.url}</loc>
           <lastmod>${new Date(
             entry.lastModified || new Date()
           ).toISOString()}</lastmod>
           <changefreq>${entry.changeFrequency}</changefreq>
           <priority>${entry.priority}</priority>
         </url>
       `
         )
         .join("")}
     </urlset>`;

export async function GET() {
  try {
    const today = new Date();
    const fromDate = format(subDays(today, 30), "yyyy-MM-dd");
    const toDate = format(addDays(today, 30), "yyyy-MM-dd");

    const { data: matches } = await axios.get(
      `${BASE_URL}/api/fixtures?from=${fromDate}&to=${toDate}`
    );

    const sitemapEntries: SitemapEntry[] = matches.flatMap((match: any) =>
      SUPPORTED_LOCALES.map((locale) => ({
        url: `${BASE_URL}${getPath(
          generateMatchSlug(
            match.teams.home.name,
            match.teams.away.name,
            match.fixture.id
          ),
          locale
        )}`,
        lastModified: new Date(match.fixture.date),
        changeFrequency: "daily",
        priority: 0.9,
      }))
    );

    const xml = generateXml(sitemapEntries);

    return new Response(xml, {
      headers: {
        "Content-Type": "application/xml",
      },
    });
  } catch (error) {

    return new Response("Error generating sitemap.", { status: 500 });
  }
}

// ===== src/app/sitemap-news.xml/route.ts =====

import { IPost } from "@/models/Post";
import dbConnect from "@/lib/dbConnect";
import Post from "@/models/Post";
import { DEFAULT_LOCALE } from "@/lib/i18n/config";

export const dynamic = "force-dynamic";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

type SitemapEntry = {
  url: string;
  lastModified?: string | Date;
  changeFrequency?: "daily" | "weekly" | "monthly";
  priority?: number;
};

const getPath = (path: string, locale: string) => {
  if (locale === DEFAULT_LOCALE) {
    return path;
  }
  return `/${locale}${path}`;
};

const generateXml = (entries: SitemapEntry[]) =>
  `<?xml version="1.0" encoding="UTF-8"?>
     <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
       ${entries
         .map(
           (entry) => `
         <url>
           <loc>${entry.url}</loc>
           <lastmod>${new Date(
             entry.lastModified || new Date()
           ).toISOString()}</lastmod>
           <changefreq>${entry.changeFrequency}</changefreq>
           <priority>${entry.priority}</priority>
         </url>
       `
         )
         .join("")}
     </urlset>`;

export async function GET() {
  try {

    await dbConnect();
    const posts: IPost[] = await Post.find({ status: "published" }).lean();

    const sitemapEntries: SitemapEntry[] = posts.map((post) => {
      const basePath = `/news/${post.slug}`;
      const finalPath = getPath(basePath, post.language);

      return {
        url: `${BASE_URL}${finalPath}`,
        lastModified: new Date(post.updatedAt || post.createdAt),
        changeFrequency: "weekly",
        priority: 0.8,
      };
    });

    const xml = generateXml(sitemapEntries);

    return new Response(xml, {
      headers: {
        "Content-Type": "application/xml",
      },
    });
  } catch (error) {

    return new Response("Error generating sitemap.", { status: 500 });
  }
}

// ===== src/app/sitemap-standings.xml/route.ts =====

import axios from "axios";
import { SUPPORTED_LOCALES, DEFAULT_LOCALE } from "@/lib/i18n/config";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

type SitemapEntry = {
  url: string;
  lastModified?: string | Date;
  changeFrequency?: "daily" | "weekly" | "monthly";
  priority?: number;
};

const getUrl = (path: string, locale: string) => {
  if (locale === DEFAULT_LOCALE) {
    return `${BASE_URL}${path}`;
  }
  return `${BASE_URL}/${locale}${path}`;
};

const generateXml = (entries: SitemapEntry[]) =>
  `<?xml version="1.0" encoding="UTF-8"?>
     <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
       ${entries
         .map(
           (entry) => `
         <url>
           <loc>${entry.url}</loc>
           <lastmod>${new Date(
             entry.lastModified || new Date()
           ).toISOString()}</lastmod>
           <changefreq>${entry.changeFrequency}</changefreq>
           <priority>${entry.priority}</priority>
         </url>
       `
         )
         .join("")}
     </urlset>`;

export async function GET() {
  try {

    const { data: leagues } = await axios.get(
      `${BASE_URL}/api/directory/standings-leagues`
    );

    if (!leagues || leagues.length === 0) {
      return new Response(generateXml([]), {
        headers: { "Content-Type": "application/xml" },
      });
    }

    const sitemapEntries: SitemapEntry[] = leagues.flatMap((league: any) =>

      SUPPORTED_LOCALES.map((locale) => ({
        url: getUrl(league.href, locale),
        lastModified: new Date(),
        changeFrequency: "daily",
        priority: 0.8,
      }))
    );

    const xml = generateXml(sitemapEntries);

    return new Response(xml, {
      headers: {
        "Content-Type": "application/xml",
      },
    });
  } catch (error) {

    return new Response("Error generating standings sitemap.", { status: 500 });
  }
}

// ===== src/app/sitemap-static.xml/route.ts =====

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

const SUPPORTED_LOCALES = ["tr", "en", "fr", "es", "zu"];
const DEFAULT_LOCALE = "tr";

type SitemapEntry = {
  url: string;
  lastModified?: string | Date;
  changeFrequency?:
    | "always"
    | "hourly"
    | "daily"
    | "weekly"
    | "monthly"
    | "yearly"
    | "never";
  priority?: number;
};

const getPath = (path: string, locale: string) => {
  if (locale === DEFAULT_LOCALE) {
    return path === "/" ? "" : path;
  }
  return `/${locale}${path}`;
};

export async function GET() {
  const staticPaths = [
    { path: "/", priority: 1.0, changeFrequency: "daily" },
    { path: "/football/news", priority: 0.9, changeFrequency: "daily" },
    { path: "/news", priority: 0.9, changeFrequency: "daily" },
    { path: "/football/leagues", priority: 0.9, changeFrequency: "daily" },
    { path: "/football/teams", priority: 0.9, changeFrequency: "daily" },
    { path: "/contact-us", priority: 0.5, changeFrequency: "monthly" },
    { path: "/faq", priority: 0.6, changeFrequency: "monthly" },
    { path: "/author", priority: 0.4, changeFrequency: "yearly" },
    { path: "/report-abuse", priority: 0.4, changeFrequency: "yearly" },
    { path: "/privacy-policy", priority: 0.3, changeFrequency: "yearly" },
    { path: "/terms-and-conditions", priority: 0.3, changeFrequency: "yearly" },
    { path: "/gdpr", priority: 0.3, changeFrequency: "yearly" },
  ];

  const sitemapEntries: SitemapEntry[] = staticPaths.flatMap((page) =>
    SUPPORTED_LOCALES.map((locale) => ({
      url: `${BASE_URL}${getPath(page.path, locale)}`,
      lastModified: new Date(),
      changeFrequency: page.changeFrequency as SitemapEntry["changeFrequency"],
      priority: page.priority,
    }))
  );

  const generateXml = (entries: SitemapEntry[]) =>
    `<?xml version="1.0" encoding="UTF-8"?>
     <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
       ${entries
         .map(
           (entry) => `
         <url>
           <loc>${entry.url}</loc>
           <lastmod>${new Date(
             entry.lastModified || new Date()
           ).toISOString()}</lastmod>
           <changefreq>${entry.changeFrequency}</changefreq>
           <priority>${entry.priority}</priority>
         </url>
       `
         )
         .join("")}
     </urlset>`;

  const xml = generateXml(sitemapEntries);

  return new Response(xml, {
    headers: {
      "Content-Type": "application/xml",
    },
  });
}

// ===== src/app/sitemap-teams.xml/route.ts =====

import axios from "axios";
import slugify from "slugify";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

const SUPPORTED_LOCALES = ["tr", "en", "fr", "es", "zu"];
const DEFAULT_LOCALE = "tr";

type SitemapEntry = {
  url: string;
  lastModified?: string | Date;
  changeFrequency?: "daily" | "weekly" | "monthly";
  priority?: number;
};

const getPath = (path: string, locale: string) => {
  if (locale === DEFAULT_LOCALE) return path;
  return `/${locale}${path}`;
};

const generateTeamSlug = (name: string, id: number): string => {
  const slug = slugify(name, {
    lower: true,
    strict: true,
    remove: /[*+~.()'"!:@]/g,
  });
  return `/football/team/${slug}-${id}`;
};

const generateXml = (entries: SitemapEntry[]) =>
  `<?xml version="1.0" encoding="UTF-8"?>
     <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
       ${entries
         .map(
           (entry) => `
         <url>
           <loc>${entry.url}</loc>
           <lastmod>${new Date(
             entry.lastModified || new Date()
           ).toISOString()}</lastmod>
           <changefreq>${entry.changeFrequency}</changefreq>
           <priority>${entry.priority}</priority>
         </url>
       `
         )
         .join("")}
     </urlset>`;

export async function GET() {
  try {
    const { data: teamsData } = await axios.get(
      `${BASE_URL}/api/directory/teams`
    );

    const sitemapEntries: SitemapEntry[] = teamsData.flatMap((teamData: any) =>
      SUPPORTED_LOCALES.map((locale) => ({
        url: `${BASE_URL}${getPath(
          generateTeamSlug(teamData.team.name, teamData.team.id),
          locale
        )}`,
        lastModified: new Date(),
        changeFrequency: "weekly",
        priority: 0.6,
      }))
    );

    const xml = generateXml(sitemapEntries);

    return new Response(xml, {
      headers: {
        "Content-Type": "application/xml",
      },
    });
  } catch (error) {

    return new Response("Error generating sitemap.", { status: 500 });
  }
}

// ===== src/app/sitemap.xml/route.ts =====

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

const generateSitemapIndexXml = () => {
  const sitemaps = [
    "sitemap-static.xml",
    "sitemap-news.xml",
    "sitemap-leagues.xml",
    "sitemap-teams.xml",
    "sitemap-matches.xml",

    "sitemap-standings.xml",
  ];

  const sitemapEntries = sitemaps
    .map(
      (route) => `
    <sitemap>
      <loc>${BASE_URL}/${route}</loc>
      <lastmod>${new Date().toISOString()}</lastmod>
    </sitemap>
  `
    )
    .join("");

  return `<?xml version="1.0" encoding="UTF-8"?>
    <sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
      ${sitemapEntries}
    </sitemapindex>
  `;
};

export async function GET() {
  const xml = generateSitemapIndexXml();

  return new Response(xml, {
    headers: {
      "Content-Type": "application/xml",
    },
  });
}

// ===== src/components/Accordion.tsx =====

"use client";

import { useState, ReactNode } from 'react';
import { ChevronDown } from 'lucide-react';

interface AccordionProps {
  title: ReactNode;
  statusNode?: ReactNode;
  children: ReactNode;
  defaultOpen?: boolean;
}

export default function Accordion({ title, statusNode, children, defaultOpen = false }: AccordionProps) {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <div className="border-b border-gray-700/50 last:border-b-0">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="w-full flex justify-between items-center p-4 transition-colors duration-200 bg-gray-800/50 hover:bg-gray-800/80"
      >
        {}
        <div className="flex items-center gap-4">
            {}
            <div className="font-bold text-lg text-white text-left">{title}</div>
            {}
            {statusNode}
        </div>

        {}
        <ChevronDown
          size={24}
          className={`transform transition-transform duration-300 flex-shrink-0 ${isOpen ? 'rotate-180' : ''}`}
        />
      </button>

      {}
      <div
        className={`grid transition-all duration-300 ease-in-out ${
          isOpen ? 'grid-rows-[1fr] opacity-100' : 'grid-rows-[0fr] opacity-0'
        }`}
      >
        <div className="overflow-hidden">
          <div className="p-4 space-y-3 bg-brand-dark/30">{children}</div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/AdSlotWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import Link from "next/link";
import { IBanner } from "@/models/Banner";

interface AdSlotWidgetProps {
  location: string;
  initialBanner?: IBanner | null;
}

const fetchBannerForSlot = async (
  location: string
): Promise<IBanner | null> => {
  try {
    const { data } = await axios.get(
      `/api/banners?location=${location}&active=true`
    );
    return data?.[0] || null;
  } catch (error) {
    console.error(
      `[AdSlotWidget] Client fetch failed for location "${location}":`,
      error
    );
    return null;
  }
};

const AdBannerSkeleton = () => (
  <div className="w-full h-[250px] bg-brand-secondary rounded-lg animate-pulse"></div>
);

export default function AdSlotWidget({
  location,
  initialBanner,
}: AdSlotWidgetProps) {
  const {
    data: banner,
    isLoading,
    isError,
  } = useQuery<IBanner | null>({
    queryKey: ["banner", location],
    queryFn: () => fetchBannerForSlot(location),
    staleTime: 1000 * 60 * 5,
    refetchOnWindowFocus: false,

    initialData: initialBanner,

    enabled: !initialBanner,
  });

  const finalBanner = initialBanner ?? banner;

  if (isLoading && !initialBanner) {
    return <AdBannerSkeleton />;
  }

  if (isError || !finalBanner) {
    return null;
  }

  return (
    <div className="w-full">
      <Link
        href={finalBanner.linkUrl}
        target="_blank"
        rel="noopener sponsored"
        className="relative block w-full overflow-hidden rounded-lg group"
        aria-label={`Advertisement: ${finalBanner.title}`}
      >
        <Image
          src={finalBanner.imageUrl}
          alt={finalBanner.title}
          width={300}
          height={250}
          unoptimized={true}
          className="w-full h-auto object-cover transition-transform duration-300 group-hover:scale-105"
        />
        <div className="absolute bottom-0 left-0 p-2 w-full bg-gradient-to-t from-black/70 to-transparent">
          <p className="text-sm font-bold text-white drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)]">
            {finalBanner.title}
          </p>
          <span className="text-xs text-gray-300 drop-shadow-md">
            Advertisement
          </span>
        </div>
      </Link>
    </div>
  );
}

// ===== src/components/BettingPromotionWidget.tsx =====

"use client";

import { memo } from 'react';
import { ShieldCheck } from 'lucide-react';

const BettingPromotionWidget = memo(function BettingPromotionWidget() {

    const handleBetClick = () => {

    };

    return (
        <div className="bg-gradient-to-br from-green-500/20 to-brand-purple/20 p-4 rounded-xl border border-green-400/30 text-center space-y-3">

            <h3 className="text-lg font-bold text-white">
                Exclusive Welcome Offer!
            </h3>

            <p className="text-sm text-brand-light">
                Get a <span className="font-bold text-green-400">100% bonus</span> on your first deposit to bet on today's matches.
            </p>

            {}
            <div className="relative pt-2">
                {}
                <span className="absolute top-2 left-0 inline-flex h-full w-full rounded-lg bg-green-400 opacity-75 animate-ping"></span>

                <button
                    onClick={handleBetClick}
                    className="relative w-full bg-[#16A34A] text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2 hover:bg-green-700 transition-colors"
                >
                    <ShieldCheck size={18} />
                    <span>Claim Your Bonus Now</span>
                </button>
            </div>

            <p className="text-xs text-brand-muted/80">
                18+ | T&Cs apply. Please gamble responsibly.
            </p>
        </div>
    );
});

export default BettingPromotionWidget;

// ===== src/components/CasinoPartnerWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { Crown } from "lucide-react";
import StyledLink from "./StyledLink";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useTranslation } from "@/hooks/useTranslation";

interface ICasinoPartner {
  _id: string;
  name: string;
  logoUrl: string;
  redirectUrl: string;
  description?: string;
  isFeatured: boolean;
  isActive: boolean;
  order: number;
}

const fetchCasinoPartners = async (): Promise<ICasinoPartner[]> => {
  const { data } = await axios.get("/api/casino-partners");
  return data;
};

const CasinoPartnerWidget: React.FC = () => {
  const { t } = useTranslation();
  const {
    data: partners,
    isLoading,
    isError,
  } = useQuery<ICasinoPartner[]>({
    queryKey: ["casinoPartnersPublic"],
    queryFn: fetchCasinoPartners,
    staleTime: 1000 * 60 * 15,
  });

  if (isLoading) {
    return (
      <div className="bg-brand-secondary rounded-lg shadow-lg p-4 animate-pulse space-y-4">
        <div className="h-6 w-3/4 bg-gray-700 rounded mb-4"></div>
        <div className="h-10 bg-gray-700 rounded"></div>
        <div className="h-10 bg-gray-700 rounded"></div>
        <div className="h-10 bg-gray-700 rounded"></div>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="bg-brand-secondary rounded-lg shadow-lg p-4 text-red-400">
        {t("error_loading_partners")}
      </div>
    );
  }

  if (!partners || partners.length === 0) {
    return (
      <div className="bg-brand-secondary rounded-lg shadow-lg p-4 text-brand-muted text-center">
        {t("no_active_partners")}
      </div>
    );
  }

  return (
    <div className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden">
      <div className="p-4 border-b border-gray-700">
        <p className="text-xl font-bold text-white flex items-center gap-2">
          <Crown size={20} className="text-brand-purple" />{" "}
          {t("partner_casinos_title")}
        </p>
      </div>
      <div className="p-4 space-y-3">
        {partners.map((partner) => (
          <StyledLink
            key={partner._id}
            href={partner.redirectUrl}
            target="_blank"
            rel="noopener noreferrer nofollow"
            className={`
              block rounded-lg p-3 transition-all duration-300 transform
              ${
                partner.isFeatured
                  ? "bg-gradient-to-br from-[#ea5a1e40] to-[#ea5a1e] border border-[#ea5a1e] hover:border-[#ea5a1e] shadow-xl shadow-brand-purple/30 transform scale-[1.02] -translate-y-0.5"
                  : "bg-brand-dark/50 border border-gray-700 hover:bg-brand-dark/70"
              }
              hover:shadow-2xl hover:shadow-brand-purple/50
              flex items-center gap-3 relative overflow-hidden group
            `}
            title={partner.description || partner.name}
            gaEventName="casino_partner_click"
            gaEventParams={{
              partner_name: partner.name,
              is_featured: partner.isFeatured,
            }}
          >
            {partner.isFeatured && (
              <div className="absolute inset-0 bg-[#ea5a1e32] opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none"></div>
            )}
            <div className="h-15 w-15 flex justify-center items-center">
              <Image
                src={partner.logoUrl}
                alt={`${partner.name} Logo`}
                width={60}
                height={60}
                objectFit="contain"
                unoptimized={true}
                className=" rounded-lg bg-gray-900 p-1 z-10"
              />
            </div>
            <div className="flex flex-col flex-grow truncate z-10">
              <span
                className={`font-semibold text-lg truncate
                                  ${
                                    partner.isFeatured
                                      ? "text-white"
                                      : "text-brand-light"
                                  }`}
              >
                {partner.name}
              </span>
              {partner.description && (
                <span
                  className={`text-sm text-white mt-0.5 truncate
                                      ${
                                        partner.isFeatured
                                          ? "text-white"
                                          : "text-brand-muted"
                                      }`}
                >
                  {partner.description}
                </span>
              )}
            </div>

            {partner.isFeatured && (
              <Crown size={20} className="text-yellow-400 flex-shrink-0 z-10" />
            )}
          </StyledLink>
        ))}
      </div>
    </div>
  );
};

export default CasinoPartnerWidget;

// ===== src/components/CompactNewsItem.tsx =====

"use client";

import Image from "next/image";
import Link from "next/link";
import { IPost } from "@/models/Post";
import { formatDistanceToNow } from "date-fns";
import { Calendar, User } from "lucide-react";
import StyledLink from "./StyledLink";

interface CompactNewsItemProps {
  post: IPost;
}

export function CompactNewsItemSkeleton() {
  return (
    <div className="flex items-center gap-4 p-4 animate-pulse">
      <div className="w-24 h-16 bg-gray-700 rounded-md flex-shrink-0"></div>
      <div className="flex-1 space-y-2">
        <div className="h-5 w-full bg-gray-600 rounded"></div>
        <div className="h-5 w-4/5 bg-gray-600 rounded"></div>
        <div className="h-3 w-1/3 bg-gray-700 rounded mt-3"></div>
      </div>
    </div>
  );
}

export default function CompactNewsItem({ post }: CompactNewsItemProps) {
  if (!post) return null;

  const postUrl = `/news/${post.slug}`;

  const placeholderImage = "/images/placeholder-logo.svg";

  return (
    <div className="bg-brand-secondary rounded-lg transition-colors hover:bg-gray-800/50">
      <StyledLink href={postUrl} className="flex items-center gap-4 p-4 group">
        <div className="flex-shrink-0 w-24 h-16 relative">
          <Image
            src={post.featuredImage || placeholderImage}
            alt={post.title}
            layout="fill"
            objectFit="cover"
            className="rounded-md"
          />
        </div>
        <div className="flex-1 min-w-0">
          <h3 className="font-bold text-white leading-tight text-base md:text-lg line-clamp-2 mb-2 group-hover:text-brand-purple transition-colors">
            {post.title}
          </h3>
          <div className="flex items-center gap-4 text-xs text-brand-muted">
            <div className="flex items-center gap-1.5">
              <User size={12} />
              <span>{post.author}</span>
            </div>
            <div className="flex items-center gap-1.5">
              <Calendar size={12} />
              <time dateTime={new Date(post.createdAt).toISOString()}>
                {formatDistanceToNow(new Date(post.createdAt), {
                  addSuffix: true,
                })}
              </time>
            </div>
          </div>
        </div>
      </StyledLink>
    </div>
  );
}

// ===== src/components/ContactFormClient.tsx =====

"use client";

import { useState } from "react";
import { useMutation } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { Loader2, CheckCircle } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

const ContactFormClient: React.FC = () => {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [subject, setSubject] = useState("");
  const [message, setMessage] = useState("");
  const { t } = useTranslation();

  const contactMutation = useMutation({
    mutationFn: (formData: {
      name: string;
      email: string;
      subject: string;
      message: string;
    }) => axios.post("/api/contact", formData),
    onSuccess: () => {
      toast.success(t("contact_form_success_message"));
      setName("");
      setEmail("");
      setSubject("");
      setMessage("");
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || t("contact_form_error_message"));
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    contactMutation.mutate({ name, email, subject, message });
  };

  return (
    <div className="bg-brand-secondary p-8 rounded-lg shadow-xl">
      <h2 className="text-3xl font-bold text-white mb-6">
        {t("contact_us_form_title")}
      </h2>
      <form onSubmit={handleSubmit} className="space-y-5">
        <div>
          <label
            htmlFor="name"
            className="block text-sm font-medium text-brand-light mb-1"
          >
            {t("your_name_label")}
          </label>
          <input
            type="text"
            id="name"
            value={name}
            onChange={(e) => setName(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            required
            disabled={contactMutation.isPending}
          />
        </div>
        <div>
          <label
            htmlFor="email"
            className="block text-sm font-medium text-brand-light mb-1"
          >
            {t("your_email_label")}
          </label>
          <input
            type="email"
            id="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            required
            disabled={contactMutation.isPending}
          />
        </div>
        <div>
          <label
            htmlFor="subject"
            className="block text-sm font-medium text-brand-light mb-1"
          >
            {t("subject_label")}
          </label>
          <input
            type="text"
            id="subject"
            value={subject}
            onChange={(e) => setSubject(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            required
            disabled={contactMutation.isPending}
          />
        </div>
        <div>
          <label
            htmlFor="message"
            className="block text-sm font-medium text-brand-light mb-1"
          >
            {t("your_message_label")}
          </label>
          <textarea
            id="message"
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            rows={5}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
            required
            disabled={contactMutation.isPending}
          ></textarea>
        </div>
        <button
          type="submit"
          className="w-full bg-[#ea5a1e] text-white font-bold py-3 rounded-lg hover:opacity-90 transition-opacity flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
          disabled={contactMutation.isPending}
        >
          {contactMutation.isPending ? (
            <Loader2 size={20} className="animate-spin" />
          ) : (
            <CheckCircle size={20} />
          )}
          {contactMutation.isPending
            ? t("sending_button_text")
            : t("send_message_button_text")}
        </button>
      </form>
    </div>
  );
};

export default ContactFormClient;

// ===== src/components/CountryDropdown.tsx =====

"use client";

import { useState, useRef, useEffect } from 'react';
import Image from 'next/image';
import { ChevronDown, Globe } from 'lucide-react';
import { useQuery } from '@tanstack/react-query';
import axios from 'axios';
import { Country } from '@/types/api-football';
import { useLeagueContext } from '@/context/LeagueContext';
import { useTranslation } from '@/hooks/useTranslation';

const fetchCountries = async (): Promise<Country[]> => {
  const { data } = await axios.get('/api/countries');
  return data;
};

export default function CountryDropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const { t } = useTranslation();

  const { selectedCountry, setSelectedCountry } = useLeagueContext();

  const globalOption: Country = {
      name: t('global'),
      code: 'GLOBAL_VIEW',
      flagUrl: '',
  };

  const { data: countries, isLoading } = useQuery<Country[]>({
    queryKey: ['countries', globalOption.name],
    queryFn: fetchCountries,
    staleTime: 1000 * 60 * 60 * 24,
    refetchOnWindowFocus: false,
    select: (data) => {
      return [globalOption, ...data];
    },
  });

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleSelect = (country: Country) => {
    if (country.code === 'GLOBAL_VIEW') {
      setSelectedCountry(null);
    } else {
      setSelectedCountry(country);
    }
    setIsOpen(false);
  };

  return (
    <div className="relative" ref={dropdownRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        disabled={isLoading}
        className="flex items-center gap-2 bg-brand-secondary px-4 py-2 rounded-lg text-brand-light font-medium hover:bg-gray-700/50 transition-colors disabled:opacity-50 disabled:cursor-wait w-40 justify-between"
      >
        {isLoading ? (
          <span className="flex-grow text-left">{t('loading')}...</span>
        ) : selectedCountry ? (
          <>
            <Image
              src={selectedCountry.flagUrl}
              alt={selectedCountry.name}
              width={20}
              height={15}
              className="flex-shrink-0"
            />
            <span className="truncate flex-grow text-left">{selectedCountry.name}</span>
          </>
        ) : (
          <>
            <Globe size={16} className="flex-shrink-0" />
            <span className="truncate flex-grow text-left">{t('global')}</span>
          </>
        )}
        <ChevronDown size={16} className={`transition-transform duration-200 flex-shrink-0 ${isOpen ? 'rotate-180' : ''}`} />
      </button>

      {isOpen && countries && (
        <div className="absolute top-full mt-2 w-56 max-h-80 overflow-y-auto bg-brand-secondary rounded-lg shadow-lg z-50 border border-gray-700/50 custom-scrollbar">
          <ul className="text-brand-light">
            {countries.map((country) => (
              <li key={country.code || country.name}>
                <button
                  onClick={() => handleSelect(country)}
                  className="flex w-full items-center gap-3 px-4 py-2.5 text-sm hover:bg-brand-purple transition-colors"
                >
                  {country.code === 'GLOBAL_VIEW' ? (
                    <Globe size={16} className="h-4 w-5 text-center" />
                  ) : (
                    <Image src={country.flagUrl} alt={country.name} width={20} height={15} />
                  )}
                  <span>{country.name}</span>
                </button>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}

// ===== src/components/DatePicker.tsx =====

"use client";

import { useState, useRef, useEffect } from 'react';
import { format } from 'date-fns';
import { DayPicker } from 'react-day-picker';
import { Calendar as CalendarIcon } from 'lucide-react';
import 'react-day-picker/dist/style.css';

interface DatePickerProps {
  date: Date;
  setDate: (date: Date) => void;
}

export default function DatePicker({ date, setDate }: DatePickerProps) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleDaySelect = (selectedDate: Date | undefined) => {
    if (selectedDate) {
      setDate(selectedDate);
      setIsOpen(false);
    }
  };

  return (
    <div className="relative" ref={dropdownRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center justify-center gap-2 w-full min-w-[280px] text-lg font-bold p-2 rounded-md hover:bg-brand-purple"
      >
        <CalendarIcon size={20} />
        <span>{format(date, 'eeee, dd MMMM yyyy')}</span>
      </button>

      {isOpen && (
        <div className="absolute top-full mt-2 bg-brand-secondary border border-gray-600 rounded-lg shadow-lg z-20 p-2">
          <DayPicker
            mode="single"
            selected={date}
            onSelect={handleDaySelect}
            initialFocus

            classNames={{
              caption: 'flex justify-center py-2 mb-4 relative items-center',
              caption_label: 'text-sm font-medium text-white',
              nav: 'flex items-center',
              nav_button: 'h-6 w-6 bg-transparent hover:bg-brand-purple p-1 rounded-md',
              nav_button_previous: 'absolute left-1.5',
              nav_button_next: 'absolute right-1.5',
              table: 'w-full border-collapse',
              head_row: 'flex font-medium text-brand-muted',
              head_cell: 'w-full p-2',
              row: 'flex w-full mt-2',
              cell: 'text-white',
              day: 'h-8 w-8 p-0 hover:bg-brand-purple rounded-md',
              day_selected: 'bg-brand-purple font-bold',
              day_today: 'bg-gray-700 rounded-md',
              day_outside: 'text-brand-muted opacity-50',
              day_disabled: 'text-brand-muted opacity-50 cursor-not-allowed',
            }}
          />
        </div>
      )}
    </div>
  );
}

// ===== src/components/DesktopMatchListItem.tsx =====

"use client";

import { useState, useMemo } from "react";
import Image from "next/image";
import Link from "@/components/StyledLink";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import {
  History,
  CheckCircle,
  XCircle,
  TrendingUp,
  Loader2,
} from "lucide-react";
import { generateMatchSlug } from "@/lib/generate-match-slug";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useTranslation } from "@/hooks/useTranslation";
import ZonedDate from "./ZonedDate";

type Odds = { home: string; draw: string; away: string } | undefined | null;
const fetchFanskorOdds = async (fixtureId: number): Promise<Odds | null> => {
  try {
    const { data } = await axios.post("/api/batch-predictions", {
      fixtureIds: [fixtureId],
    });
    return data[fixtureId] || null;
  } catch (error) {
    console.error(
      `Failed to fetch Fanskor odds for fixture ${fixtureId}`,
      error
    );
    return null;
  }
};

interface DesktopMatchListItemProps {
  match: any;
  isLive: boolean;
}

export default function DesktopMatchListItem({
  match,
  isLive,
}: DesktopMatchListItemProps) {
  const { fixture, teams, goals } = match;
  const { t } = useTranslation();

  const slug = generateMatchSlug(teams.home, teams.away, fixture.id);
  const isFinished = ["FT", "AET", "PEN"].includes(fixture.status.short);

  const [showResult, setShowResult] = useState(false);

  const { data: customOdds, isLoading } = useQuery({
    queryKey: ["customOdds", fixture.id],
    queryFn: () => fetchFanskorOdds(fixture.id),
    enabled: showResult,
    staleTime: Infinity,
    refetchOnWindowFocus: false,
  });

  const { predictedOutcome, lowestOddValue } = useMemo(() => {
    if (!customOdds) return { predictedOutcome: null, lowestOddValue: null };
    const odds = {
      home: parseFloat(customOdds.home || "999"),
      draw: parseFloat(customOdds.draw || "999"),
      away: parseFloat(customOdds.away || "999"),
    };
    const minOdd = Math.min(odds.home, odds.draw, odds.away);
    if (minOdd === odds.home)
      return { predictedOutcome: "Home", lowestOddValue: customOdds.home };
    if (minOdd === odds.away)
      return { predictedOutcome: "Away", lowestOddValue: customOdds.away };
    return { predictedOutcome: "Draw", lowestOddValue: customOdds.draw };
  }, [customOdds]);

  const actualResult = useMemo(() => {
    if (!isFinished) return null;
    if (teams.home.winner) return "Home";
    if (teams.away.winner) return "Away";
    return "Draw";
  }, [isFinished, teams]);

  const wasPredictionCorrect = predictedOutcome === actualResult;

  const CustomOddBox = ({
    value,
    label,
    isFavorite,
  }: {
    value: string | undefined;
    label: string;
    isFavorite: boolean;
  }) => {
    const favoriteClasses =
      "bg-gradient-to-br from-[var(--brand-accent)] to-[#c54c14] text-white shadow-lg shadow-[var(--brand-accent)]/20";
    const defaultClasses =
      "bg-[var(--color-primary)] text-[var(--text-secondary)]";
    return (
      <div
        className={`flex flex-col items-center justify-center p-1 rounded-md w-16 h-12 transition-all duration-300 ${
          isFavorite ? favoriteClasses : defaultClasses
        }`}
      >
        <span
          className={`text-xs font-semibold ${
            isFavorite ? "opacity-80" : "text-[var(--text-muted)]"
          }`}
        >
          {label}
        </span>
        <span className="text-base font-black">{value || "-"}</span>
      </div>
    );
  };

  return (
    <div
      className="group flex items-center p-2 rounded-lg transition-all duration-300 ease-in-out border border-transparent hover:border-[var(--brand-accent)]/20 hover:bg-[var(--color-primary)]"
      style={{ backgroundColor: "var(--color-secondary)" }}
    >
      <Link href={slug} className="flex flex-1 items-center min-w-0">
        <div className="w-16 flex-shrink-0 text-center text-sm font-semibold">
          {isLive ? (
            <div className="flex items-center justify-center gap-1.5 text-green-400">
              <span className="h-1.5 w-1.5 rounded-full bg-green-500"></span>
              <span>{fixture.status.elapsed}'</span>
            </div>
          ) : isFinished ? (
            <div className="text-text-muted">{t("ft_short")}</div>
          ) : (
            <div className="text-text-primary">
              <ZonedDate date={fixture.date} format="HH:mm" />
            </div>
          )}
        </div>
        <div className="flex-1 flex flex-col gap-1.5 pr-4">
          <div className="flex items-center gap-3">
            <Image
              src={proxyImageUrl(teams.home.logo)}
              alt={teams.home.name}
              width={20}
              height={20}
              unoptimized={true}
            />
            <span className="font-semibold text-base text-text-primary">
              {teams.home.name}
            </span>
          </div>
          <div className="flex items-center gap-3">
            <Image
              src={proxyImageUrl(teams.away.logo)}
              alt={teams.away.name}
              width={20}
              height={20}
              unoptimized={true}
            />
            <span className="font-semibold text-base text-text-primary">
              {teams.away.name}
            </span>
          </div>
        </div>
        <div
          className={`w-10 flex-shrink-0 flex flex-col items-center gap-1.5 text-base font-bold ${
            isLive ? "text-green-400" : "text-text-primary"
          }`}
        >
          <span>{goals.home ?? "-"}</span>
          <span>{goals.away ?? "-"}</span>
        </div>
      </Link>

      <div className="w-64 flex-shrink-0 flex items-center justify-end gap-4 pl-4 border-l border-gray-700/50">
        <div className="flex-1 text-center">
          {isFinished ? (
            !showResult ? (
              <button
                onClick={() => setShowResult(true)}
                className="flex items-center justify-center gap-2 w-full text-sm font-semibold bg-[var(--color-primary)] border border-[var(--text-muted)]/20 text-text-muted hover:bg-[var(--text-muted)] hover:text-black rounded-md p-2.5 transition-all duration-200"
              >
                <History size={16} /> {t("see_prediction_result")}
              </button>
            ) : isLoading ? (
              <div className="flex justify-center items-center gap-2 text-sm font-semibold text-text-muted p-2.5">
                <Loader2 size={16} className="animate-spin" />{" "}
                {t("loading_result")}
              </div>
            ) : customOdds ? (
              <div
                className={`flex items-center justify-center gap-2 p-2.5 rounded-md text-sm font-bold ${
                  wasPredictionCorrect
                    ? "bg-green-500/10 text-green-400"
                    : "bg-gray-700/50 text-text-muted"
                }`}
              >
                {wasPredictionCorrect ? (
                  <CheckCircle size={18} />
                ) : (
                  <XCircle size={18} />
                )}
                <span>
                  {t("predicted_result", {
                    outcome: predictedOutcome,
                    odds: lowestOddValue,
                  })}
                </span>
              </div>
            ) : (
              <span className="text-xs text-text-muted font-semibold">
                {t("prediction_data_unavailable")}
              </span>
            )
          ) : !showResult ? (
            <button
              onClick={() => setShowResult(true)}
              className="flex items-center justify-center gap-2 w-full text-sm font-semibold bg-[var(--brand-accent)]/10 border border-[var(--brand-accent)]/50 text-[var(--brand-accent)] hover:bg-[var(--brand-accent)] hover:text-white rounded-md p-2.5 transition-all duration-200"
            >
              <TrendingUp size={16} />
              {t("show_odds")}
            </button>
          ) : isLoading ? (
            <div className="flex justify-center items-center gap-2 text-sm font-semibold text-text-muted p-2.5">
              <Loader2 size={16} className="animate-spin" />{" "}
              {t("calculating_odds")}
            </div>
          ) : customOdds ? (
            <div className="flex items-center justify-around gap-1">
              <CustomOddBox
                value={customOdds.home}
                label={t("odd_label_home")}
                isFavorite={predictedOutcome === "Home"}
              />
              <CustomOddBox
                value={customOdds.draw}
                label={t("odd_label_draw")}
                isFavorite={predictedOutcome === "Draw"}
              />
              <CustomOddBox
                value={customOdds.away}
                label={t("odd_label_away")}
                isFavorite={predictedOutcome === "Away"}
              />
            </div>
          ) : (
            <span className="text-xs text-text-muted font-semibold">
              {t("odds_unavailable")}
            </span>
          )}
        </div>
      </div>
    </div>
  );
}

export const MatchListItemSkeleton = () => (
  <div
    className="flex items-center p-2 rounded-lg animate-pulse"
    style={{ backgroundColor: "var(--color-secondary)" }}
  >
    <div className="flex-1 flex items-center">
      <div className="w-16 flex-shrink-0">
        <div className="h-5 w-10 mx-auto rounded bg-[var(--color-primary)]"></div>
      </div>
      <div className="flex-1 flex flex-col gap-3">
        <div className="flex items-center gap-3 w-4/5">
          <div className="w-6 h-6 rounded-full bg-[var(--color-primary)]"></div>
          <div className="h-5 w-full rounded bg-[var(--color-primary)]"></div>
        </div>
        <div className="flex items-center gap-3 w-4/5">
          <div className="w-6 h-6 rounded-full bg-[var(--color-primary)]"></div>
          <div className="h-5 w-full rounded bg-[var(--color-primary)]"></div>
        </div>
      </div>
      <div className="w-10 flex-shrink-0 flex flex-col items-center gap-3">
        <div className="h-5 w-4 bg-[var(--color-primary)] rounded"></div>
        <div className="h-5 w-4 bg-[var(--color-primary)] rounded"></div>
      </div>
    </div>
    <div className="w-64 flex-shrink-0 pl-4 border-l border-gray-700/50 flex items-center justify-end gap-4">
      <div className="w-full h-11 rounded-md bg-[var(--color-primary)]"></div>
      <div className="w-6 h-6 rounded-full bg-[var(--color-primary)]"></div>
    </div>
  </div>
);

// ===== src/components/DirectoryCard.tsx =====

import Image from "next/image";
import StyledLink from "./StyledLink";
import { League } from "@/types/api-football";
import { proxyImageUrl } from "@/lib/image-proxy";
import { Star } from "lucide-react";

export const DirectoryCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg p-4 flex items-center gap-4 animate-pulse">
    <div className="w-10 h-10 rounded-full bg-gray-700"></div>
    <div className="space-y-2 flex-1">
      <div className="h-4 w-3/4 rounded bg-gray-600"></div>
      <div className="h-3 w-1/2 rounded bg-gray-600"></div>
    </div>
  </div>
);

interface DirectoryCardProps extends League {
  isPopular?: boolean;
}

export default function DirectoryCard({
  id,
  name,
  logoUrl,
  countryName,
  href,
  isPopular,
}: DirectoryCardProps) {

  const containerClasses = isPopular
    ? "border-l-4 border-brand-purple"
    : "border-l-4 border-transparent";

  return (
    <StyledLink href={href} className="block group h-full">
      {}
      <div
        className={`bg-brand-secondary rounded-lg flex items-center gap-4 p-4 h-full transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20 ${containerClasses}`}
      >
        <Image
          src={proxyImageUrl(logoUrl)}
          alt={`${name} logo`}
          width={40}
          height={40}
          className="flex-shrink-0"
        />
        <div className="flex-1 min-w-0">
          <h3 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
            {name}
          </h3>
          <p className="text-sm text-brand-muted">{countryName}</p>
        </div>
        {}
        {isPopular && (
          <div className="flex-shrink-0" title="Popular Competition">
            <Star className="w-5 h-5 text-yellow-500/80" />
          </div>
        )}
      </div>
    </StyledLink>
  );
}

// ===== src/components/FaqAccordion.tsx =====

"use client";

import { useState } from "react";
import { ChevronDown } from "lucide-react";

interface FaqAccordionProps {
  question: string;
  answer: string;
}

export default function FaqAccordion({ question, answer }: FaqAccordionProps) {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="border-b border-gray-700/50 last:border-b-0">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="w-full flex justify-between items-center text-left p-6 hover:bg-[var(--color-primary)]/50 transition-colors"
        aria-expanded={isOpen}
      >
        {}
        <h3
          className={`text-lg font-semibold transition-colors ${
            isOpen ? "text-[var(--brand-accent)]" : "text-white"
          }`}
        >
          {question}
        </h3>
        <ChevronDown
          size={24}
          className={`text-[var(--brand-accent)] transform transition-transform duration-300 flex-shrink-0 ${
            isOpen ? "rotate-180" : ""
          }`}
        />
      </button>

      <div
        className={`grid transition-all duration-300 ease-in-out ${
          isOpen ? "grid-rows-[1fr] opacity-100" : "grid-rows-[0fr] opacity-0"
        }`}
      >
        <div className="overflow-hidden">
          {}
          <div
            className="px-6 pb-6 text-text-secondary leading-relaxed"
            dangerouslySetInnerHTML={{ __html: answer }}
          />
        </div>
      </div>
    </div>
  );
}

// ===== src/components/FaqClient.tsx =====

"use client";

import { useState, useMemo } from "react";
import Link from "next/link";
import FaqAccordion from "./FaqAccordion";
import { Info, Search, MessageSquarePlus } from "lucide-react";
import { IFaq } from "@/models/Faq";
import { useTranslation } from "@/hooks/useTranslation";

interface FaqClientProps {
  initialFaqs: IFaq[];
}

export default function FaqClient({ initialFaqs }: FaqClientProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const { t } = useTranslation();

  const groupedAndFilteredFaqs = useMemo(() => {
    if (!initialFaqs) return {};

    const filtered =
      searchTerm.length > 2
        ? initialFaqs.filter(
            (faq) =>
              faq.question.toLowerCase().includes(searchTerm.toLowerCase()) ||
              faq.answer.toLowerCase().includes(searchTerm.toLowerCase())
          )
        : initialFaqs;

    return filtered.reduce((acc, faq) => {
      const category = faq.category || "General Questions";
      if (!acc[category]) acc[category] = [];
      acc[category].push(faq);
      return acc;
    }, {} as Record<string, IFaq[]>);
  }, [initialFaqs, searchTerm]);

  const categories = Object.keys(groupedAndFilteredFaqs);

  return (
    <>
      <div className="relative">
        <Search
          className="absolute left-4 top-1/2 -translate-y-1/2 text-text-muted"
          size={20}
        />
        <input
          type="text"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          placeholder={t("faq_search_placeholder")}
          className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-4 pl-12 text-white placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-[var(--brand-accent)]"
        />
      </div>

      {categories.length > 0 ? (
        categories.map((category) => (
          <div
            key={category}
            className="bg-brand-secondary rounded-lg shadow-xl overflow-hidden"
          >
            <h2 className="text-2xl font-bold text-white p-6 border-b border-gray-700/50">
              {category}
            </h2>
            <div>
              {groupedAndFilteredFaqs[category].map((faq) => (
                <FaqAccordion
                  key={faq._id}
                  question={faq.question}
                  answer={faq.answer}
                />
              ))}
            </div>
          </div>
        ))
      ) : (
        <div className="bg-brand-secondary rounded-lg p-8 text-center text-text-muted">
          <Info size={32} className="mx-auto mb-3" />
          <p>{t("faq_no_results_message", { searchTerm })}</p>
        </div>
      )}

      <div className="bg-[var(--brand-accent)]/10 border border-[var(--brand-accent)]/20 p-6 rounded-lg text-center">
        <h3 className="text-xl font-bold text-white mb-2">
          {t("faq_cant_find_answer_title")}
        </h3>
        <p className="text-text-secondary mb-4">
          {t("faq_cant_find_answer_subtitle")}
        </p>
        <Link
          href="/contact-us"
          className="inline-flex items-center justify-center gap-2 bg-[var(--brand-accent)] text-white font-bold py-2 px-5 rounded-lg hover:opacity-90 transition-opacity"
        >
          <MessageSquarePlus size={18} /> {t("contact_support_button")}
        </Link>
      </div>
    </>
  );
}

// ===== src/components/FeaturedNewsRow.tsx =====

import Image from "next/image";
import Link from "next/link";
import { IPost } from "@/models/Post";
import { format } from "date-fns";
import { ArrowUpRight, Calendar, User } from "lucide-react";

interface FeaturedNewsRowProps {
  post: IPost;
  tFeaturedArticle: string;
  tReadMore: string;
}

export function FeaturedNewsRowSkeleton() {
  return (
    <div className="bg-brand-secondary rounded-lg flex flex-col sm:flex-row gap-0 animate-pulse mb-8">
      <div className="w-full sm:w-2/5 h-64 sm:h-auto bg-gray-700 rounded-t-lg sm:rounded-l-lg sm:rounded-tr-none flex-shrink-0"></div>
      <div className="w-full p-8 space-y-4">
        <div className="h-4 w-1/3 bg-gray-600 rounded"></div>
        <div className="h-8 w-full bg-gray-600 rounded"></div>
        <div className="h-8 w-4/5 bg-gray-600 rounded"></div>
        <div className="h-4 w-full bg-gray-600 rounded"></div>
        <div className="h-4 w-2/3 bg-gray-600 rounded"></div>
      </div>
    </div>
  );
}

export default function FeaturedNewsRow({
  post,
  tFeaturedArticle,
  tReadMore,
}: FeaturedNewsRowProps) {

  if (!post) return null;

  const postUrl = `/news/${post.slug}`;

  return (
    <div className="bg-brand-secondary rounded-lg flex flex-col sm:flex-row items-center transition-shadow hover:shadow-2xl hover:shadow-brand-purple/10 mb-8">
      {}
      <Link
        href={postUrl}
        className="block w-full sm:w-2/5 flex-shrink-0 h-64 sm:h-80"
      >
        <div className="relative w-full h-full">
          {post.featuredImage ? (
            <Image
              src={post.featuredImage}
              alt={post.featuredImageAltText || post.title}
              layout="fill"
              objectFit="cover"
              className="rounded-t-lg sm:rounded-l-lg sm:rounded-tr-none"
            />
          ) : (
            <div className="w-full h-full bg-gray-800 flex items-center justify-center rounded-t-lg sm:rounded-l-lg sm:rounded-tr-none">
              <span className="text-brand-muted">No Image</span>
            </div>
          )}
        </div>
      </Link>

      {}
      <div className="p-6 md:p-8 flex flex-col flex-1 min-w-0">
        <p className="text-sm text-brand-purple font-bold mb-2">
          {tFeaturedArticle} {}
        </p>
        <h2 className="font-bold text-white leading-tight mb-3 text-2xl md:text-3xl">
          <Link href={postUrl} className="hover:underline">
            {post.title}
          </Link>
        </h2>
        {post.metaDescription && (
          <p className="text-brand-light text-base flex-grow mb-4 line-clamp-3">
            {post.metaDescription}
          </p>
        )}
        <div className="mt-auto">
          <Link
            href={postUrl}
            className="text-brand-purple font-semibold text-sm flex items-center gap-1"
          >
            {tReadMore} <ArrowUpRight size={16} /> {}
          </Link>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/FinishedMatchSlide.tsx =====

"use client";

import Image from 'next/image';
import { format } from 'date-fns';
import { Calendar, History } from 'lucide-react';

interface MatchSlideProps {
  match: any;
}

export default function FinishedMatchSlide({ match }: MatchSlideProps) {
  const { teams, fixture, goals, league } = match;

  return (
    <div className="relative w-full h-64 overflow-hidden rounded-2xl bg-brand-secondary text-white">
      {}
      <Image
        src="https://images.unsplash.com/photo-1508098682722-e99c43a406b2?q=80&w=2070&auto=format&fit=crop"
        alt="Dark stadium background"
        layout="fill"
        objectFit="cover"
        className="z-0 opacity-80"
      />
      <div className="absolute inset-0 bg-black/70 z-10" />

      {}
      <div className="relative z-20 flex h-full flex-col items-center justify-center p-4">
        <p className="font-semibold tracking-wider text-brand-muted flex items-center gap-2">
            <History size={14} />
            Recent Result
        </p>
        <p className="text-sm text-brand-muted mb-4">{league.round}</p>

        <div className="flex items-center justify-around w-full max-w-2xl my-2">
          {}
          <div className="flex flex-col items-center gap-2 text-center w-1/3">
            <Image src={teams.home.logo} alt={teams.home.name} width={48} height={48}/>
            <h2 className="text-xl font-bold truncate">{teams.home.name}</h2>
          </div>

          {}
          <span className="text-5xl font-black text-white mx-4">
            {goals.home} - {goals.away}
          </span>

          {}
          <div className="flex flex-col items-center gap-2 text-center w-1/3">
            <Image src={teams.away.logo} alt={teams.away.name} width={48} height={48}/>
            <h2 className="text-xl font-bold truncate">{teams.away.name}</h2>
          </div>
        </div>

        <div className="mt-6 flex items-center gap-2 text-brand-muted">
            <Calendar size={16} />
            <span>{format(new Date(fixture.date), "dd MMMM yyyy")}</span>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/Footer.tsx =====

import Image from "next/image";
import Link from "next/link";
import { getI18n } from "@/lib/i18n/server";
import { headers } from "next/headers";
import FooterContent from "./FooterContent";
import { SUPPORTED_LOCALES, DEFAULT_LOCALE } from "@/lib/i18n/config";

const getLocaleFromPathname = (pathname: string) => {
  const firstSegment = pathname.split("/")[1];
  if (SUPPORTED_LOCALES.includes(firstSegment)) {
    return firstSegment;
  }
  return DEFAULT_LOCALE;
};

export default async function Footer() {
  const pathname = headers().get("x-next-pathname") || "/";
  const locale = getLocaleFromPathname(pathname);
  const t = await getI18n(locale);

  return (
    <footer className="bg-brand-secondary text-white py-12">
      <div className="container mx-auto px-4">
        <FooterContent locale={locale} />

        <div className="flex flex-col md:flex-row justify-between items-center border-t border-gray-700/50 pt-8 mb-8">
          <div className="mb-6 md:mb-0">
            <Image
              src="/fanskor-transparent.webp"
              alt="Fanskor logo"
              width={280}
              height={40}
            />
          </div>
          <div className="flex items-center justify-center flex-wrap gap-x-6 gap-y-4 md:gap-8">
            <Image
              src="/images/logos/18plus.svg"
              alt="18+ Responsible Gaming"
              width={40}
              height={40}
            />
            <Image
              src="/images/logos/gamcare.svg"
              alt="GamCare Verified"
              width={110}
              height={35}
            />
            <Image
              src="/images/logos/begambleaware.svg"
              alt="BeGambleAware"
              width={190}
              height={25}
            />
            <Image
              src="/images/logos/dmca-protected.svg"
              alt="DMCA Protected"
              width={180}
              height={35}
            />
          </div>
        </div>

        <div className="flex flex-col md:flex-row justify-between items-center text-sm text-brand-muted">
          <p className="mb-4 md:mb-0 text-center md:text-left">
             {new Date().getFullYear()} Fan skor -{" "}
            {t("footer_rights_reserved")}
          </p>
          <div className="flex flex-wrap justify-center gap-x-4 gap-y-2">
            <Link href="/privacy-policy" className="hover:text-white">
              {t("privacy_policy_title")}
            </Link>
            <Link href="/terms-and-conditions" className="hover:text-white">
              {t("terms_and_conditions_title")}
            </Link>
            <Link href="/gdpr" className="hover:text-white">
              {t("gdpr_title")}
            </Link>
          </div>
        </div>
      </div>
    </footer>
  );
}

// ===== src/components/FooterContent.tsx =====

import Link from "next/link";

import { getI18n } from "@/lib/i18n/server";

const FooterLink = ({
  href,
  children,
}: {
  href: string;
  children: React.ReactNode;
}) => (
  <Link
    href={href}
    className="text-sm text-brand-muted hover:text-white transition-colors"
  >
    {children}
  </Link>
);

const FooterColumn = ({
  title,
  children,
}: {
  title: string;
  children: React.ReactNode;
}) => (
  <div className="space-y-4">
    <h4 className="font-bold text-white uppercase tracking-wider">{title}</h4>
    <div className="flex flex-col space-y-3">{children}</div>
  </div>
);

const fetchRecentFootballScores = async () => {
  return [
    { id: 1, home: "RB Salzburg", away: "Real Madrid", href: "#" },
    { id: 2, home: "Juventus", away: "Man City", href: "#" },
    { id: 3, home: "Man City", away: "Al-Ain", href: "#" },
    { id: 4, home: "Benfica", away: "Chelsea", href: "#" },
    { id: 5, home: "Esprance", away: "Chelsea", href: "#" },
  ];
};

export default async function FooterContent({ locale }: { locale: string }) {
  const t = await getI18n(locale);

  const footballScores = await fetchRecentFootballScores();

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8 mb-12">
      <div className="space-y-8">
        <div>
          <p className="font-bold text-white uppercase tracking-wider mb-4">
            {t("footer_about_title")}
          </p>
          <p className="text-sm text-brand-muted leading-relaxed">
            {t("footer_about_text")}
          </p>
        </div>
        <div>
          {}
          <div className="text-sm text-brand-muted space-y-2">
            {}
          </div>
        </div>
      </div>

      <div>
        <FooterColumn title={t("football")}>
          <FooterLink href="/football/league/premier-league-39">
            Premier League
          </FooterLink>
          <FooterLink href="/football/league/la-liga-140">LaLiga</FooterLink>
          <FooterLink href="/football/league/serie-a-135">Serie A</FooterLink>
          <FooterLink href="/football/league/bundesliga-78">
            Bundesliga
          </FooterLink>
          <FooterLink href="/football/league/ligue-1-61">Ligue 1</FooterLink>
          <FooterLink href="/football/league/uefa-champions-league-2">
            UEFA Champions League
          </FooterLink>
        </FooterColumn>
      </div>

      <div>
        <FooterColumn title={t("footer_football_scores_title")}>
          {footballScores?.map((score) => (
            <FooterLink key={score.id} href={score.href}>
              {score.home} - {score.away}
            </FooterLink>
          ))}
        </FooterColumn>
      </div>

      <div>
        <FooterColumn title={t("footer_information_title")}>
          <FooterLink href="/contact-us">{t("contact_us")}</FooterLink>
          <FooterLink href="/faq">{t("faq_title")}</FooterLink>
          <FooterLink href="/author">{t("author_title")}</FooterLink>
          <FooterLink href="/report-abuse">
            {t("report_abuse_title")}
          </FooterLink>
          <FooterLink href="/privacy-policy">
            {t("privacy_policy_title")}
          </FooterLink>
          <FooterLink href="/terms-and-conditions">
            {t("terms_and_conditions_title")}
          </FooterLink>
        </FooterColumn>
      </div>
    </div>
  );
}

// ===== src/components/Header.tsx =====

"use client";

import { useState, useEffect, Suspense, Fragment } from "react";
import { usePathname } from "next/navigation";
import Image from "next/image";
import {
  Users,
  Newspaper,
  BookOpen,
  Repeat,
  Menu,
  X,
  Search,
  ChevronDown,
  ListOrdered,
  Shield,
  Trophy,
  TrendingUp,
  Radio,
} from "lucide-react";
import { Dialog, Transition } from "@headlessui/react";
import LanguageDropdown from "./LanguageDropdown";
import { useTranslation } from "@/hooks/useTranslation";
import StyledLink from "./StyledLink";
import Ticker from "./Ticker";
import { useScrollDirection } from "@/hooks/useScrollDirection";
import HeaderSearchModal from "./HeaderSearchModal";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { ILanguage } from "@/models/Language";

type NavIcon = React.ElementType;

interface SubLink {
  name: string;
  href: string;
  description: string;
  icon?: NavIcon;
}

interface NavItem {
  title: string;
  href: string;
  icon: NavIcon;
  isDropdown?: boolean;
  subLinks?: SubLink[];
}

const fetchActiveLanguages = async (): Promise<ILanguage[]> => {
  const { data } = await axios.get("/api/admin/languages?active=true");
  return data;
};

export default function Header() {
  const { t } = useTranslation();
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const [openMenu, setOpenMenu] = useState<string | null>(null);
  const pathname = usePathname();

  const { isSticky, isVisible } = useScrollDirection({ threshold: 50 });

  const { data: languages, isLoading: isLoadingLanguages } = useQuery<
    ILanguage[]
  >({
    queryKey: ["activeLanguages"],
    queryFn: fetchActiveLanguages,
    staleTime: 1000 * 60 * 60,
  });

  useEffect(() => {
    if (isMobileMenuOpen || isSearchOpen) {
      setIsMobileMenuOpen(false);
      setIsSearchOpen(false);
    }
  }, [pathname]);

  const navItems: NavItem[] = [
    { title: t("fixtures"), href: "/", icon: Shield },
    { title: t("teams"), href: "/football/teams", icon: Users },
    { title: t("highlights"), href: "/highlights", icon: Trophy },
    { title: t("predictions"), href: "/predictions", icon: TrendingUp },
    { title: t("standings"), href: "/football/standings", icon: ListOrdered },
    {
      title: t("news_and_stories"),
      href: "/news",
      icon: Radio,
      isDropdown: true,
      subLinks: [
        {
          name: t("latest_news"),
          href: "/news/category/recent",
          description: t("latest_news_desc"),
          icon: Newspaper,
        },
        {
          name: t("transfer_news"),
          href: "/news/category/transfer",
          description: t("transfer_news_desc"),
          icon: Repeat,
        },
        {
          name: t("blogs"),
          href: "/news/category/football",
          description: t("blogs_desc"),
          icon: BookOpen,
        },
      ],
    },
  ];

  const MobileFlyoutMenu = () => (
    <Transition.Root show={isMobileMenuOpen} as={Fragment}>
      <Dialog
        as="div"
        className="relative z-[100] lg:hidden"
        onClose={setIsMobileMenuOpen}
      >
        <Transition.Child
          as={Fragment}
          enter="ease-in-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in-out duration-300"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black" />
        </Transition.Child>
        <Transition.Child
          as={Fragment}
          enter="transform transition ease-in-out duration-300"
          enterFrom="-translate-x-full"
          enterTo="translate-x-0"
          leave="transform transition ease-in-out duration-300"
          leaveFrom="translate-x-0"
          leaveTo="-translate-x-full"
        >
          <Dialog.Panel className="fixed inset-y-0 left-0 w-full max-w-xs bg-brand-dark flex flex-col">
            <div className="flex items-center justify-between px-4 h-20 border-b border-gray-800 flex-shrink-0">
              <StyledLink href="/">
                <Image
                  src={"/fanskor.webp"}
                  alt="fanskor-logo"
                  width={150}
                  height={50}
                />
              </StyledLink>
              <button
                onClick={() => setIsMobileMenuOpen(false)}
                className="p-2"
                aria-label="Close mobile menu"
              >
                <X size={28} />
              </button>
            </div>

            <div className="p-4 border-b border-gray-800">
              <LanguageDropdown
                languages={languages}
                isLoading={isLoadingLanguages}
              />
            </div>

            <nav className="flex-1 overflow-y-auto custom-scrollbar p-4">
              <ul className="space-y-1">
                {navItems.map((item) => {
                  const isActive =
                    (pathname === item.href && item.href === "/") ||
                    (item.href !== "/" && pathname.startsWith(item.href));
                  return (
                    <li key={item.title}>
                      <StyledLink
                        href={item.href}
                        className={`flex items-center gap-4 w-full rounded-lg p-3 text-lg font-semibold transition-colors ${
                          isActive
                            ? "bg-[var(--brand-accent)] text-white"
                            : "text-brand-light hover:bg-brand-secondary"
                        }`}
                      >
                        <item.icon size={22} /> {item.title}
                      </StyledLink>
                    </li>
                  );
                })}
              </ul>
            </nav>

            <div className="p-4 mt-auto border-t border-gray-800">
              <div className="flex justify-center gap-x-6 text-xs text-text-muted">
                <StyledLink href="/privacy-policy" className="hover:text-white">
                  Privacy
                </StyledLink>
                <StyledLink
                  href="/terms-and-conditions"
                  className="hover:text-white"
                >
                  Terms
                </StyledLink>
                <StyledLink href="/contact-us" className="hover:text-white">
                  Contact
                </StyledLink>
              </div>
            </div>
          </Dialog.Panel>
        </Transition.Child>
      </Dialog>
    </Transition.Root>
  );

  return (
    <div
      className={`
        ${isSticky ? "sticky" : "relative"}
        top-0 z-50 w-full bg-brand-secondary
        transition-transform duration-300 ease-in-out
        ${isVisible ? "translate-y-0" : "-translate-y-full"}
      `}
    >
      <header className="relative w-full z-40 border-b border-gray-700/50">
        <div className="container mx-auto flex h-20 items-center justify-between px-4 lg:px-6">
          <div className="flex items-center gap-x-6">
            <StyledLink href="/" className="flex-shrink-0">
              <Image
                src={"/fanskor.webp"}
                alt="fanskor-logo"
                width={160}
                height={54}
                priority
              />
            </StyledLink>
            <nav className="hidden lg:flex items-center gap-x-2">
              {navItems.map((item) => (
                <li
                  key={item.title}
                  className="list-none relative"
                  onMouseEnter={() =>
                    item.isDropdown && setOpenMenu(item.title)
                  }
                  onMouseLeave={() => item.isDropdown && setOpenMenu(null)}
                >
                  <StyledLink
                    href={item.href}
                    className={`relative flex items-center gap-2 px-4 py-2 text-base font-semibold transition-colors group rounded-md ${
                      (pathname === item.href && item.href === "/") ||
                      (item.href !== "/" && pathname.startsWith(item.href))
                        ? "text-white bg-white/5"
                        : "text-text-secondary hover:text-white hover:bg-white/5"
                    }`}
                  >
                    <item.icon size={18} />
                    {item.title}
                    {item.isDropdown && (
                      <ChevronDown
                        size={16}
                        className={`transition-transform duration-300 ${
                          openMenu === item.title ? "rotate-180" : ""
                        }`}
                      />
                    )}
                    {((pathname === item.href && item.href === "/") ||
                      (item.href !== "/" &&
                        pathname.startsWith(item.href))) && (
                      <span className="absolute -bottom-1.5 left-1/2 -translate-x-1/2 w-1.5 h-1.5 bg-[var(--brand-accent)] rounded-full"></span>
                    )}
                  </StyledLink>
                  {item.isDropdown && (
                    <Transition
                      show={openMenu === item.title}
                      as={Fragment}
                      enter="transition ease-out duration-200"
                      enterFrom="opacity-0 translate-y-2"
                      enterTo="opacity-100 translate-y-0"
                      leave="transition ease-in duration-150"
                      leaveFrom="opacity-100 translate-y-0"
                      leaveTo="opacity-0 translate-y-2"
                    >
                      <div className="absolute top-full left-1/2 -translate-x-1/2 pt-4 w-auto">
                        <div className="bg-brand-secondary rounded-xl shadow-2xl border border-gray-700/50 p-4">
                          <div className="grid grid-flow-col auto-cols-max gap-4">
                            {(item.subLinks || []).map((subLink) => (
                              <StyledLink
                                key={subLink.name}
                                href={subLink.href}
                                className="group flex items-start gap-4 p-3 rounded-lg hover:bg-black/20 transition-colors w-72"
                              >
                                <div className="flex-shrink-0 bg-black/20 p-3 rounded-lg text-[var(--brand-accent)]">
                                  {subLink.icon && <subLink.icon size={24} />}
                                </div>
                                <div>
                                  <p className="font-bold text-white group-hover:text-[var(--brand-accent)] transition-colors">
                                    {subLink.name}
                                  </p>
                                  <p className="text-sm text-text-muted mt-1">
                                    {subLink.description}
                                  </p>
                                </div>
                              </StyledLink>
                            ))}
                          </div>
                        </div>
                      </div>
                    </Transition>
                  )}
                </li>
              ))}
            </nav>
          </div>
          <div className="flex items-center gap-2 md:gap-4 flex-shrink-0">
            <button
              onClick={() => setIsSearchOpen(true)}
              className="p-2 text-text-muted hover:text-white transition-colors"
            >
              <Search size={22} />
            </button>
            <div className="hidden md:block">
              <LanguageDropdown
                languages={languages}
                isLoading={isLoadingLanguages}
              />
            </div>
            <div className="flex lg:hidden">
              <button
                onClick={() => setIsMobileMenuOpen(true)}
                aria-label="Open menu"
                className="p-2"
              >
                <Menu size={26} />
              </button>
            </div>
          </div>
        </div>
      </header>
      <HeaderSearchModal
        isOpen={isSearchOpen}
        onClose={() => setIsSearchOpen(false)}
      />
      <MobileFlyoutMenu />
      <Suspense fallback={null}>
        <Ticker />
      </Suspense>
    </div>
  );
}

// ===== src/components/HeaderSearchModal.tsx =====

"use client";

import { useState, useEffect, Fragment } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { Search, Loader2, Trophy, Users, X, ChevronDown } from "lucide-react";
import { Transition, Popover } from "@headlessui/react";
import Image from "next/image";

import { useDebounce } from "@/hooks/useDebounce";
import { useTranslation } from "@/hooks/useTranslation";
import StyledLink from "./StyledLink";
import { proxyImageUrl } from "@/lib/image-proxy";

interface SearchResult {
  teams: any[];
  leagues: any[];
}
type SearchCategory = "all" | "league" | "team";

const POPULAR_SEARCHES = [
  {
    id: 39,
    name: "Premier League",
    meta: "LEAGUE, ENGLAND",
    logo: "https://media-4.api-sports.io/football/leagues/39.png",
    href: "/football/league/premier-league-39",
  },
  {
    id: 2,
    name: "UEFA Champions League",
    meta: "LEAGUE, WORLD",
    logo: "https://media-4.api-sports.io/football/leagues/2.png",
    href: "/football/league/uefa-champions-league-2",
  },
  {
    id: 33,
    name: "Manchester United",
    meta: "TEAM, ENGLAND",
    logo: "https://media-4.api-sports.io/football/teams/33.png",
    href: "/football/team/manchester-united-33",
  },
  {
    id: 140,
    name: "La Liga",
    meta: "LEAGUE, SPAIN",
    logo: "https://media-4.api-sports.io/football/leagues/140.png",
    href: "/football/league/la-liga-140",
  },
  {
    id: 529,
    name: "Barcelona",
    meta: "TEAM, SPAIN",
    logo: "https://media-4.api-sports.io/football/teams/529.png",
    href: "/football/team/barcelona-529",
  },
];

const fetchSearchResults = async (query: string): Promise<SearchResult> => {
  const { data } = await axios.get(`/api/search/global?q=${query}`);
  return data;
};

const SearchResultItem = ({
  href,
  logo,
  name,
  meta,
  onClose,
}: {
  href: string;
  logo: string;
  name: string;
  meta: string;
  onClose: () => void;
}) => (
  <StyledLink
    href={href}
    onClick={onClose}
    className="flex items-center gap-3 p-2.5 rounded-lg hover:bg-white/5 transition-colors"
  >
    <Image
      src={proxyImageUrl(logo)}
      alt={name}
      width={32}
      height={32}
      className="bg-white/10 rounded-full p-0.5"
    />
    <div>
      <p className="font-semibold text-white text-sm">{name}</p>
      <p className="text-xs text-text-muted">{meta}</p>
    </div>
  </StyledLink>
);

const SearchResultSkeleton = () => (
  <div className="flex items-center gap-3 p-2.5 animate-pulse">
    <div className="w-8 h-8 rounded-full bg-gray-700"></div>
    <div className="flex-1 space-y-1.5">
      <div className="h-4 w-3/4 bg-gray-600 rounded"></div>
      <div className="h-3 w-1/2 bg-gray-600 rounded"></div>
    </div>
  </div>
);

export default function HeaderSearchModal({
  isOpen,
  onClose,
}: {
  isOpen: boolean;
  onClose: () => void;
}) {
  const { t } = useTranslation();
  const [query, setQuery] = useState("");
  const [category, setCategory] = useState<SearchCategory>("all");
  const debouncedQuery = useDebounce(query, 300);

  const { data, isLoading } = useQuery({
    queryKey: ["globalSearch", debouncedQuery],
    queryFn: () => fetchSearchResults(debouncedQuery),
    enabled: debouncedQuery.length >= 3,
    staleTime: 1000 * 60 * 5,
  });

  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "";
    }

    return () => {
      document.body.style.overflow = "";
    };
  }, [isOpen]);

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === "Escape") onClose();
    };
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [onClose]);

  useEffect(() => {
    if (!isOpen) {
      setQuery("");
      setCategory("all");
    }
  }, [isOpen]);

  const filteredData = {
    leagues:
      category === "all" || category === "league" ? data?.leagues || [] : [],
    teams: category === "all" || category === "team" ? data?.teams || [] : [],
  };

  const hasResults =
    filteredData.teams.length > 0 || filteredData.leagues.length > 0;

  const categoryOptions: { key: SearchCategory; label: string }[] = [
    { key: "all", label: t("all") },
    { key: "league", label: t("leagues") },
    { key: "team", label: t("teams") },
  ];

  return (
    <Transition show={isOpen} as={Fragment}>
      <div className="fixed inset-0 z-[100] bg-black/50 flex items-start justify-center pt-24 p-4">
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-200"
          enterFrom="opacity-0 scale-95"
          enterTo="opacity-100 scale-100"
          leave="ease-in duration-150"
          leaveFrom="opacity-100 scale-100"
          leaveTo="opacity-0 scale-95"
        >
          <div className="bg-brand-secondary rounded-xl shadow-2xl border border-gray-700 flex flex-col w-full max-w-xl">
            {}
            <div className="flex justify-between items-center p-3 pl-4 border-b border-gray-700/50">
              <h2 className="text-lg font-bold text-white">{t("search")}</h2>
              <button
                onClick={onClose}
                className="p-2 text-text-muted hover:text-white rounded-full hover:bg-white/10"
              >
                <X size={20} />
              </button>
            </div>

            {}
            <div className="flex items-center gap-2 p-3">
              <div className="relative flex-grow">
                <Search
                  className="absolute left-4 top-1/2 -translate-y-1/2 text-text-muted"
                  size={18}
                />
                <input
                  type="search"
                  autoFocus
                  value={query}
                  onChange={(e) => setQuery(e.target.value)}
                  placeholder={t("search_type_here")}
                  className="w-full bg-brand-dark border border-gray-600 rounded-md py-2 pl-11 pr-4 text-base text-white placeholder:text-text-muted focus:outline-none focus:ring-1 focus:ring-[var(--brand-accent)]"
                />
              </div>

              <Popover className="relative">
                <Popover.Button className="flex items-center gap-2 w-32 justify-between px-3 py-2 bg-brand-dark border border-gray-600 rounded-md text-white text-sm font-semibold">
                  <span>
                    {categoryOptions.find((c) => c.key === category)?.label}
                  </span>
                  <ChevronDown size={16} />
                </Popover.Button>
                <Transition
                  as={Fragment}
                  enter="transition ease-out duration-100"
                  enterFrom="opacity-0 scale-95"
                  enterTo="opacity-100 scale-100"
                  leave="transition ease-in duration-75"
                  leaveFrom="opacity-100 scale-100"
                  leaveTo="opacity-0 scale-95"
                >
                  <Popover.Panel className="absolute right-0 mt-1 w-36 origin-top-right rounded-md bg-brand-dark shadow-lg ring-1 ring-black/5 focus:outline-none">
                    <div className="p-1">
                      {categoryOptions.map((opt) => (
                        <Popover.Button
                          as="button"
                          key={opt.key}
                          onClick={() => setCategory(opt.key)}
                          className="w-full text-left px-3 py-2 text-sm rounded hover:bg-brand-secondary"
                        >
                          {opt.label}
                        </Popover.Button>
                      ))}
                    </div>
                  </Popover.Panel>
                </Transition>
              </Popover>
            </div>

            {}
            <div className="max-h-[50vh] min-h-[18rem] overflow-y-auto custom-scrollbar p-2">
              {debouncedQuery.length < 3 && (
                <div className="p-4">
                  <h3 className="text-xs font-bold uppercase text-text-muted px-2 py-2">
                    {t("most_popular_searches")}
                  </h3>
                  {POPULAR_SEARCHES.map((item) => (
                    <SearchResultItem
                      key={item.id}
                      {...item}
                      meta={item.meta}
                      onClose={onClose}
                    />
                  ))}
                </div>
              )}
              {debouncedQuery.length >= 3 && isLoading && (
                <div className="p-2 space-y-1">
                  <SearchResultSkeleton />
                  <SearchResultSkeleton />
                  <SearchResultSkeleton />
                </div>
              )}
              {debouncedQuery.length >= 3 && !isLoading && !hasResults && (
                <div className="p-10 text-center text-text-muted text-sm">
                  <p>
                    {t("no_search_results_subtitle", {
                      searchTerm: debouncedQuery,
                    })}
                  </p>
                </div>
              )}
              {debouncedQuery.length >= 3 && hasResults && (
                <div className="space-y-2">
                  {filteredData.leagues.length > 0 && (
                    <section>
                      <h3 className="text-xs font-bold uppercase text-text-muted px-2 py-2 flex items-center gap-2">
                        <Trophy size={14} /> {t("leagues")}
                      </h3>
                      {filteredData.leagues.map((league) => (
                        <SearchResultItem
                          key={`l-${league.id}`}
                          {...league}
                          meta={league.country}
                          onClose={onClose}
                        />
                      ))}
                    </section>
                  )}
                  {filteredData.teams.length > 0 && (
                    <section>
                      <h3 className="text-xs font-bold uppercase text-text-muted px-2 py-2 flex items-center gap-2">
                        <Users size={14} /> {t("teams")}
                      </h3>
                      {filteredData.teams.map((team) => (
                        <SearchResultItem
                          key={`t-${team.id}`}
                          {...team}
                          meta={team.country}
                          onClose={onClose}
                        />
                      ))}
                    </section>
                  )}
                </div>
              )}
            </div>
          </div>
        </Transition.Child>
      </div>
    </Transition>
  );
}

// ===== src/components/HighlightCard.tsx =====

"use client";

import { useState } from "react";
import Image from "next/image";
import { PlayCircle, Youtube, Film } from "lucide-react";

interface Highlight {
  id: string;
  title: string;
  thumbnailUrl: string;
  embedUrl: string;
  source: "Highlightly" | "YouTube";
  publishedAt: string;
}

const HighlightCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg animate-pulse">
    <div className="aspect-video w-full bg-gray-700/50 rounded-t-lg"></div>
    <div className="p-4 space-y-3">
      <div className="h-4 w-1/4 bg-gray-600 rounded"></div>
      <div className="h-5 w-full bg-gray-600 rounded"></div>
      <div className="h-5 w-4/5 bg-gray-600 rounded"></div>
    </div>
  </div>
);

export default function HighlightCard({ highlight }: { highlight: Highlight }) {
  const [isModalOpen, setIsModalOpen] = useState(false);

  const SourceIcon = highlight.source === "YouTube" ? Youtube : Film;
  const sourceColor =
    highlight.source === "YouTube" ? "text-red-500" : "text-blue-400";

  return (
    <>
      <div
        className="bg-brand-secondary rounded-lg overflow-hidden group cursor-pointer transition-all duration-300 hover:shadow-xl hover:shadow-[var(--brand-accent)]/20 hover:-translate-y-1"
        onClick={() => setIsModalOpen(true)}
      >
        <div className="relative aspect-video w-full">
          <Image
            src={highlight.thumbnailUrl}
            alt={highlight.title}
            layout="fill"
            objectFit="cover"
            className="transition-transform duration-500 group-hover:scale-105"
          />
          <div className="absolute inset-0 bg-black/40 group-hover:bg-black/60 transition-opacity flex items-center justify-center">
            <PlayCircle
              size={64}
              className="text-white/80 group-hover:text-white group-hover:scale-110 transition-transform duration-300"
              strokeWidth={1.5}
            />
          </div>
        </div>
        <div className="p-4">
          <div className="flex items-center gap-2 mb-2">
            <SourceIcon size={16} className={sourceColor} />
            <span className={`text-xs font-bold uppercase ${sourceColor}`}>
              {highlight.source}
            </span>
          </div>
          <h3 className="font-bold text-white leading-tight line-clamp-2">
            {highlight.title}
          </h3>
        </div>
      </div>

      {}
      {isModalOpen && (
        <div
          className="fixed inset-0 z-[101] bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 animate-fade-in"
          onClick={() => setIsModalOpen(false)}
        >
          <div
            className="relative w-full max-w-4xl"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="aspect-video w-full bg-black rounded-lg overflow-hidden">
              <iframe
                src={`${highlight.embedUrl}?autoplay=1`}
                title={highlight.title}
                frameBorder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowFullScreen
                className="w-full h-full"
              ></iframe>
            </div>
          </div>
        </div>
      )}
    </>
  );
}

export { HighlightCardSkeleton };

// ===== src/components/HighlightSlide.tsx =====

"use client";

import LiteYouTubeEmbed from "./LiteYouTubeEmbed";

interface Highlight {
  id: string;
  embedUrl: string | null | undefined;
  title: string;
}

interface HighlightSlideProps {
  highlight: Highlight;
}

function getYouTubeId(url: string | null | undefined): string | null {

  if (!url || typeof url !== "string") {
    return null;
  }

  const regExp =
    /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
  const match = url.match(regExp);
  return match && match[2].length === 11 ? match[2] : null;
}

export default function HighlightSlide({ highlight }: HighlightSlideProps) {
  const videoId = getYouTubeId(highlight.embedUrl);

  if (!videoId) {
    return null;
  }

  return <LiteYouTubeEmbed id={videoId} title={highlight.title} />;
}

// ===== src/components/LanguageDropdown.tsx =====

"use client";

import { useState, Fragment } from "react";
import { usePathname, useRouter } from "next/navigation";
import Image from "next/image";
import { ChevronDown, Loader2 } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";
import { ILanguage } from "@/models/Language";
import { Menu, Transition } from "@headlessui/react";
import { setLocaleCookie } from "@/app/actions/language";
import { DEFAULT_LOCALE } from "@/lib/i18n/config";

interface LanguageDropdownProps {
  languages: ILanguage[] | undefined;
  isLoading: boolean;
}

export default function LanguageDropdown({
  languages,
  isLoading,
}: LanguageDropdownProps) {
  const [isPending, startTransition] = useState(false);
  const router = useRouter();
  const pathname = usePathname();
  const { locale: currentLocale } = useTranslation();

  const selectedLanguage = languages?.find(
    (lang) => lang.code === currentLocale
  );

  const handleSelect = (newLocale: string) => {
    let newPath = "";
    const isSwitchingToDefault = newLocale === DEFAULT_LOCALE;
    const isSwitchingFromDefault = currentLocale === DEFAULT_LOCALE;

    if (isSwitchingToDefault) {
      newPath = pathname.replace(`/${currentLocale}`, "");
    } else if (isSwitchingFromDefault) {
      newPath = `/${newLocale}${pathname}`;
    } else {
      newPath = pathname.replace(`/${currentLocale}`, `/${newLocale}`);
    }
    if (newPath === "") newPath = "/";

    startTransition(true);
    setLocaleCookie(newLocale).then(() => {
      router.push(newPath);
    });
  };

  const buttonContent = () => {
    if (isLoading || isPending) {
      return <Loader2 size={20} className="animate-spin" />;
    }
    if (selectedLanguage) {
      return (
        <>
          {selectedLanguage.flagUrl ? (
            <Image
              src={selectedLanguage.flagUrl}
              alt={selectedLanguage.name}
              width={20}
              height={15}
              unoptimized
            />
          ) : (
            <span className="font-bold text-sm">
              {selectedLanguage.code.toUpperCase()}
            </span>
          )}
          <span className="text-sm hidden md:block">
            {selectedLanguage.name}
          </span>
          <ChevronDown
            size={16}
            className="transition-transform duration-200 ui-open:rotate-180"
          />
        </>
      );
    }
    return <span>Select Language</span>;
  };

  return (
    <Menu as="div" className="relative inline-block text-left w-full md:w-auto">
      <div>
        <Menu.Button
          disabled={isLoading || isPending}
          className="inline-flex w-full justify-center items-center gap-2 bg-brand-secondary px-3 py-2 rounded-lg text-brand-light font-medium hover:bg-gray-700/50 transition-colors disabled:opacity-50"
        >
          {buttonContent()}
        </Menu.Button>
      </div>

      <Transition
        as={Fragment}
        enter="transition ease-out duration-100"
        enterFrom="transform opacity-0 scale-95"
        enterTo="transform opacity-100 scale-100"
        leave="transition ease-in duration-75"
        leaveFrom="transform opacity-100 scale-100"
        leaveTo="transform opacity-0 scale-95"
      >
        <Menu.Items className="absolute right-0 mt-2 w-48 origin-top-right divide-y divide-gray-700 rounded-md bg-brand-secondary shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none z-[100]">
          <div className="p-1">
            {languages?.map((lang) => (
              <Menu.Item key={lang.code}>
                {({ active }) => (
                  <button
                    onClick={() => handleSelect(lang.code)}
                    disabled={lang.code === currentLocale}
                    className={`${
                      active || lang.code === currentLocale
                        ? "bg-brand-purple text-white"
                        : "text-brand-light"
                    } group flex w-full items-center rounded-md px-2 py-2 text-sm disabled:opacity-70 disabled:cursor-not-allowed`}
                  >
                    <div className="flex items-center gap-3">
                      {lang.flagUrl ? (
                        <Image
                          src={lang.flagUrl}
                          alt={lang.name}
                          width={20}
                          height={15}
                          unoptimized
                        />
                      ) : (
                        <span className="w-5 text-center font-semibold">
                          {lang.code.toUpperCase()}
                        </span>
                      )}
                      <span>{lang.name}</span>
                    </div>
                  </button>
                )}
              </Menu.Item>
            ))}
          </div>
        </Menu.Items>
      </Transition>
    </Menu>
  );
}

// ===== src/components/LatestHighlightsWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Slider from "react-slick";
import HighlightSlide from "./HighlightSlide";
import { ChevronLeft, ChevronRight } from "lucide-react";

interface Highlight {
  id: string;
  embedUrl: string;
  title: string;
}

const fetchLatestHighlights = async (): Promise<Highlight[] | null> => {
  try {
    const { data } = await axios.get("/api/highlights/latest");
    return data?.highlights || null;
  } catch (error) {

    return null;
  }
};

const SliderSkeleton = () => (
  <div className="aspect-video w-full bg-brand-dark rounded-lg animate-pulse"></div>
);

const NextArrow = ({ onClick }: { onClick?: () => void }) => (
  <button
    onClick={onClick}
    className="absolute top-4 right-4 z-10 p-2 bg-black/40 text-white rounded-full hover:bg-black/70 transition-colors"
    aria-label="Next slide"
  >
    <ChevronRight size={20} />
  </button>
);

const PrevArrow = ({ onClick }: { onClick?: () => void }) => (
  <button
    onClick={onClick}
    className="absolute top-4 right-16 z-10 p-2 bg-black/40 text-white rounded-full hover:bg-black/70 transition-colors"
    aria-label="Previous slide"
  >
    <ChevronLeft size={20} />
  </button>
);

export default function LatestHighlightsWidget() {
  const {
    data: highlights,
    isLoading,
    isError,
  } = useQuery<Highlight[] | null>({
    queryKey: ["latestHighlightsWidget"],
    queryFn: fetchLatestHighlights,
    staleTime: 1000 * 60 * 10,
  });

  const sliderSettings = {
    dots: false,
    infinite: true,
    speed: 500,
    slidesToShow: 1,
    slidesToScroll: 1,
    arrows: true,
    nextArrow: <NextArrow />,
    prevArrow: <PrevArrow />,
    autoplay: true,
    autoplaySpeed: 8000,
    pauseOnHover: true,
  };

  if (isError || (!isLoading && (!highlights || highlights.length === 0))) {
    return null;
  }

  return (
    <section className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden">
      {}
      <div className="relative w-full">
        {isLoading ? (
          <SliderSkeleton />
        ) : (
          <Slider {...sliderSettings}>
            {highlights?.map((highlight) => (
              <HighlightSlide key={highlight.id} highlight={highlight} />
            ))}
          </Slider>
        )}
      </div>
    </section>
  );
}

// ===== src/components/LayoutSkeletons.tsx =====

export const HeaderSkeleton = () => (

    <div className="h-20 w-full" style={{ backgroundColor: 'var(--color-primary)' }}></div>
);

export const SidebarSkeleton = () => (

    <div className="hidden lg:block w-72 rounded-xl" style={{ backgroundColor: 'var(--color-primary)' }}></div>
);

// ===== src/components/LeagueListClient.tsx =====

"use client";

import { useState, useMemo, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { League } from "@/types/api-football";
import DirectoryCard, {
  DirectoryCardSkeleton,
} from "@/components/DirectoryCard";
import Pagination from "@/components/Pagination";
import { Search, SearchX } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";
import { useDebounce } from "@/hooks/useDebounce";

const ITEMS_PER_PAGE = 15;

const fetchActiveLeagueIds = async (): Promise<number[]> => {
  const { data } = await axios.get("/api/active-leagues");
  return data;
};

interface PaginatedLeaguesResponse {
  leagues: League[];
  pagination: {
    currentPage: number;
    totalPages: number;
    totalCount: number;
  };
}

const fetchPaginatedLeagues = async (
  page: number,
  search: string,
  type: string
): Promise<PaginatedLeaguesResponse> => {
  const params = new URLSearchParams({
    page: page.toString(),
    limit: ITEMS_PER_PAGE.toString(),
    search: search,
    type: type,
    fetchAll: "true",
  });
  const { data } = await axios.get(`/api/leagues?${params.toString()}`);
  return data;
};

export default function LeagueListClient() {
  const [searchTerm, setSearchTerm] = useState("");
  const [filter, setFilter] = useState<"all" | "league" | "cup">("all");
  const [currentPage, setCurrentPage] = useState(1);
  const { t } = useTranslation();
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  const { data: leaguesResponse, isLoading: isLoadingLeagues } = useQuery({
    queryKey: ["paginatedLeagues", currentPage, debouncedSearchTerm, filter],
    queryFn: () =>
      fetchPaginatedLeagues(currentPage, debouncedSearchTerm, filter),
    placeholderData: (previousData) => previousData,
    keepPreviousData: true,
  });

  const { data: activeLeagueIds } = useQuery({
    queryKey: ["activeLeagueIds"],
    queryFn: fetchActiveLeagueIds,
    staleTime: 1000 * 60 * 10,
  });

  useEffect(() => {
    setCurrentPage(1);
  }, [debouncedSearchTerm, filter]);

  const isLoading = isLoadingLeagues && !leaguesResponse;

  return (
    <>
      <div className="bg-brand-secondary p-4 rounded-lg mb-8 flex flex-col md:flex-row items-center gap-4">
        <div className="relative flex-grow w-full">
          <Search
            className="absolute left-3.5 top-1/2 -translate-y-1/2 text-text-muted"
            size={20}
          />
          <input
            type="text"
            placeholder={t("search_leagues_placeholder")}
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-full bg-[var(--color-primary)] border border-gray-700/50 rounded-lg p-3 pl-12 text-white focus:outline-none focus:ring-2 focus:ring-[var(--brand-accent)]"
          />
        </div>
        <div className="flex items-center gap-2 p-1 rounded-lg bg-[var(--color-primary)] w-full md:w-auto">
          <button
            onClick={() => setFilter("all")}
            className={`flex-1 md:flex-none px-4 py-1.5 rounded-md text-sm font-semibold transition-colors ${
              filter === "all"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700/50"
            }`}
          >
            {t("filter_all")}
          </button>
          <button
            onClick={() => setFilter("league")}
            className={`flex-1 md:flex-none px-4 py-1.5 rounded-md text-sm font-semibold transition-colors ${
              filter === "league"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700/50"
            }`}
          >
            {t("filter_leagues")}
          </button>
          <button
            onClick={() => setFilter("cup")}
            className={`flex-1 md:flex-none px-4 py-1.5 rounded-md text-sm font-semibold transition-colors ${
              filter === "cup"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700/50"
            }`}
          >
            {t("filter_cups")}
          </button>
        </div>
      </div>

      <div>
        {isLoading ? (
          <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
            {Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
              <DirectoryCardSkeleton key={i} />
            ))}
          </div>
        ) : leaguesResponse && leaguesResponse.leagues.length > 0 ? (
          <>
            <div className="mb-4">
              <h2 className="text-xl font-bold text-white">
                {t("showing_competitions", {
                  count: leaguesResponse.pagination.totalCount,
                })}
              </h2>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
              {leaguesResponse.leagues.map((league) => (
                <DirectoryCard
                  key={league.id}
                  {...league}
                  isPopular={activeLeagueIds?.includes(league.id)}
                />
              ))}
            </div>
            {leaguesResponse.pagination.totalPages > 1 && (
              <Pagination
                currentPage={leaguesResponse.pagination.currentPage}
                totalPages={leaguesResponse.pagination.totalPages}
                onPageChange={setCurrentPage}
              />
            )}
          </>
        ) : (
          <div className="text-center py-20 bg-brand-secondary rounded-lg">
            <SearchX size={48} className="mx-auto text-text-muted mb-4" />
            <p className="text-xl font-bold text-white">
              {t("no_leagues_found_title")}
            </p>
            <p className="text-text-muted mt-2">
              {t("no_leagues_found_subtitle", {
                searchTerm: debouncedSearchTerm,
              })}
            </p>
          </div>
        )}
      </div>
    </>
  );
}

// ===== src/components/LeagueListSidebar.tsx =====

"use client";

import { useState, useMemo } from "react";
import Link from "@/components/StyledLink";
import Image from "next/image";
import { usePathname } from "next/navigation";
import { League } from "@/types/api-football";
import { useTranslation } from "@/hooks/useTranslation";
import { proxyImageUrl } from "@/lib/image-proxy";
import { ChevronRight, ChevronDown } from "lucide-react";
import { useLeagueContext } from "@/context/LeagueContext";

const INITIAL_LEAGUE_COUNT = 15;

const LeagueItem = ({
  league,
  isActive,
  onSelect,
}: {
  league: League;
  isActive: boolean;
  onSelect: () => void;
}) => (
  <li>
    <button
      onClick={onSelect}
      className={`w-full flex items-center justify-between p-2 rounded-lg transition-all duration-200 group ${
        isActive
          ? "bg-[var(--brand-accent)] shadow-md text-white"
          : "hover:bg-gray-700/50 text-text-primary"
      }`}
    >
      <div className="flex items-center gap-3 overflow-hidden">
        <Image
          src={proxyImageUrl(league.logoUrl)}
          alt={`${league.name} logo`}
          width={24}
          height={24}
          className="flex-shrink-0"
          unoptimized={true}
        />
        <span
          className={`font-bold text-sm truncate ${
            isActive ? "text-white" : "text-text-primary"
          }`}
        >
          {league.name}
        </span>
      </div>
      <ChevronRight
        size={16}
        className="text-text-muted flex-shrink-0 opacity-0 group-hover:opacity-100 transition-opacity"
      />
    </button>
  </li>
);

export default function LeagueListSidebar({
  allLeagues,
}: {
  allLeagues: League[];
}) {
  const { t } = useTranslation();
  const { selectedLeague, setSelectedLeague } = useLeagueContext();
  const [isExpanded, setIsExpanded] = useState(false);

  const displayedLeagues = useMemo(() => {
    if (!allLeagues) return [];
    return isExpanded ? allLeagues : allLeagues.slice(0, INITIAL_LEAGUE_COUNT);
  }, [allLeagues, isExpanded]);

  if (!allLeagues || allLeagues.length === 0) {
    return (
      <p className="text-text-muted text-xs p-2.5">
        {t("no_competitions_found")}
      </p>
    );
  }

  return (
    <>
      <ul className="space-y-1">
        {displayedLeagues.map((league) => (
          <LeagueItem
            key={league.id}
            league={league}
            isActive={selectedLeague?.id === league.id}
            onSelect={() => setSelectedLeague(league)}
          />
        ))}
      </ul>
      {allLeagues.length > INITIAL_LEAGUE_COUNT && (
        <div className="mt-2">
          <button
            onClick={() => setIsExpanded(!isExpanded)}
            className="w-full flex items-center justify-center gap-2 py-2 text-xs font-semibold text-text-muted hover:text-white hover:bg-gray-700/50 rounded-md transition-colors"
          >
            <span>{isExpanded ? t("show_less") : t("show_more")}</span>
            <ChevronDown
              size={14}
              className={`transition-transform duration-200 ${
                isExpanded ? "rotate-180" : ""
              }`}
            />
          </button>
        </div>
      )}
    </>
  );
}

// ===== src/components/LeagueStandingsSlide.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { League } from "@/types/api-football";

type StandingsData = {
  league: { id: number; name: string; logo: string; };
  standings: TeamStanding[];
};
type TeamStanding = {
  rank: number;
  team: { id: number; name: string; logo: string };
  points: number;
  all: { played: number };
};

const fetchStandingsForLeague = async (leagueId: number): Promise<StandingsData | null> => {
  try {
    const { data } = await axios.get(`/api/standings?league=${leagueId}`);

    if (!data || !data.standings || data.standings.length === 0) {
        return null;
    }
    return data;
  } catch (error) {

    return null;
  }
};

const SlideSkeleton = () => (
    <div className="bg-brand-secondary rounded-xl p-4 lg:p-6 animate-pulse">
        <div className="h-7 w-3/4 rounded bg-gray-600/50 mb-4"></div>
        <div className="space-y-3 mt-4">
            {Array.from({ length: 5 }).map((_, i) => <div key={i} className="h-5 w-full rounded bg-gray-600/50"></div>)}
        </div>
    </div>
);

export default function LeagueStandingsSlide({ league }: { league: League }) {
  const { data, isLoading } = useQuery<StandingsData | null>({
    queryKey: ['standings', league.id],
    queryFn: () => fetchStandingsForLeague(league.id),
    staleTime: 1000 * 60 * 10,
  });

  if (isLoading) return <SlideSkeleton />;

  if (!data) {
    return null;
  }

  const topStandings = data.standings.slice(0, 5);

  return (
    <div className="bg-brand-secondary rounded-xl p-4 lg:p-6 h-full">
      <div className="flex items-center gap-3 mb-4">
        <Image src={data.league.logo} alt={data.league.name} width={32} height={32}/>
        <h3 className="text-xl font-bold text-brand-light truncate">{data.league.name}</h3>
      </div>
      {}
      <table className="w-full text-sm">
        <thead className="text-brand-muted text-xs">
          <tr className="border-b border-gray-700/50">
            <th className="p-2 font-semibold text-left w-8">#</th>
            <th className="p-2 font-semibold text-left">Team</th>
            <th className="p-2 font-semibold text-center">P</th>
            <th className="p-2 font-semibold text-center">Pts</th>
          </tr>
        </thead>
        <tbody>
          {topStandings.map((team: TeamStanding) => (
            <tr key={team.team.id} className="border-t border-gray-700/50">
              <td className="p-2 text-center">{team.rank}</td>
              <td className="p-2 flex items-center gap-2 font-medium truncate">
                <Image src={team.team.logo} alt={team.team.name} width={16} height={16} />
                {team.team.name}
              </td>
              <td className="p-2 text-center text-brand-muted">{team.all.played}</td>
              <td className="p-2 text-center font-bold text-brand-light">{team.points}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

// ===== src/components/LiteYouTubeEmbed.tsx =====

"use client";

import { useState, useRef } from "react";

interface LiteYouTubeEmbedProps {
  id: string;
  title: string;
}

export default function LiteYouTubeEmbed({ id, title }: LiteYouTubeEmbedProps) {
  const [preconnected, setPreconnected] = useState(false);
  const [iframeLoaded, setIframeLoaded] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);

  const warmConnections = () => {
    if (preconnected) return;
    setPreconnected(true);
  };

  const addIframe = () => {
    if (iframeLoaded) return;
    setIframeLoaded(true);
  };

  const videoUrl = `https://www.youtube-nocookie.com/embed/${id}`;
  const thumbnailUrl = `https://i.ytimg.com/vi/${id}/hqdefault.jpg`;
  const iframeSrc = `https://www.youtube-nocookie.com/embed/${id}?autoplay=1`;

  return (
    <>
      {}
      {preconnected && (
        <>
          <link rel="preconnect" href="https://www.youtube-nocookie.com" />
          <link rel="preconnect" href="https://www.google.com" />
        </>
      )}

      <div
        ref={containerRef}
        onClick={addIframe}
        onPointerOver={warmConnections}
        className="relative block w-full bg-black cursor-pointer overflow-hidden"
        style={{ paddingBottom: "56.25%" }}
        data-title={title}
      >
        {}
        {}
        <img
          src={thumbnailUrl}
          alt={`Play button for ${title}`}
          decoding="async"
          loading="lazy"
          className="absolute top-0 left-0 w-full h-full object-cover border-0"
        />

        {}
        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[68px] h-[48px] bg-[rgba(23,23,23,0.8)] rounded-[14px] flex items-center justify-center transition-transform duration-200 ease-in-out group-hover:scale-110">
          <svg
            width="100%"
            height="100%"
            viewBox="0 0 68 48"
            aria-hidden="true"
          >
            <path
              d="M66.52,7.74c-0.78-2.93-2.49-5.41-5.42-6.19C55.79,.13,34,0,34,0S12.21,.13,6.9,1.55 C3.97,2.33,2.27,4.81,1.48,7.74C0.06,13.05,0,24,0,24s0.06,10.95,1.48,16.26c0.78,2.93,2.49,5.41,5.42,6.19 C12.21,47.87,34,48,34,48s21.79-0.13,27.1-1.55c2.93-0.78,4.64-3.26,5.42-6.19C67.94,34.95,68,24,68,24S67.94,13.05,66.52,7.74z"
              fill="#f00"
              fillOpacity="0.8"
            ></path>
            <path d="M 45,24 27,14 27,34" fill="#fff"></path>
          </svg>
        </div>

        {}
        {iframeLoaded && (
          <iframe
            width="560"
            height="315"
            title={title}
            src={iframeSrc}
            frameBorder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowFullScreen
            className="absolute top-0 left-0 w-full h-full"
          ></iframe>
        )}
      </div>
    </>
  );
}

// ===== src/components/LiveMatchCard.tsx =====

"use client";

import { useState, useMemo } from 'react';
import Image from 'next/image';
import { format } from 'date-fns';
import Link from '@/components/StyledLink';
import { History, BarChart2, Star } from 'lucide-react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'axios';
import { useVoteStorage } from '@/hooks/useVoteStorage';
import { useTranslation } from '@/hooks/useTranslation';

interface VoteData {
    homeVotes: number;
    drawVotes: number;
    awayVotes: number;
}

const getVotes = async (fixtureId: number): Promise<VoteData> => {
    const { data } = await axios.get(`/api/votes?fixture=${fixtureId}`);
    return data;
};

const submitVote = async ({ fixtureId, vote }: { fixtureId: number; vote: string }): Promise<VoteData> => {
    const { data } = await axios.post('/api/votes', { fixtureId, vote });
    return data;
};

const TeamRow = ({ team, score, hasMomentum, momentumType, onVote, isVotedFor, isDisabled }: any) => (
    <div className="flex justify-between items-center">
        <div className="flex items-center gap-3 min-w-0">
            <div className="relative flex-shrink-0">
                <Image src={team.logo} alt={team.name} width={32} height={32} className="object-contain h-8 w-8"/>
                {hasMomentum && (
                    <span className="absolute -top-1 -right-1 flex h-3 w-3">
                        <span className={`absolute inline-flex h-full w-full rounded-full ${momentumType === 'Goal' ? 'bg-green-400' : 'bg-red-400'} opacity-75 animate-ping`}></span>
                        <span className={`relative inline-flex rounded-full h-3 w-3 ${momentumType === 'Goal' ? 'bg-green-500' : 'bg-red-500'}`}></span>
                    </span>
                )}
            </div>
            <span className="font-bold text-white truncate">{team.name}</span>
        </div>
        <div className="flex items-center gap-3">
            <span className="text-xl font-black text-white">{score ?? 0}</span>
            <button onClick={onVote} disabled={isDisabled} className="disabled:cursor-not-allowed disabled:opacity-50">
                <Star size={20} className={`transition-all duration-200 ${isVotedFor ? 'text-yellow-400 fill-yellow-400' : 'text-gray-500 hover:text-yellow-400'}`} />
            </button>
        </div>
    </div>
);

export default function MobileLiveMatchCard({ match }: { match: any }) {
  const { fixture, teams, goals, league, events } = match;
  const { t } = useTranslation();
  const queryClient = useQueryClient();
  const { setVote, getVoteForFixture } = useVoteStorage();

  const isFinished = ['FT', 'AET', 'PEN'].includes(fixture.status.short);

  const [votedFor, setVotedFor] = useState<'home' | 'away' | null>(() => getVoteForFixture(fixture.id) as 'home' | 'away' | null);

  const { data: voteData } = useQuery({
      queryKey: ['votes', fixture.id],
      queryFn: () => getVotes(fixture.id),
      staleTime: 1000 * 60,
      enabled: !isFinished,
  });

  const voteMutation = useMutation({
      mutationFn: submitVote,
      onSuccess: () => {
          queryClient.invalidateQueries({ queryKey: ['votes', fixture.id] });
      },
  });

  const handleVote = (choice: 'home' | 'away') => {
      if (votedFor) return;
      setVotedFor(choice);
      setVote(fixture.id, choice);
      voteMutation.mutate({ fixtureId: fixture.id, vote: choice });
  };

  const momentumData = useMemo(() => {

    if (!['1H', 'HT', '2H', 'ET', 'P'].includes(fixture.status.short) || !events || events.length === 0) return { teamId: null, type: null };
    const lastMajorEvent = [...events].reverse().find(e => e.type === 'Goal' || (e.type === 'Card' && e.detail === 'Red Card'));
    if (!lastMajorEvent) return { teamId: null, type: null };
    let momentumTeamId = lastMajorEvent.team.id;
    if (lastMajorEvent.type === 'Card') {
        momentumTeamId = momentumTeamId === teams.home.id ? teams.away.id : teams.home.id;
    }
    return { teamId: momentumTeamId, type: lastMajorEvent.type };
  }, [events, fixture.status.short, teams.home.id, teams.away.id]);

  const totalVotes = (voteData?.homeVotes || 0) + (voteData?.awayVotes || 0);
  const homePercent = totalVotes > 0 ? Math.round(((voteData?.homeVotes || 0) / totalVotes) * 100) : 50;

  return (
    <div className="bg-[#252837] rounded-xl overflow-hidden flex flex-col">
      {}
      <div className="flex justify-between items-center p-3 border-b border-gray-700/50">
          <div className="flex items-center gap-2 min-w-0">
            <Image src={league.logo} alt={league.name} width={20} height={20} className="flex-shrink-0" />
            <span className="text-sm font-semibold truncate text-brand-muted">{league.name}</span>
          </div>
          <div className="flex-shrink-0">
            {['1H', 'HT', '2H', 'ET', 'P'].includes(fixture.status.short) && <div className="flex items-center gap-1.5 text-brand-live font-semibold text-xs"><span className="relative flex h-2 w-2"><span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span><span className="relative inline-flex rounded-full h-2 w-2 bg-brand-live"></span></span><span>{fixture.status.elapsed}'</span></div>}
            {isFinished && <div className="flex items-center gap-1.5 bg-gray-700/50 text-gray-300 px-2 py-0.5 rounded-full text-xs font-semibold"><History size={12} /><span>{t('finished')}</span></div>}
            {!isFinished && !['1H', 'HT', '2H', 'ET', 'P'].includes(fixture.status.short) && <div className="font-bold text-brand-light text-sm">{format(new Date(fixture.date), "HH:mm")}</div>}
          </div>
      </div>

      {}
      <div className="p-3 space-y-2">
          <TeamRow
            team={teams.home}
            score={goals.home}
            hasMomentum={momentumData.teamId === teams.home.id}
            momentumType={momentumData.type}
            onVote={() => handleVote('home')}
            isVotedFor={votedFor === 'home'}
            isDisabled={!!votedFor || isFinished}
          />
          <TeamRow
            team={teams.away}
            score={goals.away}
            hasMomentum={momentumData.teamId === teams.away.id}
            momentumType={momentumData.type}
            onVote={() => handleVote('away')}
            isVotedFor={votedFor === 'away'}
            isDisabled={!!votedFor || isFinished}
          />
      </div>

      {}
      {votedFor && voteData && (
          <div className="px-3 pb-3 space-y-2">
              <div className="flex justify-between items-center">
                  <span className="text-xs font-bold text-white">{homePercent}%</span>
                  <span className="text-xs font-semibold text-brand-muted">Community Rating</span>
                  <span className="text-xs font-bold text-white">{100 - homePercent}%</span>
              </div>
              <div className="flex w-full h-1.5 rounded-full overflow-hidden bg-gray-700">
                  <div className="bg-brand-purple" style={{ width: `${homePercent}%` }}></div>
                  <div className="bg-blue-600" style={{ width: `${100 - homePercent}%` }}></div>
              </div>
          </div>
      )}

      {}
      <div className="p-2 bg-gray-900/30 flex justify-end items-center">
        <Link href={`/football/match/${fixture.id}`} className="flex items-center gap-2 text-xs text-brand-muted hover:text-white transition-colors py-1 px-2">
            <BarChart2 size={14} />
            <span>{t('match_details')}</span>
        </Link>
      </div>
    </div>
  );
}

export const MatchCardSkeleton = () => (
    <div className="bg-[#252837] rounded-xl p-4 flex flex-col gap-4 animate-pulse">
        <div className="flex justify-between items-center">
            <div className="h-4 w-1/3 rounded bg-gray-600/50"></div>
            <div className="h-4 w-1/4 rounded bg-gray-600/50"></div>
        </div>
        <div className="flex items-center justify-between py-4">
            <div className="flex flex-col items-center gap-2 w-1/3"><div className="h-12 w-12 rounded-full bg-gray-600/50"></div><div className="h-4 w-2/3 rounded bg-gray-600/50"></div></div>
            <div className="h-8 w-1/4 rounded bg-gray-600/50"></div>
            <div className="flex flex-col items-center gap-2 w-1/3"><div className="h-12 w-12 rounded-full bg-gray-600/50"></div><div className="h-4 w-2/3 rounded bg-gray-600/50"></div></div>
        </div>
        <div className="h-10 w-full rounded-lg bg-gray-600/50 mt-auto"></div>
    </div>
);

// ===== src/components/LiveMatchUpdater.tsx =====

"use client";

import { useQuery } from '@tanstack/react-query';
import axios from 'axios';

import SidebarMatchItem, { SidebarMatchItemSkeleton } from './SidebarMatchItem';

interface MatchData {
  fixture: { id: number; status: { elapsed: number; }; };
  teams: { home: any; away: any; };
  goals: { home: any; away: any; };
}

const fetchGlobalLiveMatches = async (): Promise<MatchData[]> => {
    const { data } = await axios.get('/api/global-live');
    return data;
};

export default function LiveMatchUpdater({ initialLiveMatches }: { initialLiveMatches: MatchData[] }) {

  const { data: liveMatches, isLoading } = useQuery<MatchData[]>({
    queryKey: ['globalLiveMatches'],
    queryFn: fetchGlobalLiveMatches,
    initialData: initialLiveMatches,
    refetchInterval: 30000,
  });

  if (!liveMatches || liveMatches.length === 0) {
      return <p className="text-sm text-brand-muted text-center py-4">No matches are currently live.</p>;
  }

  return (
    <div className="space-y-1">
      {}
      {liveMatches.slice(0, 5).map(match => (
        <SidebarMatchItem key={match.fixture.id} match={match} />
      ))}
    </div>
  );
}

// ===== src/components/LottiePreloader.tsx =====

"use client";

import Lottie from "lottie-react";

import animationData from "../../public/fanskor-preloader.json";

export default function LottiePreloader() {
  const style = {
    height: 250,
    width: 250,
  };

  return (
    <div className="flex flex-col items-center gap-2">
      <Lottie animationData={animationData} style={style} loop={true} />
    </div>
  );
}

// ===== src/components/MainContent.tsx =====

"use client";

import { useLeagueContext } from "@/context/LeagueContext";
import dynamic from "next/dynamic";
import { useTranslation } from "@/hooks/useTranslation";
import LeagueDetailView from "./league-detail-view";
import PredictionSidebarWidget from "./PredictionSidebarWidget";

import {
  AdSlotWidgetSkeleton,
  RecentNewsWidgetSkeleton,
} from "./skeletons/WidgetSkeletons";

const MatchListSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg p-4 h-[600px] animate-pulse">
    <div className="h-10 w-full bg-gray-700 rounded-md mb-4"></div>
    <div className="h-8 w-3/4 bg-gray-700 rounded-md mb-6"></div>
    <div className="space-y-2">
      {Array.from({ length: 5 }).map((_, i) => (
        <div key={i} className="h-16 w-full bg-gray-700/50 rounded-lg"></div>
      ))}
    </div>
  </div>
);

const StandingsDisplaySkeleton = () => (
  <div className="bg-brand-secondary rounded-lg h-[480px] animate-pulse">
    <div className="p-2 border-b border-gray-700/50 flex space-x-1">
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
    </div>
    <div className="p-4 h-full"></div>
  </div>
);

const MatchList = dynamic(() => import("./MatchList"), {
  loading: () => <MatchListSkeleton />,
});

const StandingsDisplay = dynamic(() => import("./StandingsDisplay"), {
  loading: () => <StandingsDisplaySkeleton />,
});

const AdSlotWidget = dynamic(() => import("./AdSlotWidget"), {
  loading: () => <AdSlotWidgetSkeleton />,
  ssr: false,
});

const NewsSection = dynamic(() => import("./NewsSection"), {
  loading: () => <RecentNewsWidgetSkeleton />,
});

interface MainContentProps {
  sidebarAboutSeoText: string;
  homepageAboutSeoText: string;
}

export const MainContent: React.FC<MainContentProps> = ({
  sidebarAboutSeoText,
  homepageAboutSeoText,
}) => {
  const { selectedLeague } = useLeagueContext();
  const { t } = useTranslation();

  if (selectedLeague) {
    return (
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 p-4 lg:p-0 lg:pl-8">
        <div className="lg:col-span-2 flex flex-col gap-8">
          <LeagueDetailView leagueData={selectedLeague} />
        </div>
        <div className="lg:col-span-1 flex flex-col gap-6">
          <AdSlotWidget location="homepage_right_sidebar" />
          <NewsSection />
        </div>
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 p-4 lg:p-0 lg:pl-8">
      <div className="lg:col-span-2 flex flex-col gap-8">
        <MatchList />
        <div className="bg-brand-secondary rounded-lg shadow-lg p-6">
          <h2 className="text-2xl font-bold text-white mb-4">
            {t("about_fanskor_title")}
          </h2>
          <p className="text-brand-light text-base leading-relaxed">
            {homepageAboutSeoText}
          </p>
        </div>
      </div>

      <div className="lg:col-span-1 flex flex-col gap-6">
        <AdSlotWidget location="homepage_right_sidebar" />
        <PredictionSidebarWidget />
        <StandingsDisplay />
        <div className="space-y-8 gap-8">
          <section className="bg-brand-secondary rounded-lg shadow-lg p-6">
            <h2 className="text-2xl font-bold text-white mb-4">
              {t("about_fanskor_title")}
            </h2>
            <p className="text-brand-light text-base leading-relaxed">
              {sidebarAboutSeoText}
            </p>
          </section>
          <NewsSection />
        </div>
      </div>
    </div>
  );
};

// ===== src/components/MatchDateNavigator.tsx =====

"use client";

import { useState, useRef, useEffect } from "react";
import { format, addDays, subDays, isToday, Locale } from "date-fns";
import { DayPicker } from "react-day-picker";
import "react-day-picker/dist/style.css";
import {
  Calendar as CalendarIcon,
  ChevronLeft,
  ChevronRight,
} from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

import { enUS, tr, fr, es } from "date-fns/locale";

interface DateNavigatorProps {
  selectedDate: Date;
  onDateChange: (date: Date) => void;
}

const dateLocales: Record<string, Locale> = { en: enUS, tr,  fr, es, };

export default function MatchDateNavigator({
  selectedDate,
  onDateChange,
}: DateNavigatorProps) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const { t, locale } = useTranslation();

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const handleDaySelect = (date: Date | undefined) => {
    if (date) {
      onDateChange(date);
      setIsOpen(false);
    }
  };

  const handleTodayClick = () => {
    onDateChange(new Date());
    setIsOpen(false);
  };

  const currentLocale = dateLocales[locale] || enUS;

  return (
    <div className="relative w-full" ref={dropdownRef}>
      <div className="flex items-center justify-between rounded-lg p-2 bg-brand-secondary">
        <button
          onClick={handleTodayClick}
          disabled={isToday(selectedDate)}
          className="px-4 py-2 text-sm font-semibold text-white rounded-md hover:bg-brand-purple/80 transition-colors disabled:opacity-50 disabled:hover:bg-transparent"
          aria-label="Go to today's date"
        >
          {t("today")}
        </button>

        <div className="flex items-center gap-2">
          <button
            onClick={() => onDateChange(subDays(selectedDate, 1))}
            className="p-2 transition-colors hover:bg-gray-700/50 rounded-full"
            aria-label="Previous day"
          >
            <ChevronLeft size={20} />
          </button>

          <button
            onClick={() => setIsOpen(!isOpen)}
            className="flex items-center gap-2 px-4 py-2 rounded-md hover:bg-gray-700/50 transition-colors"
            aria-expanded={isOpen}
          >
            <CalendarIcon size={18} className="text-text-muted" />
            <span className="font-bold text-lg text-white capitalize">
              {format(selectedDate, "d MMMM", { locale: currentLocale })}
            </span>
          </button>

          <button
            onClick={() => onDateChange(addDays(selectedDate, 1))}
            className="p-2 transition-colors hover:bg-gray-700/50 rounded-full"
            aria-label="Next day"
          >
            <ChevronRight size={20} />
          </button>
        </div>
        <div className="w-[84px]"></div>
      </div>

      <div
        className={`absolute top-full right-0 mt-2 bg-brand-secondary border border-gray-700/50 rounded-lg shadow-2xl z-20
                   transition-all duration-200 ease-out
                   ${
                     isOpen
                       ? "opacity-100 translate-y-0"
                       : "opacity-0 -translate-y-2 pointer-events-none"
                   }`}
      >
        <DayPicker
          mode="single"
          selected={selectedDate}
          onSelect={handleDaySelect}
          initialFocus
          locale={currentLocale}
          classNames={{
            root: "p-3",
            caption: "flex justify-between items-center mb-4",
            caption_label: "text-base font-bold text-white capitalize",
            nav_button:
              "h-8 w-8 flex items-center justify-center rounded-full hover:bg-gray-700 transition-colors",
            head_row: "flex",
            head_cell:
              "w-10 h-10 flex items-center justify-center font-semibold text-brand-muted text-sm",
            row: "flex w-full mt-2",
            cell: "flex items-center justify-center",
            day: "h-10 w-10 text-white rounded-full hover:bg-brand-purple/60 transition-colors cursor-pointer",
            day_selected:
              "bg-brand-purple text-white font-bold hover:bg-brand-purple",
            day_today:
              "ring-2 ring-brand-purple ring-offset-2 ring-offset-brand-secondary",
            day_outside: "text-brand-muted/40 cursor-default",
            day_disabled: "text-brand-muted/40 cursor-not-allowed",
          }}
        />
      </div>
    </div>
  );
}

// ===== src/components/MatchList.tsx =====

"use client";

import { useEffect, useState, Dispatch, SetStateAction } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { League } from "@/types/api-football";
import MatchListItem, { MatchListItemSkeleton } from "./MatchListItem";
import MatchDateNavigator from "./MatchDateNavigator";
import { Globe, Search, XCircle, ChevronDown } from "lucide-react";
import { format } from "date-fns";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useTranslation } from "@/hooks/useTranslation";
import StyledLink from "./StyledLink";
import { generateLeagueSlug } from "@/lib/generate-league-slug";

function useDebounce(value: string, delay: number) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  return debouncedValue;
}

type StatusFilter = "all" | "live" | "finished" | "scheduled";

const fetchAllFixturesByGroup = async (date: Date, status: StatusFilter) => {
  const dateString = format(date, "yyyy-MM-dd");
  const params = new URLSearchParams({
    date: dateString,
    status,
    groupByLeague: "true",
  });
  const { data } = await axios.get(`/api/fixtures?${params.toString()}`);
  return data;
};

const searchFixtures = async (query: string): Promise<any[]> => {
  if (query.length < 3) return [];
  const { data } = await axios.get(
    `/api/search/fixtures?q=${encodeURIComponent(query)}`
  );
  return data;
};

const LeagueGroupHeader = ({
  league,
}: {
  league: {
    id: number;
    name: string;
    logo: string;
    country: string;
    flag: string | null;
  };
}) => {
  const leagueHref = generateLeagueSlug(league.name, league.id);

  return (
    <div
      className="flex items-center gap-3 p-3 sticky top-0 z-10"
      style={{ backgroundColor: "var(--color-primary)" }}
    >
      <div className="w-[28px] h-[28px] flex items-center justify-center flex-shrink-0">
        {league.country === "World" ? (
          <Globe size={24} className="text-text-muted" />
        ) : (
          league.flag && (
            <Image
              src={proxyImageUrl(league.flag)}
              alt={league.country}
              width={28}
              height={28}
              className="rounded-full object-contain"
            />
          )
        )}
      </div>
      <div className="min-w-0">
        <p className="font-bold text-sm text-white truncate">
          {league.country}
        </p>
        <StyledLink href={leagueHref} className="group">
          <p className="text-sm text-[var(--brand-accent)] font-bold truncate group-hover:underline">
            {league.name}
          </p>
        </StyledLink>
      </div>
    </div>
  );
};

const TabButton = ({
  label,
  isActive,
  liveCount,
  onClick,
  hasLiveIndicator,
}: {
  label: string;
  isActive: boolean;
  liveCount?: number;
  onClick: () => void;
  hasLiveIndicator?: boolean;
}) => (
  <button
    onClick={onClick}
    className={`relative flex-1 md:flex-none flex items-center justify-center gap-2 px-3 md:px-4 py-2.5 rounded-lg text-xs md:text-sm font-bold transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-brand-purple/50 ${
      isActive
        ? "bg-brand-purple text-white shadow-lg"
        : "bg-transparent text-text-muted hover:text-white"
    }`}
  >
    {hasLiveIndicator && (
      <span className="relative flex h-3 w-3">
        <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span>
        <span className="relative inline-flex rounded-full h-3 w-3 bg-brand-live"></span>
      </span>
    )}
    {label}
    {liveCount && liveCount > 0 && (
      <span className="ml-1 flex items-center justify-center text-[10px] font-bold text-white bg-brand-live rounded-full h-4 w-4">
        {liveCount}
      </span>
    )}
  </button>
);

export default function MatchList({
  setLiveLeagues,
}: {
  setLiveLeagues: Dispatch<SetStateAction<League[]>>;
}) {
  const [activeStatusFilter, setActiveStatusFilter] =
    useState<StatusFilter>("all");
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [searchTerm, setSearchTerm] = useState("");
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  const { t } = useTranslation();

  const [expandedLeagues, setExpandedLeagues] = useState<Set<number>>(
    new Set()
  );

  const { data: searchResults, isLoading: isLoadingSearch } = useQuery({
    queryKey: ["fixtureSearch", debouncedSearchTerm],
    queryFn: () => searchFixtures(debouncedSearchTerm),
    enabled: debouncedSearchTerm.length >= 3,
  });

  const { data: fixtureData, isLoading: isLoadingFixtures } = useQuery({
    queryKey: [
      "allFixturesByGroup",
      format(selectedDate, "yyyy-MM-dd"),
      activeStatusFilter,
    ],
    queryFn: () => fetchAllFixturesByGroup(selectedDate, activeStatusFilter),
    enabled: !debouncedSearchTerm,
  });

  const toggleLeagueExpansion = (leagueId: number) => {
    setExpandedLeagues((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(leagueId)) {
        newSet.delete(leagueId);
      } else {
        newSet.add(leagueId);
      }
      return newSet;
    });
  };

  const { data: globalLiveCount } = useQuery({
    queryKey: ["globalLiveCount"],
    queryFn: () => axios.get("/api/global-live").then((res) => res.data.length),
    refetchInterval: 30000,
    staleTime: 25000,
  });

  const isCurrentlyLoading =
    isLoadingFixtures || (isLoadingSearch && debouncedSearchTerm.length >= 3);

  if (debouncedSearchTerm) {
    return (
      <div className="space-y-4">
        <div
          className="flex flex-col gap-3 p-2 rounded-xl"
          style={{ backgroundColor: "var(--color-primary)" }}
        >
          <h1 className="py-2 italic">{t("homepage_seo_text_title")}</h1>
          <div className="relative">
            <Search
              className="absolute left-3 top-1/2 -translate-y-1/2 text-text-muted"
              size={20}
            />
            <input
              type="text"
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              placeholder={t("search_fixtures_placeholder")}
              className="w-full bg-[var(--color-secondary)] border border-gray-700/50 rounded-lg p-3 pl-11 text-white placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-[var(--brand-accent)]"
            />
            {searchTerm && (
              <button
                onClick={() => setSearchTerm("")}
                className="absolute right-3 top-1/2 -translate-y-1/2 text-text-muted hover:text-white"
              >
                <XCircle size={18} />
              </button>
            )}
          </div>
        </div>
        <div className="space-y-2">
          {isLoadingSearch ? (
            Array.from({ length: 5 }).map((_, i) => (
              <MatchListItemSkeleton key={i} />
            ))
          ) : searchResults && searchResults.length > 0 ? (
            searchResults.map((match: any) => (
              <MatchListItem key={match.fixture.id} match={match} />
            ))
          ) : (
            <div
              className="text-center py-20 rounded-lg"
              style={{ backgroundColor: "var(--color-primary)" }}
            >
              <p className="text-white font-semibold capitalize">
                {t("no_matches_found_title")}
              </p>
              <p className="text-sm text-text-muted mt-1">
                {t("no_search_results_subtitle", {
                  searchTerm: debouncedSearchTerm,
                })}
              </p>
            </div>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div
        className="flex flex-col gap-3 p-2 rounded-xl"
        style={{ backgroundColor: "var(--color-primary)" }}
      >
        <h1 className="py-2 italic">{t("homepage_seo_text_title")}</h1>
        <div className="relative">
          <Search
            className="absolute left-3 top-1/2 -translate-y-1/2 text-text-muted"
            size={20}
          />
          <input
            type="text"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            placeholder={t("search_fixtures_placeholder")}
            className="w-full bg-[var(--color-secondary)] border border-gray-700/50 rounded-lg p-3 pl-11 text-white placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-[var(--brand-accent)]"
          />
        </div>
        <>
          <div className="flex justify-center">
            <MatchDateNavigator
              selectedDate={selectedDate}
              onDateChange={setSelectedDate}
            />
          </div>
          <div
            className="flex items-center gap-1 p-1 rounded-xl w-full"
            style={{ backgroundColor: "var(--color-secondary)" }}
          >
            {[
              { key: "all", label: t("filter_all") },
              { key: "live", label: t("filter_live") },
              { key: "finished", label: t("filter_finished") },
              { key: "scheduled", label: t("filter_scheduled") },
            ].map((tab) => (
              <TabButton
                key={tab.key}
                label={tab.label}
                isActive={activeStatusFilter === tab.key}
                liveCount={tab.key === "live" ? globalLiveCount : undefined}
                hasLiveIndicator={
                  tab.key === "live" && (globalLiveCount ?? 0) > 0
                }
                onClick={() => setActiveStatusFilter(tab.key as StatusFilter)}
              />
            ))}
          </div>
        </>
      </div>

      <div className="space-y-4">
        {isCurrentlyLoading ? (
          <div
            style={{ backgroundColor: "var(--color-primary)" }}
            className="rounded-lg p-2 space-y-2"
          >
            {Array.from({ length: 10 }).map((_, i) => (
              <MatchListItemSkeleton key={i} />
            ))}
          </div>
        ) : fixtureData?.leagueGroups?.length > 0 ? (
          <>
            {fixtureData.leagueGroups.map(({ leagueInfo, matches }: any) => {
              const isExpanded = expandedLeagues.has(leagueInfo.id);
              const displayedMatches = isExpanded
                ? matches
                : matches.slice(0, 3);

              return (
                <div
                  key={leagueInfo.id}
                  style={{ backgroundColor: "var(--color-primary)" }}
                  className="rounded-lg overflow-hidden"
                >
                  <LeagueGroupHeader league={leagueInfo} />
                  <div className="p-2 space-y-2">
                    {displayedMatches.map((match: any) => (
                      <MatchListItem key={match.fixture.id} match={match} />
                    ))}
                  </div>
                  {}
                  {matches.length > 3 && (
                    <div className="p-2 pt-0 text-center">
                      <button
                        onClick={() => toggleLeagueExpansion(leagueInfo.id)}
                        className="w-full flex items-center justify-center gap-2 text-sm font-semibold text-text-muted hover:text-white hover:bg-gray-700/50 transition-colors py-2 rounded-md"
                      >
                        <span>
                          {isExpanded
                            ? t("show_less")
                            : t("show_more_matches", {
                                count: matches.length - 3,
                              })}
                        </span>
                        <ChevronDown
                          size={16}
                          className={`transition-transform duration-200 ${
                            isExpanded ? "rotate-180" : ""
                          }`}
                        />
                      </button>
                    </div>
                  )}
                </div>
              );
            })}
          </>
        ) : (
          <div
            className="text-center py-20 rounded-lg"
            style={{ backgroundColor: "var(--color-primary)" }}
          >
            <p className="text-white font-semibold capitalize">
              {t("no_matches_found_title")}
            </p>
            <p className="text-sm text-text-muted mt-1">
              {t("no_matches_for_date_subtitle")}
            </p>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/MatchListItem.tsx =====

import DesktopMatchListItem, {
  MatchListItemSkeleton as DesktopSkeleton,
} from "./DesktopMatchListItem";
import MobileMatchListItem, {
  MobileMatchListItemSkeleton as MobileSkeleton,
} from "./MobileMatchListItem";

interface MatchListItemProps {
  match: any;
}

export default function MatchListItem({ match }: MatchListItemProps) {
  const status = match.fixture.status.short;
  const isLive = ["1H", "HT", "2H", "ET", "P", "LIVE"].includes(status);

  return (
    <>
      <div className="hidden lg:block">
        <DesktopMatchListItem match={match} isLive={isLive} />
      </div>
      <div className="block lg:hidden">
        <MobileMatchListItem match={match} />
      </div>
    </>
  );
}

export const MatchListItemSkeleton = () => {
  return (
    <>
      <div className="hidden lg:block">
        <DesktopSkeleton />
      </div>
      <div className="block lg:hidden">
        <MobileSkeleton />
      </div>
    </>
  );
};

// ===== src/components/MatchSlide.tsx =====

import Image from 'next/image';
import { format } from 'date-fns';
import { Calendar, MapPin } from 'lucide-react';

interface MatchSlideProps {
  match: any;
}

export default function MatchSlide({ match }: MatchSlideProps) {
  const { teams, fixture, league } = match;

  return (
    <div className="relative w-full h-64 overflow-hidden rounded-2xl bg-brand-secondary text-white">
      {}
      <Image

        src="https://images.unsplash.com/photo-1579952363873-27f3bade9f55?q=80&w=1935&auto=format&fit=crop"
        alt="Stadium background"
        layout="fill"
        objectFit="cover"
        className="z-0"
      />
      <div className="absolute inset-0 bg-black/70 z-10" />

      {}
      <div className="relative z-20 flex h-full flex-col items-center justify-center p-4">
        <p className="font-semibold tracking-wider text-brand-muted">Upcoming Match</p>
        <p className="text-sm text-brand-muted mb-4">{league.round}</p>

        <div className="flex items-center justify-around w-full max-w-lg my-2">
          {}
          <div className="flex items-center gap-3">
            <Image src={teams.home.logo} alt={teams.home.name} width={40} height={40}/>
            <h2 className="text-3xl sm:text-4xl font-black">{teams.home.name}</h2>
          </div>

          <span className="text-xl font-light text-brand-muted mx-4">VS</span>

          {}
          <div className="flex items-center gap-3">
            <h2 className="text-3xl sm:text-4xl font-black">{teams.away.name}</h2>
            <Image src={teams.away.logo} alt={teams.away.name} width={40} height={40}/>
          </div>
        </div>

        <div className="mt-6 flex flex-col sm:flex-row items-center gap-x-6 gap-y-2 text-brand-muted">
          <div className="flex items-center gap-2">
            <Calendar size={16} />
            <span>{format(new Date(fixture.date), "dd MMMM yyyy  h:mma")}</span>
          </div>
          <div className="flex items-center gap-2">
            <MapPin size={16} />
            <span>{fixture.venue.name}</span>
          </div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/MobileLiveMatchCard.tsx =====

"use client";

import { useState, useMemo } from 'react';
import Image from 'next/image';
import { format } from 'date-fns';
import Link from '@/components/StyledLink';
import { History, ChevronDown, BarChart2 } from 'lucide-react';
import VotingPanel from './VotingPanel';
import { useTranslation } from '@/hooks/useTranslation';

interface MatchCardProps {
  match: any;
}

const TeamRow = ({ team, score, hasMomentum, momentumType }: any) => (
    <div className="flex justify-between items-center">
        <div className="flex items-center gap-3 min-w-0">
            <div className="relative flex-shrink-0">
                <Image src={team.logo} alt={team.name} width={32} height={32} className="object-contain h-8 w-8"/>
                {hasMomentum && (
                    <span className="absolute -top-1 -right-1 flex h-3 w-3">
                        <span className={`absolute inline-flex h-full w-full rounded-full ${momentumType === 'Goal' ? 'bg-green-400' : 'bg-red-400'} opacity-75 animate-ping`}></span>
                        <span className={`relative inline-flex rounded-full h-3 w-3 ${momentumType === 'Goal' ? 'bg-green-500' : 'bg-red-500'}`}></span>
                    </span>
                )}
            </div>
            <span className="font-bold text-white truncate">{team.name}</span>
        </div>
        <span className="text-xl font-black text-white">{score ?? 0}</span>
    </div>
);

export default function MobileLiveMatchCard({ match }: MatchCardProps) {
  const { fixture, teams, goals, league, events } = match;
  const [isExpanded, setIsExpanded] = useState(false);
  const { t } = useTranslation();

  const isLive = ['1H', 'HT', '2H', 'ET', 'P'].includes(fixture.status.short);
  const isFinished = ['FT', 'AET', 'PEN'].includes(fixture.status.short);
  const isUpcoming = !isLive && !isFinished;

  const momentumData = useMemo(() => {
    if (!isLive || !events || events.length === 0) return { teamId: null, type: null };
    const lastMajorEvent = [...events].reverse().find(e => e.type === 'Goal' || (e.type === 'Card' && e.detail === 'Red Card'));
    if (!lastMajorEvent) return { teamId: null, type: null };
    let momentumTeamId = lastMajorEvent.team.id;
    if (lastMajorEvent.type === 'Card') {
        momentumTeamId = momentumTeamId === teams.home.id ? teams.away.id : teams.home.id;
    }
    return { teamId: momentumTeamId, type: lastMajorEvent.type };
  }, [events, isLive, teams.home.id, teams.away.id]);

  return (
    <div className="bg-[#252837] rounded-xl overflow-hidden flex flex-col">
      {}
      <div className="flex justify-between items-center p-3 border-b border-gray-700/50">
          <div className="flex items-center gap-2 min-w-0">
            <Image src={league.logo} alt={league.name} width={20} height={20} className="flex-shrink-0" />
            <span className="text-sm font-semibold truncate text-brand-muted">{league.name}</span>
          </div>
          <div className="flex-shrink-0">
            {isLive && <div className="flex items-center gap-1.5 text-brand-live font-semibold text-xs"><span className="relative flex h-2 w-2"><span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span><span className="relative inline-flex rounded-full h-2 w-2 bg-brand-live"></span></span><span>{fixture.status.elapsed}'</span></div>}
            {isFinished && <div className="flex items-center gap-1.5 bg-gray-700/50 text-gray-300 px-2 py-0.5 rounded-full text-xs font-semibold"><History size={12} /><span>{t('finished')}</span></div>}
            {isUpcoming && <div className="font-bold text-brand-light text-sm">{format(new Date(fixture.date), "HH:mm")}</div>}
          </div>
      </div>

      {}
      <div className="p-3 space-y-2">
          <TeamRow
            team={teams.home}
            score={goals.home}
            hasMomentum={momentumData.teamId === teams.home.id}
            momentumType={momentumData.type}
          />
          <TeamRow
            team={teams.away}
            score={goals.away}
            hasMomentum={momentumData.teamId === teams.away.id}
            momentumType={momentumData.type}
          />
      </div>

      {}
      <div className="p-2 bg-gray-900/30 flex justify-between items-center">
        <Link href={`/football/match/${fixture.id}`} className="flex items-center gap-2 text-xs text-brand-muted hover:text-white transition-colors py-1 px-2">
            <BarChart2 size={14} />
            <span>{t('match_details')}</span>
        </Link>
        {!isFinished && (
            <button
                onClick={() => setIsExpanded(!isExpanded)}
                className="flex items-center gap-1.5 text-xs text-green-400 hover:text-green-300 font-bold transition-all duration-300 rounded-lg px-2 py-1.5 bg-green-500/10"
                aria-label={isExpanded ? t('hide_panel') : t('vote_and_see_poll')}
            >
                <span>{t('vote_and_see_poll')}</span>
                <ChevronDown size={14} className={`transition-transform duration-300 ${isExpanded ? 'rotate-180' : ''}`} />
            </button>
        )}
      </div>

      {}
      <div className={`transition-all duration-300 ease-in-out grid ${isExpanded ? 'grid-rows-[1fr]' : 'grid-rows-[0fr]'}`}>
          <div className="overflow-hidden">
            {isExpanded && <VotingPanel fixtureId={fixture.id} teams={teams} />}
          </div>
      </div>
    </div>
  );
}

// ===== src/components/MobileMatchListItem.tsx =====

"use client";

import { useState, useMemo } from "react";
import Image from "next/image";
import Link from "@/components/StyledLink";
import { format } from "date-fns";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import {
  Loader2,
  BarChart2,
  TrendingUp,
  History,
  CheckCircle,
  XCircle,
} from "lucide-react";
import { generateMatchSlug } from "@/lib/generate-match-slug";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useTranslation } from "@/hooks/useTranslation";
import ZonedDate from "./ZonedDate";

type Odds = { home: string; draw: string; away: string } | undefined | null;
const fetchFanskorOdds = async (fixtureId: number): Promise<Odds | null> => {
  try {
    const { data } = await axios.post("/api/batch-predictions", {
      fixtureIds: [fixtureId],
    });
    return data[fixtureId] || null;
  } catch (error) {
    console.error(
      `Failed to fetch Fanskor odds for fixture ${fixtureId}`,
      error
    );
    return null;
  }
};

const TeamRow = ({
  team,
  score,
  isLive,
}: {
  team: { name: string; logo: string; winner: boolean };
  score: number | null;
  isLive: boolean;
}) => (
  <div className="flex items-center justify-between">
    <div className="flex items-center gap-3 min-w-0">
      <Image
        src={proxyImageUrl(team.logo)}
        alt={team.name}
        width={24}
        height={24}
        unoptimized={true}
      />
      <span
        className={`font-semibold text-sm truncate ${
          team.winner ? "text-text-primary" : "text-text-secondary"
        }`}
      >
        {team.name}
      </span>
    </div>
    <span
      className={`font-bold text-sm ${
        isLive
          ? "text-green-400"
          : team.winner
          ? "text-text-primary"
          : "text-text-secondary"
      }`}
    >
      {score ?? "-"}
    </span>
  </div>
);

export default function MobileMatchListItem({ match }: { match: any }) {
  const { fixture, teams, goals } = match;
  const { t } = useTranslation();
  const slug = generateMatchSlug(teams.home, teams.away, fixture.id);
  const [isExpanded, setIsExpanded] = useState(false);

  const isLive = ["1H", "HT", "2H", "ET", "P", "LIVE"].includes(
    fixture.status.short
  );
  const isFinished = ["FT", "AET", "PEN"].includes(fixture.status.short);

  const { data: customOdds, isLoading } = useQuery({
    queryKey: ["customOdds", fixture.id],
    queryFn: () => fetchFanskorOdds(fixture.id),
    enabled: isExpanded,
    staleTime: Infinity,
    refetchOnWindowFocus: false,
  });

  const { predictedOutcome, lowestOddValue } = useMemo(() => {
    if (!customOdds) return { predictedOutcome: null, lowestOddValue: null };
    const odds = {
      home: parseFloat(customOdds.home || "999"),
      draw: parseFloat(customOdds.draw || "999"),
      away: parseFloat(customOdds.away || "999"),
    };
    const minOdd = Math.min(odds.home, odds.draw, odds.away);
    if (minOdd === odds.home)
      return { predictedOutcome: "Home", lowestOddValue: customOdds.home };
    if (minOdd === odds.away)
      return { predictedOutcome: "Away", lowestOddValue: customOdds.away };
    return { predictedOutcome: "Draw", lowestOddValue: customOdds.draw };
  }, [customOdds]);

  const actualResult = useMemo(() => {
    if (!isFinished) return null;
    if (teams.home.winner) return "Home";
    if (teams.away.winner) return "Away";
    return "Draw";
  }, [isFinished, teams]);

  const wasPredictionCorrect = predictedOutcome === actualResult;

  const CustomOddBox = ({
    value,
    label,
    isFavorite,
  }: {
    value: string | undefined;
    label: string;
    isFavorite: boolean;
  }) => {
    const favoriteClasses =
      "bg-gradient-to-br from-[var(--brand-accent)] to-[#c54c14] text-white";
    const defaultClasses =
      "bg-[var(--color-primary)] text-[var(--text-secondary)]";
    return (
      <div
        className={`flex flex-col flex-1 items-center justify-center p-2 rounded-md transition-all duration-300 ${
          isFavorite ? favoriteClasses : defaultClasses
        }`}
      >
        <span
          className={`text-xs font-semibold ${
            isFavorite ? "opacity-80" : "text-[var(--text-muted)]"
          }`}
        >
          {label}
        </span>
        <span className="text-sm font-black">{value || "-"}</span>
      </div>
    );
  };

  return (
    <div
      className="rounded-lg overflow-hidden"
      style={{ backgroundColor: "var(--color-secondary)" }}
    >
      <Link href={`/football/match/${slug}`}>
        <div className="flex items-center gap-2 p-3">
          <div className="w-12 flex-shrink-0 text-center text-xs font-bold">
            {isLive ? (
              <div className="flex flex-col items-center justify-center gap-1 text-green-400">
                <span className="h-1.5 w-1.5 rounded-full bg-green-500"></span>
                <span>{fixture.status.elapsed}'</span>
              </div>
            ) : isFinished ? (
              <div className="text-text-muted">{t("ft_short")}</div>
            ) : (
              <ZonedDate date={fixture.date} format="HH:mm" />
            )}
          </div>
          <div className="flex-1 flex flex-col gap-2">
            <TeamRow team={teams.home} score={goals.home} isLive={isLive} />
            <TeamRow team={teams.away} score={goals.away} isLive={isLive} />
          </div>
        </div>
      </Link>

      {isExpanded && (
        <div className="mx-3 mb-3 pt-3 border-t border-[var(--color-primary)]">
          {isLoading ? (
            <div className="flex justify-center items-center gap-2 text-sm font-semibold text-text-muted p-2.5">
              <Loader2 size={16} className="animate-spin" /> {t("loading")}...
            </div>
          ) : customOdds ? (
            isFinished ? (
              <div
                className={`flex items-center justify-center gap-2 p-2.5 rounded-md text-sm font-bold ${
                  wasPredictionCorrect
                    ? "bg-green-500/10 text-green-400"
                    : "bg-gray-700/50 text-text-muted"
                }`}
              >
                {wasPredictionCorrect ? (
                  <CheckCircle size={18} />
                ) : (
                  <XCircle size={18} />
                )}
                <span>
                  {t("predicted_result", {
                    outcome: predictedOutcome,
                    odds: lowestOddValue,
                  })}
                </span>
              </div>
            ) : (
              <div className="flex items-center justify-around gap-2">
                <CustomOddBox
                  value={customOdds.home}
                  label={t("odd_label_home")}
                  isFavorite={predictedOutcome === "Home"}
                />
                <CustomOddBox
                  value={customOdds.draw}
                  label={t("odd_label_draw")}
                  isFavorite={predictedOutcome === "Draw"}
                />
                <CustomOddBox
                  value={customOdds.away}
                  label={t("odd_label_away")}
                  isFavorite={predictedOutcome === "Away"}
                />
              </div>
            )
          ) : (
            <p className="text-xs text-center text-text-muted p-2">
              {t("prediction_data_unavailable")}
            </p>
          )}
        </div>
      )}

      <div
        className="flex items-center justify-between p-2"
        style={{ backgroundColor: "var(--color-primary)" }}
      >
        <Link
          href={`/football/match/${slug}`}
          className="flex items-center gap-1.5 text-xs text-text-muted font-semibold hover:text-white transition-colors px-2 py-1"
        >
          <BarChart2 size={14} />
          <span>{t("match_details")}</span>
        </Link>
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className="flex items-center gap-1.5 text-xs font-semibold bg-[var(--brand-accent)]/10 text-[var(--brand-accent)] hover:bg-[var(--brand-accent)] hover:text-white rounded-full px-3 py-1.5 transition-all duration-200"
        >
          {isFinished ? <History size={14} /> : <TrendingUp size={14} />}
          <span>
            {isExpanded
              ? isFinished
                ? t("hide_result")
                : t("hide_odds")
              : isFinished
              ? t("see_result")
              : t("show_odds")}
          </span>
        </button>
      </div>
    </div>
  );
}

export const MobileMatchListItemSkeleton = () => (
  <div
    className="flex flex-col p-3 rounded-lg animate-pulse"
    style={{ backgroundColor: "var(--color-secondary)" }}
  >
    <div className="flex items-center gap-3">
      <div className="w-12 h-8 rounded bg-[var(--color-primary)]"></div>
      <div className="flex-1 space-y-2">
        <div className="h-4 w-4/5 rounded bg-[var(--color-primary)]"></div>
        <div className="h-4 w-3/5 rounded bg-[var(--color-primary)]"></div>
      </div>
    </div>
    <div className="h-8 mt-3 rounded-md bg-[var(--color-primary)]"></div>
  </div>
);

// ===== src/components/NavDropdown.tsx =====

"use client";

import { useState } from "react";
import { ChevronDown } from "lucide-react";
import StyledLink from "./StyledLink";
import { usePathname } from "next/navigation";

type NavIcon = React.ElementType;

interface SubLink {
  name: string;
  href: string;
  description: string;
  icon?: NavIcon;
}

interface NavDropdownProps {
  title: string;
  icon: NavIcon;
  subLinks: SubLink[];
}

export default function NavDropdown({
  title,
  icon: Icon,
  subLinks,
}: NavDropdownProps) {
  const [isOpen, setIsOpen] = useState(false);
  const pathname = usePathname();

  const isActive = subLinks.some((link) => pathname.startsWith(link.href));

  return (
    <div
      className="relative"
      onMouseEnter={() => setIsOpen(true)}
      onMouseLeave={() => setIsOpen(false)}
    >
      {}
      <button
        className={`flex items-center gap-2 py-2 text-base font-semibold transition-colors group
                    ${
                      isActive
                        ? "text-white"
                        : "text-[var(--text-secondary)] hover:text-white"
                    }
                    ${
                      isActive
                        ? "after:absolute after:bottom-0 after:left-0 after:w-full after:h-0.5 after:bg-[var(--brand-accent)] after:rounded-t-sm"
                        : "after:absolute after:bottom-0 after:left-1/2 after:w-0 after:h-0.5 after:bg-[var(--brand-accent)] after:rounded-t-sm group-hover:after:w-full group-hover:after:left-0 after:transition-all after:duration-300"
                    }
                `}
      >
        <Icon size={20} />
        <span>{title}</span>
        <ChevronDown
          size={16}
          className={`transition-transform duration-300 ${
            isOpen ? "rotate-180" : ""
          }`}
        />
      </button>

      {}
      <div
        className={`absolute top-full pt-3 transition-all duration-300 ease-in-out ${
          isOpen
            ? "opacity-100 translate-y-0"
            : "opacity-0 -translate-y-2 pointer-events-none"
        }`}
      >
        <div className="bg-[var(--color-secondary)] rounded-lg shadow-2xl border border-gray-700/50 w-64 overflow-hidden">
          <ul className="space-y-1 p-2">
            {subLinks.map((link) => (
              <li key={link.name}>
                <StyledLink
                  href={link.href}
                  className="block p-3 rounded-md hover:bg-[var(--brand-accent)]/20 hover:text-[var(--brand-accent)] transition-colors"
                >
                  <p className="font-bold text-white flex items-center gap-2">
                    {link.icon && <link.icon size={20} />}{" "}
                    {}
                    {link.name}
                  </p>
                  <p className="text-sm text-[var(--text-muted)]">
                    {link.description}
                  </p>
                </StyledLink>
              </li>
            ))}
          </ul>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/NewsCard.tsx =====

"use client";

import Image from "next/image";
import { IPost } from "@/models/Post";
import { formatDistanceToNow } from "date-fns";
import { ArrowRight, Calendar } from "lucide-react";
import StyledLink from "./StyledLink";
import { useTranslation } from "@/hooks/useTranslation";

interface NewsCardProps {
  post: IPost;
  variant?: "featured" | "grid";
}

const categoryColors: Record<string, string> = {
  prediction: "bg-blue-500/10 text-blue-300",
  reviews: "bg-indigo-500/10 text-indigo-300",
  highlights: "bg-amber-500/10 text-amber-300",
  news: "bg-gray-500/10 text-gray-400",
};

export default function NewsCard({ post, variant = "grid" }: NewsCardProps) {
  const { t } = useTranslation();
  if (!post) return null;

  const postUrl = `/news/${post.slug}`;

  const placeholderImage = "/images/placeholder-logo.svg";

  if (variant === "featured") {
    return (
      <StyledLink
        href={postUrl}
        className="block group relative rounded-xl overflow-hidden text-white shadow-lg shadow-black/30"
      >
        <div className="relative w-full aspect-video md:aspect-[2.4/1]">
          <Image
            src={post.featuredImage || placeholderImage}
            alt={post.title}
            layout="fill"
            objectFit="cover"
            className="transition-transform duration-500 ease-in-out group-hover:scale-105"
            priority
          />
          <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-transparent"></div>
        </div>
        <div className="absolute bottom-0 left-0 p-6 md:p-8">
          <span
            className={`text-xs font-bold px-2 py-1 rounded-full mb-3 inline-block ${
              categoryColors[post.newsType] || categoryColors.news
            }`}
          >
            {t(post.newsType)}
          </span>
          <h2 className="font-extrabold text-2xl md:text-4xl leading-tight line-clamp-2 group-hover:text-brand-purple transition-colors">
            {post.title}
          </h2>
          <div className="flex items-center gap-4 text-sm text-brand-muted mt-3">
            <div className="flex items-center gap-1.5">
              <Calendar size={14} />
              <time dateTime={new Date(post.createdAt).toISOString()}>
                {formatDistanceToNow(new Date(post.createdAt), {
                  addSuffix: true,
                })}
              </time>
            </div>
          </div>
        </div>
      </StyledLink>
    );
  }

  return (
    <StyledLink
      href={postUrl}
      className="block group bg-brand-secondary rounded-xl overflow-hidden transition-all duration-300 hover:-translate-y-1 hover:shadow-xl hover:shadow-brand-purple/20 border border-gray-800/50 hover:border-brand-purple/30"
    >
      <div className="relative w-full aspect-video overflow-hidden">
        <Image
          src={post.featuredImage || placeholderImage}
          alt={post.title}
          layout="fill"
          objectFit="cover"
          className="transition-transform duration-300 group-hover:scale-105"
        />
      </div>
      <div className="p-4 flex flex-col flex-grow">
        <div className="flex items-center gap-2 mb-3">
          <span
            className={`text-xs font-bold px-2 py-1 rounded-full ${
              categoryColors[post.newsType] || categoryColors.news
            }`}
          >
            {t(post.newsType)}
          </span>
          <span className="text-xs text-brand-muted flex items-center gap-1.5 ml-auto">
            <Calendar size={12} />
            <time dateTime={new Date(post.createdAt).toISOString()}>
              {formatDistanceToNow(new Date(post.createdAt), {
                addSuffix: true,
              })}
            </time>
          </span>
        </div>
        <h3 className="font-bold text-white leading-tight text-base line-clamp-3 flex-grow group-hover:text-brand-purple transition-colors">
          {post.title}
        </h3>
      </div>
    </StyledLink>
  );
}

export const NewsCardSkeleton = ({
  variant = "grid",
}: {
  variant?: "featured" | "grid";
}) => {
  if (variant === "featured") {
    return (
      <div className="w-full aspect-video md:aspect-[2.4/1] bg-brand-secondary rounded-xl animate-pulse"></div>
    );
  }
  return (
    <div className="bg-brand-secondary rounded-xl animate-pulse">
      <div className="aspect-video w-full bg-gray-700/50 rounded-t-xl"></div>
      <div className="p-4 space-y-3">
        <div className="h-4 w-1/3 bg-gray-700 rounded"></div>
        <div className="h-5 w-full bg-gray-700 rounded"></div>
        <div className="h-5 w-4/5 bg-gray-700 rounded"></div>
      </div>
    </div>
  );
};

// ===== src/components/NewsItemCard.tsx =====

import Image from "next/image";
import Link from "@/components/StyledLink";

export interface NewsArticleType {
  id: string;
  title: string;
  excerpt: string;
  imageUrl: string;
  articleUrl: string;
}

interface NewsItemCardProps {
  article: NewsArticleType;
}

export default function NewsItemCard({ article }: NewsItemCardProps) {
  return (

    <Link
      href={article.articleUrl}
      target="_blank"
      rel="noopener noreferrer"
      className="block"
    >
      <div className="bg-brand-secondary rounded-xl overflow-hidden group transition-all duration-300 hover:shadow-lg hover:shadow-purple-900/20">
        {}
        <div className="relative w-full h-40">
          <Image
            src={article.imageUrl}
            alt={article.title}
            layout="fill"
            unoptimized={true}
            objectFit="cover"
            className="transition-transform duration-300 group-hover:scale-110"
          />
        </div>

        {}
        <div className="p-4">
          <h4 className="font-bold text-lg text-brand-light mb-2 leading-tight group-hover:text-brand-purple transition-colors">
            {article.title}
          </h4>
          <p className="text-sm text-brand-muted line-clamp-3">
            {article.excerpt}
          </p>
        </div>
      </div>
    </Link>
  );
}

export const NewsItemCardSkeleton = () => {
  return (
    <div className="bg-brand-secondary rounded-xl overflow-hidden animate-pulse">
      <div className="w-full h-40 bg-gray-600/50"></div>
      <div className="p-4 space-y-3">
        <div className="h-5 w-full rounded bg-gray-600/50"></div>
        <div className="h-5 w-4/5 rounded bg-gray-600/50"></div>
        <div className="h-3 w-full rounded bg-gray-600/50 mt-2"></div>
        <div className="h-3 w-1/2 rounded bg-gray-600/50"></div>
      </div>
    </div>
  );
};

// ===== src/components/NewsLeagueStandingsSlide.tsx =====

"use client";

import Image from 'next/image';
import Link from '@/components/StyledLink';

interface TeamStanding {
  rank: number;
  team: { id: number; name: string; logo: string; };
  points: number;
}
interface StandingsData {
  league: { id: number; name: string; logo: string; };
  standings: TeamStanding[];
}

export default function NewsLeagueStandingsSlide({ standingsData }: { standingsData: StandingsData }) {
  const { league, standings } = standingsData;

  return (

    <div className="px-1">
      <div className="bg-brand-secondary rounded-xl p-4 h-full">
        {}
            <Image src={league.logo} alt={league.name} width={32} height={32} />
            <h4 className="font-bold text-xl text-brand-light truncate group-hover:text-brand-purple transition-colors">
              {league.name}
            </h4>
        {}
        <div className="overflow-x-auto">
            <table className="w-full text-sm">
                <thead className="text-brand-muted text-xs">
                    <tr className="border-b border-gray-700/50">
                        <th className="p-2 font-semibold text-center w-8">#</th>
                        <th className="p-2 font-semibold text-left">Team</th>
                        <th className="p-2 font-semibold text-center">Pts</th>
                    </tr>
                </thead>
                <tbody>
                    {}
                    {standings.slice(0, 5).map((team) => (
                    <tr key={team.team.id} className="border-t border-gray-700/50">
                        <td className="p-2 text-center text-brand-muted">{team.rank}</td>
                        <td className="p-2 flex items-center gap-2 font-medium">
                        <Image src={team.team.logo} alt={team.team.name} width={18} height={18} />
                        <span className="truncate">{team.team.name}</span>
                        </td>
                        <td className="p-2 text-center font-bold">{team.points}</td>
                    </tr>
                    ))}
                </tbody>
            </table>
        </div>
      </div>
    </div>
  );
}

export const LeagueStandingsSlideSkeleton = () => (
    <div className="px-1">
        <div className="bg-brand-secondary rounded-xl p-4 animate-pulse">
            <div className="flex items-center gap-3 mb-4">
                <div className="w-8 h-8 rounded-full bg-gray-600/50"></div>
                <div className="h-6 w-3/4 rounded bg-gray-600/50"></div>
            </div>
            <div className="space-y-3 mt-4">
                {Array.from({ length: 5 }).map((_, i) => (
                    <div key={i} className="h-5 w-full rounded bg-gray-600/50"></div>
                ))}
            </div>
        </div>
    </div>
);

// ===== src/components/NewsListItemCompact.tsx =====

"use client";

import Image from "next/image";
import { IPost } from "@/models/Post";
import { formatDistanceToNow } from "date-fns";
import { Calendar, User } from "lucide-react";
import StyledLink from "./StyledLink";
import { useTranslation } from "@/hooks/useTranslation";

interface NewsListItemCompactProps {
  post: IPost;
}

const categoryColors: Record<string, string> = {
  prediction: "border-blue-500/50 text-blue-300",
  reviews: "border-indigo-500/50 text-indigo-300",
  highlights: "border-amber-500/50 text-amber-300",
  news: "border-gray-500/50 text-gray-400",
};

export function NewsListItemCompactSkeleton() {
  return (
    <div className="bg-brand-secondary rounded-lg p-4 flex flex-col sm:flex-row gap-4 md:gap-6 animate-pulse">
      <div className="w-full sm:w-40 md:w-48 flex-shrink-0">
        <div className="w-full aspect-video bg-gray-700 rounded-md"></div>
      </div>
      <div className="flex-1 flex flex-col space-y-3">
        <div className="h-4 w-1/4 bg-gray-600 rounded"></div>
        <div className="h-5 w-full bg-gray-600 rounded"></div>
        <div className="h-5 w-4/5 bg-gray-600 rounded"></div>
        <div className="flex-grow"></div> {}
        <div className="h-3 w-1/2 bg-gray-700 rounded mt-2"></div>
      </div>
    </div>
  );
}

export default function NewsListItemCompact({
  post,
}: NewsListItemCompactProps) {
  const { t } = useTranslation();
  if (!post) return null;

  const postUrl = `/news/${post.slug}`;

  const placeholderImage = "/images/placeholder-logo.svg";

  return (
    <StyledLink
      href={postUrl}
      className="block group bg-brand-secondary rounded-lg transition-shadow duration-300 hover:shadow-xl hover:shadow-brand-purple/20"
    >
      <div className="flex flex-col sm:flex-row items-center gap-4 md:gap-6 p-4">
        {}
        <div className="w-full sm:w-40 md:w-48 flex-shrink-0">
          <div className="relative w-full aspect-video overflow-hidden rounded-md">
            <Image
              src={post.featuredImage || placeholderImage}
              alt={post.title}
              layout="fill"
              objectFit="cover"
              className="transition-transform duration-300 group-hover:scale-105"
            />
          </div>
        </div>

        {}
        <div className="flex-1 flex flex-col self-stretch min-w-0">
          <div className="flex items-center gap-2 mb-2">
            <span
              className={`text-xs font-bold px-2 py-0.5 rounded-full border ${
                categoryColors[post.newsType] || categoryColors.news
              }`}
            >
              {t(post.newsType)}
            </span>
          </div>

          <h3 className="font-bold text-white leading-tight text-lg md:text-xl line-clamp-2 mb-2 group-hover:text-brand-purple transition-colors">
            {post.title}
          </h3>

          {}
          {post.metaDescription && (
            <p className="hidden md:block text-sm text-brand-light line-clamp-2 mb-3">
              {post.metaDescription}
            </p>
          )}

          {}
          <div className="flex-grow"></div>

          {}
          <div className="flex items-center gap-4 text-xs text-brand-muted mt-2">
            <div className="flex items-center gap-1.5" title="Author">
              <User size={12} />
              <span>{post.author}</span>
            </div>
            <div className="flex items-center gap-1.5" title="Publish Date">
              <Calendar size={12} />
              <time dateTime={new Date(post.createdAt).toISOString()}>
                {formatDistanceToNow(new Date(post.createdAt), {
                  addSuffix: true,
                })}
              </time>
            </div>
          </div>
        </div>
      </div>
    </StyledLink>
  );
}

// ===== src/components/NewsSection.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { IPost } from "@/models/Post";
import SidebarNewsItem, { SidebarNewsItemSkeleton } from "./SidebarNewsItem";
import { ArrowRight, Newspaper, Info } from "lucide-react";
import Link from "next/link";
import { useTranslation } from "@/hooks/useTranslation";

const fetchNews = async (
  limit: number = 5,
  locale: string
): Promise<IPost[]> => {
  const { data } = await axios.get(
    `/api/posts?status=published&limit=${limit}&language=${locale}&newsType=news`
  );

  return data.posts;

};

export default function NewsSection() {
  const { t, locale } = useTranslation();

  const {
    data: news,
    isLoading,
    isError,
  } = useQuery<IPost[]>({
    queryKey: ["newsArticlesSidebarWidget", locale],
    queryFn: () => fetchNews(5, locale!),
    staleTime: 1000 * 60 * 10,
    enabled: !!locale,
  });

  return (
    <section className="bg-brand-secondary rounded-lg shadow-lg">
      <div className="flex justify-between items-center p-4 border-b border-gray-700/50">
        <h3 className="text-xl font-bold text-white flex items-center gap-2">
          <Newspaper size={20} className="text-brand-purple" />
          {t("latest_news")}
        </h3>
        <Link
          href="/news/category/news"
          className="flex items-center gap-1 text-xs font-semibold text-text-muted transition-colors hover:text-white"
        >
          {t("see_all")}
          <ArrowRight size={14} />
        </Link>
      </div>

      <div className="p-2 space-y-1">
        {isLoading ? (
          <>
            <SidebarNewsItemSkeleton />
            <SidebarNewsItemSkeleton />
            <SidebarNewsItemSkeleton />
            <SidebarNewsItemSkeleton />
            <SidebarNewsItemSkeleton />
          </>
        ) : isError ? (
          <div className="rounded-lg p-6 text-center text-red-400">
            <p>{t("error_loading_news")}</p>
          </div>
        ) : news && news.length > 0 ? (
          news.map((post) => (
            <SidebarNewsItem
              key={post._id as string}
              post={{
                ...post,
                slug: `/news/${post.slug}`,
              }}
            />
          ))
        ) : (
          <div className="rounded-lg p-6 text-center text-text-muted">
            <Info size={28} className="mx-auto mb-2" />
            <p className="text-sm">{t("no_news_yet")}</p>
          </div>
        )}
      </div>
    </section>
  );
}

// ===== src/components/NewsSidebar.tsx =====

import React from "react";

import NewsSidebarClientContent from "./NewsSidebarClientContent";

export default function NewsSidebar({
  children,
}: {
  children?: React.ReactNode;
}) {
  return (

    <aside className="space-y-8 lg:sticky lg:top-8">
      {children}
      {}
      <NewsSidebarClientContent />
    </aside>
  );
}

// ===== src/components/NewsSidebarClientContent.tsx =====

"use client";

import dynamic from "next/dynamic";
import {
  AdSlotWidgetSkeleton,
  RecentNewsWidgetSkeleton,
} from "./skeletons/WidgetSkeletons";

const AdSlotWidget = dynamic(() => import("./AdSlotWidget"), {
  loading: () => <AdSlotWidgetSkeleton />,
  ssr: false,
});

const RecentNewsWidget = dynamic(() => import("./RecentNewsWidget"), {
  loading: () => <RecentNewsWidgetSkeleton />,
});

const CasinoPartnerWidget = dynamic(() => import("./CasinoPartnerWidget"), {
  loading: () => <RecentNewsWidgetSkeleton />,
});

export default function NewsSidebarClientContent() {
  return (
    <>
      <AdSlotWidget location="news_sidebar" />
      <RecentNewsWidget />
      {}
      <AdSlotWidget location="news_sidebar_bottom" />
    </>
  );
}

// ===== src/components/NotificationDropdown.tsx =====

"use client";

import NotificationList from "./NotificationList";
import Link from "next/link";
import { ArrowRight } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface NotificationDropdownProps {
  onClose: () => void;
}

export default function NotificationDropdown({
  onClose,
}: NotificationDropdownProps) {
  const { t } = useTranslation();

  return (
    <div
      className="fixed top-28 left-1/2 -translate-x-1/2 w-[90vw] max-w-sm
                 md:absolute md:top-full md:left-auto md:right-0 md:translate-x-0 md:w-96
                 bg-brand-secondary rounded-xl shadow-2xl border border-gray-700/50 z-[100] animate-fade-in"
      onClick={(e) => e.stopPropagation()}
    >
      <div className="p-4 border-b border-gray-700/50">
        <h3 className="font-bold text-lg text-white">{t("notifications")}</h3>{" "}
        {}
      </div>
      <div className="max-h-[60vh] overflow-y-auto custom-scrollbar">
        <NotificationList onItemClick={onClose} />
      </div>
      <div className="p-2 border-t border-gray-700/50 text-center">
        <Link
          href="/football/news"
          onClick={onClose}
          className="text-sm font-semibold text-brand-purple hover:underline flex items-center justify-center gap-1"
        >
          {t("view_all_news")} <ArrowRight size={14} />{" "}
          {}
        </Link>
      </div>
    </div>
  );
}

// ===== src/components/NotificationItem.tsx =====

"use client";

import { IPost } from "@/models/Post";
import Link from "next/link";
import Image from "next/image";
import { formatDistanceToNow } from "date-fns";
import { proxyImageUrl } from "@/lib/image-proxy";

interface NotificationItemProps {
  post: IPost;
  onItemClick?: () => void;
}

export default function NotificationItem({
  post,
  onItemClick,
}: NotificationItemProps) {

  const postUrl = `/${post.language}/news/${post.slug}`;

  const placeholderImage = "/images/placeholder-logo.svg";

  return (
    <Link
      href={postUrl}
      onClick={onItemClick}
      className="flex items-start gap-3 p-2 rounded-lg hover:bg-brand-purple/20 transition-colors"
    >
      <div className="flex-shrink-0 w-10 h-10 relative">
        <Image
          src={proxyImageUrl(post.featuredImage || placeholderImage)}
          alt={post.title}
          layout="fill"
          objectFit="cover"
          className="rounded-md"
        />
      </div>
      <div className="flex-1 min-w-0">
        <p className="text-sm font-semibold text-white line-clamp-2">
          {post.title}
        </p>
        <p className="text-xs text-brand-muted mt-0.5">
          {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}
        </p>
      </div>
    </Link>
  );
}

// ===== src/components/NotificationList.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { IPost } from "@/models/Post";
import NotificationItem from "./NotificationItem";
import { BellOff } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

const Skeleton = () => (
  <div className="flex items-start gap-4 p-3 animate-pulse">
    <div className="w-12 h-12 bg-gray-700 rounded-md"></div>
    <div className="flex-1 space-y-2">
      <div className="h-4 w-full bg-gray-700 rounded"></div>
      <div className="h-3 w-1/3 bg-gray-600 rounded"></div>
    </div>
  </div>
);

interface NotificationListProps {
  onItemClick?: () => void;
}

const fetchLatestPosts = async (locale: string): Promise<IPost[]> => {
  const { data } = await axios.get(
    `/api/posts?status=published&limit=5&language=${locale}`
  );
  return data.posts;
};

export default function NotificationList({
  onItemClick,
}: NotificationListProps) {
  const { t, locale } = useTranslation();

  const {
    data: posts,
    isLoading,
    isError,
  } = useQuery<IPost[]>({
    queryKey: ["latestPostsForNotifications", locale],
    queryFn: () => fetchLatestPosts(locale!),
    staleTime: 1000 * 60 * 5,
    enabled: !!locale,
  });

  if (isLoading) {
    return (
      <div className="space-y-1">
        {Array.from({ length: 5 }).map((_, i) => (
          <Skeleton key={i} />
        ))}
      </div>
    );
  }

  if (isError || !posts || posts.length === 0) {
    return (
      <div className="text-center py-10 text-brand-muted">
        <BellOff size={32} className="mx-auto mb-3" />
        <p className="text-sm">{t("no_new_notifications")}</p>
      </div>
    );
  }

  return (
    <div className="space-y-1">
      {posts.map((post) => (
        <NotificationItem
          key={post._id as string}
          post={post}
          onItemClick={onItemClick}
        />
      ))}
    </div>
  );
}

// ===== src/components/OddsDisplay.tsx =====

"use client";

import { useQuery } from '@tanstack/react-query';
import axios from 'axios';

type Odds = { home: string; draw: string; away: string; } | undefined | null;

const fetchOdds = async (fixtureId: number): Promise<Odds> => {
    try {
        const { data } = await axios.get(`/api/odds?fixture=${fixtureId}`);
        return data;
    } catch (error) {

        return null;
    }
};

const OddBox = ({ label, value }: { label: string, value: string }) => (
    <div className="flex-1 flex items-center justify-between p-2 rounded-md" style={{ backgroundColor: 'var(--color-primary)' }}>
        <span className="font-bold text-sm text-text-muted">{label}</span>
        <span className="font-bold text-sm text-brand-highlight">{value}</span>
    </div>
);

export default function OddsDisplay({ fixtureId, initialOdds }: { fixtureId: number, initialOdds?: Odds }) {
    const { data: odds, isLoading, isError } = useQuery({
        queryKey: ['odds', fixtureId],
        queryFn: () => fetchOdds(fixtureId),

        enabled: !initialOdds,

        initialData: initialOdds,
        staleTime: 1000 * 60 * 5,
        refetchOnWindowFocus: false,
    });

    const displayData = initialOdds || odds;

    if (isLoading && !initialOdds) {
        return <div className="text-xs text-center text-text-muted p-2 animate-pulse">Loading Odds...</div>;
    }

    if (isError || !displayData) {
        return <div className="text-xs text-center text-text-muted p-2">Odds not available.</div>;
    }

    return (
        <div className="flex items-center justify-center gap-2">
            <OddBox label="1" value={displayData.home} />
            <OddBox label="X" value={displayData.draw} />
            <OddBox label="2" value={displayData.away} />
        </div>
    );
}

// ===== src/components/Pagination.tsx =====

"use client";

import { ChevronLeft, ChevronRight } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
}

export default function Pagination({
  currentPage,
  totalPages,
  onPageChange,
}: PaginationProps) {
  const { t } = useTranslation();

  if (totalPages <= 1) {
    return null;
  }

  const handlePrevious = () => {
    if (currentPage > 1) {
      onPageChange(currentPage - 1);
    }
  };

  const handleNext = () => {
    if (currentPage < totalPages) {
      onPageChange(currentPage + 1);
    }
  };

  return (
    <div className="flex items-center justify-center gap-4 mt-8">
      <button
        onClick={handlePrevious}
        disabled={currentPage === 1}
        className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-brand-secondary rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50 transition-colors"
        aria-label={t("previous_page")}
      >
        <ChevronLeft size={16} />
        <span>{t("previous")}</span>
      </button>

      <span className="text-sm font-semibold text-brand-muted">
        {t("page_of", { currentPage, totalPages })}
      </span>

      <button
        onClick={handleNext}
        disabled={currentPage === totalPages}
        className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-brand-secondary rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50 transition-colors"
        aria-label={t("next_page")}
      >
        <span>{t("next")}</span>
        <ChevronRight size={16} />
      </button>
    </div>
  );
}

// ===== src/components/PopularTeamsList.tsx =====

"use client";

import { useState, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Link from "@/components/StyledLink";
import { usePathname } from "next/navigation";
import Image from "next/image";
import slugify from "slugify";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";
import { proxyImageUrl } from "@/lib/image-proxy";

interface TeamData {
  team: { id: number; name: string; logo: string };
  venue: any;
}

const generateTeamSlug = (name: string, id: number) => {
  const slug = slugify(name, { lower: true, strict: true });
  return `/football/team/${slug}-${id}`;
};

const fetchPopularTeams = async (): Promise<TeamData[]> => {
  const POPULAR_LEAGUE_ID = 39;
  const season = new Date().getFullYear();
  const { data } = await axios.get(
    `/api/teams?league=${POPULAR_LEAGUE_ID}&season=${season}`
  );
  return data;
};

const TeamItemSkeleton = () => (
  <div className="flex items-center p-2.5 rounded-lg animate-pulse">
    <div className="flex items-center gap-3 w-full">
      <div className="h-6 w-6 rounded-full bg-gray-600/50"></div>
      <div className="h-4 w-4/5 rounded bg-gray-600/50"></div>
    </div>
  </div>
);

export default function PopularTeamsList() {
  const pathname = usePathname();
  const [currentPage, setCurrentPage] = useState(1);
  const ITEMS_PER_PAGE = 6;
  const { t } = useTranslation();

  const {
    data: allTeams,
    isLoading,
    isError,
  } = useQuery<TeamData[]>({
    queryKey: ["popularTeams"],
    queryFn: fetchPopularTeams,
    staleTime: 1000 * 60 * 60 * 24,
    refetchOnWindowFocus: false,
  });

  const totalPages = allTeams ? Math.ceil(allTeams.length / ITEMS_PER_PAGE) : 0;

  const paginatedTeams = useMemo(() => {
    if (!allTeams) return [];
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    return allTeams.slice(startIndex, endIndex);
  }, [allTeams, currentPage]);

  if (isLoading) {
    return (
      <div className="space-y-1">
        {Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
          <TeamItemSkeleton key={i} />
        ))}
      </div>
    );
  }

  if (isError || !paginatedTeams || paginatedTeams.length === 0) {
    return (
      <p className="text-brand-muted text-xs p-2.5">
        {t("error_loading_teams")}
      </p>
    );
  }

  return (
    <div>
      <ul className="space-y-1">
        {paginatedTeams.map(({ team }) => {
          const href = generateTeamSlug(team.name, team.id);
          const isActive = pathname.startsWith(href);
          return (
            <li key={team.id}>
              <Link
                href={href}
                className={`w-full flex items-center p-2.5 rounded-lg transition-all duration-200 ${
                  isActive
                    ? "bg-brand-purple shadow-md text-white"
                    : "hover:bg-gray-700/50 text-brand-light"
                }`}
              >
                <div className="flex items-center gap-3 overflow-hidden">
                  <Image
                    src={proxyImageUrl(team.logo)}
                    alt={`${team.name} logo`}
                    width={24}
                    height={24}
                    className="flex-shrink-0"
                  />
                  <span
                    className={`font-bold text-sm truncate ${
                      isActive ? "text-white" : "text-brand-light"
                    }`}
                  >
                    {team.name}
                  </span>
                </div>
              </Link>
            </li>
          );
        })}
      </ul>

      {totalPages > 1 && (
        <div className="flex items-center justify-between mt-4 px-2">
          <button
            onClick={() => setCurrentPage((p) => p - 1)}
            disabled={currentPage === 1}
            className="p-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50"
            aria-label={t("previous_page")}
          >
            <ChevronLeft size={18} />
          </button>
          <span className="text-xs font-semibold text-brand-muted">
            {t("page_of", { currentPage, totalPages })}
          </span>
          <button
            onClick={() => setCurrentPage((p) => p + 1)}
            disabled={currentPage === totalPages}
            className="p-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50"
            aria-label={t("next_page")}
          >
            <ChevronRight size={18} />
          </button>
        </div>
      )}
    </div>
  );
}

// ===== src/components/PostCategories.tsx =====

"use client";

import React from "react";

export type NewsCategory =
  | "all"
  | "trending"
  | "football"
  | "basketball"
  | "tennis"
  | "general"
  | "prediction"
  | "match_reports";

interface PostCategoriesProps {
  activeCategory: NewsCategory;
  onCategoryChange: (category: NewsCategory) => void;
}

const categories: { value: NewsCategory; label: string }[] = [
  { value: "all", label: "All News" },
  { value: "trending", label: "Trending News" },
  { value: "prediction", label: "Prediction" },
  { value: "match_reports", label: "Match Reports" },
];

const PostCategories: React.FC<PostCategoriesProps> = ({
  activeCategory,
  onCategoryChange,
}) => {

  const effectiveActiveCategory =
    activeCategory === "trending" ? "all" : activeCategory;

  const handleClick = (category: NewsCategory) => {
    onCategoryChange(category);
  };

  return (
    <div className="flex flex-wrap gap-3 mb-8">
      {categories.map((category) => {

        const isActive =
          (category.value === "trending" && activeCategory === "trending") ||
          (category.value !== "trending" &&
            effectiveActiveCategory === category.value);

        return (
          <button
            key={category.value}
            onClick={() => handleClick(category.value)}
            className={`
              px-4 py-2 rounded-full font-semibold text-sm transition-all duration-200 ease-in-out
              ${
                isActive
                  ? "bg-brand-purple text-white border border-brand-purple"
                  : "bg-transparent text-white border border-white hover:bg-white/10"
              }
            `}
          >
            {category.label}
          </button>
        );
      })}
    </div>
  );
};

export default PostCategories;

// ===== src/components/PredictionDisplay.tsx =====

"use client";

import { useQuery } from '@tanstack/react-query';
import axios from 'axios';
import Image from 'next/image';

interface PredictionData {
    teams: {
        home: { id: number; name: string; logo: string; };
        away: { id: number; name: string; logo: string; };
    };
    percent: { home: number; draw: number; away: number };
}

const fetchPrediction = async (fixtureId: number): Promise<PredictionData> => {
    const { data } = await axios.get(`/api/predictions?fixture=${fixtureId}`);
    return data;
};

const PredictionSkeleton = () => (
    <div className="pt-4 mt-4 border-t border-gray-700/50 animate-pulse">
        <div className="h-4 w-1/2 mx-auto rounded bg-gray-600/50 mb-4"></div>
        <div className="flex justify-between items-center">
            <div className="flex flex-col items-center gap-2 w-1/4">
                <div className="w-8 h-8 rounded-full bg-gray-600/50"></div>
                <div className="h-5 w-10 rounded bg-gray-600/50"></div>
            </div>
            <div className="h-5 w-10 rounded bg-gray-600/50"></div>
            <div className="flex flex-col items-center gap-2 w-1/4">
                <div className="w-8 h-8 rounded-full bg-gray-600/50"></div>
                <div className="h-5 w-10 rounded bg-gray-600/50"></div>
            </div>
        </div>
        <div className="h-2 w-full rounded-full bg-gray-600/50 mt-3"></div>
    </div>
);

export default function PredictionDisplay({ fixtureId }: { fixtureId: number }) {
    const { data, isLoading, error } = useQuery({
        queryKey: ['prediction', fixtureId],
        queryFn: () => fetchPrediction(fixtureId),
        staleTime: 1000 * 60 * 60,
        retry: 1,
    });

    if (isLoading) return <PredictionSkeleton />;
    if (error || !data) return null;

    const { teams, percent } = data;
    const { home, draw, away } = percent;

    return (
        <div className="pt-4 mt-4 border-t border-gray-700/50 space-y-3">
            <h4 className="text-sm font-semibold text-center text-brand-muted tracking-wider">PREDICTION</h4>
            <div className="flex justify-between items-center text-white">
                <div className="flex flex-col items-center gap-2 w-1/4">
                    {}
                    <Image src={teams.home.logo} alt={teams.home.name} width={32} height={32} className="object-contain"/>
                    <span className="font-bold text-lg">{home}%</span>
                </div>
                <div className="flex flex-col items-center gap-2 opacity-80">
                    <span className="text-xs text-brand-muted">DRAW</span>
                    <span className="font-bold text-lg">{draw}%</span>
                </div>
                <div className="flex flex-col items-center gap-2 w-1/4">
                    {}
                    <Image src={teams.away.logo} alt={teams.away.name} width={32} height={32} className="object-contain"/>
                    <span className="font-bold text-lg">{away}%</span>
                </div>
            </div>
            <div className="flex w-full h-2 rounded-full overflow-hidden bg-gray-800">
                <div className="bg-[#6D28D9] transition-all duration-500" style={{ width: `${home}%` }}></div>
                <div className="bg-gray-500 transition-all duration-500" style={{ width: `${draw}%` }}></div>
                <div className="bg-blue-600 transition-all duration-500" style={{ width: `${away}%` }}></div>
            </div>
        </div>
    );
}

// ===== src/components/PredictionSidebarWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { Info, Sparkles, ArrowRight, TrendingUp } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";
import { proxyImageUrl } from "@/lib/image-proxy";
import StyledLink from "./StyledLink";
import { generateMatchSlug } from "@/lib/generate-match-slug";
import { useMemo } from "react";

interface Prediction {
  fixture: any;
  teams: { home: any; away: any };
  league: { name: string; logo: string };
  prediction: { home: number; draw: number; away: number };
}

const fetchSidebarPredictions = async (
  limit: number
): Promise<Prediction[]> => {
  const { data } = await axios.get(
    `/api/predictions/upcoming?page=1&limit=${limit}`
  );
  return data.fixtures || [];
};

const PredictionRow = ({ prediction }: { prediction: Prediction }) => {
  const { t } = useTranslation();
  const { teams, prediction: preds, fixture, league } = prediction;
  const matchSlug = generateMatchSlug(teams.home, teams.away, fixture.id);

  const { predictedOutcomeText, confidence, predictedTeam } = useMemo(() => {
    const maxConfidence = Math.max(preds.home, preds.draw, preds.away);
    let outcome = t("draw_prediction");
    let team = null;

    if (maxConfidence === preds.home) {
      outcome = t("win_prediction", { teamName: teams.home.name });
      team = teams.home;
    } else if (maxConfidence === preds.away) {
      outcome = t("win_prediction", { teamName: teams.away.name });
      team = teams.away;
    }

    return {
      predictedOutcomeText: outcome,
      confidence: maxConfidence,
      predictedTeam: team,
    };
  }, [preds, teams, t]);

  return (
    <StyledLink
      href={matchSlug}
      className="block p-3 rounded-lg hover:bg-brand-dark transition-colors group"
    >
      {}
      <div className="flex items-center gap-2 mb-2">
        <Image
          src={proxyImageUrl(league.logo)}
          alt={league.name}
          width={16}
          height={16}
        />
        <span className="text-xs text-text-muted font-semibold truncate">
          {league.name}
        </span>
      </div>

      {}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2 w-2/5 truncate">
          <Image
            src={proxyImageUrl(teams.home.logo)}
            alt={teams.home.name}
            width={24}
            height={24}
          />
          <span className="font-bold text-sm text-white truncate">
            {teams.home.name}
          </span>
        </div>
        <span className="text-xs font-mono text-text-muted">VS</span>
        <div className="flex items-center gap-2 w-2/5 justify-end truncate">
          <span className="font-bold text-sm text-white truncate text-right">
            {teams.away.name}
          </span>
          <Image
            src={proxyImageUrl(teams.away.logo)}
            alt={teams.away.name}
            width={24}
            height={24}
          />
        </div>
      </div>

      {}
      <div className="mt-2 flex w-full h-1.5 rounded-full overflow-hidden bg-gray-700/50">
        <div className="bg-green-500" style={{ width: `${preds.home}%` }}></div>
        <div className="bg-amber-500" style={{ width: `${preds.draw}%` }}></div>
        <div className="bg-blue-500" style={{ width: `${preds.away}%` }}></div>
      </div>

      {}
      <div className="mt-2 flex items-center justify-center gap-2 text-xs text-center p-2 rounded-md bg-brand-dark/30 group-hover:bg-[var(--brand-accent)]/10 transition-colors">
        <Sparkles size={14} className="text-[var(--brand-accent)]" />
        <p className="text-text-secondary">
          {predictedOutcomeText}
          <span className="font-bold text-white"> ({confidence}%)</span>
        </p>
      </div>
    </StyledLink>
  );
};

const WidgetSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg shadow-lg animate-pulse">
    <div className="p-4 border-b border-gray-700/50">
      <div className="h-6 w-3/4 bg-gray-700 rounded"></div>
    </div>
    <div className="p-2 space-y-1">
      {Array.from({ length: 4 }).map((_, i) => (
        <div key={i} className="p-3 space-y-2">
          <div className="h-4 w-1/2 bg-gray-600 rounded"></div>
          <div className="flex justify-between items-center">
            <div className="h-5 w-2/5 bg-gray-600 rounded"></div>
            <div className="h-5 w-2/5 bg-gray-600 rounded"></div>
          </div>
          <div className="h-2 w-full bg-gray-700 rounded-full"></div>
          <div className="h-8 w-full bg-gray-700/50 rounded-md"></div>
        </div>
      ))}
    </div>
  </div>
);

export default function PredictionSidebarWidget() {
  const { t } = useTranslation();

  const {
    data: predictions,
    isLoading,
    isError,
  } = useQuery<Prediction[]>({
    queryKey: ["sidebarPredictions"],
    queryFn: () => fetchSidebarPredictions(4),
    staleTime: 1000 * 60 * 15,
  });

  if (isLoading) {
    return <WidgetSkeleton />;
  }

  if (isError || !predictions || predictions.length === 0) {
    return (
      <div className="bg-brand-secondary rounded-lg shadow-lg">
        <div className="flex justify-between items-center p-4 border-b border-gray-700/50">
          <h3 className="text-xl font-bold text-white flex items-center gap-2">
            <TrendingUp size={20} className="text-[var(--brand-accent)]" />
            {t("upcoming_predictions")}
          </h3>
        </div>
        <div className="p-6 text-center text-brand-muted">
          <Info size={28} className="mx-auto mb-2" />
          <p className="text-sm">{t("no_upcoming_predictions")}</p>
        </div>
      </div>
    );
  }

  return (
    <section className="bg-brand-secondary rounded-lg shadow-lg">
      <div className="flex justify-between items-center p-4 border-b border-gray-700/50">
        <h3 className="text-xl font-bold text-white flex items-center gap-2">
          <TrendingUp size={20} className="text-[var(--brand-accent)]" />
          {t("upcoming_predictions")}
        </h3>
      </div>

      <div className="p-2 space-y-1">
        {predictions.map((p) => (
          <PredictionRow key={p.fixture.id} prediction={p} />
        ))}
      </div>

      {}
      <div className="p-2 border-t border-gray-700/50">
        <StyledLink
          href="/predictions"
          className="w-full flex items-center justify-center gap-2 text-sm font-semibold text-brand-muted hover:text-white hover:bg-brand-dark py-2 rounded-lg transition-colors"
        >
          {t("view_more_predictions")}
          <ArrowRight size={16} />
        </StyledLink>
      </div>
    </section>
  );
}

// ===== src/components/ProgressBar.tsx =====

"use client";

import { useEffect } from 'react';
import { usePathname, useSearchParams } from 'next/navigation';
import NProgress from 'nprogress';

export default function ProgressBar() {
  const pathname = usePathname();
  const searchParams = useSearchParams();

  useEffect(() => {

    NProgress.configure({ showSpinner: false });

    NProgress.done();

    return () => {
      NProgress.remove();
    };
  }, [pathname, searchParams]);

  return null;
}

// ===== src/components/RecentNewsWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { IPost } from "@/models/Post";
import SidebarNewsItem, { SidebarNewsItemSkeleton } from "./SidebarNewsItem";
import { ArrowRight, Newspaper, Info } from "lucide-react";
import Link from "next/link";
import { useTranslation } from "@/hooks/useTranslation";

const fetchRecentNews = async (
  limit: number = 4,
  locale: string
): Promise<IPost[]> => {
  const { data } = await axios.get(
    `/api/posts?status=published&limit=${limit}&language=${locale}&newsType=recent`
  );

  return data.posts;
};

interface RecentNewsWidgetProps {
  limit?: number;
}

export default function RecentNewsWidget({ limit = 4 }: RecentNewsWidgetProps) {
  const { t, locale } = useTranslation();

  const {
    data: recentPosts,
    isLoading,
    isError,
  } = useQuery<IPost[]>({
    queryKey: ["recentNewsWidget", limit, locale],
    queryFn: () => fetchRecentNews(limit, locale!),
    staleTime: 1000 * 60 * 5,
    enabled: !!locale,
  });

  return (
    <section className="bg-brand-secondary rounded-lg shadow-lg">
      <div className="flex justify-between items-center p-4 border-b border-gray-700/50">
        <h2 className="text-xl font-bold text-white flex items-center gap-2">
          <Newspaper size={20} className="text-[var(--brand-accent)]" />
          {t("recent_news")}
        </h2>
        <Link
          href="/news"
          className="flex items-center gap-1 text-xs font-semibold text-text-muted transition-colors hover:text-white"
        >
          {t("see_all")}
          <ArrowRight size={14} />
        </Link>
      </div>

      <div className="p-2 space-y-1">
        {isLoading ? (
          <>
            <SidebarNewsItemSkeleton />
            <SidebarNewsItemSkeleton />
            <SidebarNewsItemSkeleton />
            <SidebarNewsItemSkeleton />
          </>
        ) : isError ? (
          <div className="rounded-lg p-6 text-center text-red-400">
            <p>{t("error_loading_news")}</p>
          </div>
        ) : recentPosts && recentPosts.length > 0 ? (
          recentPosts.map((post) => (
            <SidebarNewsItem
              key={post._id as string}
              post={{
                ...post,
                slug: `/news/${post.slug}`,
                createdAt: new Date(post.createdAt),
                updatedAt: new Date(post.updatedAt),
              }}
            />
          ))
        ) : (
          <div className="rounded-lg p-6 text-center text-text-muted">
            <Info size={28} className="mx-auto mb-2" />
            <p className="text-sm">{t("no_news_yet")}</p>
          </div>
        )}
      </div>
    </section>
  );
}

// ===== src/components/Sidebar.tsx =====

import { Suspense } from "react";
import PopularTeamsList from "./PopularTeamsList";
import AdSlotWidget from "./AdSlotWidget";
import { getI18n } from "@/lib/i18n/server";
import SidebarLeagueList, {
  SidebarLeagueListSkeleton,
} from "./SidebarLeagueList";

export default async function Sidebar() {
  const t = await getI18n();

  return (
    <aside className="hidden lg:block">
      <div className="flex flex-col gap-4 h-auto">
        <AdSlotWidget location="homepage_left_sidebar" />

        {}
        <section
          className="flex flex-col gap-2 p-3 rounded-xl"
          style={{ backgroundColor: "var(--color-primary)" }}
        >
          <p className="text-sm font-bold uppercase tracking-wider text-text-muted px-2">
            {t("popular_leagues")}
          </p>
          <Suspense fallback={<SidebarLeagueListSkeleton />}>
            <SidebarLeagueList />
          </Suspense>
        </section>

        <section
          className="flex flex-col gap-2 p-3 rounded-xl sticky top-8"
          style={{ backgroundColor: "var(--color-primary)" }}
        >
          <p className="text-sm font-bold uppercase tracking-wider text-text-muted px-2">
            {t("popular_teams")}
          </p>
          <PopularTeamsList />
        </section>
      </div>
    </aside>
  );
}

// ===== src/components/SidebarLeagueList.tsx =====

import {
  topLeaguesConfig,
  leagueIdToPriorityMap,
} from "@/config/topLeaguesConfig";
import dbConnect from "@/lib/dbConnect";
import LeagueModel from "@/models/League";
import { League } from "@/types/api-football";
import { generateLeagueSlug } from "@/lib/generate-league-slug";
import LeagueListSidebar from "./LeagueListSidebar";

const LeagueItemSkeleton = () => (
  <div className="flex items-center justify-between p-2 rounded-lg animate-pulse">
    <div className="flex items-center gap-3 w-3/4">
      <div className="h-6 w-6 rounded-full bg-gray-600/50"></div>
      <div className="h-4 w-full rounded bg-gray-600/50"></div>
    </div>
  </div>
);

export const SidebarLeagueListSkeleton = () => {
  const INITIAL_LEAGUE_COUNT = 15;
  return (
    <div className="space-y-1">
      {Array.from({ length: INITIAL_LEAGUE_COUNT }).map((_, i) => (
        <LeagueItemSkeleton key={i} />
      ))}
    </div>
  );
};

const fetchLeagues = async (): Promise<League[]> => {
  try {
    await dbConnect();
    const leagueIds = topLeaguesConfig.map((l) => parseInt(l.leagueId, 10));

    const leaguesFromDB = await LeagueModel.find({
      leagueId: { $in: leagueIds },
    }).lean();

    const formattedLeagues: League[] = leaguesFromDB.map((league) => ({
      id: league.leagueId,
      name: league.name,
      logoUrl: league.logoUrl,
      countryName: league.countryName,
      countryFlagUrl: league.countryFlagUrl || "",
      type: league.type,
      href: generateLeagueSlug(league.name, league.leagueId),
    }));

    const sortedData = formattedLeagues.sort((a, b) => {
      const priorityA = leagueIdToPriorityMap.get(a.id.toString()) || 999;
      const priorityB = leagueIdToPriorityMap.get(b.id.toString()) || 999;
      return priorityA - priorityB;
    });

    return sortedData;
  } catch (error) {
    console.error(
      "[SidebarLeagueList] Failed to fetch leagues from DB:",
      error
    );
    return [];
  }
};

export default async function SidebarLeagueList() {
  const allLeagues = await fetchLeagues();

  return <LeagueListSidebar allLeagues={allLeagues} />;
}

// ===== src/components/SidebarMatchItem.tsx =====

"use client";

import Image from 'next/image';
import Link from '@/components/StyledLink';

interface SidebarMatchItemProps {
  match: {
    fixture: {
      id: number;
      status: {
        elapsed: number;
      };
    };
    teams: {
      home: { name: string; logo: string; };
      away: { name: string; logo: string; };
    };
    goals: {
      home: number;
      away: number;
    };
  };
}

export default function SidebarMatchItem({ match }: SidebarMatchItemProps) {
  const { fixture, teams, goals } = match;

  return (
    <Link
      href={`/football/match/${fixture.id}`}
      className="block p-2.5 rounded-lg transition-colors duration-200 hover:bg-gray-700/50"
    >
      <div className="flex items-center gap-3 w-full">
        {}
        <div className="flex flex-col items-center w-10 text-center text-brand-live font-semibold text-sm">
          <span>{fixture.status.elapsed}'</span>
          <div className="relative flex h-2 w-2 mt-1">
            <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span>
            <span className="relative inline-flex rounded-full h-2 w-2 bg-brand-live"></span>
          </div>
        </div>

        {}
        <div className="flex-1 space-y-1.5 text-sm">
          {}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2 truncate">
              <Image src={teams.home.logo} alt={teams.home.name} width={18} height={18} />
              <span className="font-medium truncate">{teams.home.name}</span>
            </div>
            <span className="font-bold">{goals.home}</span>
          </div>
          {}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2 truncate">
              <Image src={teams.away.logo} alt={teams.away.name} width={18} height={18} />
              <span className="font-medium truncate">{teams.away.name}</span>
            </div>
            <span className="font-bold">{goals.away}</span>
          </div>
        </div>
      </div>
    </Link>
  );
}

export const SidebarMatchItemSkeleton = () => (
    <div className="flex items-center gap-3 w-full p-2.5 animate-pulse">
        <div className="flex flex-col items-center w-10">
            <div className="h-4 w-6 rounded bg-gray-600/50"></div>
            <div className="h-2 w-2 rounded-full bg-gray-600/50 mt-1.5"></div>
        </div>
        <div className="flex-1 space-y-2">
            <div className="flex items-center justify-between">
                <div className="h-4 w-3/5 rounded bg-gray-600/50"></div>
                <div className="h-4 w-4 rounded bg-gray-600/50"></div>
            </div>
            <div className="flex items-center justify-between">
                <div className="h-4 w-3/5 rounded bg-gray-600/50"></div>
                <div className="h-4 w-4 rounded bg-gray-600/50"></div>
            </div>
        </div>
    </div>
);

// ===== src/components/SidebarNewsItem.tsx =====

"use client";

import Link from "next/link";
import { formatDistanceToNow } from "date-fns";
import { IPost } from "@/models/Post";
import { ChevronRight } from "lucide-react";

interface SidebarNewsItemProps {
  post: IPost;

}

export const SidebarNewsItemSkeleton = () => (
  <div className="flex flex-col gap-1.5 p-3 animate-pulse">
    <div className="h-4 w-full rounded bg-gray-700"></div>
    <div className="h-3 w-1/3 rounded bg-gray-700"></div>
  </div>
);

export default function SidebarNewsItem({ post }: SidebarNewsItemProps) {

  const postUrl = post.slug;

  return (
    <Link
      href={postUrl}
      className="block p-3 rounded-lg group hover:bg-[var(--color-primary)] transition-colors"
    >
      <div className="flex items-start justify-between gap-3">
        <div className="flex-1">
          <h4 className="font-semibold text-sm text-text-primary leading-snug group-hover:text-[var(--brand-accent)] transition-colors line-clamp-2">
            {post.title}
          </h4>
          <p className="text-xs text-text-muted mt-1.5">
            {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}
          </p>
        </div>
        <ChevronRight className="w-5 h-5 text-text-muted flex-shrink-0 mt-0.5 group-hover:text-[var(--brand-accent)] transition-colors" />
      </div>
    </Link>
  );
}

// ===== src/components/SidebarNewsItemWithImage.tsx =====

"use client";

import Link from "next/link";
import Image from "next/image";
import { formatDistanceToNow } from "date-fns";
import { IPost } from "@/models/Post";
import { proxyImageUrl } from "@/lib/image-proxy";

interface SidebarNewsItemWithImageProps {
  post: IPost;
}

export const SidebarNewsItemWithImageSkeleton = () => (
  <div className="flex items-center gap-3 p-2 animate-pulse">
    <div className="w-16 h-12 bg-gray-700 rounded-md flex-shrink-0"></div>
    <div className="flex-1 space-y-2">
      <div className="h-4 w-full bg-gray-700 rounded"></div>
      <div className="h-4 w-2/3 bg-gray-700 rounded"></div>
      <div className="h-3 w-1/3 bg-gray-600 rounded"></div>
    </div>
  </div>
);

export default function SidebarNewsItemWithImage({
  post,
}: SidebarNewsItemWithImageProps) {

  const postUrl = `/${post.language}/news/${post.slug}`;

  const placeholderImage = "/images/placeholder-logo.svg";

  return (
    <Link
      href={postUrl}
      className="block p-2 rounded-lg group hover:bg-brand-dark transition-colors"
    >
      <div className="flex items-center gap-3">
        <div className="flex-shrink-0 w-16 h-12 relative">
          <Image
            src={proxyImageUrl(post.featuredImage || placeholderImage)}
            alt={post.title}
            layout="fill"
            objectFit="cover"
            className="rounded-md"
          />
        </div>
        <div className="flex-1 min-w-0">
          <h4 className="font-semibold text-sm text-white leading-snug group-hover:text-brand-purple transition-colors line-clamp-2">
            {post.title}
          </h4>
          <p className="text-xs text-brand-muted mt-1">
            {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}
          </p>
        </div>
      </div>
    </Link>
  );
}

// ===== src/components/SocialShareButtons.tsx =====

"use client";

import {
  FacebookShareButton,
  FacebookIcon,
  TwitterShareButton,
  XIcon,
  WhatsappShareButton,
  WhatsappIcon,
  LinkedinShareButton,
  LinkedinIcon,
  TelegramShareButton,
  TelegramIcon,
  RedditShareButton,
  RedditIcon,
} from 'react-share';

interface SocialShareButtonsProps {
  url: string;
  title: string;
}

export default function SocialShareButtons({ url, title }: SocialShareButtonsProps) {
  const iconSize = 48;
  const iconBgStyle = { background: 'none' };
  const iconClassName = "rounded-full transition-transform duration-200 hover:scale-110";

  return (
    <div className="flex items-center justify-center gap-4 flex-wrap">
      <FacebookShareButton url={url} quote={title} className={iconClassName}>
        <FacebookIcon size={iconSize} round bgStyle={iconBgStyle} />
      </FacebookShareButton>

      <TwitterShareButton url={url} title={title} className={iconClassName}>
        <XIcon size={iconSize} round bgStyle={iconBgStyle} />
      </TwitterShareButton>

      <WhatsappShareButton url={url} title={title} separator=":: " className={iconClassName}>
        <WhatsappIcon size={iconSize} round bgStyle={iconBgStyle} />
      </WhatsappShareButton>

      <LinkedinShareButton url={url} title={title} className={iconClassName}>
        <LinkedinIcon size={iconSize} round bgStyle={iconBgStyle} />
      </LinkedinShareButton>

      <TelegramShareButton url={url} title={title} className={iconClassName}>
        <TelegramIcon size={iconSize} round bgStyle={iconBgStyle} />
      </TelegramShareButton>

      <RedditShareButton url={url} title={title} className={iconClassName}>
        <RedditIcon size={iconSize} round bgStyle={iconBgStyle} />
      </RedditShareButton>
    </div>
  );
}

// ===== src/components/StandingsDisplay.tsx =====

"use client";

import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Slider from "react-slick";
import Image from "next/image";
import { ChevronRight, Info } from "lucide-react";

import { useLeagueContext } from "@/context/LeagueContext";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import StyledLink from "./StyledLink";
import { useTranslation } from "@/hooks/useTranslation";

interface Team {
  id: number;
  name: string;
  logo: string;
}
interface TeamStats {
  played: number;
  win: number;
  draw: number;
  lose: number;
}
interface TeamStanding {
  rank: number;
  team: Team;
  points: number;
  goalsDiff: number;
  group: string;
  description: string | null;
  all: TeamStats;
}
interface League {
  id: number;
  name: string;
  logo: string;
  href: string;
}
interface StandingsResponse {
  league: League | null;
  standings: TeamStanding[][];
}

const POPULAR_LEAGUES = [
  {
    id: 39,
    name: "Premier League",
    logo: "https://media.api-sports.io/football/leagues/39.png",
  },
  {
    id: 140,
    name: "La Liga",
    logo: "https://media.api-sports.io/football/leagues/140.png",
  },
  {
    id: 135,
    name: "Serie A",
    logo: "https://media.api-sports.io/football/leagues/135.png",
  },
  {
    id: 78,
    name: "Bundesliga",
    logo: "https://media.api-sports.io/football/leagues/78.png",
  },
  {
    id: 61,
    name: "Ligue 1",
    logo: "https://media.api-sports.io/football/leagues/61.png",
  },
];

const fetchStandings = async (
  leagueId: number,
  season: number
): Promise<StandingsResponse> => {
  const { data } = await axios.get(
    `/api/standings?league=${leagueId}&season=${season}`
  );
  return data;
};

const getRankIndicatorClass = (description: string | null): string => {
  if (!description) return "bg-gray-700 text-brand-light";
  const desc = description.toLowerCase();
  if (desc.includes("champions league") || desc.includes("promotion"))
    return "bg-green-500/20 text-green-400";
  if (desc.includes("europa league") || desc.includes("qualification"))
    return "bg-orange-500/20 text-orange-400";
  if (desc.includes("conference league") || desc.includes("play-off"))
    return "bg-sky-400/20 text-sky-300";
  if (desc.includes("relegation")) return "bg-red-600/20 text-red-500";
  return "bg-gray-700 text-brand-light";
};

const InternalStandingTable = ({
  group,
  league,
}: {
  group: TeamStanding[];
  league: League;
}) => {
  const { t } = useTranslation();
  const validGroup = group.filter((item) => item && item.team);
  if (validGroup.length === 0) return null;

  return (
    <div className="px-1 overflow-y-auto max-h-96 custom-scrollbar">
      <table className="w-full text-sm">
        <thead className="text-left text-brand-muted sticky top-0 bg-brand-secondary z-10">
          <tr className="text-xs">
            <th className="p-2 w-8 text-center">#</th>
            <th className="p-2">{t("table_header_team")}</th>
            <th className="p-2 text-center">P</th>
            <th className="p-2 text-center">GD</th>
            <th className="p-2 text-center font-bold">Pts</th>
          </tr>
        </thead>
        <tbody className="text-brand-light">
          {validGroup.map((item) => (
            <tr key={item.team.id} className="border-t border-gray-700/50">
              <td className="p-2 text-center">
                <span
                  className={`w-6 h-6 flex items-center justify-center text-xs font-bold rounded-md ${getRankIndicatorClass(
                    item.description
                  )}`}
                >
                  {item.rank}
                </span>
              </td>
              <td className="p-2">
                <StyledLink
                  href={generateTeamSlug(item.team.name, item.team.id)}
                  className="flex items-center gap-2 group"
                >
                  <Image
                    src={proxyImageUrl(item.team.logo)}
                    alt={item.team.name}
                    width={20}
                    height={20}
                  />
                  <span className="font-semibold group-hover:text-brand-purple transition-colors whitespace-nowrap">
                    {item.team.name}
                  </span>
                </StyledLink>
              </td>
              <td className="p-2 text-center">{item.all.played}</td>
              <td className="p-2 text-center">{item.goalsDiff}</td>
              <td className="p-2 text-center font-bold text-white">
                {item.points}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

const StandingsDisplaySkeleton = () => (
  <div className="bg-brand-secondary rounded-lg h-[480px] animate-pulse">
    <div className="p-2 border-b border-gray-700/50 flex space-x-1">
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
    </div>
    <div className="p-4">
      <div className="flex justify-between items-center mb-4">
        <div className="h-5 w-2/5 bg-gray-700 rounded"></div>
        <div className="h-4 w-1/4 bg-gray-700 rounded"></div>
      </div>
      <div className="space-y-2">
        {[...Array(8)].map((_, i) => (
          <div key={i} className="flex items-center gap-3 h-8">
            <div className="w-6 h-6 bg-gray-600 rounded"></div>
            <div className="w-5 h-5 bg-gray-600 rounded-full"></div>
            <div className="flex-1 h-4 bg-gray-600 rounded"></div>
            <div className="w-6 h-4 bg-gray-600 rounded"></div>
          </div>
        ))}
      </div>
    </div>
  </div>
);

export default function StandingsDisplay() {
  const { t } = useTranslation();
  const { selectedLeague } = useLeagueContext();
  const [activePopularLeagueId, setActivePopularLeagueId] = useState(
    POPULAR_LEAGUES[0].id
  );
  const season = new Date().getFullYear();
  const leagueIdToFetch = selectedLeague?.id || activePopularLeagueId;

  const { data, isLoading, isError } = useQuery<StandingsResponse>({
    queryKey: ["standings", leagueIdToFetch, season],
    queryFn: () => fetchStandings(leagueIdToFetch, season),
    staleTime: 1000 * 60 * 15,
  });

  const sliderSettings = {
    dots: true,
    infinite: false,
    speed: 500,
    slidesToShow: 1,
    slidesToScroll: 1,
    arrows: false,
    appendDots: (dots: any) => (
      <div>
        <ul className="m-0 pt-3"> {dots} </ul>
      </div>
    ),
  };

  const sanitizedStandingsGroups = data?.standings?.filter(
    (group) => group && group.length > 0
  );
  const hasStandings =
    sanitizedStandingsGroups && sanitizedStandingsGroups.length > 0;
  const showTabs = !selectedLeague || (selectedLeague && !hasStandings);

  if (isLoading) return <StandingsDisplaySkeleton />;

  return (
    <div className="bg-brand-secondary rounded-lg">
      {showTabs && (
        <div className="flex items-center p-2 space-x-1 border-b border-gray-700/50">
          {POPULAR_LEAGUES.map((popLeague) => (
            <button
              key={popLeague.id}
              onClick={() => setActivePopularLeagueId(popLeague.id)}
              className={`group flex-1 p-2 rounded-md transition-colors ${
                activePopularLeagueId === popLeague.id
                  ? "bg-brand-purple/20"
                  : "hover:bg-white/5"
              }`}
              title={popLeague.name}
            >
              <Image
                src={proxyImageUrl(popLeague.logo)}
                alt={popLeague.name}
                width={24}
                height={24}
                className="mx-auto transition-transform duration-300 ease-in-out group-hover:scale-110"
              />
            </button>
          ))}
        </div>
      )}

      <div className="p-4">
        {hasStandings && data?.league ? (
          <>
            <div className="flex justify-between items-center mb-3">
              <h3 className="text-white font-bold">{data.league.name}</h3>
              <StyledLink
                href={data.league.href}
                className="text-xs text-brand-muted hover:text-white flex items-center gap-1"
              >
                View Full Table <ChevronRight size={14} />
              </StyledLink>
            </div>
            {sanitizedStandingsGroups.length === 1 ? (
              <InternalStandingTable
                group={sanitizedStandingsGroups[0]}
                league={data.league}
              />
            ) : (
              <Slider {...sliderSettings}>
                {sanitizedStandingsGroups.map((group) => (
                  <div key={group[0].group}>
                    <h4 className="text-center text-brand-light font-bold text-sm mb-2">
                      {group[0].group}
                    </h4>
                    <InternalStandingTable
                      group={group}
                      league={data.league!}
                    />
                  </div>
                ))}
              </Slider>
            )}
          </>
        ) : (
          <div className="text-center py-6">
            <Info size={32} className="mx-auto text-brand-muted mb-3" />
            <h4 className="font-bold text-white mb-1">
              {data?.league?.name ||
                selectedLeague?.name ||
                t("no_standings_title")}
            </h4>
            <p className="text-sm text-brand-muted">
              {t("standings_not_available")}
              {showTabs && t("select_another_league_prompt")}
            </p>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/StandingsWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { Info } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";
import LeagueStandingsWidget from "@/components/league-detail-view/LeagueStandingsWidget";

interface StandingsWidgetProps {
  leagueId: number;
  season: number;
  homeTeamId?: number;
  awayTeamId?: number;
  variant?: "default" | "compact";
}

const fetchStandings = async (leagueId: number, season: number) => {
  try {
    const { data } = await axios.get(
      `/api/standings?league=${leagueId}&season=${season}`
    );
    return data;
  } catch (error) {
    console.error(
      `[StandingsWidget] Failed to fetch standings for league ${leagueId}:`,
      error
    );
    return null;
  }
};

const StandingsSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg h-96 animate-pulse p-6">
    <div className="h-8 w-1/2 bg-gray-700 rounded mb-4"></div>
    <div className="h-6 w-1/3 bg-gray-700 rounded mb-6"></div>
    <div className="space-y-2">
      <div className="h-10 bg-gray-700/50 rounded-md"></div>
      <div className="h-10 bg-gray-700/50 rounded-md"></div>
      <div className="h-10 bg-gray-700/50 rounded-md"></div>
    </div>
  </div>
);

export default function StandingsWidget({
  leagueId,
  season,
  homeTeamId,
  awayTeamId,
  variant = "default",
}: StandingsWidgetProps) {
  const { t } = useTranslation();

  const {
    data: standingsData,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["standings", leagueId, season],
    queryFn: () => fetchStandings(leagueId, season),
    staleTime: 1000 * 60 * 15,
    enabled: !!leagueId && !!season,
  });

  if (isLoading) return <StandingsSkeleton />;

  if (
    isError ||
    !standingsData ||
    !standingsData.league ||
    !standingsData.standings ||
    standingsData.standings.length === 0
  ) {
    return (
      <div className="bg-brand-secondary rounded-lg p-6 text-center">
        <Info size={32} className="mx-auto text-brand-muted mb-3" />
        <p className="font-semibold text-white">
          {t("standings_not_available")}
        </p>
      </div>
    );
  }

  return (
    <LeagueStandingsWidget
      initialStandings={standingsData.standings}
      leagueSeasons={standingsData.league.seasons}
      currentSeason={standingsData.league.season}
      isLoading={isLoading}
      leagueId={leagueId}
      leagueSlug={standingsData.league.href.split("/").pop()}
      homeTeamId={homeTeamId}
      awayTeamId={awayTeamId}

      hideSeasonDropdown={true}
    />
  );
}

// ===== src/components/StickyFooterAd.tsx =====

"use client";

import { useState, useEffect, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { X } from "lucide-react";

interface IBanner {
  _id: string;
  title: string;
  imageUrl: string;
  linkUrl: string;
  isActive: boolean;
}

export default function StickyFooterAd() {
  const [isDismissed, setIsDismissed] = useState(true);
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (sessionStorage.getItem("footerAdDismissed") === "true") {
      setIsDismissed(true);
    } else {
      setIsDismissed(false);
    }
  }, []);

  const { data: banners, isLoading } = useQuery<IBanner[]>({

    queryKey: ["sticky_footer"],
    queryFn: () =>
      axios
        .get("/api/banners?active=true&location=sticky_footer")
        .then((res) => res.data),
    staleTime: 5 * 60 * 1000,
    refetchOnWindowFocus: false,
  });

  const randomAd = useMemo(() => {
    if (!banners || banners.length === 0) return null;
    const randomIndex = Math.floor(Math.random() * banners.length);
    return banners[randomIndex];
  }, [banners]);

  useEffect(() => {
    if (!isLoading && randomAd && !isDismissed) {
      const timer = setTimeout(() => setIsVisible(true), 100);
      return () => clearTimeout(timer);
    }
  }, [isLoading, randomAd, isDismissed]);

  const handleDismiss = () => {
    setIsVisible(false);
    setTimeout(() => {
      setIsDismissed(true);
      sessionStorage.setItem("footerAdDismissed", "true");
    }, 500);
  };

  if (!randomAd || isDismissed) {
    return null;
  }

  return (
    <div className="fixed inset-0 top-auto z-50 flex justify-center p-2 pointer-events-none">
      <div
        className={`
          pointer-events-auto flex items-center gap-4 w-full max-w-lg
          bg-brand-secondary/80 backdrop-blur-sm
          border border-gray-600/50 shadow-2xl shadow-black/50 rounded-lg
          transition-all duration-500 ease-in-out
          ${
            isVisible
              ? "translate-y-0 opacity-100"
              : "translate-y-full opacity-0"
          }
        `}
      >
        <a
          href={randomAd.linkUrl}
          target="_blank"
          rel="noopener sponsored"
          className="flex-grow flex items-center gap-4 p-3 group"
        >
          <div className="flex-shrink-0 w-20 h-16 relative">
            <Image
              src={randomAd.imageUrl}
              alt={randomAd.title}
              layout="fill"
              objectFit="cover"
              className="rounded-md"
              unoptimized={true}
            />
          </div>
          <div className="flex-grow min-w-0">
            <p className="text-xs text-brand-muted">Sponsored</p>
            <h4 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
              {randomAd.title}
            </h4>
          </div>
        </a>

        <button
          onClick={handleDismiss}
          className="flex-shrink-0 self-start p-2 text-brand-muted hover:text-white"
          aria-label="Close ad"
        >
          <X size={18} />
        </button>
      </div>
    </div>
  );
}

// ===== src/components/StyledLink.tsx =====

"use client";

import { default as NextLink, LinkProps } from "next/link";
import NProgress from "nprogress";
import React from "react";
import { sendGAEvent } from "@/lib/analytics";
import { useTranslation } from "@/hooks/useTranslation";
import { usePathname } from "next/navigation";

const DEFAULT_LOCALE = "tr";

export default function StyledLink({
  href,
  children,
  className,
  style,
  gaEventName,
  gaEventParams,
  ...props
}: LinkProps & {
  children: React.ReactNode;
  className?: string;
  style?: React.CSSProperties;
  gaEventName?: string;
  gaEventParams?: { [key: string]: any };
} & Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, "href">) {
  const currentPathname = usePathname();

  const isAdminRoute = currentPathname.startsWith("/admin");
  const i18n = !isAdminRoute ? useTranslation() : { locale: DEFAULT_LOCALE };
  const { locale } = i18n;

  const isExternal =
    typeof href === "string" &&
    (href.startsWith("http") || href.startsWith("mailto:"));
  const isAnchor = typeof href === "string" && href.startsWith("#");

  const isAdminLink = typeof href === "string" && href.startsWith("/admin");

  let localizedHref = href;

  if (!isExternal && !isAnchor && !isAdminLink) {
    if (locale === DEFAULT_LOCALE) {
      localizedHref = href;
    } else {
      localizedHref = `/${locale}${href}`;
    }
  }

  const handleLinkClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
    if (gaEventName) {
      sendGAEvent(gaEventName, gaEventParams || {});
    }

    if (localizedHref.toString() !== currentPathname) {
      NProgress.start();
    }

    if (props.onClick) {
      props.onClick(e);
    }
  };

  if (isExternal) {
    return (
      <a
        href={href as string}
        className={className}
        style={style}
        {...props}
        onClick={handleLinkClick}
        target="_blank"
        rel="noopener noreferrer"
      >
        {children}
      </a>
    );
  }

  return (
    <NextLink
      href={localizedHref}
      className={className}
      style={style}
      {...props}
      onClick={handleLinkClick}
    >
      {children}
    </NextLink>
  );
}

// ===== src/components/TableOfContents.tsx =====

"use client";

import { useState, useEffect, useRef } from "react";
import { TocEntry } from "@/lib/toc";
import { List } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface TableOfContentsProps {
  toc: TocEntry[];
}

export default function TableOfContents({ toc }: TableOfContentsProps) {
  const { t } = useTranslation();
  const [activeId, setActiveId] = useState<string | null>(null);
  const observer = useRef<IntersectionObserver | null>(null);

  useEffect(() => {
    if (observer.current) {
      observer.current.disconnect();
    }

    observer.current = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setActiveId(entry.target.id);
          }
        });
      },
      { rootMargin: "0% 0% -60% 0%", threshold: 1.0 }
    );

    const headings = document.querySelectorAll("h2[id], h3[id]");
    headings.forEach((heading) => {
      observer.current?.observe(heading);
    });

    return () => observer.current?.disconnect();
  }, [toc]);

  if (!toc || toc.length === 0) {
    return null;
  }

  const handleLinkClick = (
    e: React.MouseEvent<HTMLAnchorElement>,
    id: string
  ) => {
    e.preventDefault();
    const element = document.getElementById(id);
    if (element) {
      const topOffset =
        element.getBoundingClientRect().top + window.pageYOffset - 100;
      window.scrollTo({
        top: topOffset,
        behavior: "smooth",
      });
      setActiveId(id);
    }
  };

  return (

    <div className="bg-brand-secondary rounded-lg p-6 my-8 border border-gray-700/50">
      {}
      <h3 className="font-bold text-white text-lg mb-4 flex items-center gap-2">
        <List size={20} className="text-brand-purple" />
        {t("table_of_contents")}
      </h3>
      <ul className="space-y-2">
        {toc.map((item) => (
          <li key={item.id}>
            <a
              href={`#${item.id}`}
              onClick={(e) => handleLinkClick(e, item.id)}
              className={`block text-sm transition-colors duration-200 border-l-2
                ${item.level === "h3" ? "pl-6" : "pl-3"}
                ${
                  activeId === item.id
                    ? "border-brand-purple text-white font-semibold"
                    : "border-transparent text-brand-muted hover:text-white hover:border-gray-500"
                }
              `}
            >
              {item.text}
            </a>
          </li>
        ))}
      </ul>
    </div>
  );
}

// ===== src/components/TeamDetailView.tsx =====

import TeamHeader from "./team/TeamHeader";
import TeamSquadWidget from "./team/TeamSquadWidget";
import TeamFixturesWidget from "./team/TeamFixturesWidget";
import LeagueStandingsWidget from "@/components/league-detail-view/LeagueStandingsWidget";
import { generateLeagueSlug } from "@/lib/generate-league-slug";
import { getI18n } from "@/lib/i18n/server";

export default async function TeamDetailView({ teamData }: { teamData: any }) {
  const t = await getI18n();
  const { teamInfo, squad, fixtures, standings } = teamData;
  const { team } = teamInfo;

  const primaryLeague = standings?.[0]?.league;
  const leagueWithHref = primaryLeague
    ? {
        ...primaryLeague,
        href: generateLeagueSlug(primaryLeague.name, primaryLeague.id),
      }
    : null;

  return (
    <div className="space-y-8">
      {}
      <TeamHeader
        team={team}
        countryFlag={fixtures?.[0]?.league?.flag || ""}
        foundedText={t("founded_in", { year: team.founded })}
      />

      <TeamFixturesWidget fixtures={fixtures} />

      {primaryLeague && leagueWithHref && (
        <LeagueStandingsWidget
          standings={standings[0].league.standings}
          league={leagueWithHref}
        />
      )}

      <TeamSquadWidget squad={squad} />
    </div>
  );
}

// ===== src/components/TeamDirectoryCard.tsx =====

"use client";

import Image from "next/image";
import StyledLink from "./StyledLink";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import { proxyImageUrl } from "@/lib/image-proxy";
import { MapPin, Calendar } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface TeamDirectoryCardProps {
  team: {
    id: number;
    name: string;
    logo: string;
    country: string;
    founded?: number;
  };
  venue: { name: string; city: string };
}

export const TeamDirectoryCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg flex flex-col h-full animate-pulse">
    <div className="p-4 flex items-center gap-4">
      <div className="w-12 h-12 rounded-full bg-gray-700"></div>
      <div className="flex-1 space-y-2">
        <div className="h-5 w-full rounded bg-gray-700"></div>
        <div className="h-4 w-1/2 rounded bg-gray-700"></div>
      </div>
    </div>
    <div className="mt-auto border-t border-gray-700/50 p-4 space-y-3">
      <div className="h-3 w-3/4 rounded bg-gray-700"></div>
      <div className="h-3 w-2/3 rounded bg-gray-700"></div>
    </div>
  </div>
);

export default function TeamDirectoryCard({
  team,
  venue,
}: TeamDirectoryCardProps) {
  const { t } = useTranslation();

  const href = generateTeamSlug(team.name, team.id);

  return (
    <StyledLink href={href} className="block group h-full">
      <div className="bg-brand-secondary rounded-lg flex flex-col h-full transition-all duration-300 transform hover:-translate-y-1 hover:shadow-2xl hover:shadow-[var(--brand-accent)]/20">
        <div className="p-4 flex items-center gap-4">
          <Image
            src={proxyImageUrl(team.logo)}
            alt={`${team.name} logo`}
            width={48}
            height={48}
            className="flex-shrink-0"
          />
          <div className="min-w-0 flex-1">
            <h3 className="font-bold text-lg text-white truncate group-hover:text-[var(--brand-accent)] transition-colors">
              {team.name}
            </h3>
            <p className="text-sm text-text-muted">{team.country}</p>
          </div>
        </div>

        <div className="mt-auto border-t border-gray-700/50 p-4 space-y-2">
          {team.founded && (
            <div className="flex items-center gap-2.5 text-sm text-text-secondary">
              <Calendar size={14} className="text-text-muted flex-shrink-0" />
              <span className="font-semibold">
                {t("founded_in", { year: team.founded })}
              </span>
            </div>
          )}
          {venue?.name && (
            <div className="flex items-center gap-2.5 text-sm text-text-secondary">
              <MapPin size={14} className="text-text-muted flex-shrink-0" />
              <span className="font-semibold truncate" title={venue.name}>
                {venue.name}
              </span>
            </div>
          )}
        </div>
      </div>
    </StyledLink>
  );
}

// ===== src/components/TeamListClient.tsx =====

"use client";

import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { usePathname, useRouter, useSearchParams } from "next/navigation";
import axios from "axios";
import { Search, SearchX } from "lucide-react";
import TeamDirectoryCard, {
  TeamDirectoryCardSkeleton,
} from "./TeamDirectoryCard";
import Pagination from "./Pagination";
import { useTranslation } from "@/hooks/useTranslation";
import { useDebounce } from "@/hooks/useDebounce";

const ITEMS_PER_PAGE = 21;

interface TeamData {
  team: {
    id: number;
    name: string;
    logo: string;
    country: string;
    founded?: number;
  };
  venue: { name: string; city: string };
}

interface PaginatedTeamsResponse {
  teams: TeamData[];
  pagination: {
    currentPage: number;
    totalPages: number;
    totalCount: number;
  };
}

const fetchPaginatedTeams = async (
  page: number,
  search: string
): Promise<PaginatedTeamsResponse> => {
  const params = new URLSearchParams({
    page: page.toString(),
    limit: ITEMS_PER_PAGE.toString(),
    search,
  });
  const { data } = await axios.get(`/api/teams/paginated?${params.toString()}`);
  return data;
};

interface TeamListClientProps {
  initialData: PaginatedTeamsResponse;
}

export default function TeamListClient({ initialData }: TeamListClientProps) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const { t } = useTranslation();

  const [searchTerm, setSearchTerm] = useState(searchParams.get("q") || "");
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  const currentPage = Number(searchParams.get("page")) || 1;

  const { data: teamsResponse, isLoading } = useQuery({
    queryKey: ["paginatedTeams", currentPage, debouncedSearchTerm],
    queryFn: () => fetchPaginatedTeams(currentPage, debouncedSearchTerm),
    placeholderData: (previousData) => previousData,
    initialData:
      currentPage === 1 && !debouncedSearchTerm ? initialData : undefined,
  });

  const handlePageChange = (page: number) => {
    const params = new URLSearchParams(searchParams.toString());
    params.set("page", page.toString());
    router.push(`${pathname}?${params.toString()}`, { scroll: false });
  };

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newSearchTerm = e.target.value;
    setSearchTerm(newSearchTerm);
    const params = new URLSearchParams(searchParams.toString());
    params.set("q", newSearchTerm);
    params.set("page", "1");
    router.replace(`${pathname}?${params.toString()}`, { scroll: false });
  };

  const isLoadingData = isLoading && !teamsResponse;

  return (
    <div>
      <div className="bg-brand-secondary p-4 rounded-lg mb-8">
        <div className="relative w-full">
          <Search
            className="absolute left-4 top-1/2 -translate-y-1/2 text-text-muted"
            size={20}
          />
          <input
            type="text"
            value={searchTerm}
            onChange={handleSearchChange}
            placeholder={t("search_by_team_name_placeholder")}
            className="w-full bg-[var(--color-primary)] border border-gray-700/50 rounded-lg p-3 pl-12 text-white placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-[var(--brand-accent)]"
          />
        </div>
      </div>

      <div>
        {isLoadingData ? (
          <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
            {Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
              <TeamDirectoryCardSkeleton key={i} />
            ))}
          </div>
        ) : teamsResponse && teamsResponse.teams.length > 0 ? (
          <>
            <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
              {teamsResponse.teams.map((item) => (
                <TeamDirectoryCard
                  key={item.team.id}
                  team={item.team}
                  venue={item.venue}
                />
              ))}
            </div>
            {teamsResponse.pagination.totalPages > 1 && (
              <Pagination
                currentPage={teamsResponse.pagination.currentPage}
                totalPages={teamsResponse.pagination.totalPages}
                onPageChange={handlePageChange}
              />
            )}
          </>
        ) : (
          <div className="text-center py-20 bg-brand-secondary rounded-lg">
            <SearchX size={48} className="mx-auto text-text-muted mb-4" />
            <p className="text-xl font-bold text-white">
              {t("no_teams_found_title")}
            </p>
            <p className="text-text-muted mt-2">
              {t("no_teams_found_subtitle", {
                searchTerm: debouncedSearchTerm,
              })}
            </p>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/TeamsByCountryClient.tsx =====

"use client";

import { useState, useMemo, useEffect } from "react";
import Pagination from "./Pagination";
import { Search, SearchX } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";
import TeamDirectoryCard, {
  TeamDirectoryCardSkeleton,
} from "./TeamDirectoryCard";

const ITEMS_PER_PAGE = 18;

interface TeamData {
  team: any;
  venue: any;
}

interface TeamsByCountryClientProps {
  initialTeams: TeamData[];
}

export default function TeamsByCountryClient({
  initialTeams,
}: TeamsByCountryClientProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const [currentPage, setCurrentPage] = useState(1);
  const { t } = useTranslation();

  const filteredTeams = useMemo(() => {
    if (!initialTeams) return [];
    return searchTerm.length > 2
      ? initialTeams.filter((item) =>
          item.team.name.toLowerCase().includes(searchTerm.toLowerCase())
        )
      : initialTeams;
  }, [initialTeams, searchTerm]);

  const { paginatedData, totalPages } = useMemo(() => {
    const total = Math.ceil(filteredTeams.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    return {
      paginatedData: filteredTeams.slice(startIndex, endIndex),
      totalPages: total,
    };
  }, [filteredTeams, currentPage]);

  useEffect(() => {
    setCurrentPage(1);
  }, [searchTerm]);

  return (
    <>
      <div className="relative flex-grow w-full mb-8">
        <Search
          className="absolute left-3.5 top-1/2 -translate-y-1/2 text-text-muted"
          size={20}
        />
        <input
          type="text"
          placeholder={t("search_by_team_name_placeholder")}
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-3 pl-12 text-white focus:outline-none focus:ring-2 focus:ring-brand-purple"
        />
      </div>

      {paginatedData.length > 0 ? (
        <>
          <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
            {paginatedData.map((teamData) => (
              <TeamDirectoryCard
                key={teamData.team.id}
                team={teamData.team}
                venue={teamData.venue}
              />
            ))}
          </div>
          {totalPages > 1 && (
            <Pagination
              currentPage={currentPage}
              totalPages={totalPages}
              onPageChange={setCurrentPage}
            />
          )}
        </>
      ) : (
        <div className="col-span-full text-center py-20 bg-brand-secondary rounded-lg">
          <SearchX size={32} className="mx-auto text-brand-muted mb-3" />
          <p className="text-xl font-bold text-white">
            {t("no_teams_found_title")}
          </p>
          <p className="text-brand-muted mt-2">
            {t("no_teams_found_subtitle", { searchTerm })}
          </p>
        </div>
      )}
    </>
  );
}

// ===== src/components/Ticker.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Marquee from "react-fast-marquee";
import { IoMdFootball } from "react-icons/io";
import { FaBasketballBall } from "react-icons/fa";
import { IoTennisballOutline } from "react-icons/io5";
import { ITickerMessage } from "@/models/TickerMessage";
import { useTranslation } from "@/hooks/useTranslation";
import StyledLink from "./StyledLink";

const fetchTickerMessages = async (
  locale: string
): Promise<ITickerMessage[]> => {
  const { data } = await axios.get(`/api/ticker-messages?locale=${locale}`);
  return data;
};

const SportSeparator = ({ index }: { index: number }) => {
  const icons = [IoMdFootball, FaBasketballBall, IoTennisballOutline];
  const Icon = icons[index % icons.length];
  return (
    <div className="flex items-center justify-center w-12 h-full">
      <Icon className="text-white/80" size={16} />
    </div>
  );
};

export default function Ticker() {
  const { locale } = useTranslation();

  const { data: messages, isLoading } = useQuery<ITickerMessage[]>({
    queryKey: ["tickerMessages", locale],
    queryFn: () => fetchTickerMessages(locale!),
    staleTime: 1000 * 60 * 5,
    refetchOnWindowFocus: true,
    enabled: !!locale,
  });

  if (isLoading || !messages || messages.length === 0) {
    return null;
  }

  return (
    <div className="bg-[var(--brand-accent)] text-white py-2 shadow-md">
      <Marquee gradient={false} speed={50}>
        <div className="flex items-center">
          {messages.map((item, index) => (
            <div key={item._id as string} className="flex items-center">
              {}
              {}
              {item.href ? (
                <StyledLink
                  href={item.href}
                  className="font-semibold text-sm px-6 whitespace-nowrap hover:underline"
                >
                  {item.message}
                </StyledLink>
              ) : (
                <span className="font-semibold text-sm px-6 whitespace-nowrap">
                  {item.message}
                </span>
              )}
              {}
              <SportSeparator index={index} />
            </div>
          ))}
        </div>
      </Marquee>
    </div>
  );
}

// ===== src/components/UpcomingMatchesSlider.tsx =====

"use client";

import Slider from "react-slick";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { useLeagueContext } from "@/context/LeagueContext";

import MatchSlide from "./MatchSlide";
import FinishedMatchSlide from "./FinishedMatchSlide";

const fetchLeagueMatches = async (leagueId: number) => {
  const { data } = await axios.get(`/api/upcoming-matches?league=${leagueId}`);
  return data;
};

const SliderSkeleton = () => (
    <div className="relative w-full h-64 overflow-hidden rounded-2xl bg-brand-secondary p-8 animate-pulse">
        <div className="flex h-full items-center justify-center">
            <div className="h-12 w-80 rounded bg-gray-600/50"></div>
        </div>
    </div>
);

export default function UpcomingMatchesSlider() {
  const { selectedLeague } = useLeagueContext();

  const { data: matches, isLoading } = useQuery({
    queryKey: ['leagueMatches', selectedLeague?.id],
    queryFn: () => fetchLeagueMatches(selectedLeague!.id),
    enabled: !!selectedLeague,
    staleTime: 1000 * 60 * 5,
  });

  const sliderSettings = {
    dots: true,
    infinite: true,
    speed: 500,
    slidesToShow: 1,
    slidesToScroll: 1,
    autoplay: true,
    autoplaySpeed: 7000,
    pauseOnHover: true,
    arrows: false,
    appendDots: (dots: any) => (
      <div><ul className="-bottom-5 relative">{dots}</ul></div>
    ),
  };

  if (isLoading) {
    return <SliderSkeleton />;
  }

  if (!matches || matches.length === 0) {
    return (
        <div className="flex h-64 items-center justify-center rounded-xl bg-brand-secondary text-brand-muted">
            No recent or upcoming matches found for this league.
        </div>
    );
  }

  return (
    <div className="w-full">
      <Slider {...sliderSettings}>
        {matches.map((match: any) => {

          const isFinished = match.fixture.status.short === 'FT';

          return (
            <div key={match.fixture.id} className="px-1">
              {isFinished ? (
                <FinishedMatchSlide match={match} />
              ) : (
                <MatchSlide match={match} />
              )}
            </div>
          );
        })}
      </Slider>
    </div>
  );
}

// ===== src/components/VotingPanel.tsx =====

"use client";

import { useState, memo } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'axios';
import Image from 'next/image';
import { useVoteStorage } from '@/hooks/useVoteStorage';

interface VoteData {
    homeVotes: number;
    drawVotes: number;
    awayVotes: number;
}
interface VotingPanelProps {
    fixtureId: number;
    teams: { home: any; away: any; };
}

const getVotes = async (fixtureId: number): Promise<VoteData> => {
    const { data } = await axios.get(`/api/votes?fixture=${fixtureId}`);
    return data;
};

const submitVote = async ({ fixtureId, vote }: { fixtureId: number; vote: string }): Promise<VoteData> => {
    const { data } = await axios.post('/api/votes', { fixtureId, vote });
    return data;
};

const PanelSkeleton = () => (
    <div className="animate-pulse p-4">
        <div className="h-4 w-1/2 mx-auto rounded bg-gray-600/50 mb-4"></div>
        <div className="grid grid-cols-3 gap-3">
            <div className="h-24 rounded-lg bg-gray-700/50"></div>
            <div className="h-24 rounded-lg bg-gray-700/50"></div>
            <div className="h-24 rounded-lg bg-gray-700/50"></div>
        </div>
    </div>
);

const VotingPanel = memo(function VotingPanel({ fixtureId, teams }: VotingPanelProps) {
    const queryClient = useQueryClient();
    const { setVote, getVoteForFixture } = useVoteStorage();

    const [hasVoted, setHasVoted] = useState(() => !!getVoteForFixture(fixtureId));

    const { data: voteData, isLoading } = useQuery({
        queryKey: ['votes', fixtureId],
        queryFn: () => getVotes(fixtureId),
        staleTime: 1000 * 60,
    });

    const voteMutation = useMutation({
        mutationFn: submitVote,
        onSuccess: () => {

            queryClient.invalidateQueries({ queryKey: ['votes', fixtureId] });
        },
    });

    const handleVote = (choice: 'home' | 'draw' | 'away') => {
        if (hasVoted) return;

        setVote(fixtureId, choice);
        setHasVoted(true);
        voteMutation.mutate({ fixtureId, vote: choice });
    };

    const handleBetClick = (e: React.MouseEvent) => {
        e.stopPropagation();

    };

    if (isLoading) {
        return <PanelSkeleton />;
    }

    if (!voteData) {
        return <p className="text-center text-sm text-brand-muted py-4">Could not load voting data.</p>;
    }

    const totalVotes = voteData.homeVotes + voteData.drawVotes + voteData.awayVotes;
    const homePercent = totalVotes > 0 ? Math.round((voteData.homeVotes / totalVotes) * 100) : 34;
    const awayPercent = totalVotes > 0 ? Math.round((voteData.awayVotes / totalVotes) * 100) : 33;
    const drawPercent = 100 - homePercent - awayPercent;

    return (
        <div className="bg-[#1F1D2B] p-4 border-t-2 border-gray-900/50">
            {!hasVoted ? (

                <>
                    <h4 className="text-center text-sm font-bold text-brand-muted mb-3 tracking-wider">WHO WILL WIN?</h4>
                    <div className="flex justify-center items-stretch gap-3">
                        <button onClick={() => handleVote('home')} className="flex-1 flex flex-col items-center gap-2 p-3 rounded-lg bg-gray-800/60 hover:bg-brand-purple transition-all duration-200 transform hover:-translate-y-1">
                            <Image src={teams.home.logo} alt={teams.home.name} width={48} height={48} className="object-contain h-12"/>
                            <span className="text-xs font-semibold text-white truncate">{teams.home.name}</span>
                        </button>
                        <button onClick={() => handleVote('draw')} className="flex-1 flex flex-col items-center justify-center gap-2 p-3 rounded-lg bg-gray-800/60 hover:bg-brand-purple transition-all duration-200 transform hover:-translate-y-1">
                            <span className="font-bold text-3xl text-white">=</span>
                            <span className="text-xs font-semibold text-white">DRAW</span>
                        </button>
                        <button onClick={() => handleVote('away')} className="flex-1 flex flex-col items-center gap-2 p-3 rounded-lg bg-gray-800/60 hover:bg-brand-purple transition-all duration-200 transform hover:-translate-y-1">
                            <Image src={teams.away.logo} alt={teams.away.name} width={48} height={48} className="object-contain h-12"/>
                            <span className="text-xs font-semibold text-white truncate">{teams.away.name}</span>
                        </button>
                    </div>
                </>
            ) : (

                <>
                    <h4 className="text-xs font-bold text-center text-brand-muted mb-2 tracking-widest">COMMUNITY VOTE</h4>
                    <div className="flex justify-between items-center mb-1">
                        <span className="text-sm font-bold text-white">{homePercent}%</span>
                        <span className="text-xs text-brand-muted">Draw {drawPercent}%</span>
                        <span className="text-sm font-bold text-white">{awayPercent}%</span>
                    </div>
                    <div className="flex w-full h-2 rounded-full overflow-hidden bg-gray-800 mb-4">
                        <div className="bg-brand-purple" style={{ width: `${homePercent}%` }}></div>
                        <div className="bg-gray-500" style={{ width: `${drawPercent}%` }}></div>
                        <div className="bg-blue-600" style={{ width: `${awayPercent}%` }}></div>
                    </div>
                    <div className="relative">
                        <span className="absolute top-0 left-0 inline-flex h-full w-full rounded-lg bg-orange-400 opacity-75 animate-ping"></span>
                        <button onClick={handleBetClick} className="relative w-full bg-orange-500 text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2 hover:bg-orange-600 transition-colors">
                            Bet 10 and Win 1000 
                        </button>
                    </div>
                    <p className="text-xs text-brand-muted mt-1.5 text-center">18+. Gamble responsibly. Verified Partner chinchincasino.com.</p>
                </>
            )}
        </div>
    );
});

export default VotingPanel;

// ===== src/components/ZonedDate.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useTimeZone } from "@/context/TimeZoneContext";
import { formatZonedTime } from "@/lib/date-formatter";

interface ZonedDateProps {
  date: string | Date;
  format?: string;
}

export default function ZonedDate({ date, format = "HH:mm" }: ZonedDateProps) {
  const { timeZone } = useTimeZone();
  const [isMounted, setIsMounted] = useState(false);

  useEffect(() => {
    setIsMounted(true);
  }, []);

  if (!isMounted || !timeZone) {
    const fallbackTime = new Date(date).toLocaleTimeString("en-GB", {
      hour: "2-digit",
      minute: "2-digit",
      timeZone: "UTC",
    });
    return <span className="tabular-nums">{fallbackTime}</span>;
  }

  const formattedDate = formatZonedTime(date, timeZone, format);

  return <span className="tabular-nums">{formattedDate}</span>;
}

// ===== src/components/admin/AIPromptDisplayCard.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  BrainCircuit,
  FileText,
  Type,
  Info,
  AlertTriangle,
  Edit,
  Save,
  X,
  Loader2,
} from "lucide-react";

interface IAIPrompt {
  _id: string;
  name: string;
  prompt: string;
  description?: string;
  type: "title" | "content" | "prediction_content";
}

interface AIPromptDisplayCardProps {
  promptName: string;
  promptType: "title" | "content" | "prediction_content";
}

const fetchAIPrompt = async (
  name: string,
  type: "title" | "content" | "prediction_content"
): Promise<IAIPrompt> => {
  const { data } = await axios.get(
    `/api/admin/ai-prompt?name=${encodeURIComponent(name)}&type=${type}`
  );
  return data;
};

const CardSkeleton = () => (
  <div className="bg-brand-secondary p-6 rounded-lg shadow-xl animate-pulse h-[350px]"></div>
);

export default function AIPromptDisplayCard({
  promptName,
  promptType,
}: AIPromptDisplayCardProps) {
  const queryClient = useQueryClient();
  const [isEditing, setIsEditing] = useState(false);
  const [description, setDescription] = useState("");
  const [promptContent, setPromptContent] = useState("");

  const {
    data: prompt,
    isLoading,
    isError,
    error,
  } = useQuery<IAIPrompt>({
    queryKey: ["aiPrompt", promptName, promptType],
    queryFn: () => fetchAIPrompt(promptName, promptType),
    staleTime: Infinity,
    refetchOnWindowFocus: false,
  });

  useEffect(() => {
    if (prompt) {
      setDescription(prompt.description || "");
      setPromptContent(prompt.prompt);
    }
  }, [prompt]);

  const updateMutation = useMutation({
    mutationFn: (updatedPrompt: {
      id: string;
      description?: string;
      prompt: string;
    }) => axios.put("/api/admin/ai-prompt", updatedPrompt),
    onSuccess: (updatedData) => {
      toast.success("Prompt updated successfully!");
      queryClient.setQueryData(
        ["aiPrompt", promptName, promptType],
        updatedData.data
      );
      setIsEditing(false);
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to update prompt.");
    },
  });

  const handleSave = () => {
    if (!prompt) return;
    if (promptContent.trim() === "") {
      toast.error("Prompt content cannot be empty.");
      return;
    }
    updateMutation.mutate({
      id: prompt._id,
      description,
      prompt: promptContent,
    });
  };

  const handleCancel = () => {
    if (prompt) {
      setDescription(prompt.description || "");
      setPromptContent(prompt.prompt);
    }
    setIsEditing(false);
  };

  if (isLoading) return <CardSkeleton />;

  if (isError) {
    return (
      <div className="bg-red-900/50 border border-red-500/50 p-6 rounded-lg text-red-300">
        <h3 className="font-bold text-lg text-white">{promptName}</h3>
        <p className="text-sm">Error: Prompt not found or server error.</p>
      </div>
    );
  }

  return (
    <div className="bg-brand-secondary p-6 rounded-lg shadow-xl flex flex-col h-full min-h-[350px]">
      <div className="flex justify-between items-start gap-4 mb-4">
        <div className="flex items-start gap-4">
          <div className="flex-shrink-0 bg-brand-purple/20 text-brand-purple p-3 rounded-lg">
            {promptType === "title" ? (
              <Type size={24} />
            ) : (
              <FileText size={24} />
            )}
          </div>
          <div>
            <h3 className="text-xl font-bold text-white">{prompt?.name}</h3>
            {isEditing ? (
              <input
                type="text"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder="Enter a short description..."
                className="w-full mt-1 p-1 text-sm rounded bg-gray-700 text-white border border-gray-600"
              />
            ) : (
              <p className="text-sm text-brand-muted">
                {prompt?.description || "No description."}
              </p>
            )}
          </div>
        </div>
        {!isEditing && (
          <button
            onClick={() => setIsEditing(true)}
            className="flex-shrink-0 p-2 text-brand-muted hover:text-white hover:bg-gray-700 rounded-full"
            title="Edit Prompt"
          >
            <Edit size={16} />
          </button>
        )}
      </div>

      <div className="flex-grow flex flex-col bg-brand-dark p-4 rounded-md">
        {isEditing ? (
          <textarea
            value={promptContent}
            onChange={(e) => setPromptContent(e.target.value)}
            className="w-full h-full flex-grow bg-transparent text-white font-mono text-xs focus:outline-none resize-none"
            rows={10}
          />
        ) : (
          <p className="whitespace-pre-wrap font-mono text-xs text-brand-light">
            {prompt?.prompt}
          </p>
        )}
      </div>

      {isEditing && (
        <div className="flex justify-end gap-3 mt-4">
          <button
            onClick={handleCancel}
            disabled={updateMutation.isPending}
            className="flex items-center gap-2 bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
          >
            <X size={18} /> Cancel
          </button>
          <button
            onClick={handleSave}
            disabled={updateMutation.isPending}
            className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
          >
            {updateMutation.isPending ? (
              <Loader2 size={18} className="animate-spin" />
            ) : (
              <Save size={18} />
            )}
            {updateMutation.isPending ? "Saving..." : "Save"}
          </button>
        </div>
      )}
    </div>
  );
}

// ===== src/components/admin/AdminPagination.tsx =====

"use client";

import { ChevronLeft, ChevronRight } from "lucide-react";

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
}

export default function AdminPagination({
  currentPage,
  totalPages,
  onPageChange,
}: PaginationProps) {

  if (totalPages <= 1) {
    return null;
  }

  const handlePrevious = () => {
    if (currentPage > 1) {
      onPageChange(currentPage - 1);
    }
  };

  const handleNext = () => {
    if (currentPage < totalPages) {
      onPageChange(currentPage + 1);
    }
  };

  return (
    <div className="flex items-center justify-center gap-4 mt-8">
      <button
        onClick={handlePrevious}
        disabled={currentPage === 1}
        className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-brand-secondary rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50 transition-colors"
        aria-label="Previous page"
      >
        <ChevronLeft size={16} />
        <span>Previous</span>
      </button>

      <span className="text-sm font-semibold text-brand-muted">
        {`Page ${currentPage} of ${totalPages}`}
      </span>

      <button
        onClick={handleNext}
        disabled={currentPage === totalPages}
        className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-brand-secondary rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50 transition-colors"
        aria-label="Next page"
      >
        <span>Next</span>
        <ChevronRight size={16} />
      </button>
    </div>
  );
}

// ===== src/components/admin/AdminSidebar.tsx =====

"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import {
  LayoutDashboard,
  Newspaper,
  Image as ImageIcon,
  Sparkles,
  User,
  Crown,
  FileText,
  HelpCircle,
  FileStack,
  ChevronRight,
  AlertTriangle,
  Shield,
  UserCircle,
  DatabaseZap,
  Type,
  Bot,
  Languages,
  Megaphone,
  FileJson,
  Trophy,
  Users as TeamsIcon,
  BrainCircuit,
} from "lucide-react";
import { useSession, signOut } from "next-auth/react";

const SubNavItem = ({
  href,
  name,
  icon: Icon,
  isActive,
}: {
  href: string;
  name: string;
  icon: React.ElementType;
  isActive: boolean;
}) => (
  <li>
    <Link
      href={href}
      className={`flex items-center gap-3 p-2 pl-4 rounded-md text-sm transition-colors ${
        isActive
          ? "text-white bg-brand-purple/50"
          : "text-brand-muted hover:text-white hover:bg-gray-700/50"
      }`}
    >
      <Icon size={16} />
      <span>{name}</span>
    </Link>
  </li>
);

export default function AdminSidebar() {
  const pathname = usePathname();
  const { data: session } = useSession();

  const isAiSectionActive =
    pathname.startsWith("/admin/auto-news") ||
    pathname.startsWith("/admin/ai-journalists") ||
    pathname.startsWith("/admin/title-templates") ||
    pathname.startsWith("/admin/curated-news") ||
    pathname.startsWith("/admin/predictions");

  const isPagesSectionActive =
    pathname.startsWith("/admin/faqs") || pathname.startsWith("/admin/pages");

  const isLocalizationSectionActive =
    pathname.startsWith("/admin/languages") ||
    pathname.startsWith("/admin/translations");

  const [isAiOpen, setIsAiOpen] = useState(isAiSectionActive);
  const [isPagesOpen, setIsPagesOpen] = useState(isPagesSectionActive);

  const [isLocalizationOpen, setIsLocalizationOpen] = useState(
    isLocalizationSectionActive
  );

  useEffect(() => {
    setIsAiOpen(isAiSectionActive);
  }, [isAiSectionActive]);

  useEffect(() => {
    setIsPagesOpen(isPagesSectionActive);
  }, [isPagesSectionActive]);

  useEffect(() => {
    setIsLocalizationOpen(isLocalizationSectionActive);
  }, [isLocalizationSectionActive]);

  const navItems = [
    { name: "Dashboard", href: "/admin/dashboard", icon: LayoutDashboard },
    { name: "News", href: "/admin/news", icon: Newspaper },
    { name: "Leagues", href: "/admin/leagues", icon: Trophy },
    { name: "Teams", href: "/admin/teams", icon: TeamsIcon },
    {
      name: "Ticker Messages",
      href: "/admin/ticker-messages",
      icon: Megaphone,
    },
    { name: "Casino Partners", href: "/admin/casino-partners", icon: Crown },
    { name: "File Manager", href: "/admin/file-manager", icon: FileText },
    { name: "Banners", href: "/admin/banners", icon: ImageIcon },
  ];

  const localizationSubNav = [
    { name: "Languages", href: "/admin/languages", icon: Languages },
    { name: "Translations", href: "/admin/translations", icon: FileJson },
  ];

  const aiSubNav = [
    { name: "Automation Log", href: "/admin/auto-news", icon: Sparkles },
    { name: "Curated News", href: "/admin/curated-news", icon: Bot },
    { name: "AI Journalists", href: "/admin/ai-journalists", icon: User },
    { name: "Title Templates", href: "/admin/title-templates", icon: Type },

    { name: "Predictions", href: "/admin/predictions", icon: BrainCircuit },
  ];

  const pagesSubNav = [
    { name: "FAQs", href: "/admin/faqs", icon: HelpCircle },
    {
      name: "Report Abuse",
      href: "/admin/pages/report-abuse",
      icon: AlertTriangle,
    },
    {
      name: "Privacy Policy",
      href: "/admin/pages/privacy-policy",
      icon: Shield,
    },
    {
      name: "Terms & Conditions",
      href: "/admin/pages/terms-and-conditions",
      icon: FileText,
    },
    { name: "Author Page", href: "/admin/pages/author", icon: UserCircle },
    { name: "GDPR Page", href: "/admin/pages/gdpr", icon: DatabaseZap },
  ];

  return (
    <aside className="w-72 bg-brand-secondary h-screen sticky top-0 p-4 flex flex-col justify-between">
      <div>
        <div className="text-2xl font-bold text-white mb-8 px-2">
          Admin Panel
        </div>
        <nav className="space-y-1">
          {navItems.map((item) => {
            const isActive = pathname === item.href;
            const Icon = item.icon;
            return (
              <Link
                key={item.name}
                href={item.href}
                className={`flex items-center gap-3 p-3 rounded-lg transition-colors duration-200 ${
                  isActive
                    ? "bg-brand-purple text-white"
                    : "text-brand-muted hover:bg-gray-700 hover:text-white"
                }`}
              >
                <Icon size={20} />
                <span>{item.name}</span>
              </Link>
            );
          })}

          <div>
            <button
              onClick={() => setIsLocalizationOpen(!isLocalizationOpen)}
              className={`w-full flex items-center justify-between p-3 rounded-lg transition-colors duration-200 ${
                isLocalizationSectionActive
                  ? "bg-brand-purple text-white"
                  : "text-brand-muted hover:bg-gray-700 hover:text-white"
              }`}
            >
              <div className="flex items-center gap-3">
                <Languages size={20} />
                <span>Localization</span>
              </div>
              <ChevronRight
                size={18}
                className={`transition-transform duration-300 ${
                  isLocalizationOpen ? "rotate-90" : ""
                }`}
              />
            </button>
            <div
              className={`grid transition-all duration-300 ease-in-out ${
                isLocalizationOpen
                  ? "grid-rows-[1fr] opacity-100 pt-1"
                  : "grid-rows-[0fr] opacity-0"
              }`}
            >
              <ul className="overflow-hidden space-y-1 pl-4">
                {localizationSubNav.map((item) => (
                  <SubNavItem
                    key={item.name}
                    href={item.href}
                    name={item.name}
                    icon={item.icon}
                    isActive={pathname.startsWith(item.href)}
                  />
                ))}
              </ul>
            </div>
          </div>

          <div>
            <button
              onClick={() => setIsAiOpen(!isAiOpen)}
              className={`w-full flex items-center justify-between p-3 rounded-lg transition-colors duration-200 ${
                isAiSectionActive
                  ? "bg-brand-purple text-white"
                  : "text-brand-muted hover:bg-gray-700 hover:text-white"
              }`}
            >
              <div className="flex items-center gap-3">
                <Bot size={20} />
                <span>AI Content Engine</span>
              </div>
              <ChevronRight
                size={18}
                className={`transition-transform duration-300 ${
                  isAiOpen ? "rotate-90" : ""
                }`}
              />
            </button>
            <div
              className={`grid transition-all duration-300 ease-in-out ${
                isAiOpen
                  ? "grid-rows-[1fr] opacity-100 pt-1"
                  : "grid-rows-[0fr] opacity-0"
              }`}
            >
              <ul className="overflow-hidden space-y-1 pl-4">
                {aiSubNav.map((item) => (
                  <SubNavItem
                    key={item.name}
                    href={item.href}
                    name={item.name}
                    icon={item.icon}
                    isActive={pathname.startsWith(item.href)}
                  />
                ))}
              </ul>
            </div>
          </div>

          <div>
            <button
              onClick={() => setIsPagesOpen(!isPagesOpen)}
              className={`w-full flex items-center justify-between p-3 rounded-lg transition-colors duration-200 ${
                isPagesSectionActive
                  ? "bg-brand-purple text-white"
                  : "text-brand-muted hover:bg-gray-700 hover:text-white"
              }`}
            >
              <div className="flex items-center gap-3">
                <FileStack size={20} />
                <span>Pages & FAQs</span>
              </div>
              <ChevronRight
                size={18}
                className={`transition-transform duration-300 ${
                  isPagesOpen ? "rotate-90" : ""
                }`}
              />
            </button>
            <div
              className={`grid transition-all duration-300 ease-in-out ${
                isPagesOpen
                  ? "grid-rows-[1fr] opacity-100 pt-1"
                  : "grid-rows-[0fr] opacity-0"
              }`}
            >
              <ul className="overflow-hidden space-y-1 pl-4">
                {pagesSubNav.map((item) => (
                  <SubNavItem
                    key={item.name}
                    href={item.href}
                    name={item.name}
                    icon={item.icon}
                    isActive={pathname.startsWith(item.href)}
                  />
                ))}
              </ul>
            </div>
          </div>
        </nav>
      </div>

      <div className="border-t border-gray-700 pt-4">
        {session?.user && (
          <div className="mb-4 text-brand-muted text-sm px-3">
            Logged in as{" "}
            <span className="font-semibold text-white">
              {session.user.name || session.user.email}
            </span>
          </div>
        )}
        <button
          onClick={() => signOut({ callbackUrl: "/login" })}
          className="w-full text-left flex items-center gap-3 p-3 rounded-lg text-red-400 hover:bg-gray-700 hover:text-red-300 transition-colors duration-200"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
            className="lucide lucide-log-out"
          >
            <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" />
            <polyline points="17 16 22 12 17 8" />
            <line x1="22" x2="10" y1="12" y2="12" />
          </svg>
          <span>Sign Out</span>
        </button>
      </div>
    </aside>
  );
}

// ===== src/components/admin/BannerFormModal.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import Image from "next/image";
import { IBanner } from "@/models/Banner";
import { AD_SLOTS } from "@/config/adSlots";
import { X, UploadCloud, XCircle } from "lucide-react";

interface BannerFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  banner: Partial<IBanner> | null;
}
type FormData = {
  title: string;
  imageUrl: string;
  linkUrl: string;
  isActive: boolean;
  location: string;
};

export default function BannerFormModal({
  isOpen,
  onClose,
  banner,
}: BannerFormModalProps) {

  const queryClient = useQueryClient();
  const [formData, setFormData] = useState<FormData>({
    title: "",
    imageUrl: "",
    linkUrl: "",
    isActive: true,
    location: AD_SLOTS[0]?.id || "",
  });
  const [isUploading, setIsUploading] = useState(false);
  useEffect(() => {
    if (banner) {
      setFormData({
        title: banner.title || "",
        imageUrl: banner.imageUrl || "",
        linkUrl: banner.linkUrl || "",
        isActive: banner.isActive !== undefined ? banner.isActive : true,
        location: banner.location || AD_SLOTS[0]?.id || "",
      });
    } else {
      setFormData({
        title: "",
        imageUrl: "",
        linkUrl: "",
        isActive: true,
        location: AD_SLOTS[0]?.id || "",
      });
    }
    setIsUploading(false);
  }, [banner, isOpen]);

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setIsUploading(true);
    const uploadFormData = new FormData();
    uploadFormData.append("file", file);

    uploadFormData.append("uploadType", "banner");

    try {
      const { data } = await axios.post("/api/upload", uploadFormData);
      setFormData((prev) => ({ ...prev, imageUrl: data.url }));
      toast.success("Image uploaded successfully!");
    } catch (error) {
      toast.error("Image upload failed. Please try again.");
    } finally {
      setIsUploading(false);
    }
  };

  const mutation = useMutation({
    mutationFn: (newBanner: FormData) => {
      if (banner?._id) {
        return axios.put(`/api/banners/${banner._id}`, newBanner);
      }
      return axios.post("/api/banners", newBanner);
    },
    onSuccess: () => {
      toast.success(
        `Banner ${banner?._id ? "updated" : "created"} successfully!`
      );
      queryClient.invalidateQueries({ queryKey: ["adminBanners"] });
      onClose();
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.error || "An error occurred.");
    },
  });
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (
      !formData.title ||
      !formData.imageUrl ||
      !formData.linkUrl ||
      !formData.location
    ) {
      toast.error("All fields, including an uploaded image, are required.");
      return;
    }
    mutation.mutate(formData);
  };

  if (!isOpen) return null;
  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg p-6 md:p-8 w-full max-w-2xl relative max-h-[90vh] overflow-y-auto">
        <button
          onClick={onClose}
          className="absolute top-4 right-4 text-brand-muted hover:text-white"
        >
          <X size={24} />
        </button>
        <h2 className="text-2xl font-bold text-white mb-6">
          {banner?._id ? "Edit Banner" : "Create New Banner"}
        </h2>

        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label className="block text-sm font-medium text-brand-light mb-2">
              Banner Image
            </label>
            <div className="mt-2 flex justify-center rounded-lg border border-dashed border-gray-600 px-6 py-10">
              {formData.imageUrl ? (
                <div className="relative group w-full h-48">
                  <Image
                    src={formData.imageUrl}
                    alt="Banner preview"
                    layout="fill"
                    objectFit="contain"
                  />
                  <button
                    type="button"
                    onClick={() =>
                      setFormData((prev) => ({ ...prev, imageUrl: "" }))
                    }
                    className="absolute top-2 right-2 bg-red-600 rounded-full p-1 text-white opacity-0 group-hover:opacity-100 transition-opacity"
                    title="Remove image"
                  >
                    <XCircle size={20} />
                  </button>
                </div>
              ) : (
                <div className="text-center">
                  <UploadCloud className="mx-auto h-12 w-12 text-gray-500" />
                  <div className="mt-4 flex text-sm leading-6 text-gray-400">
                    <label
                      htmlFor="banner-image-upload"
                      className="relative cursor-pointer rounded-md font-semibold text-brand-purple focus-within:outline-none focus-within:ring-2 focus-within:ring-brand-purple focus-within:ring-offset-2 focus-within:ring-offset-brand-dark hover:text-brand-purple/80"
                    >
                      <span>
                        {isUploading ? "Uploading..." : "Upload an image"}
                      </span>
                      <input
                        id="banner-image-upload"
                        name="banner-image-upload"
                        type="file"
                        className="sr-only"
                        onChange={handleImageUpload}
                        disabled={isUploading}
                        accept="image/*"
                      />
                    </label>
                    <p className="pl-1">or drag and drop</p>
                  </div>
                  <p className="text-xs leading-5 text-gray-500">
                    PNG, JPG, GIF up to 10MB. Will be converted to WebP.
                  </p>
                </div>
              )}
            </div>
          </div>

          <div>
            <label
              htmlFor="title"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Title
            </label>
            <input
              id="title"
              type="text"
              value={formData.title}
              onChange={(e) =>
                setFormData({ ...formData, title: e.target.value })
              }
              required
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
          </div>
          <div>
            <label
              htmlFor="linkUrl"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Link URL (Destination)
            </label>
            <input
              id="linkUrl"
              type="url"
              value={formData.linkUrl}
              onChange={(e) =>
                setFormData({ ...formData, linkUrl: e.target.value })
              }
              required
              placeholder="https://destination.com"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
          </div>

          <div>
            <label
              htmlFor="location"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Location
            </label>
            <select
              id="location"
              value={formData.location}
              onChange={(e) =>
                setFormData({ ...formData, location: e.target.value })
              }
              className="w-full p-2.5 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            >
              {AD_SLOTS.map((slot) => (
                <option key={slot.id} value={slot.id}>
                  {slot.name}
                </option>
              ))}
            </select>
            <p className="text-xs text-brand-muted mt-1">
              {AD_SLOTS.find((s) => s.id === formData.location)?.description}
            </p>
          </div>

          <div className="flex items-center gap-3">
            <input
              id="isActive"
              type="checkbox"
              checked={formData.isActive}
              onChange={(e) =>
                setFormData({ ...formData, isActive: e.target.checked })
              }
              className="h-4 w-4 rounded border-gray-300 text-brand-purple focus:ring-brand-purple"
            />
            <label
              htmlFor="isActive"
              className="text-sm font-medium text-brand-light"
            >
              Active (Visible on site)
            </label>
          </div>

          <div className="flex justify-end gap-4 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={mutation.isPending || isUploading}
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isUploading
                ? "Uploading..."
                : mutation.isPending
                ? "Saving..."
                : "Save Banner"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}

// ===== src/components/admin/BatchProcessModal.tsx =====

"use client";

import { useState, useEffect, useRef } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import toast from 'react-hot-toast';
import { XCircle, Loader2, CheckCircle } from 'lucide-react';

interface BatchProcessModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function BatchProcessModal({ isOpen, onClose }: BatchProcessModalProps) {
  const queryClient = useQueryClient();
  const [logs, setLogs] = useState<string[]>([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [isComplete, setIsComplete] = useState(false);
  const logContainerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (logContainerRef.current) {
      logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
    }
  }, [logs]);

  const processAllArticles = async () => {
    setIsProcessing(true);
    setIsComplete(false);
    setLogs([]);

    const response = await fetch("/api/cron/process-all-news", { method: "POST" });

    if (!response.body) {
      toast.error("Streaming not supported or response body is missing.");
      setIsProcessing(false);
      setIsComplete(true);
      return;
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();

    while (true) {
      const { value, done } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value);
      const lines = chunk.split("\n\n");

      lines.forEach((line) => {
        if (line.startsWith("data:")) {
          try {
            const json = JSON.parse(line.substring(5));
            if (json.event === "LOG") {
              setLogs(prev => [...prev, json.data]);
            }
            if (json.event === "COMPLETE") {
              toast.success(json.data || "Batch process complete!");
            }
          } catch (e) {

          }
        }
      });
    }
  };

  useEffect(() => {
    if (isOpen) {
      processAllArticles().finally(() => {
        setIsProcessing(false);
        setIsComplete(true);
        queryClient.invalidateQueries({ queryKey: ["externalNews"] });
        queryClient.invalidateQueries({ queryKey: ["adminCuratedPosts"] });
      });
    }
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl overflow-hidden">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white flex items-center gap-2">
            {isProcessing && <Loader2 className="animate-spin" />}
            {isComplete && <CheckCircle className="text-green-400" />}
            Batch Processing Log
          </h2>
          <button onClick={onClose} className="text-brand-muted hover:text-white" disabled={isProcessing}>
            <XCircle size={24} />
          </button>
        </div>

        <div className="p-6">
          <div
            ref={logContainerRef}
            className="bg-brand-dark p-4 rounded-lg h-96 overflow-y-auto font-mono text-sm text-brand-light space-y-2 custom-scrollbar"
          >
            {logs.map((log, index) => (
              <div key={index} className="flex items-start gap-2">
                <span className="text-brand-muted">{">"}</span>
                <span
                  className={
                    log.startsWith("") ? "text-green-400" :
                    log.startsWith("") ? "text-red-400" : ""
                  }
                >
                  {log}
                </span>
              </div>
            ))}
            {isProcessing && <div className="text-yellow-400 animate-pulse">Processing... this may take several minutes. Please keep this window open.</div>}
            {isComplete && <div className="text-green-400 font-bold"> All tasks complete. You can now close this window.</div>}
          </div>
        </div>

        <div className="p-6 border-t border-gray-700 flex justify-end">
            <button
                onClick={onClose}
                className="bg-brand-purple text-white font-bold py-2 px-6 rounded-lg hover:opacity-90 disabled:opacity-50"
                disabled={isProcessing}
            >
                Close
            </button>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/admin/CreatableSelect.tsx =====

"use client";

import { useState, useEffect, useRef } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";

const fetchCategories = async (): Promise<string[]> => {
  const { data } = await axios.get("/api/admin/faqs/categories");
  return data;
};

interface CreatableSelectProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
}

export default function CreatableSelect({
  value,
  onChange,
  placeholder,
}: CreatableSelectProps) {
  const [inputValue, setInputValue] = useState(value);
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const wrapperRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  const { data: categories } = useQuery<string[]>({
    queryKey: ["faqCategories"],
    queryFn: fetchCategories,
  });

  useEffect(() => {
    setInputValue(value);
  }, [value]);

  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (
        wrapperRef.current &&
        !wrapperRef.current.contains(event.target as Node)
      ) {
        setIsDropdownOpen(false);
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [wrapperRef]);

  const filteredCategories =
    categories?.filter((category) =>
      category.toLowerCase().includes(inputValue.toLowerCase())
    ) || [];

  const handleSelect = (selectedValue: string) => {
    setInputValue(selectedValue);
    onChange(selectedValue);
    setIsDropdownOpen(false);
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setInputValue(e.target.value);
    onChange(e.target.value);
    if (!isDropdownOpen) {
      setIsDropdownOpen(true);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      e.preventDefault();
      setIsDropdownOpen(false);
      inputRef.current?.blur();
    }
  };

  return (
    <div className="relative" ref={wrapperRef}>
      <input
        ref={inputRef}
        type="text"
        value={inputValue}
        onChange={handleInputChange}
        onFocus={() => setIsDropdownOpen(true)}
        onKeyDown={handleKeyDown}
        placeholder={placeholder}
        className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
      />

      {isDropdownOpen && (
        <div className="absolute top-full mt-1 w-full bg-brand-dark border border-gray-600 rounded-lg shadow-lg z-10 max-h-60 overflow-y-auto">
          {filteredCategories.length > 0 ? (
            filteredCategories.map((category) => (
              <div
                key={category}
                onClick={() => handleSelect(category)}
                className="p-3 text-white hover:bg-brand-purple cursor-pointer"
              >
                {category}
              </div>
            ))
          ) : (
            <div className="p-3 text-brand-muted">
              {inputValue
                ? `Create new category: "${inputValue}"`
                : "No categories found."}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

// ===== src/components/admin/RichTextEditor.tsx =====

"use client";

import { useEditor, EditorContent, Editor } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import Link from "@tiptap/extension-link";
import Placeholder from "@tiptap/extension-placeholder";
import Underline from "@tiptap/extension-underline";
import Highlight from "@tiptap/extension-highlight";
import Typography from "@tiptap/extension-typography";
import CharacterCount from "@tiptap/extension-character-count";
import Image from "@tiptap/extension-image";
import axios from "axios";
import toast from "react-hot-toast";

import {
  Bold,
  Italic,
  Strikethrough,
  Code,
  List,
  ListOrdered,
  Heading2,
  Heading3,
  Quote,
  Minus,
  Link as LinkIcon,
  Image as ImageIcon,
} from "lucide-react";
import { useEffect } from "react";

interface RichTextEditorProps {
  value: string;
  onChange: (value: string) => void;
}

const uploadPastedImage = async (file: File, editor: Editor) => {
  const loadingToast = toast.loading("Uploading pasted image...");

  try {
    const formData = new FormData();
    formData.append("file", file);

    const { data } = await axios.post("/api/upload", formData);

    if (data.url) {
      editor.chain().focus().setImage({ src: data.url }).run();
      toast.success("Image uploaded successfully!", { id: loadingToast });
    } else {
      throw new Error("Upload failed: No URL returned from API.");
    }
  } catch (error) {

    toast.error("Failed to upload image.", { id: loadingToast });
  }
};

const RichTextEditor: React.FC<RichTextEditorProps> = ({ value, onChange }) => {
  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        heading: {
          levels: [2, 3],
        },
      }),
      Link.configure({ openOnClick: false, autolink: true }),
      Placeholder.configure({
        placeholder: "Write your news article content here...",
      }),
      Underline,
      Highlight.configure({ multicolor: true }),
      Typography,
      CharacterCount.configure({ limit: 100000 }),
      Image.configure({ inline: true, allowBase64: true }),
    ],
    content: value,
    onUpdate: ({ editor }) => {
      onChange(editor.getHTML());
    },
    editorProps: {
      attributes: {

        class:
          "prose prose-invert lg:prose-xl focus:outline-none max-w-none min-h-[400px] border-x border-b border-gray-600 rounded-b-md p-4 bg-gray-800",
      },
      handlePaste: (view, event, slice) => {
        const files = event.clipboardData?.files;
        if (!files || files.length === 0) return false;
        const imageFiles = Array.from(files).filter((file) =>
          file.type.startsWith("image/")
        );
        if (imageFiles.length === 0) return false;
        event.preventDefault();
        imageFiles.forEach((file) => {
          if (view.state.editor) {
            uploadPastedImage(file, view.state.editor);
          }
        });
        return true;
      },
    },
  });

  useEffect(() => {
    if (editor && value !== editor.getHTML()) {
      editor.commands.setContent(value, false);
    }
  }, [value, editor]);

  if (!editor) {
    return null;
  }

  return (

    <div>
      {}
      {}
      {}
      <div className="sticky top-8 z-20 flex flex-wrap items-center gap-1 p-2 border-t border-x border-gray-600 bg-brand-secondary rounded-t-md">
        <button
          onClick={() => editor.chain().focus().toggleBold().run()}
          disabled={!editor.can().chain().focus().toggleBold().run()}
          className={`p-2 rounded ${
            editor.isActive("bold")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Bold size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleItalic().run()}
          disabled={!editor.can().chain().focus().toggleItalic().run()}
          className={`p-2 rounded ${
            editor.isActive("italic")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Italic size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleStrike().run()}
          disabled={!editor.can().chain().focus().toggleStrike().run()}
          className={`p-2 rounded ${
            editor.isActive("strike")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Strikethrough size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleCode().run()}
          disabled={!editor.can().chain().focus().toggleCode().run()}
          className={`p-2 rounded ${
            editor.isActive("code")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Code size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleBulletList().run()}
          disabled={!editor.can().chain().focus().toggleBulletList().run()}
          className={`p-2 rounded ${
            editor.isActive("bulletList")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <List size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleOrderedList().run()}
          disabled={!editor.can().chain().focus().toggleOrderedList().run()}
          className={`p-2 rounded ${
            editor.isActive("orderedList")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <ListOrdered size={18} />
        </button>
        <button
          onClick={() =>
            editor.chain().focus().toggleHeading({ level: 2 }).run()
          }
          className={`p-2 rounded ${
            editor.isActive("heading", { level: 2 })
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Heading2 size={18} />
        </button>
        <button
          onClick={() =>
            editor.chain().focus().toggleHeading({ level: 3 }).run()
          }
          className={`p-2 rounded ${
            editor.isActive("heading", { level: 3 })
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Heading3 size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleBlockquote().run()}
          className={`p-2 rounded ${
            editor.isActive("blockquote")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Quote size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().setHorizontalRule().run()}
          className={`p-2 rounded text-brand-muted hover:bg-gray-600`}
        >
          <Minus size={18} />
        </button>
        <button
          onClick={() => {
            const url = window.prompt("URL");
            if (url) {
              editor.chain().focus().setLink({ href: url }).run();
            }
          }}
          className={`p-2 rounded ${
            editor.isActive("link")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <LinkIcon size={18} />
        </button>
        <button
          onClick={() => {
            const url = window.prompt("Image URL");
            if (url) {
              editor.chain().focus().setImage({ src: url }).run();
            }
          }}
          className={`p-2 rounded text-brand-muted hover:bg-gray-600`}
        >
          <ImageIcon size={18} />
        </button>
      </div>
      <EditorContent editor={editor} />
    </div>
  );
};

export default RichTextEditor;

// ===== src/components/admin/TickerFormModal.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { CheckCircle, XCircle, Loader2 } from "lucide-react";
import { ITickerMessage } from "@/models/TickerMessage";
import { ILanguage } from "@/models/Language";
import mongoose from "mongoose";

const fetchActiveLanguages = async (): Promise<ILanguage[]> => {
  const { data } = await axios.get("/api/admin/languages?active=true");
  return data;
};

interface TickerFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  message?: ITickerMessage | null;
}

export const TickerFormModal: React.FC<TickerFormModalProps> = ({
  isOpen,
  onClose,
  message,
}) => {
  const queryClient = useQueryClient();
  const [content, setContent] = useState("");
  const [order, setOrder] = useState(0);
  const [isActive, setIsActive] = useState(true);
  const [language, setLanguage] = useState("");

  const { data: languages, isLoading: isLoadingLanguages } = useQuery<ILanguage[]>({
    queryKey: ["activeLanguages"],
    queryFn: fetchActiveLanguages,
  });

  useEffect(() => {
    if (isOpen) {
      if (message) {
        setContent(message.message);
        setOrder(message.order);
        setIsActive(message.isActive);
        setLanguage(message.language);
      } else {
        setContent("");
        setOrder(0);
        setIsActive(true);
        if (languages && languages.length > 0) {
          const defaultLang = languages.find((l) => l.isDefault)?.code || languages[0].code;
          setLanguage(defaultLang);
        } else {
          setLanguage("");
        }
      }
    }
  }, [message, languages, isOpen]);

  const mutation = useMutation({
    mutationFn: (payload: Partial<ITickerMessage>) => {
      if (message?._id) {
        return axios.put("/api/admin/ticker-messages", { _id: message._id, ...payload });
      }

      const payloadWithGroupId = {
        ...payload,
        translationGroupId: new mongoose.Types.ObjectId(),
      };
      return axios.post("/api/admin/ticker-messages", payloadWithGroupId);
    },
    onSuccess: () => {
      toast.success(`Message ${message ? "updated" : "created"} successfully!`);
      queryClient.invalidateQueries({ queryKey: ["tickerMessagesAdmin"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "An error occurred.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!content.trim() || !language) {
      toast.error("Message content and language are required.");
      return;
    }
    mutation.mutate({ message: content, order: Number(order), isActive, language });
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-lg">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {message ? "Edit Ticker Message" : "Create New Ticker Message"}
          </h2>
          <button onClick={onClose} className="text-brand-muted hover:text-white">
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">Language</label>
            <select
              value={language}
              onChange={(e) => setLanguage(e.target.value)}
              disabled={!!message || isLoadingLanguages}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 disabled:opacity-50"
              required
            >
              <option value="" disabled>
                {isLoadingLanguages ? "Loading..." : "Select Language"}
              </option>
              {languages?.map((lang) => (
                <option key={lang.code} value={lang.code}>{lang.name}</option>
              ))}
            </select>
          </div>
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">Message Content</label>
            <input
              type="text"
              value={content}
              onChange={(e) => setContent(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600"
              required
            />
          </div>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-brand-light mb-1">Order</label>
              <input
                type="number"
                value={order}
                onChange={(e) => setOrder(Number(e.target.value))}
                className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600"
              />
              <p className="text-xs text-brand-muted mt-1">Lower number displays first.</p>
            </div>
            <div className="flex items-center pt-6">
              <input
                type="checkbox"
                checked={isActive}
                onChange={(e) => setIsActive(e.target.checked)}
                className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded"
              />
              <label className="ml-2 text-sm font-medium text-brand-light">Active</label>
            </div>
          </div>
          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
              disabled={mutation.isPending}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg disabled:opacity-50 flex items-center gap-2"
              disabled={mutation.isPending}
            >
              {mutation.isPending ? <Loader2 size={18} className="animate-spin" /> : <CheckCircle size={18} />}
              {mutation.isPending ? "Saving..." : "Save Message"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

// ===== src/components/admin/TickerTranslationGroupRow.tsx =====

"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { ITickerMessage } from "@/models/TickerMessage";
import { ILanguage } from "@/models/Language";
import { Trash2, Languages, Loader2, Edit, XCircle } from "lucide-react";
import { Popover, Transition, Portal } from "@headlessui/react";
import { Fragment } from "react";
import Image from "next/image";

interface TickerTranslationGroupRowProps {
  group: ITickerMessage[];
  allActiveLanguages: ILanguage[];
  onDelete: (messageId: string) => void;
  onEdit: (message: ITickerMessage) => void;
}

export default function TickerTranslationGroupRow({
  group,
  allActiveLanguages,
  onDelete,
  onEdit,
}: TickerTranslationGroupRowProps) {
  const queryClient = useQueryClient();
  const masterMessage = group[0];

  const existingTranslationsMap = new Map(group.map((p) => [p.language, p]));
  const translatedCount = existingTranslationsMap.size;
  const totalCount = allActiveLanguages.length;

  const translateMutation = useMutation({
    mutationFn: (sourceMessageId: string) =>
      axios.post("/api/admin/ticker-messages/translate", { sourceMessageId }),
    onSuccess: (data) => {
      toast.success(data.data.message || "Translations generated!");
      queryClient.invalidateQueries({ queryKey: ["tickerMessagesAdmin"] });
    },
    onError: (err: any) => {
      toast.error(
        err.response?.data?.error || "Failed to generate translations."
      );
    },
  });

  const handleTranslateAll = () => {
    translateMutation.mutate(masterMessage._id);
  };

  const handleDeleteAll = () => {
    if (
      window.confirm(
        `Are you sure you want to delete this message and all of its translations? This action cannot be undone.`
      )
    ) {
      group.forEach((msg) => onDelete(msg._id));
    }
  };

  return (
    <tr className="border-t-2 border-gray-800 bg-brand-secondary hover:bg-gray-800/50 transition-colors">
      <td className="p-4 w-20 text-center font-bold align-top">
        {masterMessage.order}
      </td>
      <td className="p-4 align-top">
        <div className="flex items-start gap-3">
          <div>
            <p className="font-bold text-white text-base">{masterMessage.message}</p>
            <p className="text-xs text-brand-muted mt-1">
              Default ({masterMessage.language.toUpperCase()})
            </p>
          </div>
          <button onClick={() => onEdit(masterMessage)} className="text-brand-muted hover:text-white transition-colors flex-shrink-0">
            <Edit size={14} />
          </button>
        </div>
      </td>
      <td className="p-4 align-top">
        {}
        {}
        {}
        <Popover className="relative">
          {({ open, close }) => (
            <>
              <Popover.Button className="flex items-center gap-2 rounded-md bg-gray-700/80 px-3 py-1.5 text-xs font-semibold text-brand-light hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-brand-purple">
                <Languages size={14} />
                <span>
                  {translatedCount} / {totalCount} Languages
                </span>
              </Popover.Button>
              <Portal>
                <Transition
                  as={Fragment}
                  enter="transition ease-out duration-200"
                  enterFrom="opacity-0 translate-y-1"
                  enterTo="opacity-100 translate-y-0"
                  leave="transition ease-in duration-150"
                  leaveFrom="opacity-100 translate-y-0"
                  leaveTo="opacity-0 translate-y-1"
                >
                  {}
                  <Popover.Panel className="absolute z-30 mt-2 w-72 origin-top-left rounded-md bg-brand-dark shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none border border-gray-700">
                    <div className="p-2">
                      <div className="p-2 font-bold text-white">Translations Status</div>
                      <div className="max-h-60 overflow-y-auto custom-scrollbar space-y-1">
                        {allActiveLanguages.map((lang) => {
                          const translation = existingTranslationsMap.get(lang.code);
                          const isAvailable = !!translation;
                          return (
                            <div key={lang.code} className="flex items-center justify-between p-2 rounded-md hover:bg-brand-secondary">
                              <div className="flex items-center gap-2">
                                {lang.flagUrl && (
                                  <Image src={lang.flagUrl} alt={lang.name} width={20} height={15} className="rounded-sm" />
                                )}
                                <span className="text-sm font-medium text-brand-light">{lang.name}</span>
                              </div>
                              {isAvailable ? (
                                <button
                                  onClick={() => { onEdit(translation); close(); }}
                                  className="flex items-center gap-1.5 text-xs text-blue-400 hover:text-blue-300"
                                  title={`Edit ${lang.name} translation`}
                                >
                                  <Edit size={12} /> Edit
                                </button>
                              ) : (
                                <span className="flex items-center gap-1.5 text-xs text-brand-muted">
                                  <XCircle size={12} /> Missing
                                </span>
                              )}
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  </Popover.Panel>
                </Transition>
              </Portal>
            </>
          )}
        </Popover>
        {}
      </td>
      <td className="p-4 align-middle text-sm text-center">
        <span
          className={`px-2 py-1 text-xs font-semibold rounded-full whitespace-nowrap ${
            masterMessage.isActive
              ? "bg-green-500/20 text-green-400"
              : "bg-yellow-500/20 text-yellow-400"
          }`}
        >
          {masterMessage.isActive ? "Active" : "Inactive"}
        </span>
      </td>
      <td className="p-4 align-middle text-center space-y-2">
        <button
          onClick={handleTranslateAll}
          disabled={translateMutation.isPending || translatedCount === totalCount}
          className="w-full flex items-center justify-center gap-2 text-sm bg-indigo-500/20 text-indigo-300 hover:bg-indigo-500/30 font-semibold px-3 py-1.5 rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {translateMutation.isPending ? (
            <Loader2 size={16} className="animate-spin" />
          ) : (
            <Languages size={16} />
          )}
          <span>Translate All</span>
        </button>
        <button
          onClick={handleDeleteAll}
          className="text-gray-500 hover:text-red-400 transition-colors p-1"
          title="Delete entire translation group"
        >
          <Trash2 size={18} />
        </button>
      </td>
    </tr>
  );
}

// ===== src/components/admin/TranslationGroupRow.tsx =====

"use client";

import Link from "next/link";
import Image from "next/image";
import { format } from "date-fns";
import { IPost } from "@/models/Post";
import { ILanguage } from "@/models/Language";
import { Edit, Plus, Trash2 } from "lucide-react";

interface TranslationGroupRowProps {
  group: IPost[];
  languageMap: Map<string, ILanguage>;
  onDelete: (postId: string, title: string) => void;
}

export default function TranslationGroupRow({
  group,
  languageMap,
  onDelete,
}: TranslationGroupRowProps) {
  const sortedGroup = [...group].sort(
    (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
  );
  const masterPost = sortedGroup[0];
  const existingTranslationsMap = new Map(
    sortedGroup.map((p) => [p.language, p])
  );

  const allActiveLanguages = Array.from(languageMap.values())
    .filter((lang) => lang.isActive)
    .sort((a, b) => a.name.localeCompare(b.name));

  const handleDeleteAll = () => {
    if (
      window.confirm(
        `Are you sure you want to delete the post "${
          masterPost.title
        }" AND all of its ${
          group.length - 1
        } translations? This action cannot be undone.`
      )
    ) {
      group.forEach((post) => {
        onDelete(post._id as string, post.title);
      });
    }
  };

  return (
    <tr className="border-t-2 border-gray-800 bg-brand-secondary hover:bg-gray-800/50 transition-colors">
      <td className="p-4 w-[140px] align-top">
        {masterPost.featuredImage ? (
          <Image
            src={masterPost.featuredImage}
            alt={masterPost.title}
            width={120}
            height={67}
            objectFit="cover"
            className="rounded-md bg-gray-700"
          />
        ) : (
          <div className="w-[120px] h-[67px] bg-gray-700 rounded-md flex items-center justify-center text-xs text-brand-muted">
            No Image
          </div>
        )}
      </td>
      <td className="p-4 align-top" colSpan={2}>
        <div className="flex flex-col gap-3">
          <Link href={`/admin/news/edit/${masterPost._id}`}>
            <h3 className="font-bold text-white text-base hover:text-brand-purple transition-colors">
              {masterPost.title}
            </h3>
          </Link>
          <div className="flex flex-wrap gap-2">
            {allActiveLanguages.map((lang) => {
              const translation = existingTranslationsMap.get(lang.code);
              const isAvailable = !!translation;

              const linkHref = isAvailable
                ? `/admin/news/edit/${translation._id}`
                : {
                    pathname: "/admin/news/create",

                    query: {
                      from: masterPost.translationGroupId.toString(),
                      lang: lang.code,
                      title: `[${lang.code.toUpperCase()}] ${masterPost.title}`,

                      image: masterPost.featuredImage || "",
                      categories: masterPost.sportsCategory.join(","),
                    },
                  };

              const linkTitle = isAvailable
                ? `Edit ${lang.name} translation`
                : `Add ${lang.name} translation`;

              return (
                <div key={lang.code} className="relative group/item">
                  <Link
                    href={linkHref}
                    title={linkTitle}
                    className={`flex-shrink-0 flex items-center gap-1.5 px-2 py-1 rounded-full text-xs font-semibold border transition-all duration-200 hover:-translate-y-0.5 hover:shadow-md ${
                      isAvailable
                        ? "bg-blue-500/10 text-blue-300 border-blue-500/30 hover:bg-blue-500/20"
                        : "bg-gray-700/50 text-gray-400 border-gray-600/50 hover:bg-gray-700"
                    }`}
                  >
                    {lang.flagUrl && (
                      <Image
                        src={lang.flagUrl}
                        alt={lang.name}
                        width={16}
                        height={12}
                        className="rounded-sm"
                      />
                    )}
                    <span className="hidden sm:inline">{lang.name}</span>
                    <span className="sm:hidden">{lang.code.toUpperCase()}</span>
                    {isAvailable ? <Edit size={12} /> : <Plus size={12} />}
                  </Link>
                  {isAvailable && (
                    <button
                      onClick={() =>
                        onDelete(translation._id as string, translation.title)
                      }
                      className="absolute -top-2 -right-2 z-10 p-0.5 bg-red-600 text-white rounded-full opacity-0 group-hover/item:opacity-100 transition-opacity hover:bg-red-500"
                      title={`Delete ${lang.name} translation`}
                    >
                      <Trash2 size={12} />
                    </button>
                  )}
                </div>
              );
            })}
          </div>
        </div>
      </td>
      <td className="p-4 align-middle text-sm text-center">
        <div>
          <span
            className={`px-2 py-1 text-xs font-semibold rounded-full whitespace-nowrap ${
              masterPost.status === "published"
                ? "bg-green-500/20 text-green-400"
                : "bg-yellow-500/20 text-yellow-400"
            }`}
          >
            {masterPost.status}
          </span>
          <p className="text-brand-muted text-xs mt-2">
            {format(new Date(masterPost.createdAt), "dd MMM yyyy")}
          </p>
        </div>
      </td>
      <td className="p-4 align-middle text-center">
        <button
          onClick={handleDeleteAll}
          className="text-gray-500 hover:text-red-400 transition-colors"
          title="Delete entire translation group"
        >
          <Trash2 size={18} />
        </button>
      </td>
    </tr>
  );
}

// ===== src/components/admin/TranslationStatusPopover.tsx =====

"use client";

import { Popover, Transition } from "@headlessui/react";
import { Fragment } from "react";
import Image from "next/image";
import { ILanguage } from "@/models/Language";
import { ITickerMessage } from "@/models/TickerMessage";
import { Languages, Edit, Plus, CheckCircle, XCircle } from "lucide-react";

interface TranslationStatusPopoverProps {
  group: ITickerMessage[];
  allActiveLanguages: ILanguage[];
  onEdit: (message: ITickerMessage) => void;
}

export default function TranslationStatusPopover({
  group,
  allActiveLanguages,
  onEdit,
}: TranslationStatusPopoverProps) {
  const existingTranslationsMap = new Map(group.map((p) => [p.language, p]));
  const translatedCount = existingTranslationsMap.size;
  const totalCount = allActiveLanguages.length;

  return (
    <Popover className="relative">
      <Popover.Button className="flex items-center gap-2 rounded-md bg-gray-700/80 px-3 py-1.5 text-xs font-semibold text-brand-light hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-brand-purple">
        <Languages size={14} />
        <span>
          {translatedCount} / {totalCount} Languages
        </span>
      </Popover.Button>
      <Transition
        as={Fragment}
        enter="transition ease-out duration-200"
        enterFrom="opacity-0 translate-y-1"
        enterTo="opacity-100 translate-y-0"
        leave="transition ease-in duration-150"
        leaveFrom="opacity-100 translate-y-0"
        leaveTo="opacity-0 translate-y-1"
      >
        <Popover.Panel className="absolute right-0 z-10 mt-2 w-72 origin-top-right rounded-md bg-brand-dark shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none border border-gray-700">
          <div className="p-2">
            <div className="p-2 font-bold text-white">Translations Status</div>
            <div className="max-h-60 overflow-y-auto custom-scrollbar space-y-1">
              {allActiveLanguages.map((lang) => {
                const translation = existingTranslationsMap.get(lang.code);
                const isAvailable = !!translation;
                return (
                  <div
                    key={lang.code}
                    className="flex items-center justify-between p-2 rounded-md hover:bg-brand-secondary"
                  >
                    <div className="flex items-center gap-2">
                      {lang.flagUrl && (
                        <Image
                          src={lang.flagUrl}
                          alt={lang.name}
                          width={20}
                          height={15}
                          className="rounded-sm"
                        />
                      )}
                      <span className="text-sm font-medium text-brand-light">
                        {lang.name}
                      </span>
                    </div>
                    {isAvailable ? (
                       <button
                        onClick={() => onEdit(translation)}
                        className="flex items-center gap-1.5 text-xs text-blue-400 hover:text-blue-300"
                        title={`Edit ${lang.name} translation`}
                      >
                        <Edit size={12} /> Edit
                      </button>
                    ) : (
                      <span className="flex items-center gap-1.5 text-xs text-brand-muted">
                        <XCircle size={12} /> Missing
                      </span>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        </Popover.Panel>
      </Transition>
    </Popover>
  );
}

// ===== src/components/admin/TranslationsWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Link from "next/link";
import Image from "next/image";
import { Plus, Edit, Languages, Loader2 } from "lucide-react";
import { ILanguage } from "@/models/Language";
import { IPost } from "@/models/Post";

interface TranslationsWidgetProps {
  translationGroupId: string;
  currentPostLanguage: string;
  currentPostTitle: string;
}

interface TranslationPost {
  _id: string;
  title: string;
  language: string;
}

const fetchLanguages = async (): Promise<ILanguage[]> => {
  const { data } = await axios.get("/api/admin/languages");
  return data;
};

const fetchTranslations = async (
  groupId: string
): Promise<TranslationPost[]> => {
  if (!groupId) return [];
  const { data } = await axios.get(`/api/admin/posts/translations/${groupId}`);
  return data;
};

export default function TranslationsWidget({
  translationGroupId,
  currentPostLanguage,
  currentPostTitle,
}: TranslationsWidgetProps) {
  const { data: languages, isLoading: isLoadingLanguages } = useQuery<
    ILanguage[]
  >({
    queryKey: ["allLanguages"],
    queryFn: fetchLanguages,
  });

  const { data: translations, isLoading: isLoadingTranslations } = useQuery<
    TranslationPost[]
  >({
    queryKey: ["translations", translationGroupId],
    queryFn: () => fetchTranslations(translationGroupId),
    enabled: !!translationGroupId,
  });

  const languageMap = new Map(languages?.map((lang) => [lang.code, lang]));
  const existingTranslationsMap = new Map(
    translations?.map((t) => [t.language, t])
  );

  const isLoading = isLoadingLanguages || isLoadingTranslations;

  return (
    <div className="bg-gray-800 p-4 border border-gray-600 rounded-lg space-y-4">
      <h3 className="text-lg font-semibold text-white flex items-center gap-2">
        <Languages size={20} /> Translations
      </h3>
      {isLoading ? (
        <div className="flex items-center justify-center py-4">
          <Loader2 className="animate-spin text-brand-muted" />
        </div>
      ) : (
        <div className="space-y-3">
          {languages
            ?.filter((l) => l.isActive)
            .map((lang) => {
              const translation = existingTranslationsMap.get(lang.code);
              const isCurrent = lang.code === currentPostLanguage;

              return (
                <div
                  key={lang.code}
                  className="flex items-center justify-between p-3 bg-brand-secondary rounded-md"
                >
                  <div className="flex items-center gap-3">
                    {lang.flagUrl && (
                      <Image
                        src={lang.flagUrl}
                        alt={lang.name}
                        width={24}
                        height={18}
                      />
                    )}
                    <span className="font-semibold text-brand-light">
                      {lang.name}
                    </span>
                    {isCurrent && (
                      <span className="text-xs bg-brand-purple text-white px-2 py-0.5 rounded-full">
                        Current
                      </span>
                    )}
                  </div>

                  {translation ? (
                    <Link
                      href={`/admin/news/edit/${translation._id}`}
                      className="flex items-center gap-1.5 text-sm text-blue-400 hover:text-blue-300"
                    >
                      <Edit size={14} /> Edit
                    </Link>
                  ) : (
                    <Link
                      href={{
                        pathname: "/admin/news/create",
                        query: {
                          from: translationGroupId,
                          lang: lang.code,
                          title: `Translation of: ${currentPostTitle}`,
                        },
                      }}
                      className="flex items-center gap-1.5 text-sm text-green-400 hover:text-green-300"
                    >
                      <Plus size={14} /> Add Translation
                    </Link>
                  )}
                </div>
              );
            })}
        </div>
      )}
    </div>
  );
}

// ===== src/components/admin/translations/AddTranslationModal.tsx =====

"use client";

import { useState } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { ILanguage } from "@/models/Language";
import { XCircle, Save, Sparkles, Loader2, Info } from "lucide-react";

interface AddTranslationModalProps {
  isOpen: boolean;
  onClose: () => void;
  languages: ILanguage[];
  existingKeys: string[];
}

export default function AddTranslationModal({
  isOpen,
  onClose,
  languages,
  existingKeys,
}: AddTranslationModalProps) {
  const queryClient = useQueryClient();
  const [key, setKey] = useState("");
  const [group, setGroup] = useState("general");
  const [description, setDescription] = useState("");
  const [translations, setTranslations] = useState<{ [key: string]: string }>({
    en: "",
  });
  const [keyError, setKeyError] = useState("");

  const handleKeyChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newKey = e.target.value;
    setKey(newKey);
    if (existingKeys.includes(newKey)) {
      setKeyError("This key already exists. Please choose a unique one.");
    } else if (!/^[a-z0-9_]+$/.test(newKey) && newKey.length > 0) {
      setKeyError(
        "Key can only contain lowercase letters, numbers, and underscores."
      );
    } else {
      setKeyError("");
    }
  };

  const createMutation = useMutation({
    mutationFn: (newTranslationData: any) =>
      axios.post("/api/admin/translations/manage", newTranslationData),
    onSuccess: () => {
      toast.success("New translation key created successfully!");
      queryClient.invalidateQueries({ queryKey: ["allTranslations"] });
      onClose();
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "Creation failed."),
  });

  const aiTranslateMutation = useMutation({
    mutationFn: (payload: { text: string; targetLangCodes: string[] }) =>
      axios.post("/api/admin/translations/ai-translate", payload),
    onSuccess: (data) => {
      setTranslations((prev) => ({ ...prev, ...data.data }));
      toast.success("AI translation complete!");
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "AI translation failed."),
  });

  const handleAiTranslate = () => {
    if (!translations["en"]) {
      toast.error(
        "Please provide the English text first to use as a source for translation."
      );
      return;
    }
    const targetLangs = languages
      .filter((l) => l.code !== "en")
      .map((l) => l.code);
    aiTranslateMutation.mutate({
      text: translations["en"],
      targetLangCodes: targetLangs,
    });
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (keyError || !key.trim() || !translations["en"].trim()) {
      toast.error(
        "Please fix errors before submitting. Key and English translation are required."
      );
      return;
    }

    const translationsMap = new Map(Object.entries(translations));
    createMutation.mutate({
      key,
      group,
      description,
      translations: Object.fromEntries(translationsMap),
    });
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
        <div className="flex justify-between items-center p-6 border-b border-gray-700 flex-shrink-0">
          <h2 className="text-2xl font-bold text-white">
            Add New Translation Key
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>

        <form
          onSubmit={handleSubmit}
          className="p-6 space-y-5 overflow-y-auto custom-scrollbar"
        >
          <div className="grid grid-cols-1 md:grid-cols-2 gap-5">
            <div>
              <label className="block text-sm font-medium text-brand-light mb-1">
                Key
              </label>
              <input
                type="text"
                value={key}
                onChange={handleKeyChange}
                className={`w-full p-2 rounded bg-gray-700 text-white border ${
                  keyError ? "border-red-500" : "border-gray-600"
                }`}
                required
              />
              {keyError && (
                <p className="text-red-400 text-xs mt-1">{keyError}</p>
              )}
              {!keyError && (
                <p className="text-xs text-brand-muted mt-1">
                  e.g., "welcome_message". Lowercase, numbers, and underscores
                  only.
                </p>
              )}
            </div>
            <div>
              <label className="block text-sm font-medium text-brand-light mb-1">
                Group
              </label>
              <input
                type="text"
                value={group}
                onChange={(e) => setGroup(e.target.value)}
                className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
                required
              />
            </div>
          </div>
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">
              Description (Optional)
            </label>
            <input
              type="text"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Context for this key, e.g., 'Homepage greeting'"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
            />
          </div>

          <div className="pt-4 border-t border-gray-700">
            <div className="flex justify-between items-center mb-3">
              <h3 className="text-lg font-semibold text-white">Translations</h3>
              <button
                type="button"
                onClick={handleAiTranslate}
                disabled={aiTranslateMutation.isPending}
                className="flex items-center gap-2 bg-indigo-600 text-white font-bold py-2 px-3 rounded-lg text-sm hover:bg-indigo-700 disabled:opacity-50"
              >
                {aiTranslateMutation.isPending ? (
                  <Loader2 size={16} className="animate-spin" />
                ) : (
                  <Sparkles size={16} />
                )}
                <span>Auto-translate All</span>
              </button>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {languages.map((lang) => (
                <div key={lang.code}>
                  <label className="block text-sm font-medium text-brand-light mb-1">
                    {lang.name}
                  </label>
                  <textarea
                    value={translations[lang.code] || ""}
                    onChange={(e) =>
                      setTranslations((prev) => ({
                        ...prev,
                        [lang.code]: e.target.value,
                      }))
                    }
                    className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 resize-y"
                    rows={2}
                    required={lang.code === "en"}
                  />
                </div>
              ))}
            </div>
            <div className="mt-4 p-3 bg-indigo-500/10 border border-indigo-500/20 text-indigo-200 text-xs rounded-lg flex items-start gap-2">
              <Info size={16} className="flex-shrink-0 mt-0.5" />
              <p>
                The English (en) translation is required. It will be used as the
                source for the auto-translation feature.
              </p>
            </div>
          </div>
        </form>

        <div className="flex justify-end gap-3 p-6 border-t border-gray-700 flex-shrink-0">
          <button
            type="button"
            onClick={onClose}
            className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
          >
            Cancel
          </button>
          <button
            type="button"
            onClick={handleSubmit}
            className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg disabled:opacity-50 flex items-center gap-2"
            disabled={createMutation.isPending || !!keyError || !key.trim()}
          >
            {createMutation.isPending ? (
              <Loader2 size={18} className="animate-spin" />
            ) : (
              <Save size={18} />
            )}
            {createMutation.isPending ? "Saving..." : "Create Key"}
          </button>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/admin/translations/EditTranslationModal.tsx =====

"use client";

import { useState, useEffect } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { ILanguage } from "@/models/Language";
import { ITranslation } from "@/models/Translation";
import { XCircle, Save, Sparkles, Loader2, Info } from "lucide-react";

interface EditTranslationModalProps {
  isOpen: boolean;
  onClose: () => void;
  translation: ITranslation;
  languages: ILanguage[];
}

export default function EditTranslationModal({
  isOpen,
  onClose,
  translation,
  languages,
}: EditTranslationModalProps) {
  const queryClient = useQueryClient();
  const [editData, setEditData] = useState<ITranslation>(translation);

  useEffect(() => {

    setEditData(JSON.parse(JSON.stringify(translation)));
  }, [translation, isOpen]);

  const updateMutation = useMutation({
    mutationFn: (updatedData: ITranslation) =>
      axios.put("/api/admin/translations/manage", updatedData),
    onSuccess: (data) => {
      toast.success("Translation updated successfully!");
      queryClient.setQueryData(
        ["allTranslations"],
        (oldData: ITranslation[] | undefined) =>
          oldData?.map((t) => (t._id === data.data._id ? data.data : t))
      );
      onClose();
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "Update failed."),
  });

  const aiTranslateMutation = useMutation({
    mutationFn: (payload: { text: string; targetLangCodes: string[] }) =>
      axios.post("/api/admin/translations/ai-translate", payload),
    onSuccess: (data) => {
      setEditData((prev) => ({
        ...prev,
        translations: { ...prev.translations, ...data.data },
      }));
      toast.success("AI translation complete!");
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "AI translation failed."),
  });

  const handleEditChange = (langCode: string, value: string) => {
    setEditData((prev) => ({
      ...prev,
      translations: {
        ...prev.translations,
        [langCode]: value,
      },
    }));
  };

  const handleAiTranslate = () => {
    const englishText =
      editData.translations["en" as keyof typeof editData.translations];
    if (!englishText) {
      toast.error(
        "Please provide the English text to use as a source for translation."
      );
      return;
    }
    const targetLangs = languages
      .filter(
        (l) =>
          l.code !== "en" &&
          !editData.translations[l.code as keyof typeof editData.translations]
      )
      .map((l) => l.code);
    if (targetLangs.length === 0) {
      toast.success("All languages are already translated!");
      return;
    }
    aiTranslateMutation.mutate({
      text: englishText,
      targetLangCodes: targetLangs,
    });
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    updateMutation.mutate(editData);
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
        <div className="flex justify-between items-center p-6 border-b border-gray-700 flex-shrink-0">
          <div>
            <h2 className="text-2xl font-bold text-white">
              Edit Translation Key
            </h2>
            <p className="font-mono text-sm text-brand-purple mt-1">
              {translation.key}
            </p>
          </div>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>

        <form
          onSubmit={handleSubmit}
          className="p-6 space-y-5 overflow-y-auto custom-scrollbar"
        >
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">
              Group
            </label>
            <input
              type="text"
              value={editData.group}
              onChange={(e) =>
                setEditData((prev) => ({ ...prev, group: e.target.value }))
              }
              className="w-full md:w-1/2 p-2 rounded bg-gray-700 text-white border border-gray-600"
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-brand-light mb-1">
              Description (Optional)
            </label>
            <input
              type="text"
              value={editData.description}
              onChange={(e) =>
                setEditData((prev) => ({
                  ...prev,
                  description: e.target.value,
                }))
              }
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"
            />
          </div>

          <div className="pt-4 border-t border-gray-700">
            <div className="flex justify-between items-center mb-3">
              <h3 className="text-lg font-semibold text-white">Translations</h3>
              <button
                type="button"
                onClick={handleAiTranslate}
                disabled={aiTranslateMutation.isPending}
                className="flex items-center gap-2 bg-indigo-600 text-white font-bold py-2 px-3 rounded-lg text-sm hover:bg-indigo-700 disabled:opacity-50"
              >
                {aiTranslateMutation.isPending ? (
                  <Loader2 size={16} className="animate-spin" />
                ) : (
                  <Sparkles size={16} />
                )}
                <span>Auto-translate Missing</span>
              </button>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {languages.map((lang) => (
                <div key={lang.code}>
                  <label className="block text-sm font-medium text-brand-light mb-1">
                    {lang.name}
                  </label>
                  <textarea
                    value={
                      editData.translations[
                        lang.code as keyof typeof editData.translations
                      ] || ""
                    }
                    onChange={(e) =>
                      handleEditChange(lang.code, e.target.value)
                    }
                    className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 resize-y"
                    rows={3}
                  />
                </div>
              ))}
            </div>
          </div>
        </form>

        <div className="flex justify-end gap-3 p-6 border-t border-gray-700 flex-shrink-0">
          <button
            type="button"
            onClick={onClose}
            className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
          >
            Cancel
          </button>
          <button
            type="button"
            onClick={handleSubmit}
            className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg disabled:opacity-50 flex items-center gap-2"
            disabled={updateMutation.isPending || aiTranslateMutation.isPending}
          >
            {updateMutation.isPending ? (
              <Loader2 size={18} className="animate-spin" />
            ) : (
              <Save size={18} />
            )}
            {updateMutation.isPending ? "Saving..." : "Save Changes"}
          </button>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/admin/translations/TranslationRow.tsx =====

"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { ITranslation } from "@/models/Translation";
import { ILanguage } from "@/models/Language";
import { Edit, Trash2, Loader2 } from "lucide-react";
import TranslationStatusPopover from "./TranslationStatusPopover";

interface TranslationRowProps {
  translation: ITranslation;
  languages: ILanguage[];
  onEdit: (translation: ITranslation) => void;
}

export default function TranslationRow({
  translation,
  languages,
  onEdit,
}: TranslationRowProps) {
  const queryClient = useQueryClient();

  const deleteMutation = useMutation({
    mutationFn: (id: string) =>
      axios.delete("/api/admin/translations/manage", { data: { id } }),
    onSuccess: () => {
      toast.success("Translation key deleted!");
      queryClient.invalidateQueries({ queryKey: ["allTranslations"] });
    },
    onError: (err: any) =>
      toast.error(err.response?.data?.error || "Deletion failed."),
  });

  const handleDelete = () => {
    if (
      window.confirm(
        `Are you sure you want to delete the key "${translation.key}" and all its translations?`
      )
    ) {
      deleteMutation.mutate(translation._id as string);
    }
  };

  const englishTranslation =
    translation.translations["en" as keyof typeof translation.translations] ||
    "N/A";

  return (
    <tr className="border-t border-gray-700/50 group">
      <td className="p-4 align-top">
        <p className="font-mono text-sm font-bold text-white">
          {translation.key}
        </p>
        <p className="text-xs text-brand-muted">{translation.group}</p>
      </td>
      <td className="p-4 align-top" colSpan={1}>
        <p className="text-sm text-text-secondary whitespace-pre-wrap">
          {englishTranslation}
        </p>
      </td>
      <td className="p-4 align-top">
        <TranslationStatusPopover
          translation={translation}
          allActiveLanguages={languages}
        />
      </td>
      <td className="p-4 align-middle text-center">
        <div className="flex items-center justify-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
          <button
            onClick={() => onEdit(translation)}
            className="p-2 text-blue-400 hover:bg-gray-700 rounded-full"
            title="Edit Translations"
          >
            <Edit size={18} />
          </button>
          <button
            onClick={handleDelete}
            disabled={deleteMutation.isPending}
            className="p-2 text-red-400 hover:bg-gray-700 rounded-full disabled:opacity-50"
            title="Delete Key"
          >
            {deleteMutation.isPending ? (
              <Loader2 size={18} className="animate-spin" />
            ) : (
              <Trash2 size={18} />
            )}
          </button>
        </div>
      </td>
    </tr>
  );
}

// ===== src/components/admin/translations/TranslationStatusPopover.tsx =====

"use client";

import { Popover, Transition } from "@headlessui/react";
import { Fragment } from "react";
import Image from "next/image";
import { ILanguage } from "@/models/Language";
import { ITranslation } from "@/models/Translation";
import { Languages, CheckCircle, XCircle } from "lucide-react";

interface TranslationStatusPopoverProps {
  translation: ITranslation;
  allActiveLanguages: ILanguage[];
}

export default function TranslationStatusPopover({
  translation,
  allActiveLanguages,
}: TranslationStatusPopoverProps) {
  const translatedCount = Object.keys(translation.translations).filter(
    (key) =>
      allActiveLanguages.some((lang) => lang.code === key) &&
      translation.translations[key as keyof typeof translation.translations]
  ).length;

  const totalCount = allActiveLanguages.length;
  const isComplete = translatedCount === totalCount;

  return (
    <Popover className="relative">
      <Popover.Button
        className={`flex items-center gap-2 rounded-md bg-gray-700/80 px-3 py-1.5 text-xs font-semibold hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-brand-purple ${
          isComplete ? "text-green-400" : "text-brand-light"
        }`}
      >
        <Languages size={14} />
        <span>
          {translatedCount} / {totalCount} Languages
        </span>
      </Popover.Button>
      <Transition
        as={Fragment}
        enter="transition ease-out duration-200"
        enterFrom="opacity-0 translate-y-1"
        enterTo="opacity-100 translate-y-0"
        leave="transition ease-in duration-150"
        leaveFrom="opacity-100 translate-y-0"
        leaveTo="opacity-0 translate-y-1"
      >
        <Popover.Panel className="absolute left-1/2 z-10 mt-2 w-72 -translate-x-1/2 transform rounded-md bg-brand-dark shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none border border-gray-700">
          <div className="p-2">
            <div className="p-2 font-bold text-white">Translation Status</div>
            <div className="max-h-60 overflow-y-auto custom-scrollbar space-y-1">
              {allActiveLanguages.map((lang) => {
                const isAvailable =
                  !!translation.translations[
                    lang.code as keyof typeof translation.translations
                  ];
                return (
                  <div
                    key={lang.code}
                    className="flex items-center justify-between p-2 rounded-md"
                  >
                    <div className="flex items-center gap-2">
                      {lang.flagUrl && (
                        <Image
                          src={lang.flagUrl}
                          alt={lang.name}
                          width={20}
                          height={15}
                          className="rounded-sm"
                        />
                      )}
                      <span className="text-sm font-medium text-brand-light">
                        {lang.name}
                      </span>
                    </div>
                    {isAvailable ? (
                      <span className="flex items-center gap-1.5 text-xs text-green-400">
                        <CheckCircle size={14} /> Complete
                      </span>
                    ) : (
                      <span className="flex items-center gap-1.5 text-xs text-brand-muted">
                        <XCircle size={14} /> Missing
                      </span>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        </Popover.Panel>
      </Transition>
    </Popover>
  );
}

// ===== src/components/admin/translations/TranslationsTable.tsx =====

import { ITranslation } from "@/models/Translation";
import { ILanguage } from "@/models/Language";
import TranslationRow from "./TranslationRow";
import { Loader2, AlertTriangle } from "lucide-react";

interface TranslationsTableProps {
  translations: ITranslation[];
  languages: ILanguage[];
  isLoading: boolean;
  error: Error | null;
  onEdit: (translation: ITranslation) => void;
}

export default function TranslationsTable({
  translations,
  languages,
  isLoading,
  error,
  onEdit,
}: TranslationsTableProps) {
  if (isLoading) {
    return (
      <div className="flex items-center justify-center p-20">
        <Loader2 size={32} className="animate-spin text-brand-muted" />
        <span className="ml-4 text-lg text-brand-muted">
          Loading translations...
        </span>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex flex-col items-center justify-center p-20 text-red-400">
        <AlertTriangle size={32} className="mb-4" />
        <p className="text-lg font-semibold">Failed to load translations.</p>
        <p className="text-sm">{error.message}</p>
      </div>
    );
  }

  return (
    <div className="overflow-x-auto">
      <table className="w-full min-w-[900px] text-left text-brand-light">
        <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase sticky top-0 z-10">
          <tr>
            <th className="p-4 w-1/4">Key & Group</th>
            <th className="p-4 w-2/5">English (Default)</th>
            <th className="p-4 w-1/4">Status</th>
            <th className="p-4 w-[100px] text-center">Actions</th>
          </tr>
        </thead>
        <tbody>
          {translations.length > 0 ? (
            translations.map((translation) => (
              <TranslationRow
                key={translation._id?.toString()}
                translation={translation}
                languages={languages}
                onEdit={onEdit}
              />
            ))
          ) : (
            <tr>
              <td colSpan={4} className="text-center p-8 text-brand-muted">
                No translations found matching your criteria.
              </td>
            </tr>
          )}
        </tbody>
      </table>
    </div>
  );
}

// ===== src/components/directory/FeaturedLeagueCard.tsx =====

"use client";

import Image from "next/image";
import StyledLink from "@/components/StyledLink";
import { proxyImageUrl } from "@/lib/image-proxy";
import { ArrowRight } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface FeaturedLeagueCardProps {
  name: string;
  logoUrl: string;
  countryName: string;
  href: string;
}

export const FeaturedLeagueCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg p-6 space-y-4 animate-pulse h-48 flex flex-col justify-between">
    <div className="flex items-center gap-4">
      <div className="w-12 h-12 rounded-full bg-gray-700"></div>
      <div className="space-y-2 flex-1">
        <div className="h-5 w-3/4 rounded bg-gray-600"></div>
        <div className="h-4 w-1/2 rounded bg-gray-600"></div>
      </div>
    </div>
    <div className="h-10 w-full rounded bg-gray-700 mt-4"></div>
  </div>
);

export default function FeaturedLeagueCard({
  name,
  logoUrl,
  countryName,
  href,
}: FeaturedLeagueCardProps) {
  const { t } = useTranslation();

  return (
    <StyledLink
      href={href}
      className="block group h-full transition-transform duration-300 ease-in-out hover:-translate-y-1"
    >
      <div
        className="bg-brand-secondary rounded-lg h-full p-6 flex flex-col justify-between
                   border border-gray-700/50 relative overflow-hidden
                   hover:border-brand-purple/50 hover:shadow-2xl hover:shadow-brand-purple/20"
      >
        <div className="absolute -top-1/4 -right-1/4 w-1/2 h-1/2 bg-brand-purple/10 rounded-full blur-3xl opacity-50 group-hover:opacity-100 transition-opacity duration-500"></div>

        <div className="relative">
          <div className="flex items-center gap-4">
            <Image
              src={proxyImageUrl(logoUrl)}
              alt={`${name} logo`}
              width={48}
              height={48}
              className="flex-shrink-0 bg-white p-1 rounded-full"
            />
            <div className="flex-1 min-w-0">
              <h3 className="font-bold text-xl text-white truncate">{name}</h3>
              <p className="text-sm text-brand-muted">{countryName}</p>
            </div>
          </div>
        </div>

        <div className="relative mt-6">
          <div
            className="flex items-center justify-center gap-2 w-full bg-[var(--brand-accent)] text-white font-bold py-3 px-4 rounded-lg
                           group-hover:opacity-90 transition-opacity text-sm"
          >
            <span>{t("view_standings")}</span>
            <ArrowRight
              size={16}
              className="transition-transform duration-300 group-hover:translate-x-1"
            />
          </div>
        </div>
      </div>
    </StyledLink>
  );
}

// ===== src/components/directory/LeagueDetailWidget.tsx =====

"use client";

import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import { Shield, Flag, Calendar, BarChart3, Goal, Trophy } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface League {
  name: string;
  logo: string;
  type: string;
  country: string;
  season: number;
}
interface LeagueStats {
  totalGoals: number;
  avgGoals: string;
  totalMatches: number;
}
interface TopScorerPlayer {
  id: number;
  name: string;
  photo: string;
}
interface TopScorerStats {
  goals: { total: number };
  team: { name: string };
}
interface TopScorer {
  player: TopScorerPlayer;
  statistics: TopScorerStats[];
}

interface LeagueDetailWidgetProps {
  league: League;
  leagueStats: LeagueStats | null;
  topScorer: TopScorer | null;
}

const StatItem = ({
  label,
  value,
  icon: Icon,
}: {
  label: string;
  value: string | number;
  icon: React.ElementType;
}) => (
  <div className="text-center">
    <Icon size={24} className="mx-auto text-brand-muted mb-1" />
    <p className="font-bold text-white text-lg">{value}</p>
    <p className="text-xs text-brand-muted">{label}</p>
  </div>
);

export default function LeagueDetailWidget({
  league,
  leagueStats,
  topScorer,
}: LeagueDetailWidgetProps) {
  const { t } = useTranslation();

  return (
    <div className="bg-brand-secondary rounded-lg overflow-hidden border border-gray-700/50">
      {}
      <div className="p-4 flex items-center gap-4 bg-gray-800/30">
        <Image
          src={proxyImageUrl(league.logo)}
          alt={`${league.name} logo`}
          width={56}
          height={56}
          className="bg-white rounded-full p-1.5"
        />
        <div>
          <h3 className="text-xl font-bold text-white leading-tight">
            {league.name}
          </h3>
          <div className="flex items-center gap-2 text-sm text-brand-muted mt-1">
            <Flag size={14} />
            <span>{league.country}</span>
            <span className="font-bold"></span>
            <span>{league.season}</span>
          </div>
        </div>
      </div>

      {}
      {leagueStats && (
        <div className="grid grid-cols-3 gap-4 p-4 border-b border-gray-700/50">
          <StatItem
            label={t("total_matches")}
            icon={BarChart3}
            value={leagueStats.totalMatches}
          />
          <StatItem
            label={t("total_goals")}
            icon={Goal}
            value={leagueStats.totalGoals}
          />
          <StatItem
            label={t("avg_goals")}
            icon={Shield}
            value={leagueStats.avgGoals}
          />
        </div>
      )}

      {}
      {topScorer && (
        <div className="p-4">
          <h4 className="font-semibold text-brand-light mb-3 flex items-center gap-2">
            <Trophy size={16} className="text-yellow-400" />
            {t("top_scorer")}
          </h4>
          <div className="flex items-center gap-3">
            <Image
              src={proxyImageUrl(topScorer.player.photo)}
              alt={topScorer.player.name}
              width={40}
              height={40}
              className="rounded-full bg-gray-700"
            />
            <div className="flex-1 min-w-0">
              <p className="font-bold text-white truncate text-sm">
                {topScorer.player.name}
              </p>
              <p className="text-xs text-brand-muted truncate">
                {topScorer.statistics[0].team.name}
              </p>
            </div>
            <div className="flex items-center gap-1.5 font-bold text-yellow-400 text-lg">
              <Goal size={16} />
              <span>{topScorer.statistics[0].goals.total}</span>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// ===== src/components/directory/LeagueStandingCard.tsx =====

"use client";

import Image from "next/image";
import StyledLink from "@/components/StyledLink";
import { proxyImageUrl } from "@/lib/image-proxy";

interface LeagueStandingCardProps {
  name: string;
  logoUrl: string;
  countryName: string;
  href: string;
}

export const LeagueStandingCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg p-4 flex items-center gap-4 animate-pulse">
    <div className="w-10 h-10 rounded-full bg-gray-700"></div>
    <div className="space-y-2 flex-1">
      <div className="h-4 w-3/4 rounded bg-gray-600"></div>
      <div className="h-3 w-1/2 rounded bg-gray-600"></div>
    </div>
  </div>
);

export default function LeagueStandingCard({
  name,
  logoUrl,
  countryName,
  href,
}: LeagueStandingCardProps) {
  return (
    <StyledLink href={href} className="block group h-full">
      <div
        className="bg-brand-secondary rounded-lg flex items-center gap-4 p-4 h-full
                   transition-all duration-300 transform
                   hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20
                   border border-transparent hover:border-brand-purple/30"
      >
        <Image
          src={proxyImageUrl(logoUrl)}
          alt={`${name} logo`}
          width={40}
          height={40}
          className="flex-shrink-0"
        />
        <div className="flex-1 min-w-0">
          <h3 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
            {name}
          </h3>
          <p className="text-sm text-brand-muted">{countryName}</p>
        </div>
      </div>
    </StyledLink>
  );
}

// ===== src/components/directory/StandingsHubClient.tsx =====

"use client";

import { useState, useMemo } from "react";
import { League } from "@/types/api-football";
import FeaturedLeagueCard, {
  FeaturedLeagueCardSkeleton,
} from "./FeaturedLeagueCard";
import LeagueStandingCard, {
  LeagueStandingCardSkeleton,
} from "./LeagueStandingCard";
import { Search, SearchX } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface StandingsHubClientProps {
  leagues: League[];
}

const FEATURED_LEAGUE_IDS = new Set([39, 140, 135, 78, 61, 2]);

export default function StandingsHubClient({
  leagues = [],
}: StandingsHubClientProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const { t } = useTranslation();

  const featuredLeagues = useMemo(() => {
    return leagues.filter((l) => FEATURED_LEAGUE_IDS.has(l.id));
  }, [leagues]);

  const filteredLeagues = useMemo(() => {
    if (searchTerm.length < 3) {
      return leagues;
    }
    return leagues.filter(
      (league) =>
        league.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        league.countryName.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [leagues, searchTerm]);

  return (
    <div className="space-y-12">
      {}
      {searchTerm.length < 3 && (
        <section>
          <h2 className="text-2xl font-bold text-white mb-4">
            {t("featured_leagues")}
          </h2>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {featuredLeagues.length > 0
              ? featuredLeagues.map((league) => (
                  <FeaturedLeagueCard key={league.id} {...league} />
                ))
              : Array.from({ length: 6 }).map((_, i) => (
                  <FeaturedLeagueCardSkeleton key={i} />
                ))}
          </div>
        </section>
      )}

      {}
      <section>
        <div className="flex flex-col md:flex-row items-center justify-between gap-4 mb-6">
          <h2 className="text-2xl font-bold text-white">{t("all_leagues")}</h2>
          <div className="relative w-full md:w-72">
            <Search
              className="absolute left-3.5 top-1/2 -translate-y-1/2 text-text-muted"
              size={20}
            />
            <input
              type="text"
              placeholder={t("search_leagues_placeholder")}
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-3 pl-11 text-white placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-[var(--brand-accent)]"
            />
          </div>
        </div>

        {filteredLeagues.length > 0 ? (
          <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
            {filteredLeagues.map((league) => (
              <LeagueStandingCard key={league.id} {...league} />
            ))}
          </div>
        ) : (
          <div className="text-center py-16 bg-brand-secondary rounded-lg">
            <SearchX size={48} className="mx-auto text-text-muted mb-4" />
            <p className="text-xl font-bold text-white">
              {t("no_leagues_found_title")}
            </p>
            <p className="text-text-muted mt-2">
              {t("no_leagues_found_subtitle", { searchTerm })}
            </p>
          </div>
        )}
      </section>
    </div>
  );
}

// ===== src/components/image-templates/FixtureImageTemplate.tsx =====

import React from "react";

interface FixtureImageTemplateProps {
  homeTeamName: string;
  homeTeamLogo: string;
  awayTeamName: string;
  awayTeamLogo: string;
  leagueName: string;
}

export const FixtureImageTemplate = ({
  homeTeamName,
  homeTeamLogo,
  awayTeamName,
  awayTeamLogo,
  leagueName,
}: FixtureImageTemplateProps) => {
  return (
    <div
      style={{
        height: "100%",
        width: "100%",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "space-between",
        fontFamily: '"Poppins"',
        color: "white",
        background: "linear-gradient(to bottom, #1e1b2e, #13111e)",
        padding: "48px",
      }}
    >
      {}
      <div
        style={{
          display: "flex",
          alignSelf: "flex-start",
          fontSize: 28,
          color: "#9e9e9e",
        }}
      >
        {leagueName}
      </div>

      {}
      <div
        style={{
          display: "flex",
          width: "100%",
          alignItems: "center",
          justifyContent: "space-around",
        }}
      >
        {}
        <div
          style={{
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            gap: 24,
            width: 400,
          }}
        >
          <img
            src={homeTeamLogo}
            alt={`${homeTeamName} logo`}
            width={200}
            height={200}
            style={{ objectFit: "contain" }}
          />
          <div style={{ fontSize: 48, fontWeight: 700, textAlign: "center" }}>
            {homeTeamName}
          </div>
        </div>

        {}
        <div style={{ fontSize: 96, fontWeight: 900, color: "#9e9e9e" }}>
          VS
        </div>

        {}
        <div
          style={{
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            gap: 24,
            width: 400,
          }}
        >
          <img
            src={awayTeamLogo}
            alt={`${awayTeamName} logo`}
            width={200}
            height={200}
            style={{ objectFit: "contain" }}
          />
          <div style={{ fontSize: 48, fontWeight: 700, textAlign: "center" }}>
            {awayTeamName}
          </div>
        </div>
      </div>

      {}
      <div
        style={{
          display: "flex",
          alignSelf: "flex-end",
          fontSize: 32,
          fontWeight: 800,
          color: "#ed5c19",
        }}
      >
        FanSkor
      </div>
    </div>
  );
};

// ===== src/components/league-detail-view/LeagueFixturesWidget.tsx =====

"use client";

import { useState, useMemo, useRef, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { DayPicker } from "react-day-picker";
import "react-day-picker/dist/style.css";
import { format, Locale } from "date-fns";
import { enUS, tr, fr, es } from "date-fns/locale";
import { Calendar, Info } from "lucide-react";
import MatchListItem, { MatchListItemSkeleton } from "../MatchListItem";
import { useTranslation } from "@/hooks/useTranslation";

type FixtureView = "upcoming" | "today" | "date";

const dateLocales: Record<string, Locale> = { en: enUS, tr, fr, es };

const fetchFixtures = async (params: {
  leagueId: number;
  upcoming?: boolean;
  date?: string;
}) => {
  const queryParams = new URLSearchParams({
    league: params.leagueId.toString(),
  });

  if (params.date) queryParams.set("date", params.date);
  const { data } = await axios.get(`/api/fixtures?${queryParams.toString()}`);
  return data;
};

export default function LeagueFixturesWidget({
  leagueId,
  season,
}: {
  leagueId: number;
  season: number;
}) {
  const [view, setView] = useState<FixtureView>("today");
  const [selectedDate, setSelectedDate] = useState<Date>(new Date());
  const [isCalendarOpen, setIsCalendarOpen] = useState(false);
  const calendarRef = useRef<HTMLDivElement>(null);
  const { t, locale } = useTranslation();

  const queryParams = useMemo(() => {
    const baseParams = { leagueId, season };
    switch (view) {
      case "today":
        return { ...baseParams, date: format(new Date(), "yyyy-MM-dd") };
      case "date":
        return { ...baseParams, date: format(selectedDate, "yyyy-MM-dd") };

      default:
        return { ...baseParams, date: format(new Date(), "yyyy-MM-dd") };
    }
  }, [view, leagueId, season, selectedDate]);

  const {
    data: fixtures,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["leagueFixtures", queryParams],
    queryFn: () => fetchFixtures(queryParams),
    enabled: !!leagueId,
    staleTime: 1000 * 60 * 5,
  });

  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (
        calendarRef.current &&
        !calendarRef.current.contains(event.target as Node)
      ) {
        setIsCalendarOpen(false);
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [calendarRef]);

  const handleDateSelect = (date: Date | undefined) => {
    if (date) {
      setSelectedDate(date);
      setView("date");
      setIsCalendarOpen(false);
    }
  };

  const renderDateButtonText = () => {
    const currentLocale = dateLocales[locale] || enUS;
    if (view === "date")
      return format(selectedDate, "do MMM", { locale: currentLocale });
    return t("select_date");
  };

  const currentLocale = dateLocales[locale] || enUS;

  return (
    <div className="bg-brand-secondary rounded-xl">
      <div className="flex justify-between items-center p-4 border-b border-gray-700/50">
        <h3 className="text-xl font-bold text-white">{t("fixtures")}</h3>
        <div className="flex items-center gap-1 bg-[var(--color-primary)] p-1 rounded-lg">
          <button
            onClick={() => setView("today")}
            className={`px-3 py-1 text-sm rounded-md font-semibold transition-colors ${
              view === "today"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700"
            }`}
          >
            {t("today")}
          </button>
          <div className="relative" ref={calendarRef}>
            <button
              onClick={() => setIsCalendarOpen(!isCalendarOpen)}
              className={`flex items-center gap-1.5 px-3 py-1 text-sm rounded-md font-semibold transition-colors capitalize ${
                view === "date"
                  ? "bg-[var(--brand-accent)] text-white"
                  : "text-text-muted hover:bg-gray-700"
              }`}
            >
              <Calendar size={14} />
              {renderDateButtonText()}
            </button>
            {isCalendarOpen && (
              <div className="absolute top-full right-0 mt-2 z-20 bg-brand-dark border border-gray-700 rounded-lg shadow-lg">
                <DayPicker
                  mode="single"
                  selected={selectedDate}
                  onSelect={handleDateSelect}
                  className="text-white"
                  initialFocus
                  locale={currentLocale}
                />
              </div>
            )}
          </div>
        </div>
      </div>

      <div className="p-2 space-y-2 max-h-[600px] overflow-y-auto custom-scrollbar">
        {isLoading ? (
          Array.from({ length: 5 }).map((_, i) => (
            <MatchListItemSkeleton key={i} />
          ))
        ) : isError ? (
          <div className="text-center py-10 text-red-400">
            <p>{t("error_loading_fixtures")}</p>
          </div>
        ) : fixtures && fixtures.length > 0 ? (
          fixtures.map((match: any) => (
            <MatchListItem key={match.fixture.id} match={match} />
          ))
        ) : (
          <div className="text-center py-20 text-brand-muted">
            <Info size={32} className="mx-auto mb-3" />
            <p className="font-semibold">{t("no_fixtures_found")}</p>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/league-detail-view/LeagueHeader.tsx =====

import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import { Shield, Flag, Calendar } from "lucide-react";

interface LeagueHeaderProps {
  league: {
    name: string;
    logo: string;
    type: string;
  };
  country: {
    name: string;
    flag: string | null;
  };
  currentSeason: number;
}

export default function LeagueHeader({
  league,
  country,
  currentSeason,
}: LeagueHeaderProps) {
  return (
    <div className="relative bg-brand-secondary rounded-lg overflow-hidden p-6 pt-10 text-center md:text-left">
      {}
      {country.flag && (
        <Image
          src={proxyImageUrl(country.flag)}
          alt={`${country.name} flag`}
          layout="fill"
          objectFit="cover"
          className="absolute inset-0 z-0 opacity-5"
        />
      )}
      <div className="absolute inset-0 bg-gradient-to-t from-brand-secondary via-brand-secondary/80 to-transparent z-10"></div>

      <div className="relative z-20 flex flex-col md:flex-row items-center gap-6">
        {}
        <div className="flex-shrink-0">
          <Image
            src={proxyImageUrl(league.logo)}
            alt={league.name}
            width={96}
            height={96}
            className="bg-white/90 rounded-full p-2 shadow-lg"
          />
        </div>

        {}
        <div className="flex-1">
          <h1 className="text-4xl md:text-5xl font-extrabold text-white">
            {league.name}
          </h1>
          <div className="flex flex-wrap items-center justify-center md:justify-start gap-x-4 gap-y-2 mt-3 text-brand-muted">
            <div className="flex items-center gap-1.5 text-sm">
              <Shield size={14} />
              <span>{league.type}</span>
            </div>
            <div className="flex items-center gap-1.5 text-sm">
              <Flag size={14} />
              <span>{country.name}</span>
            </div>
            <div className="flex items-center gap-1.5 text-sm">
              <Calendar size={14} />
              <span>
                {currentSeason}/{currentSeason + 1}
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/league-detail-view/LeagueStandingsWidget.tsx =====

"use client";

import { useState, memo, useMemo } from "react";
import { useRouter } from "next/navigation";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import StyledLink from "@/components/StyledLink";
import { Info, ListOrdered, Loader2, Trophy } from "lucide-react";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import { useTranslation } from "@/hooks/useTranslation";

type StandingsView = "all" | "home" | "away";

interface TeamStats {
  played: number;
  win: number;
  draw: number;
  lose: number;
  goals: { for: number; against: number };
}

interface TeamStanding {
  rank: number;
  team: { id: number; name: string; logo: string };
  points: number;
  all: TeamStats;
  home: TeamStats;
  away: TeamStats;
  goalsDiff: number;
  description: string | null;
  group: string;
}

interface LeagueStandingsWidgetProps {
  initialStandings: TeamStanding[][];
  leagueSeasons: number[];
  currentSeason: number;
  onSeasonChange?: (season: number) => void;
  isLoading: boolean;
  leagueId?: number;
  leagueSlug?: string;
  homeTeamId?: number;
  awayTeamId?: number;
  hideSeasonDropdown?: boolean;
}

const getRankIndicatorClass = (description: string | null): string => {
  if (!description) return "bg-gray-700/50";
  const desc = description.toLowerCase();
  if (desc.includes("champions league") || desc.includes("promotion"))
    return "bg-blue-500/20";
  if (desc.includes("europa league") || desc.includes("qualification"))
    return "bg-orange-500/20";
  if (desc.includes("relegation")) return "bg-red-600/20";
  return "bg-gray-700/50";
};

const StandingsTable = memo(
  ({
    group,
    view,
    t,
    homeTeamId,
    awayTeamId,
  }: {
    group: TeamStanding[];
    view: StandingsView;
    t: (key: string) => string;
    homeTeamId?: number;
    awayTeamId?: number;
  }) => {
    const processedStandings = useMemo(() => {
      if (view === "all") return group;
      return [...group]
        .map((item) => {
          const stats = item[view];
          const points = stats.win * 3 + stats.draw;
          const goalsDiff = stats.goals.for - stats.goals.against;
          return { ...item, points, goalsDiff, stats };
        })
        .sort((a, b) => {
          if (b.points !== a.points) return b.points - a.points;
          if (b.goalsDiff !== a.goalsDiff) return b.goalsDiff - a.goalsDiff;
          return a.team.name.localeCompare(b.team.name);
        })
        .map((item, index) => ({ ...item, rank: index + 1 }));
    }, [group, view]);

    return (
      <div className="overflow-x-auto">
        <table className="w-full text-sm border-separate border-spacing-0">
          <thead className="text-left text-text-muted sticky top-0 bg-brand-secondary z-10">
            <tr className="text-xs uppercase">
              <th className="p-2 w-8 text-center font-semibold">
                {t("table_header_rank_short")}
              </th>
              <th className="p-2 font-semibold">{t("table_header_team")}</th>
              <th className="p-2 text-center font-semibold">
                {t("table_header_played_short")}
              </th>
              <th className="p-2 text-center font-semibold">
                {t("table_header_goaldiff_short")}
              </th>
              <th className="p-2 text-center font-bold">
                {t("table_header_points_short")}
              </th>
            </tr>
          </thead>
          <tbody className="text-brand-light">
            {processedStandings.map((item) => {
              const stats = view === "all" ? item.all : item.stats;
              const isMatchTeam =
                item.team.id === homeTeamId || item.team.id === awayTeamId;

              const rowClasses = isMatchTeam
                ? "bg-[#ED5C19]/20 border-l-[#ED5C19]"
                : "border-l-transparent hover:bg-[#ED5C19]/10";

              return (
                <tr
                  key={item.team.id}
                  className={`transition-colors border-l-4 ${rowClasses}`}
                >
                  <td
                    className={`p-2 border-t border-gray-700/50 text-center ${getRankIndicatorClass(
                      item.description
                    )}`}
                  >
                    <span className="font-bold">{item.rank}</span>
                  </td>
                  <td className="p-2 border-t border-gray-700/50">
                    <StyledLink
                      href={generateTeamSlug(item.team.name, item.team.id)}
                      className="flex items-center gap-2 group"
                    >
                      <Image
                        src={proxyImageUrl(item.team?.logo)}
                        alt={item.team.name}
                        width={20}
                        height={20}
                      />
                      <span
                        className={`font-semibold group-hover:text-brand-purple transition-colors whitespace-nowrap truncate ${
                          isMatchTeam ? "text-white" : ""
                        }`}
                      >
                        {item.team.name}
                      </span>
                    </StyledLink>
                  </td>
                  <td className="p-2 text-center text-text-muted border-t border-gray-700/50">
                    {stats.played}
                  </td>
                  <td className="p-2 text-center text-text-muted border-t border-gray-700/50">
                    {item.goalsDiff}
                  </td>
                  <td className="p-2 text-center font-bold text-white border-t border-gray-700/50">
                    {item.points}
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    );
  }
);
StandingsTable.displayName = "StandingsTable";

export default function LeagueStandingsWidget({
  initialStandings,
  leagueSeasons = [],
  currentSeason,
  onSeasonChange,
  isLoading,
  leagueId,
  leagueSlug,
  homeTeamId,
  awayTeamId,
  hideSeasonDropdown = false,
}: LeagueStandingsWidgetProps) {
  const { t } = useTranslation();
  const [view, setView] = useState<StandingsView>("all");
  const router = useRouter();

  const handleSeasonNavigation = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const newSeason = e.target.value;
    if (leagueSlug) {
      router.push(`/football/standings/${leagueSlug}?season=${newSeason}`);
    }
  };

  return (
    <div className="bg-brand-secondary rounded-lg">
      <div className="p-4 border-b border-gray-700/50 flex flex-col gap-4">
        <div className="flex justify-between items-start">
          <h2 className="text-xl font-bold text-white flex items-center gap-2">
            <Trophy size={22} className="text-yellow-400" />
            {t("standings")}
          </h2>
          {!hideSeasonDropdown && leagueSeasons.length > 1 && (
            <div className="flex items-center gap-2">
              <select
                value={currentSeason}
                onChange={
                  onSeasonChange
                    ? (e) => onSeasonChange(Number(e.target.value))
                    : handleSeasonNavigation
                }
                className="p-2 rounded bg-gray-800 text-white border border-gray-600 text-xs focus:outline-none focus:ring-1 focus:ring-brand-purple"
                disabled={isLoading}
              >
                {leagueSeasons.map((season) => (
                  <option key={season} value={season}>
                    {season}/{season + 1}
                  </option>
                ))}
              </select>
              {isLoading && onSeasonChange && (
                <Loader2 className="animate-spin text-brand-muted" />
              )}
            </div>
          )}
        </div>
        <div className="flex items-center gap-1 bg-[var(--color-primary)] p-1 rounded-lg w-full">
          <button
            onClick={() => setView("all")}
            className={`flex-1 py-1.5 text-sm font-semibold rounded-md transition-colors ${
              view === "all"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700"
            }`}
          >
            {t("all")}
          </button>
          <button
            onClick={() => setView("home")}
            className={`flex-1 py-1.5 text-sm font-semibold rounded-md transition-colors ${
              view === "home"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700"
            }`}
          >
            {t("home")}
          </button>
          <button
            onClick={() => setView("away")}
            className={`flex-1 py-1.5 text-sm font-semibold rounded-md transition-colors ${
              view === "away"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700"
            }`}
          >
            {t("away")}
          </button>
        </div>
      </div>

      <div className="relative">
        {isLoading && onSeasonChange && (
          <div className="absolute inset-0 bg-brand-secondary/50 backdrop-blur-sm z-20 flex items-center justify-center">
            <Loader2 size={32} className="animate-spin text-brand-purple" />
          </div>
        )}
        {!initialStandings || initialStandings.length === 0 ? (
          <div className="text-center p-8">
            <Info size={32} className="mx-auto text-brand-muted mb-3" />
            <p className="font-semibold text-white">
              {t("standings_not_available")}
            </p>
          </div>
        ) : (

          <div className="p-4 space-y-8">
            {initialStandings.map((group, index) => (
              <div key={index}>
                {initialStandings.length > 1 && (
                  <h3 className="text-center font-bold text-brand-light mb-3">
                    {group[0].group}
                  </h3>
                )}
                <StandingsTable
                  group={group}
                  view={view}
                  t={t}
                  homeTeamId={homeTeamId}
                  awayTeamId={awayTeamId}
                />
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/league-detail-view/LeagueStatCard.tsx =====

import { ReactNode } from 'react';

interface LeagueStatCardProps {
    icon: ReactNode;
    label: string;
    value: string | number;
}

export default function LeagueStatCard({ icon, label, value }: LeagueStatCardProps) {
    return (
        <div className="bg-brand-secondary p-4 rounded-lg flex items-center gap-4">
            <div className="flex-shrink-0 bg-brand-purple/20 text-brand-purple p-3 rounded-lg">
                {icon}
            </div>
            <div>
                <p className="text-sm text-brand-muted">{label}</p>
                <p className="font-bold text-white text-lg">{value}</p>
            </div>
        </div>
    );
}

// ===== src/components/league-detail-view/LeagueTeamsList.tsx =====

"use client";

import { useState, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import TeamCard, { TeamCardSkeleton } from "./TeamCard";
import { Info, Search } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface LeagueTeamsListProps {
  leagueId: number;
  season: number;
  countryName: string;
  countryFlag: string;
}

interface CombinedTeamData {
  team: any;
  venue: any;
  rank?: number;
  description?: string;
  squadSize?: number;
}

const fetchLeagueData = async (leagueId: number, season: number) => {
  const [teamsResponse, standingsResponse] = await Promise.all([
    axios.get(`/api/teams?league=${leagueId}&season=${season}`),
    axios.get(`/api/standings?league=${leagueId}&season=${season}`),
  ]);

  const teamsData = teamsResponse.data;
  const standingsData = standingsResponse.data.standings?.[0] || [];
  const standingsMap = new Map(standingsData.map((s: any) => [s.team.id, s]));

  const combinedData: CombinedTeamData[] = teamsData.map((teamData: any) => {
    const standing: any = standingsMap.get(teamData.team.id);
    return {
      ...teamData,
      rank: standing?.rank,
      description: standing?.description,
    };
  });

  combinedData.sort((a, b) => {
    if (a.rank == null) return 1;
    if (b.rank == null) return -1;
    return a.rank - b.rank;
  });

  return combinedData;
};

export default function LeagueTeamsList({
  leagueId,
  season,
  countryName,
  countryFlag,
}: LeagueTeamsListProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const { t } = useTranslation();

  const {
    data: combinedData,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["leagueCombinedData", leagueId, season],
    queryFn: () => fetchLeagueData(leagueId, season),
    staleTime: 1000 * 60 * 60,
  });

  const filteredTeams = useMemo(() => {
    if (!combinedData) return [];

    return combinedData.filter((teamData: CombinedTeamData) =>
      teamData.team.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [combinedData, searchTerm]);

  const responsiveGridClasses =
    "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4";

  if (isError) {
    return (
      <div className="bg-brand-secondary p-8 rounded-lg text-center">
        <Info size={32} className="mx-auto text-brand-muted mb-3" />
        <p className="text-brand-light font-semibold">
          {t("error_loading_teams")}
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="relative">
        <Search
          className="absolute left-3.5 top-1/2 -translate-y-1/2 text-brand-muted"
          size={20}
        />
        <input
          type="text"
          placeholder={t("search_for_team_placeholder")}
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-3 pl-12 text-white focus:outline-none focus:ring-2 focus:ring-brand-purple"
        />
      </div>

      {isLoading ? (
        <div className={responsiveGridClasses}>
          {Array.from({ length: 12 }).map((_, i) => (
            <TeamCardSkeleton key={i} />
          ))}
        </div>
      ) : filteredTeams.length > 0 ? (
        <div className={responsiveGridClasses}>
          {filteredTeams.map((data: CombinedTeamData) => (
            <TeamCard
              key={data.team.id}
              team={data.team}
              venue={data.venue}
              rank={data.rank}
              countryName={countryName}
              countryFlag={countryFlag}
              rankDescription={data.description}
            />
          ))}
        </div>
      ) : (
        <div className="bg-brand-secondary p-8 rounded-lg text-center">
          <Info size={32} className="mx-auto text-brand-muted mb-3" />
          <p className="text-brand-light font-semibold">
            {t("no_teams_found_for_search", { searchTerm })}
          </p>
        </div>
      )}
    </div>
  );
}

// ===== src/components/league-detail-view/LeagueTopScorersWidget.tsx =====

"use client";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { Trophy, Info } from "lucide-react";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useTranslation } from "@/hooks/useTranslation";

const fetchTopScorers = async (leagueId: number, season: number) => {
  const { data } = await axios.get(
    `/api/top-scorers?league=${leagueId}&season=${season}`
  );
  return data;
};

const PlayerRow = ({ player, rank }: { player: any; rank: number }) => {
  const isTop = rank === 1;
  const bgColor = isTop ? "bg-[var(--brand-accent)]/10" : "bg-transparent";
  const borderColor = isTop
    ? "border-l-[var(--brand-accent)]"
    : "border-l-transparent";

  return (
    <div
      className={`flex items-center gap-3 p-2 rounded-lg transition-colors border-l-4 ${bgColor} ${borderColor}`}
    >
      <span
        className={`w-6 text-center font-bold text-lg ${
          isTop ? "text-[var(--brand-accent)]" : "text-text-muted"
        }`}
      >
        {rank}
      </span>
      <Image
        src={proxyImageUrl(player.player.photo)}
        alt={player.player.name}
        width={36}
        height={36}
        className="rounded-full bg-gray-800"
      />
      <div className="flex-1 min-w-0">
        <p className="font-bold text-white truncate text-sm">
          {player.player.name}
        </p>
        <p className="text-xs text-text-muted truncate">
          {player.statistics[0].team.name}
        </p>
      </div>
      <div
        className={`flex items-center justify-center gap-2 font-bold text-lg p-2 rounded-lg ${
          isTop ? "text-yellow-300" : "text-white"
        }`}
      >
        <Trophy size={16} />
        <span>{player.statistics[0].goals.total}</span>
      </div>
    </div>
  );
};

export default function LeagueTopScorersWidget({
  leagueId,
  season,
}: {
  leagueId: number;
  season: number;
}) {
  const { t } = useTranslation();
  const { data: topScorers, isLoading } = useQuery({
    queryKey: ["topScorers", leagueId, season],
    queryFn: () => fetchTopScorers(leagueId, season),
    staleTime: 1000 * 60 * 60,
  });

  const renderContent = () => {
    if (isLoading) {
      return (
        <div className="space-y-2 p-2 animate-pulse">
          {Array.from({ length: 5 }).map((_, i) => (
            <div key={i} className="flex items-center gap-3 p-2">
              <div className="w-6 h-6 rounded bg-gray-700"></div>
              <div className="w-9 h-9 rounded-full bg-gray-700"></div>
              <div className="flex-1 space-y-1.5">
                <div className="h-4 w-3/4 bg-gray-700 rounded"></div>
                <div className="h-3 w-1/2 bg-gray-700 rounded"></div>
              </div>
              <div className="w-12 h-8 rounded bg-gray-700"></div>
            </div>
          ))}
        </div>
      );
    }

    if (!topScorers || topScorers.length === 0) {
      return (
        <div className="text-center h-full flex flex-col justify-center items-center p-4">
          <Info size={28} className="mx-auto text-text-muted mb-2" />
          <p className="text-text-light font-semibold text-sm">
            {t("top_scorers_not_available")}
          </p>
        </div>
      );
    }

    return (
      <div className="space-y-1 p-2">
        {topScorers.slice(0, 5).map((scorer: any, index: number) => (
          <PlayerRow key={scorer.player.id} player={scorer} rank={index + 1} />
        ))}
      </div>
    );
  };

  return (
    <div className="bg-brand-secondary rounded-lg h-full flex flex-col">
      <div className="p-4 border-b border-gray-700/50">
        <h3 className="text-lg font-bold text-white">
          {t("golden_boot_race")}
        </h3>
      </div>
      <div className="flex-grow">{renderContent()}</div>
    </div>
  );
}

// ===== src/components/league-detail-view/TeamCard.tsx =====

import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import StyledLink from "@/components/StyledLink";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import { Users, MapPin, Calendar } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface TeamCardProps {
  team: any;
  venue: any;
  rank?: number;
  countryName?: string;
  countryFlag?: string;
  squadSize?: number;
  rankDescription?: string;
}

const getRankClasses = (
  description: string | null
): { border: string; text: string } => {
  if (!description)
    return { border: "border-gray-700/50", text: "text-brand-muted" };
  const desc = description.toLowerCase();
  if (desc.includes("champions league") || desc.includes("promotion"))
    return { border: "border-green-500", text: "text-green-400" };
  if (desc.includes("europa league") || desc.includes("qualification"))
    return { border: "border-orange-500", text: "text-orange-400" };
  if (desc.includes("conference league") || desc.includes("play-off"))
    return { border: "border-sky-400", text: "text-sky-300" };
  if (desc.includes("relegation"))
    return { border: "border-red-600", text: "text-red-500" };
  return { border: "border-gray-700/50", text: "text-brand-muted" };
};

export function TeamCardSkeleton() {
  return (
    <div className="bg-brand-secondary rounded-lg flex flex-col h-full animate-pulse">
      <div className="p-4 flex items-start gap-4">
        <div className="w-10 h-10 rounded-full bg-gray-700"></div>
        <div className="flex-1 space-y-2">
          <div className="h-4 w-3/4 bg-gray-600 rounded"></div>
          <div className="h-3 w-1/2 bg-gray-600/50 rounded"></div>
        </div>
      </div>
      <div className="px-4 pb-4 mt-auto space-y-2 border-t border-gray-700/50 pt-3">
        <div className="h-3 w-full bg-gray-600/50 rounded"></div>
        <div className="h-3 w-2/3 bg-gray-600/50 rounded"></div>
      </div>
    </div>
  );
}

export default function TeamCard({
  team,
  venue,
  rank,
  countryName,
  countryFlag,
  squadSize,
  rankDescription,
}: TeamCardProps) {
  const rankClasses = getRankClasses(rankDescription || null);
  const { t } = useTranslation();

  return (
    <StyledLink
      href={generateTeamSlug(team.name, team.id)}
      className="block group h-full"
    >
      <div
        className={`bg-brand-secondary rounded-lg flex flex-col h-full border-l-4 ${rankClasses.border} transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20`}
      >
        <div className="p-4 flex items-start gap-4">
          <Image
            src={proxyImageUrl(team.logo)}
            alt={team.name}
            width={40}
            height={40}
            className="flex-shrink-0 mt-1"
          />
          <div className="flex-1 min-w-0">
            <h4 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
              {team.name}
            </h4>
            {countryName && countryFlag && (
              <div className="flex items-center gap-1.5 text-xs text-brand-muted mt-1">
                <Image
                  src={countryFlag}
                  alt={countryName}
                  width={16}
                  height={16}
                  className="rounded-full"
                />
                <span>{countryName}</span>
              </div>
            )}
          </div>
          {rank && (
            <div className={`text-2xl font-black ${rankClasses.text}`}>
              {rank}
            </div>
          )}
        </div>

        <div className="px-4 pb-4 mt-auto space-y-1.5 border-t border-gray-700/50 pt-3">
          {squadSize && (
            <div className="flex items-center gap-2 text-xs text-brand-muted">
              <Users className="w-3 h-3" />
              <span>
                {t("squad_size")}: {squadSize}
              </span>
            </div>
          )}
          {team.founded && (
            <div className="flex items-center gap-2 text-xs text-brand-muted">
              <Calendar size={12} />
              <span>{t("founded_in", { year: team.founded })}</span>
            </div>
          )}
          {venue?.name && (
            <div className="flex items-center gap-2 text-xs text-brand-muted truncate">
              <MapPin className="w-3 h-3" />
              <span>{venue.name}</span>
            </div>
          )}
        </div>
      </div>
    </StyledLink>
  );
}

// ===== src/components/league-detail-view/index.tsx =====

"use client";

import Image from "next/image";
import { Shield, Users, Trophy, Flag, ArrowLeft } from "lucide-react";
import LeagueStatCard from "./LeagueStatCard";
import LeagueFixturesWidget from "./LeagueFixturesWidget";
import LeagueStandingsWidget from "./LeagueStandingsWidget";
import LeagueTopScorersWidget from "./LeagueTopScorersWidget";
import LeagueTeamsList from "./LeagueTeamsList";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateLeagueSlug } from "@/lib/generate-league-slug";
import { useLeagueContext } from "@/context/LeagueContext";
import { useTranslation } from "@/hooks/useTranslation";

export default function LeagueDetailView({ leagueData }: { leagueData: any }) {
  const { setSelectedLeague } = useLeagueContext();
  const { t } = useTranslation();

  const isFromSidebar = !!leagueData.logoUrl;

  const league = isFromSidebar
    ? {
        id: leagueData.id,
        name: leagueData.name,
        logo: leagueData.logoUrl,
        type: leagueData.type,
      }
    : leagueData.league;

  const country = isFromSidebar
    ? {
        name: leagueData.countryName,
        flag: leagueData.countryFlagUrl,
      }
    : leagueData.country;

  const seasons = leagueData.seasons || [];
  const standings = leagueData.standings || [];

  const currentSeason =
    seasons?.find((s: any) => s.current === true)?.year ||
    new Date().getFullYear();

  const leagueWithHref = {
    ...league,
    href: generateLeagueSlug(league.name, league.id),
  };

  const hasFullData = seasons && seasons.length > 0;

  return (
    <div className="flex flex-col gap-8">
      {}
      <button
        onClick={() => setSelectedLeague(null)}
        className="flex items-center gap-2 text-sm font-semibold text-brand-muted hover:text-white transition-colors self-start"
      >
        <ArrowLeft size={16} />
        {t("back_to_match_list")}
      </button>

      <div className="flex flex-col items-center text-center gap-4 p-4 bg-brand-secondary rounded-xl">
        <Image
          src={proxyImageUrl(league.logo)}
          alt={league.name}
          width={80}
          height={80}
          className="bg-white rounded-full p-2"
        />
        <h1 className="text-4xl font-extrabold text-white">{league.name}</h1>
        <div className="flex items-center gap-2 text-brand-muted">
          {country?.flag && (
            <Image
              src={proxyImageUrl(country.flag)}
              alt={country.name}
              width={20}
              height={20}
            />
          )}
          <span>{country?.name}</span>
        </div>
      </div>

      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <LeagueStatCard icon={<Shield />} label="Type" value={league.type} />
        <LeagueStatCard icon={<Flag />} label="Country" value={country?.name} />
        <LeagueStatCard
          icon={<Trophy />}
          label="Current Season"
          value={currentSeason}
        />
        <LeagueStatCard
          icon={<Users />}
          label="Teams"
          value={standings?.[0]?.length || "N/A"}
        />
      </div>

      <LeagueFixturesWidget leagueId={league.id} season={currentSeason} />

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
        {league.type === "League" && standings.length > 0 && (
          <LeagueStandingsWidget
            initialStandings={standings}
            leagueSeasons={seasons.map((s: any) => s.year)}
            currentSeason={currentSeason}
            isLoading={false}
            leagueId={league.id}
            leagueSlug={leagueWithHref.href.split("/").pop()}
          />
        )}

        {hasFullData && (
          <LeagueTopScorersWidget leagueId={league.id} season={currentSeason} />
        )}
      </div>

      {hasFullData && (
        <LeagueTeamsList
          leagueId={league.id}
          season={currentSeason}
          countryName={country.name}
          countryFlag={country.flag}
        />
      )}
    </div>
  );
}

// ===== src/components/match/BettingPromotionWidget.tsx =====

"use client";

import { memo } from 'react';
import Image from 'next/image';
import { ShieldCheck } from 'lucide-react';

const BettingPromotionWidget = memo(function BettingPromotionWidget() {

    const handleBetClick = () => {

    };

    return (
        <div className="bg-gradient-to-br from-green-500/20 to-brand-purple/20 p-4 rounded-xl border border-green-400/30 text-center space-y-3">

            {}
            {}

            <h3 className="text-lg font-bold text-white">
                Exclusive Welcome Offer!
            </h3>
            <p className="text-sm text-brand-light">
                Get a <span className="font-bold text-green-400">100% bonus</span> on your first deposit to bet on this match.
            </p>

            {}
            <div className="relative pt-2">
                <span className="absolute top-2 left-0 inline-flex h-full w-full rounded-lg bg-green-400 opacity-75 animate-ping"></span>
                <button
                    onClick={handleBetClick}
                    className="relative w-full bg-[#16A34A] text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2 hover:bg-green-700 transition-colors"
                >
                    <ShieldCheck size={18} />
                    <span>Claim Your Bonus</span>
                </button>
            </div>

            <p className="text-xs text-brand-muted/80">
                18+ | T&Cs apply. Gamble responsibly.
            </p>
        </div>
    );
});

export default BettingPromotionWidget;

// ===== src/components/match/FormGuide.tsx =====

"use client";
import { memo } from 'react';

const FormGuide = memo(function FormGuide({ form, teamId }: { form: any[], teamId: number }) {
    if (!form || form.length === 0) return null;

    return (
        <div className="flex items-center gap-1.5">
            {form.map((match: any) => {
                const goals = match.goals;
                const home = match.teams.home;

                let result = 'D';
                if (goals.home !== goals.away) {
                    const winnerId = goals.home > goals.away ? home.id : match.teams.away.id;
                    result = winnerId === teamId ? 'W' : 'L';
                }

                const classes = {
                    W: 'bg-green-500 text-green-900',
                    D: 'bg-gray-500 text-gray-900',
                    L: 'bg-red-500 text-red-900',
                };

                return (
                    <span key={match.fixture.id} className={`flex items-center justify-center w-6 h-6 rounded-full text-xs font-bold ${classes[result as keyof typeof classes]}`}>
                        {result}
                    </span>
                );
            })}
        </div>
    );
});
export default FormGuide;

// ===== src/components/match/HeaderOdds.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { useMemo } from "react";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useTranslation } from "@/hooks/useTranslation";

interface HeaderOddsProps {
  fixtureId: number;
  teams: { home: any; away: any };
}

const fetchOdds = async (fixtureId: number) => {
  const { data } = await axios.get(`/api/odds?fixture=${fixtureId}`);
  return data;
};

const calculateProbabilities = (
  odds: { home?: string; draw?: string; away?: string } | null
) => {
  if (!odds || !odds.home || !odds.draw || !odds.away) {
    return {
      probabilities: { home: 33, draw: 34, away: 33 },
      favoriteOutcome: "draw",
    };
  }

  const pHome = 1 / parseFloat(odds.home);
  const pDraw = 1 / parseFloat(odds.draw);
  const pAway = 1 / parseFloat(odds.away);
  const totalP = pHome + pDraw + pAway;

  const probabilities = {
    home: Math.round((pHome / totalP) * 100),
    draw: Math.round((pDraw / totalP) * 100),
    away: Math.round((pAway / totalP) * 100),
  };

  const totalRounded =
    probabilities.home + probabilities.draw + probabilities.away;
  if (totalRounded !== 100) {
    probabilities.draw += 100 - totalRounded;
  }

  const favoriteOutcome =
    odds.home <= odds.draw && odds.home <= odds.away
      ? "home"
      : odds.away <= odds.home && odds.away <= odds.draw
      ? "away"
      : "draw";

  return { probabilities, favoriteOutcome };
};

export default function HeaderOdds({ fixtureId, teams }: HeaderOddsProps) {
  const { t } = useTranslation();

  const { data: odds, isLoading } = useQuery({
    queryKey: ["headerOdds", fixtureId],
    queryFn: () => fetchOdds(fixtureId),
    staleTime: 1000 * 60 * 60,
    enabled: !!fixtureId,
  });

  const { probabilities, favoriteOutcome } = useMemo(
    () => calculateProbabilities(odds),
    [odds]
  );

  if (isLoading) {
    return (
      <div className="mt-4 animate-pulse">
        <div className="flex h-16 w-full rounded-lg bg-gray-700/50"></div>
        <div className="mt-1.5 h-2 w-full rounded-full bg-gray-700/50"></div>
      </div>
    );
  }

  if (!odds) return null;

  const OddSegment = ({
    label,
    team,
    odd,
    probability,
    isFavorite,
  }: {
    label: string;
    team?: any;
    odd?: string;
    probability: number;
    isFavorite: boolean;
  }) => (
    <button
      className={`flex-1 flex flex-col items-center justify-center p-2 rounded-md transition-colors duration-200
        ${
          isFavorite
            ? "bg-brand-purple/20"
            : "bg-gray-800/50 hover:bg-gray-700/50"
        }`}
    >
      {team?.logo && (
        <Image
          src={proxyImageUrl(team.logo)}
          alt={team.name}
          width={24}
          height={24}
        />
      )}
      <span
        className={`text-sm font-bold ${
          isFavorite ? "text-brand-purple" : "text-text-muted"
        }`}
      >
        {team ? team.name.split(" ").slice(-1)[0] : label}
      </span>
      <span className="text-base font-black text-white">{odd || "-"}</span>
    </button>
  );

  return (
    <div className="mt-4 w-full max-w-xs mx-auto">
      <div className="flex items-stretch justify-center gap-1">
        <OddSegment
          label={t("home_short")}
          team={teams.home}
          odd={odds.home}
          probability={probabilities.home}
          isFavorite={favoriteOutcome === "home"}
        />
        <OddSegment
          label={t("draw")}
          odd={odds.draw}
          probability={probabilities.draw}
          isFavorite={favoriteOutcome === "draw"}
        />
        <OddSegment
          label={t("away_short")}
          team={teams.away}
          odd={odds.away}
          probability={probabilities.away}
          isFavorite={favoriteOutcome === "away"}
        />
      </div>
      <div className="mt-1.5 flex w-full h-1.5 rounded-full overflow-hidden bg-brand-dark">
        <div
          className="bg-brand-purple h-full"
          style={{ width: `${probabilities.home}%` }}
        ></div>
        <div
          className="bg-gray-500 h-full"
          style={{ width: `${probabilities.draw}%` }}
        ></div>
        <div
          className="bg-blue-500 h-full"
          style={{ width: `${probabilities.away}%` }}
        ></div>
      </div>
    </div>
  );
}

// ===== src/components/match/LinkedNewsWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { IPost } from "@/models/Post";
import { Newspaper, Info, ArrowRight } from "lucide-react";
import SidebarNewsItem, { SidebarNewsItemSkeleton } from "../SidebarNewsItem";
import { useTranslation } from "@/hooks/useTranslation";
import Link from "next/link";

interface LinkedNewsWidgetProps {
  fixtureId: number;
}

const fetchLinkedNews = async (
  fixtureId: number,
  locale: string
): Promise<IPost[]> => {
  const params = new URLSearchParams({
    linkedFixtureId: fixtureId.toString(),
    limit: "5",
    language: locale,
  });
  const { data } = await axios.get(`/api/posts?${params.toString()}`);
  return data.posts || [];
};

export default function LinkedNewsWidget({ fixtureId }: LinkedNewsWidgetProps) {
  const { t, locale } = useTranslation();

  const {
    data: posts,
    isLoading,
    isError,
  } = useQuery<IPost[]>({
    queryKey: ["linkedNews", fixtureId, locale],
    queryFn: () => fetchLinkedNews(fixtureId, locale!),
    staleTime: 1000 * 60 * 10,
    enabled: !!fixtureId && !!locale,
  });

  if (isLoading) {
    return (
      <section className="bg-brand-secondary rounded-lg shadow-lg">
        <div className="flex justify-between items-center p-4 border-b border-gray-700/50">
          <div className="h-6 w-1/2 bg-gray-700 rounded animate-pulse"></div>
        </div>
        <div className="p-2 space-y-1">
          <SidebarNewsItemSkeleton />
          <SidebarNewsItemSkeleton />
          <SidebarNewsItemSkeleton />
        </div>
      </section>
    );
  }

  if (isError || !posts || posts.length === 0) {
    return null;
  }

  return (
    <section className="bg-brand-secondary rounded-lg shadow-lg">
      <div className="flex justify-between items-center p-4 border-b border-gray-700/50">
        <h2 className="text-xl font-bold text-white flex items-center gap-2">
          <Newspaper size={20} className="text-[var(--brand-accent)]" />
          {t("related_news")}
        </h2>
        <Link
          href="/news"
          className="flex items-center gap-1 text-xs font-semibold text-text-muted transition-colors hover:text-white"
        >
          {t("see_all")}
          <ArrowRight size={14} />
        </Link>
      </div>

      <div className="p-2 space-y-1">
        {posts.map((post) => (
          <SidebarNewsItem
            key={post._id as string}
            post={{
              ...post,
              slug: `/${post.language}/news/${post.slug}`,
            }}
          />
        ))}
      </div>
    </section>
  );
}

// ===== src/components/match/LiveOddsClient.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { TrendingUp, Goal, CornerUpRight, Users } from "lucide-react";

interface LiveOddsClientProps {
  initialOdds: any;
  fixtureId: string;
}

const fetchLiveOdds = async (fixtureId: string) => {
  const { data } = await axios.get(
    `/api/live-odds-by-fixture?fixture=${fixtureId}`
  );
  return data;
};

const OddsMarketRow = ({
  title,
  icon: Icon,
  oddsData,
  labels,
}: {
  title: string;
  icon: React.ElementType;
  oddsData: any | null;
  labels: { [key: string]: string };
}) => {
  if (!oddsData) return null;
  return (
    <div>
      <h4 className="flex items-center gap-2 text-sm font-semibold text-brand-light mb-2">
        <Icon size={16} className="text-brand-purple" />
        {title} {oddsData.handicap && `(${oddsData.handicap})`}
      </h4>
      <div className="grid grid-cols-2 gap-2">
        {Object.keys(labels).map(
          (key) =>
            oddsData[key] && (
              <div
                key={key}
                className="bg-gray-800/50 p-2 rounded-md flex justify-between items-center text-xs"
              >
                <span className="text-brand-muted">{labels[key]}</span>
                <span className="font-bold text-white">{oddsData[key]}</span>
              </div>
            )
        )}
      </div>
    </div>
  );
};

const LiveOddsSkeleton = () => (
  <div className="bg-brand-secondary p-4 rounded-lg animate-pulse">
    <div className="h-5 w-3/4 mb-4 bg-gray-700 rounded"></div>
    <div className="space-y-4">
      <div className="space-y-2">
        <div className="h-4 w-1/2 bg-gray-600 rounded"></div>
        <div className="grid grid-cols-2 gap-2">
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
        </div>
      </div>
      <div className="space-y-2">
        <div className="h-4 w-1/2 bg-gray-600 rounded"></div>
        <div className="grid grid-cols-2 gap-2">
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
        </div>
      </div>
    </div>
  </div>
);

export default function LiveOddsClient({
  initialOdds,
  fixtureId,
}: LiveOddsClientProps) {
  const { data: liveOdds, isLoading } = useQuery({
    queryKey: ["liveOdds", fixtureId],
    queryFn: () => fetchLiveOdds(fixtureId),
    initialData: initialOdds,
    staleTime: 10 * 1000,
    refetchInterval: 20 * 1000,
    enabled: !!fixtureId,
  });

  if (isLoading && !initialOdds) {
    return <LiveOddsSkeleton />;
  }

  if (!liveOdds) {
    return null;
  }

  return (
    <div className="bg-brand-secondary p-4 rounded-lg">
      <div className="flex items-center gap-2 mb-4">
        <TrendingUp size={20} className="text-green-400" />
        <h3 className="text-lg font-bold text-white">Live Odds</h3>
        <span className="relative flex h-3 w-3 ml-auto">
          <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
          <span className="relative inline-flex rounded-full h-3 w-3 bg-green-500"></span>
        </span>
      </div>

      <div className="space-y-4">
        <OddsMarketRow
          title="Over / Under"
          icon={Goal}
          oddsData={liveOdds.overUnder}
          labels={{ over: "Over", under: "Under" }}
        />
        <OddsMarketRow
          title="Asian Handicap"
          icon={Users}
          oddsData={liveOdds.asianHandicap}
          labels={{ home: "Home", away: "Away" }}
        />
        <OddsMarketRow
          title="Match Corners"
          icon={CornerUpRight}
          oddsData={liveOdds.matchCorners}
          labels={{ over: "Over", under: "Under" }}
        />
      </div>
    </div>
  );
}

// ===== src/components/match/LiveOddsWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { TrendingUp, Goal, CornerUpRight, Users } from "lucide-react";

interface LiveOddsWidgetProps {
  fixtureId: string;
}

const fetchLiveOdds = async (fixtureId: string) => {
  const { data } = await axios.get(
    `/api/live-odds-by-fixture?fixture=${fixtureId}`
  );
  return data;
};

const OddsMarketRow = ({
  title,
  icon: Icon,
  oddsData,
  labels,
}: {
  title: string;
  icon: React.ElementType;
  oddsData: any | null;
  labels: { [key: string]: string };
}) => {
  if (!oddsData) return null;
  return (
    <div>
      <h4 className="flex items-center gap-2 text-sm font-semibold text-brand-light mb-2">
        <Icon size={16} className="text-brand-purple" />
        {title} {oddsData.handicap && `(${oddsData.handicap})`}
      </h4>
      <div className="grid grid-cols-2 gap-2">
        {Object.keys(labels).map(
          (key) =>
            oddsData[key] && (
              <div
                key={key}
                className="bg-gray-800/50 p-2 rounded-md flex justify-between items-center text-xs"
              >
                <span className="text-brand-muted">{labels[key]}</span>
                <span className="font-bold text-white">{oddsData[key]}</span>
              </div>
            )
        )}
      </div>
    </div>
  );
};

const LiveOddsSkeleton = () => (
  <div className="bg-brand-secondary p-4 rounded-lg animate-pulse">
    <div className="h-5 w-3/4 mb-4 bg-gray-700 rounded"></div>
    <div className="space-y-4">
      <div className="space-y-2">
        <div className="h-4 w-1/2 bg-gray-600 rounded"></div>
        <div className="grid grid-cols-2 gap-2">
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
        </div>
      </div>
      <div className="space-y-2">
        <div className="h-4 w-1/2 bg-gray-600 rounded"></div>
        <div className="grid grid-cols-2 gap-2">
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
        </div>
      </div>
    </div>
  </div>
);

export default function LiveOddsWidget({ fixtureId }: LiveOddsWidgetProps) {
  const {
    data: liveOdds,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["liveOdds", fixtureId],
    queryFn: () => fetchLiveOdds(fixtureId),
    staleTime: 10 * 1000,
    refetchInterval: 20 * 1000,
    enabled: !!fixtureId,
  });

  if (isLoading) return <LiveOddsSkeleton />;
  if (isError || !liveOdds) return null;

  return (
    <div className="bg-brand-secondary p-4 rounded-lg">
      <div className="flex items-center gap-2 mb-4">
        <TrendingUp size={20} className="text-green-400" />
        <h3 className="text-lg font-bold text-white">Live Odds</h3>
        <span className="relative flex h-3 w-3 ml-auto">
          <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
          <span className="relative inline-flex rounded-full h-3 w-3 bg-green-500"></span>
        </span>
      </div>
      <div className="space-y-4">
        <OddsMarketRow
          title="Over / Under"
          icon={Goal}
          oddsData={liveOdds.overUnder}
          labels={{ over: "Over", under: "Under" }}
        />
        <OddsMarketRow
          title="Asian Handicap"
          icon={Users}
          oddsData={liveOdds.asianHandicap}
          labels={{ home: "Home", away: "Away" }}
        />
        <OddsMarketRow
          title="Match Corners"
          icon={CornerUpRight}
          oddsData={liveOdds.matchCorners}
          labels={{ over: "Over", under: "Under" }}
        />
      </div>
    </div>
  );
}

// ===== src/components/match/MatchAboutWidget.tsx =====

"use client";

import { Info } from "lucide-react";

interface MatchAboutWidgetProps {
  title: string;
  seoText: string;
}

export default function MatchAboutWidget({
  title,
  seoText,
}: MatchAboutWidgetProps) {
  if (!seoText) return null;

  return (
    <div className="bg-brand-secondary rounded-lg p-4">
      <h3 className="text-lg font-bold text-white mb-3 flex items-center gap-2">
        <Info size={26} className="text-[var(--brand-accent)]" />
        {title}
      </h3>
      <div
        className="prose prose-sm prose-invert max-w-none text-text-secondary leading-relaxed"
        dangerouslySetInnerHTML={{ __html: seoText }}
      />
    </div>
  );
}

// ===== src/components/match/MatchActivityClient.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import { memo, useMemo } from "react";
import axios from "axios";
import {
  Clock,
  Goal,
  ArrowLeftRight,
  RectangleVertical,
  Info,
} from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface MatchEvent {
  time: { elapsed: number };
  team: { id: number; name: string; logo: string };
  player: { id: number; name: string };
  assist: { id: number | null; name: string | null };
  type: "Goal" | "Card" | "subst" | "Var";
  detail: string;
}

const fetchFixtureEvents = async (fixtureId: string): Promise<MatchEvent[]> => {
  const { data } = await axios.get(`/api/match-details?fixture=${fixtureId}`);
  return data?.events || [];
};

const getEventStyles = (type: string, detail: string) => {
  switch (type) {
    case "Goal":
      return { bg: "bg-green-500/10", iconColor: "text-green-400" };
    case "Card":
      return detail.includes("Yellow")
        ? { bg: "bg-yellow-500/10", iconColor: "text-yellow-400" }
        : { bg: "bg-red-500/10", iconColor: "text-red-400" };
    case "subst":
      return { bg: "bg-blue-500/10", iconColor: "text-blue-400" };
    default:
      return { bg: "bg-gray-500/10", iconColor: "text-gray-400" };
  }
};

const EventRow = memo(
  ({
    event,
    t,
  }: {
    event: MatchEvent;
    t: (key: string, params?: any) => string;
  }) => {
    const styles = getEventStyles(event.type, event.detail);
    const Icon =
      event.type === "Goal"
        ? Goal
        : event.type === "Card"
        ? RectangleVertical
        : event.type === "subst"
        ? ArrowLeftRight
        : Clock;
    const assistText = event.assist.name
      ? t("assist_by", { name: event.assist.name })
      : "";

    return (
      <div className="relative">
        <div
          className={`absolute -left-[38px] top-1 w-8 h-8 rounded-full flex items-center justify-center ${styles.bg} ${styles.iconColor} border-4 border-brand-dark`}
        >
          <Icon size={16} />
        </div>
        <div>
          <p className="text-xs font-bold text-brand-muted">
            {event.time.elapsed}' - {event.detail}
          </p>
          <p className="font-semibold text-white">{event.player.name}</p>
          {event.assist.name && (
            <p className="text-sm text-brand-light">{assistText}</p>
          )}
        </div>
      </div>
    );
  }
);
EventRow.displayName = "EventRow";

export default function MatchActivityClient({
  initialEvents,
  fixtureId,
  isLive,
  activitySeoDescription,
}: {
  initialEvents: MatchEvent[];
  fixtureId: string;
  isLive: boolean;
  activitySeoDescription: string;
}) {
  const { t } = useTranslation();

  const { data: events } = useQuery<MatchEvent[]>({
    queryKey: ["fixtureEvents", fixtureId],
    queryFn: () => fetchFixtureEvents(fixtureId),
    initialData: initialEvents,
    refetchInterval: isLive ? 15000 : false,
    staleTime: isLive ? 10000 : Infinity,
  });

  const sortedEvents = useMemo(() => {
    if (!events) return [];
    return [...events].sort((a, b) => b.time.elapsed - a.time.elapsed);
  }, [events]);

  return (
    <div className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden">
      <div className="p-4 md:p-6">
        <h2 className="text-2xl font-bold text-white mb-4">
          {t("match_timeline")}
        </h2>
        <p className="italic text-brand-muted leading-relaxed mb-8 text-sm">
          {activitySeoDescription}
        </p>

        {sortedEvents.length === 0 ? (
          <div className="text-center py-10 text-brand-muted">
            <Info size={32} className="mx-auto mb-3" />
            <p>{t("match_not_started")}</p>
          </div>
        ) : (
          <div className="relative border-l-2 border-gray-700/50 ml-6 pl-8 space-y-8">
            {sortedEvents.map((event, index) => (
              <EventRow
                key={`${event.time.elapsed}-${event.player.id}-${index}`}
                event={event}
                t={t}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/match/MatchActivityWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import { memo, useMemo } from "react";
import axios from "axios";
import {
  Clock,
  Goal,
  ArrowLeftRight,
  RectangleVertical,
  Info,
  Shield,
  Video,
  Flag,
} from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface MatchEvent {
  time: { elapsed: number; extra: number | null };
  team: { id: number; name: string; logo: string };
  player: { id: number; name: string };
  assist: { id: number | null; name: string | null };
  type: "Goal" | "Card" | "subst" | "Var";
  detail: string;
}

const fetchFixtureEvents = async (fixtureId: string): Promise<MatchEvent[]> => {
  if (!fixtureId) return [];
  const { data } = await axios.get(`/api/match-details?fixture=${fixtureId}`);
  return data?.fixture?.events || [];
};

const getEventStyles = (type: string, detail: string) => {
  switch (type) {
    case "Goal":
      return {
        Icon: Goal,
        color: "text-green-400",
        border: "border-green-500",
      };
    case "Card":
      return detail.includes("Yellow")
        ? {
            Icon: RectangleVertical,
            color: "text-yellow-400",
            border: "border-yellow-500",
          }
        : {
            Icon: RectangleVertical,
            color: "text-red-400",
            border: "border-red-500",
          };
    case "subst":
      return {
        Icon: ArrowLeftRight,
        color: "text-blue-400",
        border: "border-blue-500",
      };
    case "Var":
      return {
        Icon: Video,
        color: "text-purple-400",
        border: "border-purple-500",
      };
    default:
      return { Icon: Clock, color: "text-gray-400", border: "border-gray-500" };
  }
};

const EventRow = memo(
  ({ event, isHomeTeam }: { event: MatchEvent; isHomeTeam: boolean }) => {
    const { Icon, color, border } = getEventStyles(event.type, event.detail);

    const eventTime = `${event.time.elapsed}${
      event.time.extra ? `+${event.time.extra}` : ""
    }'`;

    return (
      <div
        className={`flex relative ${
          isHomeTeam ? "justify-start" : "justify-end"
        }`}
      >
        {}
        <div
          className={`absolute top-5 h-px w-[calc(50%-1.5rem)] bg-gray-700/50 ${
            isHomeTeam ? "right-1/2" : "left-1/2"
          }`}
        ></div>

        {}
        <div
          className={`w-[calc(50%-1.5rem)] relative p-3 rounded-lg border-l-4 bg-white/5 backdrop-blur-sm shadow-md ${border}`}
        >
          {}
          <div
            className={`absolute top-1/2 -translate-y-1/2 w-3 h-3 bg-gray-800 rotate-45 ${
              isHomeTeam ? "right-[-7px]" : "left-[-7px]"
            }`}
          ></div>

          <div className="flex items-start gap-3">
            <Icon size={20} className={`${color} flex-shrink-0 mt-0.5`} />
            <div className="min-w-0">
              <p className="font-bold text-white text-sm truncate">
                {event.player.name}
              </p>
              <p className="text-xs text-brand-light truncate">
                {event.detail}
              </p>
              {event.assist.name && (
                <p className="text-xs text-brand-muted truncate">
                  Assist: {event.assist.name}
                </p>
              )}
            </div>
          </div>
        </div>

        {}
        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-8 h-8 flex items-center justify-center bg-brand-dark rounded-full border-2 border-gray-700">
          <span className="text-xs font-mono font-bold text-brand-muted">
            {eventTime}
          </span>
        </div>
      </div>
    );
  }
);
EventRow.displayName = "EventRow";

const PeriodHeader = ({
  period,
  t,
}: {
  period: string;
  t: (key: string) => string;
}) => {
  const periodTranslations: Record<string, string> = {
    HT: t("half_time"),
    FT: t("full_time"),
  };
  const text = periodTranslations[period] || period;
  return (
    <div className="flex items-center gap-4 my-4">
      <div className="flex-grow h-px bg-gray-700"></div>
      <span className="text-xs font-bold text-brand-muted uppercase tracking-wider">
        {text}
      </span>
      <div className="flex-grow h-px bg-gray-700"></div>
    </div>
  );
};

const ActivitySkeleton = () => (
  <div className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden animate-pulse p-6 min-h-[400px]">
    <div className="h-8 w-1/3 bg-gray-700 rounded mb-4"></div>
    <div className="h-4 w-full bg-gray-600 rounded mb-8"></div>
    <div className="relative mx-auto w-0.5 h-[200px] bg-gray-700/50">
      {}
      <div className="absolute top-8 right-6 w-[calc(50vw-5rem)] max-w-[200px] h-20 bg-gray-700/50 rounded-lg"></div>
      {}
      <div className="absolute top-32 left-6 w-[calc(50vw-5rem)] max-w-[200px] h-20 bg-gray-700/50 rounded-lg"></div>
    </div>
  </div>
);

export default function MatchActivityWidget({
  fixtureId,
  isLive,
  homeTeamId,
}: {
  fixtureId: string;
  isLive: boolean;
  homeTeamId: number;
}) {
  const { t } = useTranslation();

  const {
    data: events,
    isLoading,
    isError,
  } = useQuery<MatchEvent[]>({
    queryKey: ["fixtureEvents", fixtureId],
    queryFn: () => fetchFixtureEvents(fixtureId),
    refetchInterval: isLive ? 15000 : false,
    staleTime: isLive ? 10000 : Infinity,
    enabled: !!fixtureId,
  });

  const timelineItems = useMemo(() => {
    if (!events) return [];

    const sorted = [...events].sort((a, b) => a.time.elapsed - b.time.elapsed);
    const items: (MatchEvent | { type: "PeriodSeparator"; detail: string })[] =
      [];

    let lastPeriod = "1H";
    items.push({ type: "PeriodSeparator", detail: "Match Started" });

    sorted.forEach((event) => {
      if (event.time.elapsed > 45 && lastPeriod === "1H") {
        items.push({ type: "PeriodSeparator", detail: "HT" });
        lastPeriod = "2H";
      }
      if (event.time.elapsed > 90 && lastPeriod === "2H") {
        items.push({ type: "PeriodSeparator", detail: "FT" });
        lastPeriod = "ET";
      }
      items.push(event);
    });

    if (isLive && sorted.length > 0) {

    } else if (sorted.length > 0) {
      items.push({ type: "PeriodSeparator", detail: "FT" });
    }

    return items.reverse();
  }, [events, isLive]);

  if (isLoading) return <ActivitySkeleton />;

  return (
    <div className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden">
      <div className="p-4 md:p-6">
        <h2 className="text-2xl font-bold text-white mb-4">
          {t("match_timeline")}
        </h2>

        {isError || timelineItems.length <= 2 ? (
          <div className="text-center py-10 text-brand-muted">
            <Info size={32} className="mx-auto mb-3" />
            <p>{t("match_not_started")}</p>
          </div>
        ) : (
          <div className="relative">
            <div className="absolute top-0 bottom-0 left-1/2 -translate-x-1/2 w-0.5 bg-gradient-to-t from-gray-800 to-gray-700"></div>
            <div className="absolute top-0 left-1/2 -translate-x-1/2 -mt-3 p-2 bg-gray-700 rounded-full">
              <Clock size={16} />
            </div>
            {isLive ? null : (
              <div className="absolute bottom-0 left-1/2 -translate-x-1/2 -mb-3 p-2 bg-gray-700 rounded-full">
                <Flag size={16} />
              </div>
            )}

            <div className="space-y-6 pt-4 pb-4">
              {timelineItems.map((item, index) => {
                if (item.type === "PeriodSeparator") {
                  return (
                    <PeriodHeader
                      key={`period-${index}`}
                      period={item.detail}
                      t={t}
                    />
                  );
                }
                return (
                  <EventRow
                    key={`${item.time.elapsed}-${item.player.id}-${index}`}
                    event={item}
                    isHomeTeam={item.team.id === homeTeamId}
                    t={t}
                  />
                );
              })}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/match/MatchAnalyticsWidget.tsx =====

import { memo } from 'react';
import Image from 'next/image';
import { CheckCircle, XCircle, ShieldQuestion, TrendingUp, TrendingDown } from 'lucide-react';

const FormGuide = memo(function FormGuide({ formString }: { formString: string }) {
    if (!formString) return <span className="text-xs text-text-muted">N/A</span>;

    return (
        <div className="flex items-center gap-1.5">
            {formString.split('').slice(0, 5).map((result, index) => {
                const classes = {
                    W: 'bg-green-500 text-green-900',
                    D: 'bg-gray-500 text-gray-900',
                    L: 'bg-red-500 text-red-900',
                };
                return (
                    <span
                        key={index}
                        className={`flex items-center justify-center w-6 h-6 rounded-full text-xs font-bold ${classes[result as keyof typeof classes]}`}
                    >
                        {result}
                    </span>
                );
            })}
        </div>
    );
});

const MatchAnalyticsWidget = memo(function MatchAnalyticsWidget({ analytics }: { analytics: any }) {

    if (!analytics?.prediction || !analytics.homeTeamStats || !analytics.awayTeamStats) {
        return (
             <div className="bg-brand-secondary rounded-xl">
                <h3 className="text-lg font-bold p-4 border-b border-gray-700/50">Prediction & Form</h3>
                <p className="text-text-muted text-center py-8">Analytics are not available for this match.</p>
            </div>
        );
    }

    const { prediction, homeTeamStats, awayTeamStats } = analytics;
    const { percent } = prediction.predictions;
    const btts = prediction.comparison.btts === 'Yes';
    const overUnder = prediction.comparison.under_over === 'Over 2.5';

    const homePercent = parseFloat(percent.home.replace('%', ''));
    const drawPercent = parseFloat(percent.draw.replace('%', ''));
    const awayPercent = parseFloat(percent.away.replace('%', ''));

    return (
        <div className="bg-brand-secondary rounded-xl">
            <h3 className="text-lg font-bold p-4 border-b border-gray-700/50">Prediction & Form</h3>
            <div className="p-4 space-y-5">

                {}
                <div>
                    <div className="flex justify-between items-center mb-1.5">
                        <div className="flex flex-col items-center gap-1 text-center">
                            <Image src={homeTeamStats.team.logo} alt={homeTeamStats.team.name} width={32} height={32} />
                            <span className="font-bold text-lg text-white">{homePercent}%</span>
                        </div>
                        <div className="flex flex-col items-center gap-1 text-center">
                            <span className="text-text-muted text-sm font-semibold">Draw</span>
                            <span className="font-bold text-lg text-white">{drawPercent}%</span>
                        </div>
                        <div className="flex flex-col items-center gap-1 text-center">
                            <Image src={awayTeamStats.team.logo} alt={awayTeamStats.team.name} width={32} height={32} />
                            <span className="font-bold text-lg text-white">{awayPercent}%</span>
                        </div>
                    </div>
                    {}
                    <div className="flex w-full h-2 rounded-full overflow-hidden" style={{ backgroundColor: 'var(--color-secondary)' }}>
                        <div className="bg-brand-purple" style={{ width: `${homePercent}%` }}></div>
                        <div className="bg-gray-500" style={{ width: `${drawPercent}%` }}></div>
                        <div className="bg-brand-highlight" style={{ width: `${awayPercent}%` }}></div>
                    </div>
                </div>

                {}
                <div className="grid grid-cols-2 gap-3 text-sm">
                    <div className="flex items-center gap-2 p-3 rounded-lg" style={{backgroundColor: 'var(--color-primary)'}}>
                        {btts ? <CheckCircle size={20} className="text-green-400" /> : <XCircle size={20} className="text-red-400" />}
                        <span className="font-semibold">Both Teams to Score</span>
                    </div>
                     <div className="flex items-center gap-2 p-3 rounded-lg" style={{backgroundColor: 'var(--color-primary)'}}>
                        {overUnder ? <TrendingUp size={20} className="text-green-400" /> : <TrendingDown size={20} className="text-red-400" />}
                        <span className="font-semibold">Over 2.5 Goals</span>
                    </div>
                </div>

                {}
                <div className="space-y-3">
                    <div className="flex items-center justify-between">
                        <span className="font-semibold text-text-secondary">{homeTeamStats.team.name}</span>
                        <FormGuide formString={homeTeamStats.form} />
                    </div>
                    <div className="flex items-center justify-between">
                        <span className="font-semibold text-text-secondary">{awayTeamStats.team.name}</span>
                        <FormGuide formString={awayTeamStats.form} />
                    </div>
                </div>

                {}
                {prediction.predictions.advice && (
                    <div className="flex items-center gap-2 p-3 text-center rounded-lg border-2 border-dashed border-gray-700">
                        <ShieldQuestion size={20} className="text-brand-purple flex-shrink-0" />
                        <p className="text-sm font-semibold text-text-secondary">{prediction.predictions.advice}</p>
                    </div>
                )}
            </div>
        </div>
    );
});

export default MatchAnalyticsWidget;

// ===== src/components/match/MatchFormationWidget.tsx =====

"use client";

import { memo } from "react";
import Image from "next/image";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { proxyImageUrl } from "@/lib/image-proxy";
import { Shirt, Users, UserSquare } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

const fetchLineups = async (fixtureId: string) => {
  const { data } = await axios.get(`/api/lineups?fixtureId=${fixtureId}`);
  return data;
};

const mapFormationToPositions = (
  formation: string,
  startXI: any[],
  isHomeTeam: boolean
) => {
  if (
    !formation ||
    !startXI ||
    !Array.isArray(startXI) ||
    startXI.length < 11
  ) {
    return [];
  }
  const formationParts = formation
    .split("-")
    .map(Number)
    .filter((n) => !isNaN(n));
  if (formationParts.reduce((a, b) => a + b, 0) !== 10) return [];

  const players = [...startXI];
  const positionedPlayers = [];

  const goalkeeper = players.find((p) => p.player.pos === "G");
  if (goalkeeper) {
    positionedPlayers.push({
      ...goalkeeper.player,
      pos: { x: 50, y: isHomeTeam ? 95 : 5 },
    });
  }

  const outfieldPlayers = players.filter((p) => p.player.pos !== "G");

  if (!isHomeTeam) outfieldPlayers.reverse();

  const totalRows = formationParts.length;
  let playerIndex = 0;

  formationParts.forEach((playersInRow, rowIndex) => {
    const y = isHomeTeam
      ? 90 - ((rowIndex + 1) / (totalRows + 1)) * 40
      : 10 + ((rowIndex + 1) / (totalRows + 1)) * 40;

    for (let i = 0; i < playersInRow; i++) {
      if (playerIndex < outfieldPlayers.length) {
        const x = (100 / (playersInRow + 1)) * (i + 1);
        positionedPlayers.push({
          ...outfieldPlayers[playerIndex].player,
          pos: { x, y },
        });
        playerIndex++;
      }
    }
  });

  return positionedPlayers;
};

const Player = memo(
  ({ player, colorClass }: { player: any; colorClass: string }) => {

    const playerPhotoUrl = `https://media.api-sports.io/football/players/${player.id}.png`;

    return (
      <div
        className="absolute -translate-x-1/2 -translate-y-1/2 flex flex-col items-center gap-1 group cursor-pointer"
        style={{ top: `${player.pos.y}%`, left: `${player.pos.x}%` }}
        title={player.name}
      >
        <div className="relative">
          <Image
            src={proxyImageUrl(playerPhotoUrl)}
            alt={player.name}
            width={40}
            height={40}
            unoptimized={true}
            className="rounded-full bg-black/20 w-10 h-10 object-cover"
          />
          <div
            className={`absolute -bottom-1 -right-1 w-5 h-5 flex items-center justify-center rounded-full font-bold text-white text-[10px] shadow-md border-2 border-brand-dark ${colorClass}`}
          >
            {player.number}
          </div>
        </div>
        <span className="text-xs font-semibold text-white bg-black/60 px-2 py-0.5 rounded-md whitespace-nowrap shadow-lg">
          {player.name.split(" ").slice(-1)[0]}
        </span>
      </div>
    );
  }
);
Player.displayName = "Player";

const FormationSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg p-4 md:p-6 animate-pulse">
    <div className="h-8 w-1/3 mx-auto bg-gray-700 rounded mb-6"></div>
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
      <div className="aspect-[7/10] w-full bg-gray-700/50 rounded-lg"></div>
      <div className="aspect-[7/10] w-full bg-gray-700/50 rounded-lg"></div>
    </div>
  </div>
);

export default memo(function MatchFormationWidget({
  fixtureId,
}: {
  fixtureId: string;
}) {
  const { t } = useTranslation();

  const {
    data: lineups,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["lineups", fixtureId],
    queryFn: () => fetchLineups(fixtureId),
    staleTime: 1000 * 60 * 5,
    enabled: !!fixtureId,
  });

  if (isLoading) {
    return <FormationSkeleton />;
  }

  if (
    isError ||
    !lineups ||
    lineups.length < 2 ||
    !lineups[0].formation ||
    !lineups[1].formation ||
    !lineups[0].startXI ||
    !lineups[1].startXI
  ) {
    return null;
  }

  const homeLineup = lineups[0];
  const awayLineup = lineups[1];
  const homePositionedPlayers = mapFormationToPositions(
    homeLineup.formation,
    homeLineup.startXI,
    true
  );
  const awayPositionedPlayers = mapFormationToPositions(
    awayLineup.formation,
    awayLineup.startXI,
    false
  );

  return (
    <div className="bg-brand-secondary rounded-lg p-4 md:p-6">
      <h2 className="text-2xl font-bold text-white mb-6 text-center">
        {t("formations")}
      </h2>

      <div className="flex justify-between items-center mb-4 px-4">
        <div className="flex items-center gap-3">
          <Image
            src={proxyImageUrl(homeLineup.team.logo)}
            alt={homeLineup.team.name}
            width={40}
            height={40}
            unoptimized={true}
          />
          <div className="text-left">
            <h3 className="font-bold text-lg text-white">
              {homeLineup.team.name}
            </h3>
            <p className="text-sm font-semibold text-brand-muted">
              {homeLineup.formation}
            </p>
          </div>
        </div>
        <div className="flex items-center gap-3">
          <div className="text-right">
            <h3 className="font-bold text-lg text-white">
              {awayLineup.team.name}
            </h3>
            <p className="text-sm font-semibold text-brand-muted">
              {awayLineup.formation}
            </p>
          </div>
          <Image
            src={proxyImageUrl(awayLineup.team.logo)}
            alt={awayLineup.team.name}
            width={40}
            height={40}
          />
        </div>
      </div>

      <div className="w-full max-w-lg mx-auto">
        <div
          className="relative aspect-[7/10] w-full rounded-lg overflow-hidden border-2 border-white/10"
          style={{
            background: "radial-gradient(circle, #057F3A 0%, #034F24 100%)",
          }}
        >
          <div className="absolute inset-0 z-0 opacity-50">
            <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[30%] aspect-square rounded-full border-2 border-white/20"></div>
            <div className="absolute top-1/2 left-0 w-full h-0.5 bg-white/20"></div>
            <div className="absolute top-0 left-[20%] w-[60%] h-[15%] rounded-b-xl border-b-2 border-l-2 border-r-2 border-white/20"></div>
            <div className="absolute bottom-0 left-[20%] w-[60%] h-[15%] rounded-t-xl border-t-2 border-l-2 border-r-2 border-white/20"></div>
          </div>
          <div className="absolute inset-0 z-10">
            {homePositionedPlayers.map((player) => (
              <Player
                key={`home-${player.id}`}
                player={player}
                colorClass="bg-[var(--brand-accent)]"
              />
            ))}
            {awayPositionedPlayers.map((player) => (
              <Player
                key={`away-${player.id}`}
                player={player}
                colorClass="bg-blue-600"
              />
            ))}
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
        <div className="bg-brand-dark/30 p-3 rounded-lg space-y-2">
          <h4 className="flex items-center gap-2 font-bold text-sm text-brand-muted">
            <Users size={16} /> {t("substitutes")} ({homeLineup.team.name})
          </h4>
          <p className="text-xs text-brand-light leading-relaxed">
            {homeLineup.substitutes.map((p: any) => p.player.name).join(", ")}
          </p>
        </div>
        <div className="bg-brand-dark/30 p-3 rounded-lg space-y-2">
          <h4 className="flex items-center gap-2 font-bold text-sm text-brand-muted">
            <Users size={16} /> {t("substitutes")} ({awayLineup.team.name})
          </h4>
          <p className="text-xs text-brand-light leading-relaxed">
            {awayLineup.substitutes.map((p: any) => p.player.name).join(", ")}
          </p>
        </div>
        <div className="bg-brand-dark/30 p-3 rounded-lg">
          <h4 className="flex items-center gap-2 font-bold text-sm text-brand-muted">
            <UserSquare size={16} /> {t("coach")}
          </h4>
          <p className="text-sm font-semibold text-brand-light mt-1">
            {homeLineup.coach.name}
          </p>
        </div>
        <div className="bg-brand-dark/30 p-3 rounded-lg">
          <h4 className="flex items-center gap-2 font-bold text-sm text-brand-muted">
            <UserSquare size={16} /> {t("coach")}
          </h4>
          <p className="text-sm font-semibold text-brand-light mt-1">
            {awayLineup.coach.name}
          </p>
        </div>
      </div>
    </div>
  );
});

// ===== src/components/match/MatchH2HWidget.tsx =====

"use client";

import { useMemo, useState } from "react";
import Image from "next/image";
import { format } from "date-fns";
import Link from "next/link";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { CalendarDays, Info, ChevronRight } from "lucide-react";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateMatchSlug } from "@/lib/generate-match-slug";
import { useTranslation } from "@/hooks/useTranslation";

interface MatchH2HWidgetProps {
  teams: {
    home: { id: number; name: string; logo: string };
    away: { id: number; name: string; logo: string };
  };
  currentFixtureId: string;
  h2hSeoDescription: string;
}

const fetchH2HData = async (homeTeamId: number, awayTeamId: number) => {
  if (!homeTeamId || !awayTeamId) return [];
  const { data } = await axios.get(
    `/api/h2h?home=${homeTeamId}&away=${awayTeamId}`
  );
  return data || [];
};

const H2HSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden animate-pulse p-6">
    <div className="h-8 w-1/3 bg-gray-700 rounded mb-4"></div>
    <div className="h-4 w-full bg-gray-600 rounded mb-6"></div>
    <div className="grid grid-cols-3 gap-4 mb-6">
      <div className="flex flex-col items-center space-y-2">
        <div className="w-12 h-12 rounded-full bg-gray-700"></div>
        <div className="h-6 w-8 bg-gray-600 rounded"></div>
      </div>
      <div className="flex flex-col items-center justify-center space-y-2">
        <div className="h-6 w-8 bg-gray-600 rounded"></div>
      </div>
      <div className="flex flex-col items-center space-y-2">
        <div className="w-12 h-12 rounded-full bg-gray-700"></div>
        <div className="h-6 w-8 bg-gray-600 rounded"></div>
      </div>
    </div>
    <div className="space-y-3">
      <div className="h-12 bg-gray-700/50 rounded-md"></div>
      <div className="h-12 bg-gray-700/50 rounded-md"></div>
      <div className="h-12 bg-gray-700/50 rounded-md"></div>
    </div>
  </div>
);

export default function MatchH2HWidget({
  teams,
  currentFixtureId,
}: MatchH2HWidgetProps) {
  const [showAll, setShowAll] = useState(false);
  const { t } = useTranslation();

  const {
    data: h2h,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["h2hData", teams.home.id, teams.away.id],
    queryFn: () => fetchH2HData(teams.home.id, teams.away.id),
    staleTime: 1000 * 60 * 60,
    enabled: !!teams.home.id && !!teams.away.id,
  });

  const filteredH2H = useMemo(
    () =>
      h2h?.filter(
        (match: any) => match.fixture.id !== parseInt(currentFixtureId)
      ) || [],
    [h2h, currentFixtureId]
  );

  const displayedH2H = showAll ? filteredH2H : filteredH2H.slice(0, 5);

  const headToHeadRecords = useMemo(() => {
    if (!filteredH2H || filteredH2H.length === 0) {
      return { homeWins: 0, awayWins: 0, draws: 0 };
    }
    let homeWins = 0,
      awayWins = 0,
      draws = 0;

    filteredH2H.forEach((match: any) => {

      if (match.teams.home.winner === true) {
        homeWins++;
      } else if (match.teams.away.winner === true) {
        awayWins++;
      } else {
        draws++;
      }

    });
    return { homeWins, awayWins, draws };
  }, [filteredH2H, teams]);

  if (isLoading) return <H2HSkeleton />;

  return (
    <div className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden">
      <div className="p-6">
        <h2 className="text-2xl font-bold text-white mb-4">
          {t("head_to_head")}
        </h2>

        {isError || filteredH2H.length === 0 ? (
          <div className="text-center py-10 text-brand-muted">
            <Info size={32} className="mx-auto mb-3" />
            <p>{t("no_h2h_matches_found")}</p>
          </div>
        ) : (
          <>
            <div className="grid grid-cols-3 text-center gap-4 mb-6">
              <div className="flex flex-col items-center p-3 bg-gray-800/30 rounded-lg">
                <Image
                  src={proxyImageUrl(teams.home.logo)}
                  alt={teams.home.name}
                  width={40}
                  height={40}
                  className="w-10 h-10 object-contain mb-2"
                />
                <span className="text-white font-black text-xl">
                  {headToHeadRecords.homeWins}
                </span>
                <span className="text-brand-muted text-xs font-bold">
                  {t("wins")}
                </span>
              </div>
              <div className="flex flex-col items-center justify-center p-3 bg-gray-800/30 rounded-lg">
                <span className="text-white font-black text-xl">
                  {headToHeadRecords.draws}
                </span>
                <span className="text-brand-muted text-xs font-bold">
                  {t("draws")}
                </span>
              </div>
              <div className="flex flex-col items-center p-3 bg-gray-800/30 rounded-lg">
                <Image
                  src={proxyImageUrl(teams.away.logo)}
                  alt={teams.away.name}
                  width={40}
                  height={40}
                  className="w-10 h-10 object-contain mb-2"
                />
                <span className="text-white font-black text-xl">
                  {headToHeadRecords.awayWins}
                </span>
                <span className="text-brand-muted text-xs font-bold">
                  {t("wins")}
                </span>
              </div>
            </div>

            <div className="space-y-3">
              {displayedH2H.map((match) => (
                <Link
                  key={match.fixture.id}
                  href={generateMatchSlug(
                    match.teams.home.name,
                    match.teams.away.name,
                    match.fixture.id
                  )}
                  className="block bg-gray-800/50 p-3 rounded-md hover:bg-gray-700/50 transition-colors duration-200 group"
                >
                  <div className="flex justify-between items-center text-sm mb-2">
                    <span className="text-brand-muted font-semibold">
                      {match.league.name}
                    </span>
                    <span className="text-brand-muted flex items-center gap-1.5">
                      <CalendarDays size={14} />
                      {format(new Date(match.fixture.date), "dd MMM yyyy")}
                    </span>
                  </div>
                  <div className="flex items-center justify-between text-base">
                    <span
                      className={`flex items-center gap-2 font-bold ${
                        match.teams.home.winner
                          ? "text-white"
                          : "text-brand-light"
                      }`}
                    >
                      <Image
                        src={proxyImageUrl(match.teams.home.logo)}
                        alt={match.teams.home.name}
                        width={24}
                        height={24}
                      />
                      {match.teams.home.name}
                    </span>
                    <span className="px-3 py-1 bg-brand-dark rounded-md font-black text-white text-lg">
                      {match.goals.home} - {match.goals.away}
                    </span>
                    <span
                      className={`flex items-center gap-2 font-bold ${
                        match.teams.away.winner
                          ? "text-white"
                          : "text-brand-light"
                      }`}
                    >
                      {match.teams.away.name}
                      <Image
                        src={proxyImageUrl(match.teams.away.logo)}
                        alt={match.teams.away.name}
                        width={24}
                        height={24}
                      />
                    </span>
                  </div>
                </Link>
              ))}
            </div>

            {filteredH2H.length > 5 && (
              <div className="text-center mt-6">
                <button
                  onClick={() => setShowAll(!showAll)}
                  className="bg-brand-purple text-white px-4 py-2 rounded-lg text-sm font-semibold hover:opacity-90 transition-opacity"
                >
                  {showAll
                    ? t("show_less")
                    : t("show_all_count", { count: filteredH2H.length })}
                </button>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
}

// ===== src/components/match/MatchHeader.tsx =====

"use client";

import Image from "next/image";
import { format } from "date-fns";
import { useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import {
  Clock,
  CalendarDays,
  Sparkles,
  CheckCircle,
  XCircle,
  TrendingUp,
} from "lucide-react";
import Link from "next/link";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateLeagueSlug } from "@/lib/generate-league-slug";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import { useTranslation } from "@/hooks/useTranslation";

interface Team {
  id: number;
  name: string;
  logo: string;
  winner?: boolean | null;
}
interface Fixture {
  fixture: any;
  teams: { home: Team; away: Team };
  league: any;
  goals: { home: number | null; away: number | null };
  score: { fulltime: { home: number | null; away: number | null } };
}
interface MatchHeaderProps {
  fixture: Fixture;
}
type Odds = { home?: string; draw?: string; away?: string } | null;
type PredictionOdds = { home: number; draw: number; away: number } | null;

const fetchHeaderEnrichmentData = async (fixtureId: string, locale: string) => {
  if (!fixtureId || !locale) return null;
  const { data } = await axios.get(
    `/api/match-prediction?fixtureId=${fixtureId}`
  );
  return data;
};

const fetchHeaderOdds = async (fixtureId: number): Promise<Odds> => {
  const { data } = await axios.get(`/api/odds?fixture=${fixtureId}`);
  return data;
};

const PredictionResultWidget = ({
  result,
  teams,
  isLoading,
  t,
}: {
  result: any;
  teams: { home: Team; away: Team };
  isLoading: boolean;
  t: (key: string, params?: any) => string;
}) => {
  if (isLoading) {
    return (
      <div className="w-full h-full bg-gray-700/50 p-3 rounded-lg text-center border border-gray-600/50 animate-pulse"></div>
    );
  }

  if (!result.predictedOutcome) {
    return null;
  }

  const outcomeTranslations: Record<string, string> = {
    "Home Win": t("outcome_home_win"),
    "Away Win": t("outcome_away_win"),
    Draw: t("outcome_draw"),
  };

  const predictedOutcomeText =
    outcomeTranslations[result.predictedOutcome] || result.predictedOutcome;
  const actualOutcomeText = result.actualOutcome
    ? outcomeTranslations[result.actualOutcome] || result.actualOutcome
    : null;

  if (!result.isFinished) {
    const predictedTeam =
      result.predictedOutcome === "Home Win"
        ? teams.home
        : result.predictedOutcome === "Away Win"
        ? teams.away
        : null;
    return (
      <div className="w-full h-full flex flex-col justify-between space-y-2 bg-[var(--brand-accent)]/5 p-3 rounded-lg text-center border border-[var(--brand-accent)]/20">
        <h4 className="text-xs font-bold text-[var(--brand-accent)] uppercase tracking-wider flex items-center justify-center gap-1.5">
          <Sparkles size={14} /> {t("fanskor_prediction")}
        </h4>
        <div className="flex items-center justify-center gap-2">
          {predictedTeam && (
            <Image
              src={proxyImageUrl(predictedTeam.logo)}
              alt={predictedTeam.name}
              width={24}
              height={24}
            />
          )}
          <p className="text-base md:text-lg font-black text-white">
            {predictedOutcomeText}
          </p>
        </div>
        <p className="text-xs md:text-sm font-semibold text-text-muted">
          {t("confidence_percent", { confidence: result.confidence })}
        </p>
      </div>
    );
  }

  const wasCorrect = result.actualOutcome === result.predictedOutcome;
  const bgColor = wasCorrect ? "bg-green-500/10" : "bg-red-500/10";
  const textColor = wasCorrect ? "text-green-400" : "text-red-400";
  const Icon = wasCorrect ? CheckCircle : XCircle;

  return (
    <div
      className={`w-full h-full flex flex-col justify-center space-y-2 ${bgColor} p-3 rounded-lg text-center`}
    >
      <h4
        className={`text-xs font-bold ${textColor} uppercase tracking-wider flex items-center justify-center gap-1.5`}
      >
        <Icon size={14} />{" "}
        {wasCorrect ? t("prediction_hit") : t("prediction_missed")}
      </h4>
      {wasCorrect ? (
        <p className="text-lg font-black text-white">{predictedOutcomeText}</p>
      ) : (
        <div className="text-sm text-white">
          <p>
            {t("predicted_label")}:{" "}
            <span className="font-bold">{predictedOutcomeText}</span>
          </p>
          <p className={`${textColor}`}>
            {t("actual_label")}:{" "}
            <span className="font-bold">{actualOutcomeText}</span>
          </p>
        </div>
      )}
    </div>
  );
};

const BookmakerOddsWidget = ({
  odds,
  predictionOdds,
  teams,
  isLoading,
  t,
}: {
  odds: Odds;
  predictionOdds: PredictionOdds;
  teams: { home: Team; away: Team };
  isLoading: boolean;
  t: (key: string, params?: any) => string;
}) => {
  if (isLoading) {
    return (
      <div className="w-full h-full bg-gray-700/50 p-3 rounded-lg text-center border border-gray-600/50 animate-pulse"></div>
    );
  }

  const displayData = useMemo(() => {
    if (odds) {
      const favoriteOutcome =
        parseFloat(odds.home || "999") <= parseFloat(odds.draw || "999") &&
        parseFloat(odds.home || "999") <= parseFloat(odds.away || "999")
          ? "home"
          : parseFloat(odds.away || "999") <= parseFloat(odds.home || "999") &&
            parseFloat(odds.away || "999") <= parseFloat(odds.draw || "999")
          ? "away"
          : "draw";
      return {
        source: "bookmaker",
        odds,
        favoriteOutcome,
        title: t("best_odds"),
      };
    }
    if (predictionOdds) {
      const convertedOdds = {
        home: (100 / predictionOdds.home).toFixed(2),
        draw: (100 / predictionOdds.draw).toFixed(2),
        away: (100 / predictionOdds.away).toFixed(2),
      };
      const favoriteOutcome =
        predictionOdds.home >= predictionOdds.draw &&
        predictionOdds.home >= predictionOdds.away
          ? "home"
          : predictionOdds.away >= predictionOdds.home &&
            predictionOdds.away >= predictionOdds.draw
          ? "away"
          : "draw";
      return {
        source: "fanskor",
        odds: convertedOdds,
        favoriteOutcome,
        title: t("fanskor_odds"),
      };
    }
    return null;
  }, [odds, predictionOdds, t]);

  if (!displayData) return null;

  const { source, odds: currentOdds, favoriteOutcome, title } = displayData;

  const Icon = source === "bookmaker" ? TrendingUp : Sparkles;
  const iconColor =
    source === "bookmaker" ? "text-text-muted" : "text-[var(--brand-accent)]";

  return (
    <div className="w-full h-full flex flex-col justify-between space-y-2 bg-brand-dark/30 p-3 rounded-lg text-center border border-gray-700/50">
      <h4
        className={`text-xs font-bold ${iconColor} uppercase tracking-wider flex items-center justify-center gap-1.5`}
      >
        <Icon size={14} /> {title}
      </h4>
      <div className="flex items-stretch justify-center gap-1 bg-gray-900/50 p-1 rounded-md">
        <div
          className={`flex-1 flex flex-col items-center justify-center p-1 rounded-md transition-colors duration-200 ${
            favoriteOutcome === "home" ? "bg-green-500/20" : ""
          }`}
        >
          <span className="text-xs font-semibold text-green-400">
            {t("home_short")}
          </span>
          <p className="font-black text-white text-base md:text-lg">
            {currentOdds.home || "-"}
          </p>
        </div>
        <div
          className={`flex-1 flex flex-col items-center justify-center p-1 rounded-md transition-colors duration-200 ${
            favoriteOutcome === "draw" ? "bg-amber-500/20" : ""
          }`}
        >
          <span className="text-xs font-semibold text-amber-400">
            {t("draw_short")}
          </span>
          <p className="font-black text-white text-base md:text-lg">
            {currentOdds.draw || "-"}
          </p>
        </div>
        <div
          className={`flex-1 flex flex-col items-center justify-center p-1 rounded-md transition-colors duration-200 ${
            favoriteOutcome === "away" ? "bg-blue-500/20" : ""
          }`}
        >
          <span className="text-xs font-semibold text-blue-400">
            {t("away_short")}
          </span>
          <p className="font-black text-white text-base md:text-lg">
            {currentOdds.away || "-"}
          </p>
        </div>
      </div>
      <a
        href="#"
        className="block text-[10px] text-brand-muted hover:text-white"
      >
        {source === "bookmaker"
          ? t("from_our_partners")
          : t("our_data_driven_odds")}
      </a>
    </div>
  );
};

export const MatchHeader: React.FC<MatchHeaderProps> = ({ fixture }) => {
  const { t, locale } = useTranslation();
  const { teams, league, fixture: fixtureDetails, goals, score } = fixture;

  const isLive = useMemo(
    () => ["1H", "HT", "2H", "ET", "P"].includes(fixtureDetails.status.short),
    [fixtureDetails.status.short]
  );
  const isFinished = useMemo(
    () => ["FT", "AET", "PEN"].includes(fixtureDetails.status.short),
    [fixtureDetails.status.short]
  );

  const { data: enrichmentData, isLoading: isLoadingEnrichment } = useQuery({
    queryKey: ["predictionData", fixtureDetails.id.toString()],
    queryFn: () =>
      fetchHeaderEnrichmentData(fixtureDetails.id.toString(), locale!),
    enabled: !!fixtureDetails.id && !!locale,
    staleTime: 1000 * 60 * 5,
  });

  const { data: odds, isLoading: isLoadingOdds } = useQuery<Odds>({
    queryKey: ["headerOdds", fixtureDetails.id],
    queryFn: () => fetchHeaderOdds(fixtureDetails.id),
    enabled: !!fixtureDetails.id && !isFinished,
    staleTime: 1000 * 60 * 60,
  });

  const finalScoreHome = score?.fulltime?.home ?? goals?.home;
  const finalScoreAway = score?.fulltime?.away ?? goals?.away;

  const predictionResult = useMemo(() => {
    let result = {
      isFinished,
      predictedOutcome: null,
      confidence: 0,
      actualOutcome: null,
    };
    if (enrichmentData?.customPrediction) {
      const pred = enrichmentData.customPrediction;
      const maxConfidence = Math.max(pred.home, pred.draw, pred.away);
      result.predictedOutcome =
        maxConfidence === pred.home
          ? "Home Win"
          : maxConfidence === pred.away
          ? "Away Win"
          : "Draw";
      result.confidence = maxConfidence;
    }
    if (isFinished) {
      result.actualOutcome = teams.home.winner
        ? "Home Win"
        : teams.away.winner
        ? "Away Win"
        : "Draw";
    }
    return result;
  }, [enrichmentData, isFinished, teams]);

  return (
    <div className="bg-brand-secondary rounded-lg overflow-hidden shadow-lg mb-4">
      <div className="p-2 bg-brand-dark/30 flex items-center justify-between text-xs border-b border-gray-700/50">
        <Link
          href={generateLeagueSlug(league.name, league.id)}
          className="flex items-center gap-2 hover:opacity-80 transition-opacity"
        >
          {league.logo && (
            <Image
              src={proxyImageUrl(league.logo)}
              alt={league.name}
              width={16}
              height={16}
            />
          )}
          <span className="font-semibold text-text-secondary">
            {league.name}
          </span>
        </Link>
        <div className="flex items-center gap-3 text-text-muted">
          <div className="flex items-center gap-1.5">
            <CalendarDays size={12} />
            <span>{format(new Date(fixtureDetails.date), "dd MMM yyyy")}</span>
          </div>
          <div className="flex items-center gap-1.5">
            <Clock size={12} />
            <span>{format(new Date(fixtureDetails.date), "HH:mm")}</span>
          </div>
        </div>
      </div>

      <div className="p-4 md:p-6 flex flex-col gap-4">
        <div className="flex md:grid md:grid-cols-3 items-center gap-2 md:gap-4">
          <div className="flex-1 flex flex-col md:flex-row items-center justify-start text-center md:text-left gap-3">
            <Link href={generateTeamSlug(teams.home.name, teams.home.id)}>
              <Image
                src={proxyImageUrl(teams.home.logo)}
                alt={teams.home.name}
                width={80}
                height={80}
                priority={true}
                className="w-12 h-12 md:w-16 md:h-16 object-contain hover:scale-110 transition-transform"
              />
            </Link>
            <h2 className="font-bold text-white text-base md:text-xl truncate w-full">
              {teams.home.name}
            </h2>
          </div>

          <div className="flex-shrink-0 flex flex-col items-center justify-start text-center gap-2">
            <span className="text-3xl md:text-5xl font-black text-white">
              {finalScoreHome ?? "?"} - {finalScoreAway ?? "?"}
            </span>
            <span
              className={`text-xs md:text-sm font-semibold px-3 py-1 rounded-full ${
                isLive
                  ? "bg-green-500/20 text-green-400 animate-pulse"
                  : "bg-brand-dark text-text-muted"
              }`}
            >
              {fixtureDetails.status.long}{" "}
              {isLive && `(${fixtureDetails.status.elapsed}')`}
            </span>
          </div>

          <div className="flex-1 flex flex-col md:flex-row-reverse items-center justify-end text-center md:text-right gap-3">
            <Link href={generateTeamSlug(teams.away.name, teams.away.id)}>
              <Image
                src={proxyImageUrl(teams.away.logo)}
                alt={teams.away.name}
                width={80}
                height={80}
                priority={true}
                className="w-12 h-12 md:w-16 md:h-16 object-contain hover:scale-110 transition-transform"
              />
            </Link>
            <h2 className="font-bold text-white text-base md:text-xl truncate w-full">
              {teams.away.name}
            </h2>
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-3 w-full max-w-lg mx-auto">
          <PredictionResultWidget
            result={predictionResult}
            teams={teams}
            isLoading={isLoadingEnrichment}
            t={t}
          />
          <BookmakerOddsWidget
            odds={odds}
            predictionOdds={enrichmentData?.customPrediction}
            teams={teams}
            isLoading={isLoadingOdds || isLoadingEnrichment}
            t={t}
          />
        </div>
      </div>
    </div>
  );
};

// ===== src/components/match/MatchHighlightsWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Slider from "react-slick";
import { Film, ChevronLeft, ChevronRight } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";
import HighlightSlide from "../HighlightSlide";
import "slick-carousel/slick/slick.css";
import "slick-carousel/slick/slick-theme.css";

interface Highlight {
  id: string;
  embedUrl: string;
  title: string;
}

interface MatchHighlightsWidgetProps {
  leagueName: string;
  homeTeamName: string;
  awayTeamName: string;
}

const fetchHighlights = async (
  leagueName: string,
  homeTeamName: string,
  awayTeamName: string
) => {
  const params = new URLSearchParams({
    leagueName,
    homeTeamName,
    awayTeamName,
  });
  const { data } = await axios.get(
    `/api/match-highlights?${params.toString()}`
  );
  return data;
};

const HighlightsSkeleton = () => (
  <div className="w-full">
    <div className="mb-4 h-8 w-1/2 bg-gray-700 rounded-md animate-pulse"></div>
    <div className="aspect-video w-full rounded-lg bg-gray-700/50 animate-pulse"></div>
  </div>
);

const NextArrow = ({ onClick }: { onClick?: () => void }) => (
  <button
    onClick={onClick}
    className="absolute top-1/2 -right-4 z-10 p-2 bg-black/40 text-white rounded-full hover:bg-black/70 transition-colors transform -translate-y-1/2"
    aria-label="Next slide"
  >
    <ChevronRight size={24} />
  </button>
);
const PrevArrow = ({ onClick }: { onClick?: () => void }) => (
  <button
    onClick={onClick}
    className="absolute top-1/2 -left-4 z-10 p-2 bg-black/40 text-white rounded-full hover:bg-black/70 transition-colors transform -translate-y-1/2"
    aria-label="Previous slide"
  >
    <ChevronLeft size={24} />
  </button>
);

export default function MatchHighlightsWidget({
  leagueName,
  homeTeamName,
  awayTeamName,
}: MatchHighlightsWidgetProps) {
  const { t } = useTranslation();

  const {
    data: highlights,
    isLoading,
    isError,
  } = useQuery<Highlight[]>({
    queryKey: ["matchHighlights", leagueName, homeTeamName, awayTeamName],
    queryFn: () => fetchHighlights(leagueName, homeTeamName, awayTeamName),
    staleTime: 1000 * 60 * 15,
    enabled: !!(leagueName && homeTeamName && awayTeamName),
  });

  if (isLoading) {
    return <HighlightsSkeleton />;
  }

  if (isError || !highlights || highlights.length === 0) {
    return null;
  }

  const sliderSettings = {
    dots: false,
    infinite: highlights.length > 1,
    speed: 500,
    slidesToShow: 1,
    slidesToScroll: 1,
    arrows: true,
    nextArrow: <NextArrow />,
    prevArrow: <PrevArrow />,
  };

  return (
    <div className="w-full">
      <div className="mb-4">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2">
          <Film size={22} className="text-brand-purple" />
          {t("match_highlights_title")}
        </h2>
      </div>
      <div className="relative w-full">
        <Slider {...sliderSettings}>
          {highlights.map((highlight) => (
            <HighlightSlide key={highlight.id} highlight={highlight} />
          ))}
        </Slider>
      </div>
    </div>
  );
}

// ===== src/components/match/MatchPredictionWidget.tsx =====

"use client";

import { useMemo } from "react";
import Image from "next/image";
import { useTranslation } from "@/hooks/useTranslation";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { Sparkles, Users, Info } from "lucide-react";
import { proxyImageUrl } from "@/lib/image-proxy";

interface PredictionData {
  home: number;
  draw: number;
  away: number;
}

interface FullPredictionData {
  customPrediction: PredictionData | null;
  bookmakerOdds: any[];
  teams: { home: any; away: any };
}

interface MatchPredictionWidgetProps {
  fixtureId: string;
}

const fetchPredictionData = async (
  fixtureId: string
): Promise<FullPredictionData | null> => {
  try {
    const { data } = await axios.get(
      `/api/match-prediction?fixtureId=${fixtureId}`
    );
    return data;
  } catch (error) {
    console.error(
      `[MatchPredictionWidget] Failed to fetch prediction data for fixture ${fixtureId}:`,
      error
    );
    return null;
  }
};

const MAJOR_BOOKMAKER_IDS = new Set([1, 2, 6, 8, 9, 24, 31]);

const PredictionCard = ({
  label,
  team,
  percentage,
  isHighest,
}: {
  label: string;
  team?: { name: string; logo: string };
  percentage: number;
  isHighest: boolean;
}) => {
  const containerClasses = isHighest
    ? "bg-brand-purple/10 border-brand-purple shadow-lg shadow-brand-purple/20"
    : "bg-gray-800/30 border-gray-700/50";
  const textClasses = isHighest ? "text-brand-purple" : "text-brand-muted";

  return (
    <div
      className={`flex flex-col items-center justify-between p-3 rounded-lg border text-center transition-all duration-300 h-36 ${containerClasses}`}
    >
      <div className="flex flex-col items-center gap-1">
        {team?.logo && (
          <Image
            src={proxyImageUrl(team.logo)}
            alt={team.name}
            width={32}
            height={32}
            className="mb-1"
          />
        )}
        <span
          className={`text-xs font-bold uppercase tracking-wider ${textClasses}`}
        >
          {label}
        </span>
      </div>
      <div className="flex flex-col items-center">
        <span className="text-3xl font-black text-white">{percentage}%</span>
        <div className="w-16 h-1.5 bg-gray-700 rounded-full overflow-hidden mt-1">
          <div
            className={`h-full rounded-full ${
              isHighest ? "bg-brand-purple" : "bg-gray-500"
            }`}
            style={{ width: `${percentage}%` }}
          ></div>
        </div>
      </div>
    </div>
  );
};

const BookmakerOddsRow = ({
  bookmaker,
  bestOdds,
}: {
  bookmaker: any;
  bestOdds: any;
}) => {
  const matchWinnerBet = bookmaker.bets.find((bet: any) => bet.id === 1);
  if (!matchWinnerBet) return null;

  const odds = {
    home:
      matchWinnerBet.values.find((v: any) => v.value === "Home")?.odd || "-",
    draw:
      matchWinnerBet.values.find((v: any) => v.value === "Draw")?.odd || "-",
    away:
      matchWinnerBet.values.find((v: any) => v.value === "Away")?.odd || "-",
  };

  const highlightClass =
    "bg-yellow-500/20 text-brand-yellow ring-1 ring-yellow-500/50";
  const defaultClass = "bg-gray-700/50";

  return (
    <div className="grid grid-cols-4 gap-2 items-center text-sm py-2 border-b border-gray-700/50 last:border-b-0">
      <span className="col-span-1 font-semibold text-brand-light truncate pr-2">
        {bookmaker.name}
      </span>
      <span
        className={`col-span-1 text-center font-mono rounded p-1.5 transition-colors ${
          odds.home === bestOdds.home ? highlightClass : defaultClass
        }`}
      >
        {odds.home}
      </span>
      <span
        className={`col-span-1 text-center font-mono rounded p-1.5 transition-colors ${
          odds.draw === bestOdds.draw ? highlightClass : defaultClass
        }`}
      >
        {odds.draw}
      </span>
      <span
        className={`col-span-1 text-center font-mono rounded p-1.5 transition-colors ${
          odds.away === bestOdds.away ? highlightClass : defaultClass
        }`}
      >
        {odds.away}
      </span>
    </div>
  );
};

export const PredictionWidgetSkeleton = () => (
  <div className="bg-brand-secondary p-4 rounded-lg animate-pulse">
    <div className="h-6 w-3/4 bg-gray-700 rounded mb-4"></div>
    <div className="grid grid-cols-3 gap-3 mb-4">
      <div className="h-32 bg-gray-700/50 rounded-lg"></div>
      <div className="h-32 bg-gray-700/50 rounded-lg"></div>
      <div className="h-32 bg-gray-700/50 rounded-lg"></div>
    </div>
    <div className="space-y-3 pt-4 border-t border-gray-700/50">
      <div className="h-8 w-full bg-gray-700/50 rounded-md"></div>
      <div className="h-8 w-full bg-gray-700/50 rounded-md"></div>
    </div>
  </div>
);

export default function MatchPredictionWidget({
  fixtureId,
}: MatchPredictionWidgetProps) {
  const { t } = useTranslation();

  const {
    data: predictionData,
    isLoading,
    isError,
  } = useQuery<FullPredictionData | null>({
    queryKey: ["predictionData", fixtureId],
    queryFn: () => fetchPredictionData(fixtureId),
    staleTime: 1000 * 60 * 5,
    enabled: !!fixtureId,
  });

  const majorBookmakers = useMemo(() => {
    if (!predictionData?.bookmakerOdds) return [];
    return predictionData.bookmakerOdds.filter((bookie) =>
      MAJOR_BOOKMAKER_IDS.has(bookie.id)
    );
  }, [predictionData?.bookmakerOdds]);

  const { bestOdds } = useMemo(() => {
    if (!majorBookmakers || majorBookmakers.length === 0) {
      return { bestOdds: null };
    }
    let maxHome = 0,
      maxDraw = 0,
      maxAway = 0;
    majorBookmakers.forEach((bookie) => {
      const bet = bookie.bets.find((b: any) => b.id === 1);
      if (bet) {
        const homeOdd = parseFloat(
          bet.values.find((v: any) => v.value === "Home")?.odd || "0"
        );
        const drawOdd = parseFloat(
          bet.values.find((v: any) => v.value === "Draw")?.odd || "0"
        );
        const awayOdd = parseFloat(
          bet.values.find((v: any) => v.value === "Away")?.odd || "0"
        );
        if (homeOdd > maxHome) maxHome = homeOdd;
        if (drawOdd > maxDraw) maxDraw = drawOdd;
        if (awayOdd > maxAway) maxAway = awayOdd;
      }
    });
    return {
      bestOdds: {
        home: maxHome.toFixed(2),
        draw: maxDraw.toFixed(2),
        away: maxAway.toFixed(2),
      },
    };
  }, [majorBookmakers]);

  const highestPrediction = useMemo(() => {
    if (!predictionData?.customPrediction) return null;
    return Math.max(
      predictionData.customPrediction.home,
      predictionData.customPrediction.draw,
      predictionData.customPrediction.away
    );
  }, [predictionData?.customPrediction]);

  if (isLoading) {
    return <PredictionWidgetSkeleton />;
  }

  if (isError || !predictionData) {
    return (
      <div className="bg-brand-secondary p-4 rounded-lg">
        <h3 className="text-lg font-bold text-white mb-2">
          {t("prediction_comparison")}
        </h3>
        <p className="text-sm text-center text-brand-muted py-4">
          {t("prediction_data_unavailable")}
        </p>
      </div>
    );
  }

  const { customPrediction, teams } = predictionData;
  const noPrediction = !customPrediction;
  const noOdds = majorBookmakers.length === 0 || !bestOdds;

  if (noPrediction && noOdds) {
    return (
      <div className="bg-brand-secondary p-4 rounded-lg">
        <h3 className="text-lg font-bold text-white mb-2">
          {t("prediction_comparison")}
        </h3>
        <p className="text-sm text-center text-brand-muted py-4">
          {t("prediction_data_unavailable")}
        </p>
      </div>
    );
  }

  return (
    <div className="bg-brand-secondary p-4 rounded-lg">
      <div className="flex items-center gap-2 mb-4">
        <Sparkles size={20} className="text-[var(--brand-accent)]" />
        <h3 className="text-lg font-bold text-white">
          {t("prediction_comparison")}
        </h3>
      </div>

      {customPrediction ? (
        <div className="mb-4">
          <h4 className="font-semibold text-brand-light mb-2">
            {t("fanskor_prediction_engine")}
          </h4>
          <div className="grid grid-cols-3 gap-2 md:gap-3">
            <PredictionCard
              label={t("home_win")}
              team={teams.home}
              percentage={customPrediction.home}
              isHighest={customPrediction.home === highestPrediction}
            />
            <PredictionCard
              label={t("draw")}
              percentage={customPrediction.draw}
              isHighest={customPrediction.draw === highestPrediction}
            />
            <PredictionCard
              label={t("away_win")}
              team={teams.away}
              percentage={customPrediction.away}
              isHighest={customPrediction.away === highestPrediction}
            />
          </div>
        </div>
      ) : (
        <div className="text-center py-4 text-brand-muted text-sm my-4 bg-gray-800/30 rounded-lg">
          <Info size={20} className="mx-auto mb-2" />
          <p>{t("prediction_engine_unavailable")}</p>
        </div>
      )}

      {majorBookmakers.length > 0 && bestOdds ? (
        <div className="mt-4 pt-4 border-t border-gray-700/50">
          <h4 className="font-semibold text-brand-light mb-2">
            {t("compare_bookmakers", { count: majorBookmakers.length })}
          </h4>
          <div className="grid grid-cols-4 gap-2 text-xs text-brand-muted font-bold mb-1">
            <span className="col-span-1">{t("bookmaker")}</span>
            <span className="col-span-1 text-center">
              {t("odd_label_home")}
            </span>
            <span className="col-span-1 text-center">
              {t("odd_label_draw")}
            </span>
            <span className="col-span-1 text-center">
              {t("odd_label_away")}
            </span>
          </div>
          <div className="space-y-1">
            {majorBookmakers.map((bookie) => (
              <BookmakerOddsRow
                key={bookie.id}
                bookmaker={bookie}
                bestOdds={bestOdds}
              />
            ))}
          </div>
        </div>
      ) : (
        <div className="text-center py-4 text-brand-muted text-sm mt-4 border-t border-gray-700/50">
          <p>{t("bookmaker_odds_unavailable")}</p>
        </div>
      )}
    </div>
  );
}

// ===== src/components/match/MatchStatsWidget.tsx =====

"use client";

import { memo, useMemo } from "react";
import {
  BarChart3,
  Info,
  Percent,
  Disc3,
  Shield,
  Square,
  CornerUpRight,
  ShieldAlert,
  Users,
  Flag,
} from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";

interface MatchStatsWidgetProps {
  statistics: any[];
  teams: { home: any; away: any };
}

const PossessionDonut = ({
  home,
  away,
  homeColor,
  awayColor,
}: {
  home: number;
  away: number;
  homeColor: string;
  awayColor: string;
}) => {
  const radius = 50;
  const circumference = 2 * Math.PI * radius;
  const homeOffset = circumference * (1 - home / 100);

  return (
    <div className="flex flex-col items-center justify-center p-4 bg-brand-dark/30 rounded-lg h-full">
      <h4 className="text-sm font-bold text-brand-muted uppercase tracking-wider mb-2">
        Ball Possession
      </h4>
      <div className="relative w-40 h-40">
        <svg className="w-full h-full" viewBox="0 0 120 120">
          <circle
            cx="60"
            cy="60"
            r={radius}
            fill="none"
            stroke={awayColor}
            strokeWidth="10"
            strokeOpacity="0.3"
          />
          <circle
            cx="60"
            cy="60"
            r={radius}
            fill="none"
            stroke={homeColor}
            strokeWidth="10"
            strokeDasharray={circumference}
            strokeDashoffset={homeOffset}
            strokeLinecap="round"
            transform="rotate(-90 60 60)"
            className="transition-all duration-700 ease-out"
          />
        </svg>
        <div className="absolute inset-0 flex items-center justify-center font-black text-white text-3xl">
          {home}%
        </div>
      </div>
    </div>
  );
};

const ShotStatCard = ({
  homeStats,
  awayStats,
  homeColor,
  awayColor,
}: {
  homeStats: any;
  awayStats: any;
  homeColor: string;
  awayColor: string;
}) => {
  const StatBar = ({
    label,
    home,
    away,
    hColor,
    aColor,
  }: {
    label: string;
    home: number;
    away: number;
    hColor: string;
    aColor: string;
  }) => {
    const total = home + away;
    const homePercent = total > 0 ? (home / total) * 100 : 50;
    return (
      <div>
        <div className="flex justify-between items-center text-xs text-brand-muted mb-1">
          <span>{home}</span>
          <span>{label}</span>
          <span>{away}</span>
        </div>
        <div className="flex w-full h-2 rounded-full bg-gray-700/50">
          <div
            className="rounded-l-full"
            style={{ width: `${homePercent}%`, backgroundColor: hColor }}
          ></div>
          <div
            className="rounded-r-full"
            style={{ width: `${100 - homePercent}%`, backgroundColor: aColor }}
          ></div>
        </div>
      </div>
    );
  };

  return (
    <div className="flex flex-col p-4 bg-brand-dark/30 rounded-lg h-full space-y-3">
      <h4 className="text-sm font-bold text-brand-muted uppercase tracking-wider">
        Shots
      </h4>
      <StatBar
        label="Total"
        home={homeStats.total}
        away={awayStats.total}
        hColor={homeColor}
        aColor={awayColor}
      />
      <StatBar
        label="On Target"
        home={homeStats.on}
        away={awayStats.on}
        hColor={homeColor}
        aColor={awayColor}
      />
      <StatBar
        label="Off Target"
        home={homeStats.off}
        away={awayStats.off}
        hColor={homeColor}
        aColor={awayColor}
      />
    </div>
  );
};

const SimpleStatCard = ({
  title,
  icon: Icon,
  homeValue,
  awayValue,
  homeColor,
  awayColor,
}: {
  title: string;
  icon: React.ElementType;
  homeValue: number;
  awayValue: number;
  homeColor: string;
  awayColor: string;
}) => (
  <div className="p-4 bg-brand-dark/30 rounded-lg h-full">
    <h4 className="text-sm font-bold text-brand-muted uppercase tracking-wider flex items-center gap-2 mb-3">
      <Icon size={14} /> {title}
    </h4>
    <div className="flex justify-around items-center">
      <div className="text-center">
        <p className="text-4xl font-black" style={{ color: homeColor }}>
          {homeValue}
        </p>
      </div>
      <div className="text-2xl font-light text-brand-muted">vs</div>
      <div className="text-center">
        <p className="text-4xl font-black" style={{ color: awayColor }}>
          {awayValue}
        </p>
      </div>
    </div>
  </div>
);

const MatchStatsWidget = memo(function MatchStatsWidget({
  statistics,
  teams,
}: MatchStatsWidgetProps) {
  const { t } = useTranslation();

  const homeColor = "#34D399";
  const awayColor = "#60A5FA";

  const processedStats = useMemo(() => {
    if (!statistics || statistics.length < 2) return null;

    const home =
      statistics.find((s) => s.team.id === teams.home.id)?.statistics || [];
    const away =
      statistics.find((s) => s.team.id === teams.away.id)?.statistics || [];

    const findStat = (stats: any[], type: string) =>
      stats.find((s) => s.type === type)?.value ?? 0;

    return {
      ballPossession: {
        home: parseFloat(findStat(home, "Ball Possession")),
        away: parseFloat(findStat(away, "Ball Possession")),
      },
      shots: {
        home: {
          total: findStat(home, "Total Shots"),
          on: findStat(home, "Shots on Goal"),
          off: findStat(home, "Shots off Goal"),
        },
        away: {
          total: findStat(away, "Total Shots"),
          on: findStat(away, "Shots on Goal"),
          off: findStat(away, "Shots off Goal"),
        },
      },
      corners: {
        home: findStat(home, "Corner Kicks"),
        away: findStat(away, "Corner Kicks"),
      },
      fouls: { home: findStat(home, "Fouls"), away: findStat(away, "Fouls") },
      yellowCards: {
        home: findStat(home, "Yellow Cards"),
        away: findStat(away, "Yellow Cards"),
      },
      redCards: {
        home: findStat(home, "Red Cards"),
        away: findStat(away, "Red Cards"),
      },
    };
  }, [statistics, teams]);

  if (!processedStats) {
    return (
      <div className="bg-brand-secondary rounded-lg p-6">
        <h2 className="text-xl font-bold text-white mb-4 flex items-center gap-2">
          <BarChart3 size={22} /> {t("match_statistics")}
        </h2>
        <div className="text-center py-6 text-brand-muted">
          <Info size={28} className="mx-auto mb-2" />
          <p>{t("live_stats_unavailable")}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-brand-secondary rounded-lg p-4 md:p-6">
      <h2 className="text-xl font-bold text-white mb-4 flex items-center gap-2">
        <BarChart3 size={22} /> {t("match_statistics")}
      </h2>
      <div className="flex justify-between items-center mb-4 p-3 bg-brand-dark/30 rounded-lg">
        <div className="flex items-center gap-3">
          <Image
            src={proxyImageUrl(teams.home.logo)}
            alt={teams.home.name}
            width={32}
            height={32}
          />
          <span className="font-bold text-white hidden sm:block">
            {teams.home.name}
          </span>
        </div>
        <div className="flex items-center gap-3">
          <span className="font-bold text-white hidden sm:block">
            {teams.away.name}
          </span>
          <Image
            src={proxyImageUrl(teams.away.logo)}
            alt={teams.away.name}
            width={32}
            height={32}
          />
        </div>
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
        <PossessionDonut
          home={processedStats.ballPossession.home}
          away={processedStats.ballPossession.away}
          homeColor={homeColor}
          awayColor={awayColor}
        />
        <ShotStatCard
          homeStats={processedStats.shots.home}
          awayStats={processedStats.shots.away}
          homeColor={homeColor}
          awayColor={awayColor}
        />
        <SimpleStatCard
          title="Corner Kicks"
          icon={CornerUpRight}
          homeValue={processedStats.corners.home}
          awayValue={processedStats.corners.away}
          homeColor={homeColor}
          awayColor={awayColor}
        />
        <SimpleStatCard
          title="Fouls"
          icon={ShieldAlert}
          homeValue={processedStats.fouls.home}
          awayValue={processedStats.fouls.away}
          homeColor={homeColor}
          awayColor={awayColor}
        />
        <SimpleStatCard
          title="Yellow Cards"
          icon={Square}
          homeValue={processedStats.yellowCards.home}
          awayValue={processedStats.yellowCards.away}
          homeColor={homeColor}
          awayColor={awayColor}
        />
        <SimpleStatCard
          title="Red Cards"
          icon={Square}
          homeValue={processedStats.redCards.home}
          awayValue={processedStats.redCards.away}
          homeColor={homeColor}
          awayColor={awayColor}
        />
      </div>
    </div>
  );
});

export default MatchStatsWidget;

// ===== src/components/match/MatchStatusBanner.tsx =====

"use client";

import { memo } from "react";
import { format } from "date-fns";
import { useTranslation } from "@/hooks/useTranslation";

interface MatchStatusBannerProps {
  fixture: any;
}

const MatchStatusBanner = memo(function MatchStatusBanner({
  fixture,
}: MatchStatusBannerProps) {
  const { t } = useTranslation();
  const status = fixture.fixture.status;

  let content = <p>{status.long}</p>;
  let bgClass = "bg-gray-600";

  switch (status.short) {
    case "TBD":
    case "NS":
      content = (
        <p>
          {t("status_upcoming")} -{" "}
          {format(new Date(fixture.fixture.date), "HH:mm")}
        </p>
      );
      bgClass = "bg-blue-600";
      break;
    case "1H":
    case "HT":
    case "2H":
    case "ET":
    case "P":
      content = (
        <p className="animate-pulse">
          {status.elapsed}' - {status.long}
        </p>
      );
      bgClass = "bg-red-600";
      break;
    case "FT":
    case "AET":
    case "PEN":
      content = <p>{t("status_full_time")}</p>;
      bgClass = "bg-gray-800";
      break;
  }

  return (
    <div
      className={`text-center font-bold text-white py-2 rounded-b-xl text-sm tracking-wider mb-8 ${bgClass}`}
    >
      {content}
    </div>
  );
});

export default MatchStatusBanner;

// ===== src/components/match/TeamFormWidget.tsx =====

"use client";

import { useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { TrendingUp, Shield, BarChart2, Info } from "lucide-react";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import { useTranslation } from "@/hooks/useTranslation";

interface TeamFormWidgetProps {
  team: any;
  location: "Home" | "Away";
  fixtureData: any;
}

const fetchTeamFormData = async (
  teamId: number,
  leagueId: number,
  season: number
) => {
  const params = new URLSearchParams({
    teamId: teamId.toString(),
    leagueId: leagueId.toString(),
    season: season.toString(),
  });
  const { data } = await axios.get(`/api/team-form-data?${params.toString()}`);
  return data;
};

const StatRow = ({
  label,
  value,
  highlight = false,
}: {
  label: string;
  value: string | number;
  highlight?: boolean;
}) => (
  <div className="flex justify-between items-center text-sm py-1.5">
    <span className="text-brand-muted">{label}</span>
    <span
      className={`font-bold ${highlight ? "text-brand-purple" : "text-white"}`}
    >
      {value}
    </span>
  </div>
);
const FormPill = ({ result }: { result: "W" | "D" | "L" }) => {
  const styles = {
    W: "bg-green-500/80 text-white",
    D: "bg-yellow-500/80 text-white",
    L: "bg-red-500/80 text-white",
  };
  return (
    <div
      className={`w-6 h-6 flex items-center justify-center rounded-full font-bold text-xs ${styles[result]}`}
    >
      {result}
    </div>
  );
};

const WidgetSkeleton = () => (
  <div className="bg-brand-secondary p-4 rounded-lg space-y-4 animate-pulse h-[400px]">
    <div className="flex items-center gap-3">
      <div className="w-10 h-10 rounded-full bg-gray-700"></div>
      <div className="space-y-2">
        <div className="h-3 w-20 bg-gray-600 rounded"></div>
        <div className="h-5 w-32 bg-gray-600 rounded"></div>
      </div>
    </div>
    <div className="h-6 w-1/2 bg-gray-700 rounded"></div>
    <div className="h-8 w-full bg-gray-700/50 rounded"></div>
    <div className="h-6 w-1/2 bg-gray-700 rounded mt-4"></div>
    <div className="h-24 w-full bg-gray-700/50 rounded"></div>
  </div>
);

export default function TeamFormWidget({
  team,
  location,
  fixtureData,
}: TeamFormWidgetProps) {
  const { t } = useTranslation();
  const { league } = fixtureData;

  const {
    data: teamStats,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["teamFormData", team.id, league.id, league.season],
    queryFn: () => fetchTeamFormData(team.id, league.id, league.season),
    staleTime: 1000 * 60 * 15,
    enabled: !!team.id && !!league.id && !!league.season,
  });

  const { formString, detailedStats } = useMemo(() => {
    let form = "";
    let stats = null;

    if (teamStats && teamStats.fixtures?.played?.total > 0) {
      form = teamStats.form || "";
      stats = {
        fixtures: teamStats.fixtures,
        goals: teamStats.goals,
      };
    }

    return { formString: form, detailedStats: stats };
  }, [teamStats]);

  if (isLoading) {
    return <WidgetSkeleton />;
  }

  if (isError || !detailedStats) {
    return (
      <div className="bg-brand-secondary p-4 rounded-lg h-full flex flex-col">
        <div className="flex items-center gap-3 mb-4">
          <Image
            src={proxyImageUrl(team.logo)}
            alt={team.name}
            width={40}
            height={40}
          />
          <div>
            <p className="text-xs text-brand-muted">
              {location === "Home" ? t("home_team") : t("away_team")}
            </p>
            <h3 className="text-lg font-bold text-white">{team.name}</h3>
          </div>
        </div>
        <div className="flex-grow flex items-center justify-center">
          <p className="text-sm text-brand-muted text-center py-4">
            {t("stats_unavailable_for_team")}
          </p>
        </div>
      </div>
    );
  }

  const formArray = formString.slice(-10).split("");

  return (
    <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
      <div className="flex items-center gap-3">
        <Image
          src={proxyImageUrl(team.logo)}
          alt={team.name}
          width={40}
          height={40}
        />
        <div>
          <p className="text-xs text-brand-muted">
            {location === "Home" ? t("home_team") : t("away_team")}
          </p>
          <h3 className="text-lg font-bold text-white">{team.name}</h3>
        </div>
      </div>

      {formArray.length > 0 && (
        <div>
          <h4 className="font-semibold text-brand-light mb-2 flex items-center gap-2">
            <TrendingUp size={16} />{" "}
            {t("recent_form_count", { count: formArray.length })}
          </h4>
          <div className="flex items-center gap-1.5">
            {formArray.map((result: "W" | "D" | "L", index: number) => (
              <FormPill key={index} result={result} />
            ))}
          </div>
        </div>
      )}

      {detailedStats && (
        <>
          <div>
            <h4 className="font-semibold text-brand-light mb-1 flex items-center gap-2">
              <BarChart2 size={16} /> {t("performance_title")}
            </h4>
            <div className="bg-gray-800/50 p-2 rounded-md">
              <StatRow
                label={t("matches_played")}
                value={`${detailedStats.fixtures.played.home} (${t(
                  "home_short"
                )}) / ${detailedStats.fixtures.played.away} (${t(
                  "away_short"
                )})`}
              />
              <StatRow
                label={t("wins")}
                value={`${detailedStats.fixtures.wins.home} (${t(
                  "home_short"
                )}) / ${detailedStats.fixtures.wins.away} (${t("away_short")})`}
              />
              <StatRow
                label={t("draws")}
                value={`${detailedStats.fixtures.draws.home} (${t(
                  "home_short"
                )}) / ${detailedStats.fixtures.draws.away} (${t(
                  "away_short"
                )})`}
              />
              <StatRow
                label={t("losses")}
                value={`${detailedStats.fixtures.loses.home} (${t(
                  "home_short"
                )}) / ${detailedStats.fixtures.loses.away} (${t(
                  "away_short"
                )})`}
              />
            </div>
          </div>
          <div>
            <h4 className="font-semibold text-brand-light mb-1 flex items-center gap-2">
              <Shield size={16} /> {t("goal_analysis_title")}
            </h4>
            <div className="bg-gray-800/50 p-2 rounded-md">
              <StatRow
                label={t("goals_for")}
                value={detailedStats.goals.for.total.total}
                highlight
              />
              <StatRow
                label={t("goals_against")}
                value={detailedStats.goals.against.total.total}
              />
              <StatRow
                label={t("avg_scored")}
                value={detailedStats.goals.for.average.total}
              />
              <StatRow
                label={t("avg_conceded")}
                value={detailedStats.goals.against.average.total}
              />
            </div>
          </div>
        </>
      )}
    </div>
  );
}

// ===== src/components/match/WinProbability.tsx =====

"use client";
import { memo } from 'react';
import { CircularProgressbar, buildStyles } from 'react-circular-progressbar';
import 'react-circular-progressbar/dist/styles.css';

const WinProbability = memo(function WinProbability({ home, draw, away }: { home: number, draw: number, away: number }) {
    const homeColor = '#8B5CF6';
    const awayColor = '#3B82F6';

    return (
        <div className="w-32 h-32 relative">
            <div className="absolute inset-0 transform scale-75">
                <CircularProgressbar
                    value={away}
                    styles={buildStyles({
                        pathColor: awayColor,
                        trailColor: 'transparent',
                        pathTransitionDuration: 0.5,
                    })}
                />
            </div>
            <CircularProgressbar
                value={home + draw}
                counterClockwise
                styles={buildStyles({
                    pathColor: homeColor,
                    trailColor: 'transparent',
                    pathTransitionDuration: 0.5,
                })}
            />
            <div className="absolute inset-0 flex flex-col items-center justify-center">
                <p className="text-xs text-brand-muted">DRAW</p>
                <p className="font-black text-2xl text-white">{draw}%</p>
            </div>
        </div>
    );
});
export default WinProbability;

// ===== src/components/predictions/PredictionCard.tsx =====

"use client";

import Image from "next/image";
import { format } from "date-fns";
import { Clock } from "lucide-react";
import StyledLink from "@/components/StyledLink";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateMatchSlug } from "@/lib/generate-match-slug";
import { useTranslation } from "@/hooks/useTranslation";
import { useMemo } from "react";

interface PredictionCardProps {
  fixture: any;
}

const FormGuideCircles = ({ formString }: { formString: string | null }) => {
  if (!formString || formString.length === 0)
    return (
      <div className="h-5 w-full flex items-center justify-end">
        <span className="text-xs text-text-muted">-</span>
      </div>
    );
  return (
    <div className="flex items-center justify-end gap-1.5">
      {formString
        .slice(-5)
        .split("")
        .map((result, index) => {
          const classes = {
            W: "bg-green-500",
            D: "bg-gray-500",
            L: "bg-red-500",
          };
          const title =
            result === "W" ? "Win" : result === "D" ? "Draw" : "Loss";
          return (
            <div
              key={index}
              title={title}
              className={`flex items-center justify-center w-5 h-5 rounded-full ${
                classes[result as keyof typeof classes]
              }`}
            >
              <span className="text-white text-[10px] font-bold">{result}</span>
            </div>
          );
        })}
    </div>
  );
};

export const PredictionCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg flex flex-col h-full border border-transparent animate-pulse p-3 space-y-2.5">
    <div className="flex justify-between items-center">
      <div className="h-4 w-2/3 bg-gray-700 rounded"></div>
    </div>
    <div className="h-8 w-full rounded bg-gray-600/50"></div>
    <div className="h-8 w-full rounded bg-gray-600/50"></div>
    <div className="h-2 w-full rounded-full bg-gray-700 mt-1"></div>
    <div className="h-8 w-full rounded-md bg-gray-700 mt-1"></div>
  </div>
);

export default function PredictionCard({ fixture }: PredictionCardProps) {
  const { t } = useTranslation();
  const { teams, league, prediction, h2h, form } = fixture;
  const matchSlug = generateMatchSlug(
    teams.home,
    teams.away,
    fixture.fixture.id
  );

  const highestPredictionValue = useMemo(() => {
    if (!prediction) return 0;
    return Math.max(prediction.home, prediction.draw, prediction.away);
  }, [prediction]);

  const h2hStats = useMemo(() => {
    if (!h2h || h2h.length === 0) return { home: 0, draw: 0, away: 0 };
    return h2h.slice(0, 5).reduce(
      (acc: any, match: any) => {
        if (match.teams.home.id === teams.home.id) {
          if (match.teams.home.winner) acc.home++;
          else if (match.teams.away.winner) acc.away++;
          else acc.draw++;
        } else {
          if (match.teams.home.winner) acc.away++;
          else if (match.teams.away.winner) acc.home++;
          else acc.draw++;
        }
        return acc;
      },
      { home: 0, draw: 0, away: 0 }
    );
  }, [h2h, teams]);

  const homeColor =
    prediction.home === highestPredictionValue
      ? "text-[var(--brand-accent)]"
      : "text-white";
  const awayColor =
    prediction.away === highestPredictionValue
      ? "text-[var(--brand-accent)]"
      : "text-white";
  const drawColor =
    prediction.draw === highestPredictionValue
      ? "text-[var(--brand-accent)]"
      : "text-white";

  return (
    <StyledLink
      href={matchSlug}
      className="block bg-brand-secondary rounded-xl h-full border border-gray-800/80 transition-all duration-300 hover:shadow-2xl hover:border-[var(--brand-accent)]/50 hover:-translate-y-1 group"
    >
      <div className="p-3 flex-grow flex flex-col gap-3">
        {}
        <div className="flex items-center justify-between gap-2 flex-shrink-0">
          <div className="flex items-center gap-2 min-w-0">
            <Image
              src={proxyImageUrl(league.logo)}
              alt={league.name}
              width={16}
              height={16}
            />
            <p className="text-xs font-semibold text-text-muted truncate">
              {league.name}
            </p>
          </div>
          <div className="text-xs font-semibold text-brand-muted flex items-center gap-1.5 flex-shrink-0">
            <Clock size={12} />
            <span>{format(new Date(fixture.fixture.date), "HH:mm")}</span>
          </div>
        </div>

        {}
        <div className="space-y-2">
          <div className="grid grid-cols-[1fr,auto] items-center gap-3">
            <div className="flex items-center gap-2.5 min-w-0">
              <Image
                src={proxyImageUrl(teams.home.logo)}
                alt={teams.home.name}
                width={24}
                height={24}
              />
              <span className="font-bold text-sm text-white truncate">
                {teams.home.name}
              </span>
            </div>
            <FormGuideCircles formString={form.home} />
          </div>
          <div className="grid grid-cols-[1fr,auto] items-center gap-3">
            <div className="flex items-center gap-2.5 min-w-0">
              <Image
                src={proxyImageUrl(teams.away.logo)}
                alt={teams.away.name}
                width={24}
                height={24}
              />
              <span className="font-bold text-sm text-white truncate">
                {teams.away.name}
              </span>
            </div>
            <FormGuideCircles formString={form.away} />
          </div>
        </div>

        {}
        <div className="space-y-2 pt-2">
          <div className="flex justify-between items-center text-center text-xs font-bold">
            <span className={`w-1/3 ${homeColor}`}>{prediction.home}%</span>
            <span className={`w-1/3 ${drawColor}`}>
              {t("draw")} {prediction.draw}%
            </span>
            <span className={`w-1/3 ${awayColor}`}>{prediction.away}%</span>
          </div>
          <div className="flex w-full h-2 rounded-full overflow-hidden bg-brand-dark/50">
            <div
              className="bg-[var(--brand-accent)]"
              style={{ width: `${prediction.home}%` }}
            ></div>
            <div
              className="bg-gray-500"
              style={{ width: `${prediction.draw}%` }}
            ></div>
            <div
              className="bg-blue-500"
              style={{ width: `${prediction.away}%` }}
            ></div>
          </div>
        </div>

        {}
        <div className="mt-auto pt-3 border-t border-gray-700/50 text-center">
          <span className="text-xs font-semibold text-text-muted">
            H2H (W-D-L):{" "}
          </span>
          <span className="font-mono text-sm text-white font-bold tracking-wider">
            {h2hStats.home}-{h2hStats.draw}-{h2hStats.away}
          </span>
        </div>
      </div>
    </StyledLink>
  );
}

// ===== src/components/skeletons/WidgetSkeletons.tsx =====

"use client";

export const AdSlotWidgetSkeleton = () => (
  <div className="w-full h-[250px] bg-brand-secondary rounded-lg animate-pulse"></div>
);

export const RecentNewsWidgetSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg shadow-lg animate-pulse">
    <div className="p-4 border-b border-gray-700/50">
      <div className="h-6 w-3/4 bg-gray-700 rounded"></div>
    </div>
    <div className="p-2 space-y-1">
      <SidebarNewsItemSkeleton />
      <SidebarNewsItemSkeleton />
      <SidebarNewsItemSkeleton />
      <SidebarNewsItemSkeleton />
    </div>
  </div>
);

const SidebarNewsItemSkeleton = () => (
  <div className="flex flex-col gap-1.5 p-3">
    <div className="h-4 w-full rounded bg-gray-700"></div>
    <div className="h-3 w-1/3 rounded bg-gray-700"></div>
  </div>
);

// ===== src/components/tabs/LineupsTab.tsx =====

import Image from 'next/image';

const PlayerList = ({ title, players }: { title: string, players: any[] }) => (
  <div>
    <h4 className="font-bold text-lg mb-2 text-brand-muted">{title}</h4>
    <ul className="space-y-3">
      {players.map((p: any) => (
        <li key={p.player.id} className="flex items-center gap-3">
          <span className="text-brand-muted font-mono w-6 text-center">{p.player.number}</span>
          <span>{p.player.name}</span>
        </li>
      ))}
    </ul>
  </div>
);

export default function LineupsTab({ lineups }: { lineups: any[] }) {
  if (!lineups || lineups.length < 2) {
    return <p className="text-brand-muted text-center py-8">Lineups are not yet available.</p>;
  }

  const homeLineup = lineups[0];
  const awayLineup = lineups[1];

  return (
    <div className="p-4 grid grid-cols-1 md:grid-cols-2 gap-8">
      {}
      <div>
        <div className="flex items-center gap-3 mb-4">
          <Image src={homeLineup.team.logo} alt={homeLineup.team.name} width={32} height={32}/>
          <h3 className="font-bold text-xl">{homeLineup.team.name}</h3>
        </div>
        <p className="mb-4 text-brand-muted">Formation: {homeLineup.formation}</p>
        <PlayerList title="Starting XI" players={homeLineup.startXI} />
        <PlayerList title="Substitutes" players={homeLineup.substitutes} />
      </div>
      {}
      <div>
        <div className="flex items-center gap-3 mb-4">
          <Image src={awayLineup.team.logo} alt={awayLineup.team.name} width={32} height={32}/>
          <h3 className="font-bold text-xl">{awayLineup.team.name}</h3>
        </div>
        <p className="mb-4 text-brand-muted">Formation: {awayLineup.formation}</p>
        <PlayerList title="Starting XI" players={awayLineup.startXI} />
        <PlayerList title="Substitutes" players={awayLineup.substitutes} />
      </div>
    </div>
  );
}

// ===== src/components/tabs/StatsTab.tsx =====

import { BarChart2 } from 'lucide-react';

export default function StatsTab({ statistics, teams }: { statistics: any[], teams: any }) {
  if (!statistics || statistics.length < 2) {
    return <p className="text-brand-muted text-center py-8">Statistics are not available for this match.</p>;
  }

  const homeStats = statistics.find((s: any) => s.team.id === teams.home.id)?.statistics || [];
  const awayStats = statistics.find((s: any) => s.team.id === teams.away.id)?.statistics || [];

  const allStatTypes = Array.from(new Set([...homeStats.map((s: any) => s.type), ...awayStats.map((s: any) => s.type)]));

  return (
    <div className="space-y-4 p-4">
      {allStatTypes.map((type) => {
        const homeStat = homeStats.find((s: any) => s.type === type)?.value ?? 0;
        const awayStat = awayStats.find((s: any) => s.type === type)?.value ?? 0;
        const total = (Number(homeStat) || 0) + (Number(awayStat) || 0);
        const homePercent = total > 0 ? ((Number(homeStat) || 0) / total) * 100 : 50;

        return (
          <div key={type}>
            <div className="flex justify-between items-center mb-1 text-sm font-semibold">
              <span>{homeStat ?? 0}</span>
              <span className="text-brand-muted">{type}</span>
              <span>{awayStat ?? 0}</span>
            </div>
            <div className="flex w-full h-2 rounded-full overflow-hidden bg-gray-700">
              <div className="bg-brand-purple" style={{ width: `${homePercent}%` }}></div>
              <div className="bg-blue-600" style={{ width: `${100 - homePercent}%` }}></div>
            </div>
          </div>
        );
      })}
    </div>
  );
}

// ===== src/components/team/TeamFixturesWidget.tsx =====

"use client";

import { useState, useMemo } from "react";
import { Info, CalendarClock } from "lucide-react";
import MatchListItem from "../MatchListItem";
import { useTranslation } from "@/hooks/useTranslation";

interface TeamFixturesWidgetProps {
  fixtures: any[];
}

export default function TeamFixturesWidget({
  fixtures,
}: TeamFixturesWidgetProps) {

  const [activeTab, setActiveTab] = useState<"upcoming" | "results">("results");
  const { t } = useTranslation();

  const filteredMatches = useMemo(() => {
    if (!fixtures) return [];

    const sortedFixtures = [...fixtures].sort(
      (a, b) =>
        new Date(a.fixture.date).getTime() - new Date(b.fixture.date).getTime()
    );

    if (activeTab === "upcoming") {
      return sortedFixtures.filter(
        (m: any) => !["FT", "AET", "PEN"].includes(m.fixture.status.short)
      );
    } else {

      return sortedFixtures
        .filter((m: any) =>
          ["FT", "AET", "PEN"].includes(m.fixture.status.short)
        )
        .reverse();
    }
  }, [fixtures, activeTab]);

  return (
    <div className="bg-brand-secondary rounded-xl">
      <div className="flex justify-between items-center p-4 border-b border-gray-700/50">
        <h3 className="text-xl font-bold text-white flex items-center gap-2">
          <CalendarClock size={22} />
          {t("match_schedule")}
        </h3>
        <div className="flex items-center gap-1 bg-[var(--color-primary)] p-1 rounded-lg">
          <button
            onClick={() => setActiveTab("upcoming")}
            className={`px-3 py-1 text-sm rounded-md font-semibold transition-colors ${
              activeTab === "upcoming"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700"
            }`}
          >
            {t("upcoming")}
          </button>
          <button
            onClick={() => setActiveTab("results")}
            className={`px-3 py-1 text-sm rounded-md font-semibold transition-colors ${
              activeTab === "results"
                ? "bg-[var(--brand-accent)] text-white"
                : "text-text-muted hover:bg-gray-700"
            }`}
          >
            {t("results")}
          </button>
        </div>
      </div>

      <div className="p-2 space-y-2 max-h-[800px] overflow-y-auto custom-scrollbar">
        {!fixtures || fixtures.length === 0 ? (
          <div className="text-center py-20 text-brand-muted">
            <Info size={32} className="mx-auto mb-3" />
            <p className="font-semibold">{t("fixture_data_unavailable")}</p>
          </div>
        ) : filteredMatches.length > 0 ? (
          filteredMatches.map((match: any) => (
            <MatchListItem key={match.fixture.id} match={match} />
          ))
        ) : (
          <div className="text-center py-20 text-brand-muted">
            <Info size={32} className="mx-auto mb-3" />
            <p className="font-semibold">
              {t("no_matches_found_for_tab", { tab: activeTab })}
            </p>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/team/TeamHeader.tsx =====

import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import { Calendar } from "lucide-react";

export default function TeamHeader({
  team,
  countryFlag,
  foundedText,
}: {
  team: any;
  countryFlag: string;
  foundedText: string;
}) {
  return (
    <div className="bg-brand-secondary p-6 rounded-lg mb-8 flex flex-col md:flex-row items-center gap-6">
      <div className="relative">
        <Image
          src={proxyImageUrl(team.logo)}
          alt={`${team.name} logo`}
          width={96}
          height={96}
        />
        {countryFlag && (
          <Image
            src={proxyImageUrl(countryFlag)}
            alt={team.country}
            width={32}
            height={32}
            className="rounded-full absolute -bottom-2 -right-2 border-2 border-brand-secondary"
          />
        )}
      </div>
      <div>
        <h1 className="text-4xl md:text-5xl font-extrabold text-white text-center md:text-left">
          {team.name}
        </h1>
        {team.founded && (
          <div className="flex items-center gap-2 text-brand-muted justify-center md:justify-start mt-2">
            <Calendar size={14} />
            {}
            <span>{foundedText}</span>
          </div>
        )}
      </div>
    </div>
  );
}

// ===== src/components/team/TeamInfoWidget.tsx =====

"use client";

import { MapPin, Users } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

const InfoRow = ({
  icon: Icon,
  label,
  value,
}: {
  icon: React.ElementType;
  label: string;
  value: string | number;
}) => (
  <div className="flex justify-between items-center text-sm py-2 border-b border-gray-700/50 last:border-b-0">
    <div className="flex items-center gap-2 text-brand-muted">
      <Icon size={14} />
      <span>{label}</span>
    </div>
    <span className="font-semibold text-white text-right">{value}</span>
  </div>
);

export default function TeamInfoWidget({ venue }: { venue: any }) {
  const { t } = useTranslation();

  return (
    <div className="bg-brand-secondary p-4 rounded-lg">
      <h3 className="text-lg font-bold text-white mb-2">
        {t("venue_information")}
      </h3>
      <div className="space-y-1">
        <InfoRow
          icon={MapPin}
          label={t("stadium")}
          value={venue.name || t("not_available_short")}
        />
        <InfoRow
          icon={MapPin}
          label={t("city")}
          value={venue.city || t("not_available_short")}
        />
        <InfoRow
          icon={Users}
          label={t("capacity")}
          value={venue.capacity?.toLocaleString() || t("not_available_short")}
        />
      </div>
    </div>
  );
}

// ===== src/components/team/TeamSeoWidget.tsx =====

import { BookOpen } from "lucide-react";

interface TeamSeoWidgetProps {
  title: string;
  seoText: string;
}

const formatTextToParagraphs = (text: string) => {
  return text.split("\n\n").map((paragraph, index) => (
    <p key={index} className={index > 0 ? "mt-4" : ""}>
      {paragraph}
    </p>
  ));
};

export default function TeamSeoWidget({ title, seoText }: TeamSeoWidgetProps) {
  if (!seoText) return null;

  return (
    <div className="bg-brand-secondary rounded-lg p-4">
      <h3 className="text-lg font-bold text-white mb-3 flex items-center gap-2">
        <BookOpen size={18} className="text-[var(--brand-accent)]" />
        {title}
      </h3>
      <div className="prose prose-sm prose-invert max-w-none text-text-secondary leading-relaxed">
        {formatTextToParagraphs(seoText)}
      </div>
    </div>
  );
}

// ===== src/components/team/TeamSquadWidget.tsx =====

"use client";

import { useState, useMemo } from "react";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import { Users, Shield, Zap, Goal, UserCircle } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

const positionStyles: {
  [key: string]: { bg: string; text: string; border: string };
} = {
  Goalkeeper: {
    bg: "bg-amber-500/10",
    text: "text-amber-400",
    border: "border-amber-500/50",
  },
  Defender: {
    bg: "bg-blue-500/10",
    text: "text-blue-400",
    border: "border-blue-500/50",
  },
  Midfielder: {
    bg: "bg-green-500/10",
    text: "text-green-400",
    border: "border-green-500/50",
  },
  Attacker: {
    bg: "bg-red-500/10",
    text: "text-red-400",
    border: "border-red-500/50",
  },
};

const PlayerRow = ({ player }: { player: any }) => {
  const style = positionStyles[player.position] || {
    bg: "bg-gray-500/10",
    text: "text-gray-400",
    border: "border-gray-500/50",
  };

  return (
    <div
      className={`flex items-center gap-3 p-2.5 rounded-lg border-l-4 transition-all duration-200 hover:bg-white/5 ${style.border}`}
    >
      <div className="relative flex-shrink-0">
        <Image
          src={proxyImageUrl(player.photo)}
          alt={player.name}
          width={40}
          height={40}
          className="rounded-full bg-gray-800"
        />
        <span
          className={`absolute -bottom-1 -right-1 w-5 h-5 flex items-center justify-center rounded-full text-xs font-bold text-white ${style.bg} border-2 border-brand-secondary`}
        >
          {player.number || "?"}
        </span>
      </div>
      <div className="flex-1 min-w-0">
        <p className="font-bold text-white truncate text-sm">{player.name}</p>
        <p className={`text-xs font-semibold ${style.text}`}>
          {player.position}
        </p>
      </div>
      <div className="flex-shrink-0 text-right">
        <p className="font-semibold text-white text-sm">{player.age}</p>
        <p className="text-xs text-brand-muted">{player.nationality}</p>
      </div>
    </div>
  );
};

export default function TeamSquadWidget({ squad }: { squad: any[] }) {
  const [filter, setFilter] = useState("All");
  const { t } = useTranslation();

  const filteredSquad = useMemo(() => {
    if (!squad || squad.length === 0) return [];
    if (filter === "All") return squad;
    return squad.filter((p) => p.position === filter);
  }, [squad, filter]);

  const squadSummary = useMemo(() => {
    if (!squad || squad.length === 0) return { count: 0, avgAge: 0 };
    const validPlayers = squad.filter((p) => p.age);
    const totalAge = validPlayers.reduce((acc, p) => acc + p.age, 0);
    return {
      count: squad.length,
      avgAge:
        validPlayers.length > 0
          ? (totalAge / validPlayers.length).toFixed(1)
          : "N/A",
    };
  }, [squad]);

  const filterButtons = [
    { label: t("filter_all"), value: "All", icon: Users },
    {
      label: t("squad_filter_goalkeeper"),
      value: "Goalkeeper",
      icon: UserCircle,
    },
    { label: t("squad_filter_defender"), value: "Defender", icon: Shield },
    { label: t("squad_filter_midfielder"), value: "Midfielder", icon: Zap },
    { label: t("squad_filter_attacker"), value: "Attacker", icon: Goal },
  ];

  return (
    <div className="bg-brand-secondary rounded-lg">
      <div className="p-4 md:p-6 border-b border-gray-700/50">
        <div className="flex flex-col sm:flex-row justify-between sm:items-center gap-4">
          <h2 className="text-xl font-bold text-white flex items-center gap-2">
            <Users size={22} /> {t("full_squad")}
          </h2>
          <div className="flex items-center gap-4">
            <div className="text-right">
              <p className="text-xs text-text-muted">{t("total_players")}</p>
              <p className="font-bold text-white">{squadSummary.count}</p>
            </div>
            <div className="text-right">
              <p className="text-xs text-text-muted">{t("average_age")}</p>
              <p className="font-bold text-white">{squadSummary.avgAge}</p>
            </div>
          </div>
        </div>
        <div className="flex flex-wrap items-center gap-2 p-1 rounded-lg bg-[var(--color-primary)] mt-4">
          {filterButtons.map(({ label, value, icon: Icon }) => (
            <button
              key={value}
              onClick={() => setFilter(value)}
              className={`flex-1 md:flex-none flex items-center justify-center gap-2 px-3 py-1.5 rounded-md text-sm font-semibold transition-colors ${
                filter === value
                  ? "bg-[var(--brand-accent)] text-white"
                  : "text-text-muted hover:bg-gray-700/50"
              }`}
            >
              <Icon size={16} />
              {label}
            </button>
          ))}
        </div>
      </div>

      {}
      <div className="p-2 space-y-2 max-h-[600px] overflow-y-auto custom-scrollbar">
        {!squad || squad.length === 0 ? (
          <div className="text-center py-8 text-brand-muted">
            {t("squad_info_unavailable")}
          </div>
        ) : (
          filteredSquad.map((player) => (
            <PlayerRow key={player.id} player={player} />
          ))
        )}
      </div>
    </div>
  );
}

// ===== src/components/team/TeamTrophiesWidget.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { Trophy } from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

const fetchTrophies = async (teamId: number) => {
  const { data } = await axios.get(`/api/team-trophies?team=${teamId}`);
  return data;
};

const Skeleton = () => (
  <div className="bg-brand-secondary p-4 rounded-lg animate-pulse">
    <div className="h-5 w-3/4 mb-4 bg-gray-700 rounded"></div>
    <div className="space-y-3">
      <div className="h-8 w-full bg-gray-600 rounded"></div>
      <div className="h-8 w-full bg-gray-600 rounded"></div>
      <div className="h-8 w-full bg-gray-600 rounded"></div>
    </div>
  </div>
);

export default function TeamTrophiesWidget({ teamId }: { teamId: number }) {
  const { t } = useTranslation();
  const {
    data: trophies,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["teamTrophies", teamId],
    queryFn: () => fetchTrophies(teamId),
    staleTime: 1000 * 60 * 60 * 24,
  });

  if (isLoading) return <Skeleton />;
  if (isError || !trophies || trophies.length === 0) return null;

  return (
    <div className="bg-brand-secondary p-4 rounded-lg">
      <h3 className="text-lg font-bold text-white mb-4">{t("honours")}</h3>
      <div className="space-y-2 max-h-80 overflow-y-auto scrollbar-thin scrollbar-track-transparent scrollbar-thumb-gray-600">
        {trophies.map((trophy: any, index: number) => (
          <div
            key={`${trophy.league}-${trophy.season}-${index}`}
            className="flex items-center gap-3 bg-gray-800/50 p-2 rounded-md"
          >
            <Trophy className="w-5 h-5 text-yellow-500 flex-shrink-0" />
            <div className="flex-1">
              <p className="text-sm font-semibold text-white">
                {trophy.league}
              </p>
              <p className="text-xs text-brand-muted">{trophy.season}</p>
            </div>
            <p className="text-sm font-bold text-brand-light">{trophy.place}</p>
          </div>
        ))}
      </div>
    </div>
  );
}

// ===== src/components/team/index.tsx =====

"use client";

import { useState } from "react";
import AdSlotWidget from "@/components/AdSlotWidget";

import TeamHeader from "./TeamHeader";
import TeamInfoWidget from "./TeamInfoWidget";
import TeamTrophiesWidget from "./TeamTrophiesWidget";
import TeamSquadTab from "./TeamSquadWidget";

import LeagueFixturesWidget from "@/components/league-detail-view/LeagueFixturesWidget";

const TABS = ["Squad", "Fixtures", "Standings"];

export default function TeamDetailView({ teamData }: { teamData: any }) {
  const [activeTab, setActiveTab] = useState(TABS[0]);

  const { teamInfo, squad, fixtures } = teamData;
  const { team, venue } = teamInfo;

  return (
    <div>
      <TeamHeader team={team} countryFlag={fixtures?.[0]?.league?.flag || ""} />

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 items-start">
        <div className="lg:col-span-2 space-y-6">
          <div className="bg-brand-secondary rounded-lg p-2 flex items-center space-x-2">
            {TABS.map((tab) => (
              <button
                key={tab}
                onClick={() => setActiveTab(tab)}
                className={`flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-colors ${
                  activeTab === tab
                    ? "bg-brand-purple text-white"
                    : "text-brand-muted hover:bg-gray-700/50"
                }`}
              >
                {tab}
              </button>
            ))}
          </div>

          <div>
            {activeTab === "Squad" && <TeamSquadTab squad={squad} />}
            {activeTab === "Fixtures" && (

              <LeagueFixturesWidget leagueId={fixtures?.[0]?.league?.id} />
            )}
            {activeTab === "Standings" && (
              <div className="bg-brand-secondary p-8 rounded-lg text-center">
                <p>Team Standings Tab - Coming Soon!</p>
              </div>
            )}
          </div>
        </div>

        <aside className="lg:col-span-1 space-y-6">
          <TeamInfoWidget venue={venue} />
          <TeamTrophiesWidget teamId={team.id} />
          <AdSlotWidget />
        </aside>
      </div>
    </div>
  );
}

// ===== src/config/adSlots.ts =====

export interface AdSlot {
  id: string;
  name: string;
  description: string;
}

export const AD_SLOTS: AdSlot[] = [
  {
    id: "match_sidebar",
    name: "Match Page Sidebar",
    description:
      "Appears in the right sidebar on the individual match detail page.",
  },
  {
    id: "news_sidebar",
    name: "News Article Sidebar",
    description:
      "Appears in the right sidebar on individual news article pages.",
  },
  {
    id: "homepage_left_sidebar",
    name: "Homepage Left Sidebar",
    description:
      "Appears on the left side of the main content on the homepage. Ideal for vertical ads.",
  },
  {
    id: "homepage_right_sidebar",
    name: "Homepage Right Sidebar",
    description:
      "Appears on the right side of the main content on the homepage. Ideal for vertical ads.",
  },
  {
    id: "homepage_header",
    name: "Homepage Header Banner",
    description:
      "A prominent banner at the top of the homepage (under the header).",
  },
  {
    id: "sticky_footer",
    name: "Sticky Footer Banner",
    description:
      "A banner that sticks to the bottom of the screen on all pages. Ideal for landscape ads (e.g., 728x90).",
  },
];

// ===== src/config/topLeaguesConfig.ts =====

export interface TopLeagueConfig {
  name: string;
  leagueId: string;
  logo: string;
  priority: number;
}

export const topLeaguesConfig: TopLeagueConfig[] = [

  {
    name: "Premier League",
    leagueId: "39",
    logo: "https://media.api-sports.io/football/leagues/39.png",
    priority: 1,
  },
  {
    name: "La Liga",
    leagueId: "140",
    logo: "https://media.api-sports.io/football/leagues/140.png",
    priority: 2,
  },
  {
    name: "Serie A",
    leagueId: "135",
    logo: "https://media.api-sports.io/football/leagues/135.png",
    priority: 3,
  },
  {
    name: "Bundesliga",
    leagueId: "78",
    logo: "https://media.api-sports.io/football/leagues/78.png",
    priority: 4,
  },
  {
    name: "Ligue 1",
    leagueId: "61",
    logo: "https://media.api-sports.io/football/leagues/61.png",
    priority: 5,
  },
  {
    name: "UEFA Champions League",
    leagueId: "2",
    logo: "https://media.api-sports.io/football/leagues/2.png",
    priority: 6,
  },
  {
    name: "UEFA Europa League",
    leagueId: "3",
    logo: "https://media.api-sports.io/football/leagues/3.png",
    priority: 7,
  },
  {
    name: "FIFA World Cup",
    leagueId: "1",
    logo: "https://media.api-sports.io/football/leagues/1.png",
    priority: 8,
  },
  {
    name: "UEFA European Championship",
    leagueId: "4",
    logo: "https://media.api-sports.io/football/leagues/4.png",
    priority: 9,
  },
  {
    name: "Copa Libertadores",
    leagueId: "13",
    logo: "https://media.api-sports.io/football/leagues/13.png",
    priority: 10,
  },

  {
    name: "Sper Lig",
    leagueId: "203",
    logo: "https://media.api-sports.io/football/leagues/203.png",
    priority: 11,
  },
  {
    name: "Brasileiro Srie A",
    leagueId: "71",
    logo: "https://media.api-sports.io/football/leagues/71.png",
    priority: 12,
  },
  {
    name: "Saudi Pro League",
    leagueId: "307",
    logo: "https://media.api-sports.io/football/leagues/307.png",
    priority: 13,
  },
  {
    name: "Primeira Liga",
    leagueId: "94",
    logo: "https://media.api-sports.io/football/leagues/94.png",
    priority: 14,
  },
  {
    name: "Eredivisie",
    leagueId: "88",
    logo: "https://media.api-sports.io/football/leagues/88.png",
    priority: 15,
  },
  {
    name: "Argentine Primera Divisin",
    leagueId: "128",
    logo: "https://media.api-sports.io/football/leagues/128.png",
    priority: 16,
  },
  {
    name: "MLS",
    leagueId: "253",
    logo: "https://media.api-sports.io/football/leagues/253.png",
    priority: 17,
  },
  {
    name: "Liga MX",
    leagueId: "262",
    logo: "https://media.api-sports.io/football/leagues/262.png",
    priority: 18,
  },
  {
    name: "UEFA Europa Conference League",
    leagueId: "848",
    logo: "https://media.api-sports.io/football/leagues/848.png",
    priority: 19,
  },
  {
    name: "Copa America",
    leagueId: "9",
    logo: "https://media.api-sports.io/football/leagues/9.png",
    priority: 20,
  },
  {
    name: "Africa Cup of Nations",
    leagueId: "6",
    logo: "https://media.api-sports.io/football/leagues/6.png",
    priority: 21,
  },

  {
    name: "EFL Championship",
    leagueId: "40",
    logo: "https://media.api-sports.io/football/leagues/40.png",
    priority: 31,
  },
  {
    name: "FA Cup",
    leagueId: "45",
    logo: "https://media.api-sports.io/football/leagues/45.png",
    priority: 32,
  },
  {
    name: "EFL Cup",
    leagueId: "48",
    logo: "https://media.api-sports.io/football/leagues/48.png",
    priority: 33,
  },
  {
    name: "EFL League One",
    leagueId: "41",
    logo: "https://media.api-sports.io/football/leagues/41.png",
    priority: 34,
  },
  {
    name: "EFL League Two",
    leagueId: "42",
    logo: "https://media.api-sports.io/football/leagues/42.png",
    priority: 35,
  },
  {
    name: "National League",
    leagueId: "43",
    logo: "https://media.api-sports.io/football/leagues/43.png",
    priority: 36,
  },

  {
    name: "Scottish Premiership",
    leagueId: "179",
    logo: "https://media.api-sports.io/football/leagues/179.png",
    priority: 41,
  },
  {
    name: "Belgian Pro League",
    leagueId: "144",
    logo: "https://media.api-sports.io/football/leagues/144.png",
    priority: 42,
  },
  {
    name: "Austrian Bundesliga",
    leagueId: "218",
    logo: "https://media.api-sports.io/football/leagues/218.png",
    priority: 43,
  },
  {
    name: "Swiss Super League",
    leagueId: "207",
    logo: "https://media.api-sports.io/football/leagues/207.png",
    priority: 44,
  },
  {
    name: "Greek Super League",
    leagueId: "197",
    logo: "https://media.api-sports.io/football/leagues/197.png",
    priority: 45,
  },
  {
    name: "Croatian Football League (HNL)",
    leagueId: "210",
    logo: "https://media.api-sports.io/football/leagues/210.png",
    priority: 46,
  },
  {
    name: "Danish Superliga",
    leagueId: "119",
    logo: "https://media.api-sports.io/football/leagues/119.png",
    priority: 47,
  },
  {
    name: "Serbian SuperLiga",
    leagueId: "286",
    logo: "https://media.api-sports.io/football/leagues/286.png",
    priority: 48,
  },
  {
    name: "Polish Ekstraklasa",
    leagueId: "106",
    logo: "https://media.api-sports.io/football/leagues/106.png",
    priority: 49,
  },
  {
    name: "Czech First League",
    leagueId: "345",
    logo: "https://media.api-sports.io/football/leagues/345.png",
    priority: 50,
  },
  {
    name: "Norwegian Eliteserien",
    leagueId: "103",
    logo: "https://media.api-sports.io/football/leagues/103.png",
    priority: 51,
  },
  {
    name: "Swedish Allsvenskan",
    leagueId: "113",
    logo: "https://media.api-sports.io/football/leagues/113.png",
    priority: 52,
  },
  {
    name: "Russian Premier League",
    leagueId: "235",
    logo: "https://media.api-sports.io/football/leagues/235.png",
    priority: 53,
  },
  {
    name: "Ukrainian Premier League",
    leagueId: "234",
    logo: "https://media.api-sports.io/football/leagues/234.png",
    priority: 54,
  },
  {
    name: "Romanian Liga I",
    leagueId: "283",
    logo: "https://media.api-sports.io/football/leagues/283.png",
    priority: 55,
  },

  {
    name: "AFC Champions League",
    leagueId: "18",
    logo: "https://media.api-sports.io/football/leagues/18.png",
    priority: 61,
  },
  {
    name: "J1 League",
    leagueId: "98",
    logo: "https://media.api-sports.io/football/leagues/98.png",
    priority: 62,
  },
  {
    name: "K League 1",
    leagueId: "292",
    logo: "https://media.api-sports.io/football/leagues/292.png",
    priority: 63,
  },
  {
    name: "A-League Men",
    leagueId: "188",
    logo: "https://media.api-sports.io/football/leagues/188.png",
    priority: 64,
  },
  {
    name: "Categora Primera A",
    leagueId: "239",
    logo: "https://media.api-sports.io/football/leagues/239.png",
    priority: 65,
  },
  {
    name: "Egyptian Premier League",
    leagueId: "233",
    logo: "https://media.api-sports.io/football/leagues/233.png",
    priority: 66,
  },
  {
    name: "South African Premier Division",
    leagueId: "288",
    logo: "https://media.api-sports.io/football/leagues/288.png",
    priority: 67,
  },

  {
    name: "1. Lig",
    leagueId: "204",
    logo: "https://media.api-sports.io/football/leagues/204.png",
    priority: 91,
  },
  {
    name: "La Liga 2",
    leagueId: "141",
    logo: "https://media.api-sports.io/football/leagues/141.png",
    priority: 92,
  },
  {
    name: "2. Bundesliga",
    leagueId: "79",
    logo: "https://media.api-sports.io/football/leagues/79.png",
    priority: 93,
  },
  {
    name: "Serie B",
    leagueId: "136",
    logo: "https://media.api-sports.io/football/leagues/136.png",
    priority: 94,
  },
  {
    name: "Ligue 2",
    leagueId: "62",
    logo: "https://media.api-sports.io/football/leagues/62.png",
    priority: 95,
  },
];

export const leagueIdToPriorityMap = new Map(
  topLeaguesConfig.map((l) => [l.leagueId, l.priority])
);

// ===== src/context/CountryContext.tsx =====

"use client";

import { createContext, useState, useContext, ReactNode, Dispatch, SetStateAction } from 'react';
import { Country } from '@/types/api-football';

interface CountryContextType {
  selectedCountry: Country | null;
  setSelectedCountry: Dispatch<SetStateAction<Country | null>>;
}

const CountryContext = createContext<CountryContextType | undefined>(undefined);

export function CountryProvider({ children }: { children: ReactNode }) {
  const [selectedCountry, setSelectedCountry] = useState<Country | null>(null);

  return (
    <CountryContext.Provider value={{ selectedCountry, setSelectedCountry }}>
      {children}
    </CountryContext.Provider>
  );
}

export function useCountry() {
  const context = useContext(CountryContext);
  if (context === undefined) {
    throw new Error('useCountry must be used within a CountryProvider');
  }
  return context;
}

// ===== src/context/LanguageContext.tsx =====

"use client";

import { createContext, useState, useContext, ReactNode, Dispatch, SetStateAction } from 'react';

interface LanguageContextType {
  locale: 'en' | 'tr';
  setLocale: Dispatch<SetStateAction<'en' | 'tr'>>;
}

const LanguageContext = createContext<LanguageContextType | undefined>(undefined);

export function LanguageProvider({ children }: { children: ReactNode }) {

  const [locale, setLocale] = useState<'en' | 'tr'>('tr');

  return (
    <LanguageContext.Provider value={{ locale, setLocale }}>
      {children}
    </LanguageContext.Provider>
  );
}

export function useLanguage() {
  const context = useContext(LanguageContext);
  if (context === undefined) {
    throw new Error('useLanguage must be used within a LanguageProvider');
  }
  return context;
}

// ===== src/context/LeagueContext.tsx =====

"use client";

import { createContext, useContext, useState, ReactNode } from "react";
import { Country, League } from "@/types/api-football";

interface LeagueContextType {
  selectedCountry: Country | null;
  setSelectedCountry: (country: Country | null) => void;
  selectedLeague: League | null;
  setSelectedLeague: (league: League | null) => void;
}

const LeagueContext = createContext<LeagueContextType | undefined>(undefined);

export const LeagueProvider = ({ children }: { children: ReactNode }) => {

  const [selectedCountry, setSelectedCountry] = useState<Country | null>(null);
  const [selectedLeague, setSelectedLeague] = useState<League | null>(null);

  const value = { selectedCountry, setSelectedCountry, selectedLeague, setSelectedLeague };

  return (
    <LeagueContext.Provider value={value}>{children}</LeagueContext.Provider>
  );
};

export const useLeagueContext = (): LeagueContextType => {
  const context = useContext(LeagueContext);
  if (!context) throw new Error("useLeagueContext must be used within a LeagueProvider");
  return context;
};

// ===== src/context/TimeZoneContext.tsx =====

"use client";

import {
  createContext,
  useState,
  useContext,
  useEffect,
  ReactNode,
} from "react";

interface TimeZoneContextType {
  timeZone: string | null;
}

const TimeZoneContext = createContext<TimeZoneContextType | undefined>(
  undefined
);

export function TimeZoneProvider({ children }: { children: ReactNode }) {
  const [timeZone, setTimeZone] = useState<string | null>(null);

  useEffect(() => {

    const detectedTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    setTimeZone(detectedTimeZone);
  }, []);

  return (
    <TimeZoneContext.Provider value={{ timeZone }}>
      {children}
    </TimeZoneContext.Provider>
  );
}

export function useTimeZone() {
  const context = useContext(TimeZoneContext);
  if (context === undefined) {
    throw new Error("useTimeZone must be used within a TimeZoneProvider");
  }
  return context;
}

// ===== src/hooks/useDebounce.ts =====

"use client";

import { useState, useEffect } from "react";

export function useDebounce<T>(value: T, delay: number): T {

  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(
    () => {

      const handler = setTimeout(() => {
        setDebouncedValue(value);
      }, delay);

      return () => {
        clearTimeout(handler);
      };
    },
    [value, delay]
  );

  return debouncedValue;
}

// ===== src/hooks/useScrollDirection.ts =====

"use client";

import { useState, useEffect, useRef } from 'react';

interface ScrollDirectionOptions {

  threshold?: number;
}

export function useScrollDirection({ threshold = 200 }: ScrollDirectionOptions = {}) {
  const [isSticky, setIsSticky] = useState(false);
  const [isVisible, setIsVisible] = useState(true);
  const lastScrollY = useRef(0);

  useEffect(() => {
    const handleScroll = () => {
      const currentScrollY = window.scrollY;

      if (currentScrollY > threshold) {
        setIsSticky(true);

        if (currentScrollY > lastScrollY.current) {
          setIsVisible(false);
        } else {
          setIsVisible(true);
        }
      } else {

        setIsSticky(false);
        setIsVisible(true);
      }

      lastScrollY.current = currentScrollY;
    };

    window.addEventListener("scroll", handleScroll, { passive: true });

    return () => {
      window.removeEventListener("scroll", handleScroll);
    };
  }, [threshold]);

  return { isSticky, isVisible };
}

// ===== src/hooks/useTranslation.ts =====

"use client";

import { useI18n } from "@/lib/i18n/client";

export function useTranslation() {
  const { t, locale } = useI18n();
  return { t, locale };
}

// ===== src/hooks/useVoteStorage.ts =====

"use client";

import { useState, useCallback } from 'react';

const VOTE_STORAGE_KEY = 'matchVotes';

export function useVoteStorage() {

    const getVotes = useCallback((): { [key: number]: string } => {

        if (typeof window === 'undefined') {
            return {};
        }
        try {
            const votes = window.localStorage.getItem(VOTE_STORAGE_KEY);
            return votes ? JSON.parse(votes) : {};
        } catch (error) {

            return {};
        }
    }, []);

    const setVote = useCallback((fixtureId: number, choice: 'home' | 'draw' | 'away') => {
        if (typeof window === 'undefined') {
            return;
        }
        try {
            const allVotes = getVotes();
            allVotes[fixtureId] = choice;
            window.localStorage.setItem(VOTE_STORAGE_KEY, JSON.stringify(allVotes));
        } catch (error) {

        }
    }, [getVotes]);

    const getVoteForFixture = useCallback((fixtureId: number): string | null => {
        return getVotes()[fixtureId] || null;
    }, [getVotes]);

    return { setVote, getVoteForFixture };
}

// ===== src/lib/ai-processing.ts =====

import "server-only";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle, {
  IExternalNewsArticle,
} from "@/models/ExternalNewsArticle";
import Post from "@/models/Post";
import AIJournalist from "@/models/AIJournalist";
import Language from "@/models/Language";
import slugify from "slugify";
import mongoose from "mongoose";
import OpenAI from "openai";

const openai = new OpenAI({
  apiKey: process.env.NEXT_PUBLIC_OPENAI_API_KEY,
});

async function paraphraseSnippet(
  originalTitle: string,
  originalDescription: string,
  journalistName: string
): Promise<{ newTitle: string; newDescription: string }> {
  const prompt = `
    You are an expert Turkish sports journalist named "${journalistName}".
    Your task is to rewrite the given title and description to be more engaging, humanized, and SEO-friendly, as if you were writing a short summary for your own news site.
    GUIDELINES:
    1.  **Language:** All output MUST be in Turkish.
    2.  **Format:** Your entire response MUST be a single, valid JSON object with two keys: "newTitle" and "newDescription".
    3.  **Paraphrase Heavily:** Do not just translate. Completely rephrase the title and description to make them unique.
    4.  **Content:** The 'newDescription' should be a concise, compelling summary of 1-3 sentences.
    CONTEXT:
    - Original Title: "${originalTitle}"
    - Original Description: "${originalDescription}"
    YOUR RESPONSE (JSON object only):
  `;
  const response = await openai.chat.completions.create({
    model: "gpt-4o",
    messages: [{ role: "user", content: prompt }],
    temperature: 0.7,
    response_format: { type: "json_object" },
  });
  const content = response.choices[0]?.message?.content;
  if (!content)
    throw new Error("OpenAI response was empty for paraphraseSnippet.");
  try {
    const parsed = JSON.parse(content);
    if (!parsed.newTitle || !parsed.newDescription)
      throw new Error(
        "AI response was missing required JSON fields for paraphraseSnippet."
      );
    return parsed;
  } catch (e) {
    console.error(
      "Failed to parse JSON from OpenAI paraphraseSnippet:",
      content,
      e
    );
    throw new Error("AI failed to generate a valid paraphrase object.");
  }
}

async function translateTextWithRetry(
  text: string,
  targetLanguage: string,
  retries = 3
): Promise<string> {
  const prompt = `Translate the following text into ${targetLanguage}. Return ONLY the translated text, without any quotes, labels, or extra formatting. TEXT TO TRANSLATE: "${text}"`;

  for (let i = 0; i < retries; i++) {
    try {
      const response = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "user", content: prompt }],
        temperature: 0.2,
      });
      const translatedText = response.choices[0]?.message?.content
        ?.trim()
        .replace(/["']/g, "");
      if (!translatedText)
        throw new Error("Empty response from OpenAI for translation.");
      return translatedText;
    } catch (error: any) {
      console.error(
        `Attempt ${i + 1} failed for translating to ${targetLanguage}:`,
        error.message
      );
      if (i === retries - 1) {
        throw new Error(
          `OpenAI failed to translate text to ${targetLanguage} after ${retries} attempts.`
        );
      }
      await new Promise((res) => setTimeout(res, 1500 * (i + 1)));
    }
  }
  throw new Error(`Translation to ${targetLanguage} failed unexpectedly.`);
}

export async function processSingleArticle(
  externalArticle: IExternalNewsArticle,
  options: { onProgress?: (log: string) => void } = {}
): Promise<{ success: boolean; primaryPostId?: string }> {
  const { onProgress = () => {} } = options;
  try {
    await dbConnect();

    const lockedArticle = await ExternalNewsArticle.findOneAndUpdate(
      { _id: externalArticle._id, status: "fetched" },
      { $set: { status: "processing" } },
      { new: false }
    );

    if (!lockedArticle) {
      onProgress(
        `Article "${externalArticle.title}" is already being processed or is in a final state. Skipping.`
      );
      return { success: true };
    }

    onProgress("Fetching languages and default AI journalist...");
    const allActiveLanguages = await Language.find({ isActive: true }).lean();
    const defaultJournalist = await AIJournalist.findOne({
      isActive: true,
    }).sort({ createdAt: 1 });

    if (!defaultJournalist) throw new Error("No active AI Journalist found.");
    if (allActiveLanguages.length === 0)
      throw new Error("No active languages found.");
    onProgress(`-> Using journalist: ${defaultJournalist.name}`);

    onProgress("Paraphrasing article in primary language (Turkish)...");
    const { newTitle, newDescription } = await paraphraseSnippet(
      externalArticle.title,
      externalArticle.content ||
        externalArticle.description ||
        externalArticle.title,
      defaultJournalist.name
    );
    onProgress(`-> Generated Title: "${newTitle}"`);

    const primaryLanguageCode = "tr";
    const slug = slugify(newTitle, { lower: true, strict: true });
    const existingPost = await Post.findOne({
      slug,
      language: primaryLanguageCode,
    });
    const finalSlug = existingPost
      ? `${slug}-${Date.now().toString().slice(-5)}`
      : slug;

    onProgress("Saving primary Turkish article...");

    const primaryPost = new Post({
      title: newTitle,
      content: `<p>${newDescription}</p>`,
      slug: finalSlug,
      author: defaultJournalist.name,
      featuredImage: externalArticle.imageUrl,
      language: primaryLanguageCode,
      translationGroupId: new mongoose.Types.ObjectId(),
      isAIGenerated: true,
      status: "published",
      newsType: "recent",
      sportsCategory: ["general", "football"],
      originalSourceUrl: externalArticle.link,
      metaTitle: newTitle,
      metaDescription: newDescription,
    });

    await primaryPost.save();
    onProgress("-> Primary article saved.");

    const otherLanguages = allActiveLanguages.filter(
      (lang) => lang.code !== primaryLanguageCode
    );
    onProgress(
      `Found ${otherLanguages.length} other languages to translate to...`
    );

    const translationPromises = otherLanguages.map((lang) =>
      Promise.all([
        translateTextWithRetry(newTitle, lang.name),
        translateTextWithRetry(newDescription, lang.name),
      ])
        .then(([translatedTitle, translatedContent]) => ({
          status: "fulfilled",
          value: { lang, translatedTitle, translatedContent },
        }))
        .catch((error) => ({ status: "rejected", reason: { lang, error } }))
    );

    const results = await Promise.all(translationPromises);

    for (const result of results) {
      if (result.status === "fulfilled") {
        const { lang, translatedTitle, translatedContent } = result.value;
        onProgress(`-- Translating to ${lang.name}...`);
        const translatedSlug = slugify(translatedTitle, {
          lower: true,
          strict: true,
        });
        const translatedPost = new Post({
          ...primaryPost.toObject(),
          _id: new mongoose.Types.ObjectId(),
          isNew: true,
          title: translatedTitle,
          content: `<p>${translatedContent}</p>`,
          slug: translatedSlug,
          language: lang.code,
          translationGroupId: primaryPost.translationGroupId,
          metaTitle: translatedTitle,
          metaDescription: translatedContent,
        });
        await translatedPost.save();
        onProgress(`--  Saved ${lang.name} translation.`);
      } else {
        const { lang, error } = result.reason;
        onProgress(
          `--  Failed to translate to ${lang.name}: ${error.message}`
        );
      }
    }

    await ExternalNewsArticle.updateOne(
      { _id: externalArticle._id },
      {
        $set: { status: "processed", processedPostId: primaryPost._id },
      }
    );

    onProgress(
      ` Successfully processed and translated article for group ${primaryPost.translationGroupId}`
    );
    return { success: true, primaryPostId: primaryPost._id.toString() };
  } catch (error: any) {
    onProgress(` ERROR: ${error.message}`);

    await ExternalNewsArticle.updateOne(
      { _id: externalArticle._id, status: "processing" },
      { $set: { status: "error" } }
    );
    return { success: false };
  }
}

// ===== src/lib/analytics.ts =====

declare global {
  interface Window {
    gtag: (
      command: "event",
      action: string,
      params: { [key: string]: any }
    ) => void;
  }
}

export const sendGAEvent = (action: string, params: { [key: string]: any }) => {
  if (typeof window.gtag === "function") {
    window.gtag("event", action, params);
  }
};

// ===== src/lib/data/directory.ts =====

import "server-only";
import axios from "axios";
import { generateStandingsSlug } from "../generate-standings-slug";

const STANDINGS_LEAGUE_IDS = new Set([
  39, 140, 135, 78, 61, 2, 3, 848, 88, 94, 203, 144, 179, 218, 207, 253, 262,
  71, 128, 239, 265, 130, 98, 307, 20,
]);

async function apiRequest(endpoint: string, params: object) {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    timeout: 10000,
  };
  try {
    const response = await axios.request(options);
    return response.data.response;
  } catch (error) {
    console.error(
      `[data/directory] API request failed for ${endpoint}:`,
      error
    );
    return [];
  }
}

export async function getLeaguesForStandingsSitemap() {
  try {
    const leagues = await apiRequest("leagues", { current: "true" });

    const popularLeagues = leagues.filter(
      (item: any) =>
        STANDINGS_LEAGUE_IDS.has(item.league.id) &&
        item.league.type === "League"
    );

    return popularLeagues.map((item: any) => ({
      id: item.league.id,
      name: item.league.name,
    }));
  } catch (error) {
    console.error(
      "[data/directory] Failed to fetch leagues for standings sitemap:",
      error
    );
    return [];
  }
}

// ===== src/lib/data/fixtures.ts =====

import "server-only";
import axios from "axios";
import { format, addDays, eachDayOfInterval } from "date-fns";

const axiosOptions = (params: object) => ({
  method: "GET",
  url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
  params,
  headers: {
    "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
  },
});

export async function getFixturesByDateRange(from: string, to: string) {
  try {
    const startDate = new Date(from);
    const endDate = new Date(to);
    const interval = eachDayOfInterval({ start: startDate, end: endDate });
    const dateStrings = interval.map((day) => format(day, "yyyy-MM-dd"));

    const fixturePromises = dateStrings.map((d) =>
      axios.request(axiosOptions({ date: d }))
    );

    const responses = await Promise.allSettled(fixturePromises);

    const allFixtures = responses
      .filter(
        (result) => result.status === "fulfilled" && result.value.data.response
      )
      .flatMap(
        (result) => (result as PromiseFulfilledResult<any>).value.data.response
      );

    const uniqueFixtures = Array.from(
      new Map(allFixtures.map((m) => [m.fixture.id, m])).values()
    );

    return uniqueFixtures;
  } catch (error) {
    console.error(
      "[data/fixtures] Failed to fetch fixtures by date range:",
      error
    );
    return [];
  }
}

// ===== src/lib/data/highlightly.ts =====

import axios from "axios";
import redis from "@/lib/redis";

const API_BASE_URL = "https://soccer.highlightly.net/highlights";
const API_KEY = process.env.NEXT_PUBLIC_HIGHLIGHTLY_API_KEY;

const CACHE_KEY = "highlights:latest-v6";
const CACHE_TTL_SUCCESS = 60 * 15;
const CACHE_TTL_RATELIMIT = 60 * 5;

async function request(endpoint: string, params?: object) {
  if (!API_KEY) {
    console.error(
      "[Highlightly Service] FATAL: HIGHLIGHTLY_API key is not configured."
    );
    throw new Error("Highlightly API Key is not configured.");
  }
  try {
    const response = await axios.get(`${API_BASE_URL}`, {
      params,
      headers: {
        "x-rapidapi-key": API_KEY,
        "x-rapidapi-host": "football-highlights-api.p.rapidapi.com",
      },
      timeout: 15000,
    });
    console.log(
      `[Highlightly Service] API SUCCESS: Fetched ${
        response.data?.data?.length || 0
      } items from /${endpoint}`
    );

    );
    );

    return response.data;
  } catch (error: any) {

    if (axios.isAxiosError(error) && error.response?.status === 429) {
      console.warn(
        "[Highlightly Service] WARN: Received 429 Rate Limit error from API."
      );

      const rateLimitError = new Error("Rate limited by Highlightly API");
      rateLimitError.name = "RateLimitError";
      throw rateLimitError;
    }
    console.error(
      `[Highlightly Service] ERROR: Failed to fetch from '${endpoint}':`,
      error.message
    );
    throw new Error(
      `Failed to fetch data from the highlights provider: ${error.message}`
    );
  }
}

export async function getMatchHighlights(params: object) {
  const data = await request("football/highlights", params);
  return data;
}

export async function getLatestPopularHighlights() {
  const cachedData = await redis.get(CACHE_KEY);
  if (cachedData) {
    const parsedData = JSON.parse(cachedData);

    if (parsedData.isRateLimited) {
      console.log(
        "[Highlightly Service] Serving RATE_LIMITED status from cache."
      );
      return [];
    }

    return parsedData;
  }

  console.log(
    "[Highlightly Service] Cache miss. Fetching latest highlights from Highlightly API's 'latest' endpoint."
  );

  try {
    const result = await request("football/highlights", {
      limit: 40,
    });

    if (!result || !result.data || !Array.isArray(result.data)) {
      console.warn(
        "[Highlightly Service] No highlights data array returned from the API."
      );
      return [];
    }

    const uniqueHighlights = Array.from(
      new Map(result.data.map((item: any) => [item.embedUrl, item])).values()
    );

    if (uniqueHighlights.length > 0) {
      await redis.set(
        CACHE_KEY,
        JSON.stringify(uniqueHighlights),
        "EX",
        CACHE_TTL_SUCCESS
      );
      console.log(
        `[Highlightly Service] Cached ${uniqueHighlights.length} new highlights.`
      );
    }

    return uniqueHighlights;
  } catch (error: any) {

    if (error.name === "RateLimitError") {
      console.log(
        `[Highlightly Service] Caching RATE_LIMITED status for ${CACHE_TTL_RATELIMIT} seconds.`
      );

      await redis.set(
        CACHE_KEY,
        JSON.stringify({ isRateLimited: true }),
        "EX",
        CACHE_TTL_RATELIMIT
      );
    } else {
      console.error(
        "[Highlightly Service] An unexpected error occurred during fetch. Returning empty array.",
        error
      );
    }

    return [];
  }
}

// ===== src/lib/data/league.ts =====

import "server-only";
import axios from "axios";
import redis from "@/lib/redis";

const STALE_CACHE_TTL_SECONDS = 60 * 60 * 24 * 7;

export async function getLeaguePageData(leagueId: string): Promise<any | null> {
  const cacheKey = `league-page-data:${leagueId}`;
  const season = new Date().getFullYear();

  try {
    const options = (endpoint: string, params: object) => ({
      method: "GET",
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
      params,
      headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
      timeout: 8000,
    });

    const [leagueDetailsResponse, standingsResponse] = await Promise.all([
      axios.request(options("leagues", { id: leagueId })),
      axios.request(options("standings", { league: leagueId, season: season })),
    ]);

    const leagueData = leagueDetailsResponse.data.response[0];
    if (!leagueData) {

      throw new Error(`League with ID ${leagueId} not found in external API.`);
    }

    leagueData.standings =
      standingsResponse.data.response[0]?.league?.standings || [];

    await redis.set(
      cacheKey,
      JSON.stringify(leagueData),
      "EX",
      STALE_CACHE_TTL_SECONDS
    );

    return leagueData;
  } catch (error: any) {

    console.error(
      `[data/league] API fetch failed for leagueId ${leagueId}:`,
      error.code || error.message
    );
    console.log(
      `[data/league] Attempting to serve stale data from cache for key: ${cacheKey}`
    );

    try {
      const cachedData = await redis.get(cacheKey);
      if (cachedData) {
        console.log(
          `[data/league]  Successfully served stale data for leagueId ${leagueId}.`
        );
        return JSON.parse(cachedData);
      } else {
        console.error(
          `[data/league]  No stale data available in cache for leagueId ${leagueId}. Returning null.`
        );
        return null;
      }
    } catch (cacheError) {
      console.error(
        `[data/league]  CRITICAL: Failed to access Redis during fallback for leagueId ${leagueId}.`,
        cacheError
      );
      return null;
    }
  }
}

// ===== src/lib/data/leagues.ts =====

import "server-only";
import dbConnect from "@/lib/dbConnect";
import League from "@/models/League";
import { generateLeagueSlug } from "@/lib/generate-league-slug";

export async function getAllLeaguesForSitemap() {
  try {
    await dbConnect();

    const leagues = await League.find({})
      .select("name leagueId")
      .sort({ name: 1 })
      .lean();

    return leagues.map((league) => ({
      name: league.name,
      id: league.leagueId,

      slug: generateLeagueSlug(league.name, league.leagueId),
    }));
  } catch (error) {
    console.error(
      `[data/leagues] Error fetching all leagues for sitemap:`,
      error
    );
    return [];
  }
}

// ===== src/lib/data/match.ts =====

import { cache } from "react";
import axios from "axios";
import "server-only";
import redis from "@/lib/redis";
import { calculateCustomPrediction } from "@/lib/prediction-engine";
import { getNews } from "@/lib/data/news";
import { getMatchHighlights as fetchHighlights } from "@/lib/data/highlightly";

const STALE_CACHE_TTL_SECONDS = 60 * 60 * 24 * 7;
const LIVE_CACHE_TTL_SECONDS = 60;

const apiRequest = async <T>(
  endpoint: string,
  params: object,
  cacheKey: string,
  ttl: number
): Promise<T | null> => {
  try {
    const options = {
      method: "GET",
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
      params,
      headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
      timeout: 8000,
    };
    const response = await axios.request(options);
    const data = response.data.response;

    if (data && (!Array.isArray(data) || data.length > 0)) {
      await redis.set(cacheKey, JSON.stringify(data), "EX", ttl);
    }
    return data;
  } catch (error: any) {
    console.error(
      `[data/match.ts] API request for ${endpoint} with key ${cacheKey} failed: ${error.message}. Attempting to serve from cache.`
    );

    try {
      const cachedData = await redis.get(cacheKey);
      if (cachedData) {
        console.log(
          `[data/match.ts]  Successfully served STALE data for key: ${cacheKey}`
        );
        return JSON.parse(cachedData);
      } else {
        console.error(
          `[data/match.ts]  No stale data available in cache for key: ${cacheKey}.`
        );
        return null;
      }
    } catch (cacheError) {
      console.error(
        `[data/match.ts]  CRITICAL: Redis lookup failed during fallback for key ${cacheKey}.`,
        cacheError
      );
      return null;
    }
  }
};

export const getFixture = cache(async (fixtureId: string) => {
  const cacheKey = `fixture:${fixtureId}`;

  try {
    const cachedData = await redis.get(cacheKey);
    if (cachedData) {

      return JSON.parse(cachedData);
    }
  } catch (e) {

  }

  const fixtureResponse = await apiRequest<any[]>(
    "fixtures",
    { id: fixtureId },
    cacheKey,
    STALE_CACHE_TTL_SECONDS
  );

  if (!fixtureResponse || fixtureResponse.length === 0) return null;
  return fixtureResponse[0];
});

export const getStatistics = cache(async (fixtureId: string) => {
  const cacheKey = `statistics:${fixtureId}`;
  const cachedData = await redis.get(cacheKey);
  if (cachedData) return JSON.parse(cachedData);

  return await apiRequest<any[]>(
    "fixtures/statistics",
    { fixture: fixtureId },
    cacheKey,
    LIVE_CACHE_TTL_SECONDS
  );
});

export const getH2H = cache(async (homeTeamId: number, awayTeamId: number) => {
  const sortedIds = [homeTeamId, awayTeamId].sort();
  const cacheKey = `h2h:${sortedIds[0]}-${sortedIds[1]}`;
  const cachedData = await redis.get(cacheKey);
  if (cachedData) return JSON.parse(cachedData);

  return await apiRequest<any[]>(
    "fixtures/headtohead",
    { h2h: `${homeTeamId}-${awayTeamId}` },
    cacheKey,
    STALE_CACHE_TTL_SECONDS
  );
});

export const getTeamStats = cache(
  async (leagueId: number, season: number, teamId: number) => {
    const cacheKey = `team-stats:${teamId}:${leagueId}:${season}`;
    const cachedData = await redis.get(cacheKey);
    if (cachedData) return JSON.parse(cachedData);

    return await apiRequest<any>(
      "teams/statistics",
      { league: leagueId, season: season, team: teamId },
      cacheKey,
      STALE_CACHE_TTL_SECONDS
    );
  }
);

export const getStandings = cache(async (leagueId: number, season: number) => {
  const cacheKey = `standings:${leagueId}:${season}`;
  const cachedData = await redis.get(cacheKey);
  if (cachedData) return JSON.parse(cachedData);

  return await apiRequest<any[]>(
    "standings",
    { league: leagueId, season: season },
    cacheKey,
    STALE_CACHE_TTL_SECONDS
  );
});

export const getBookmakerOdds = cache(async (fixtureId: string) => {
  const cacheKey = `odds:${fixtureId}`;
  const cachedData = await redis.get(cacheKey);
  if (cachedData) return JSON.parse(cachedData);

  const response = await apiRequest<any[]>(
    "odds",
    { fixture: fixtureId, bet: "1" },
    cacheKey,
    STALE_CACHE_TTL_SECONDS
  );
  return response ?? [];
});

export const getLinkedNews = cache(
  async (fixtureId: number, locale: string) => {
    const newsData = await getNews({
      linkedFixtureId: fixtureId,
      limit: 5,
      locale,
    });
    return newsData.posts;
  }
);

export const getMatchHighlights = cache(
  async (leagueName: string, homeTeamName: string, awayTeamName: string) => {
    const highlightsData = await fetchHighlights({
      leagueName,
      homeTeamName,
      awayTeamName,
      limit: 10,
    });
    return highlightsData?.data ?? [];
  }
);

export const getPredictionData = cache(
  async (
    fixtureId: string,
    homeTeamId: number,
    awayTeamId: number,
    leagueId: number,
    season: number
  ) => {
    const [h2h, homeTeamStats, awayTeamStats, standingsResponse] =
      await Promise.all([
        getH2H(homeTeamId, awayTeamId),
        getTeamStats(leagueId, season, homeTeamId),
        getTeamStats(leagueId, season, awayTeamId),
        getStandings(leagueId, season),
      ]);

    const flatStandings =
      standingsResponse?.[0]?.league?.standings?.flat() || [];
    const homeTeamRank = flatStandings.find(
      (s: any) => s.team.id === homeTeamId
    )?.rank;
    const awayTeamRank = flatStandings.find(
      (s: any) => s.team.id === awayTeamId
    )?.rank;

    const customPrediction = calculateCustomPrediction(
      h2h,
      homeTeamStats,
      awayTeamStats,
      homeTeamId,
      homeTeamRank,
      awayTeamRank,
      null,
      "NS"
    );

    return {
      homeTeamStats,
      awayTeamStats,
      customPrediction,
    };
  }
);

export const fetchMatchPageData = cache(async (fixtureId: string) => {
  console.warn(
    "DEPRECATED: fetchMatchPageData is called. Please refactor to use granular data hooks."
  );
  const fixtureData = await getFixture(fixtureId);
  if (!fixtureData) return null;
  const { league, teams } = fixtureData;
  const { home: homeTeam, away: awayTeam } = teams;
  const [
    statistics,
    h2h,
    homeTeamStats,
    awayTeamStats,
    standingsResponse,
    bookmakerOdds,
  ] = await Promise.all([
    getStatistics(fixtureId),
    getH2H(homeTeam.id, awayTeam.id),
    getTeamStats(league.id, league.season, homeTeam.id),
    getTeamStats(league.id, league.season, awayTeam.id),
    getStandings(league.id, league.season),
    getBookmakerOdds(fixtureId),
  ]);
  const standings = standingsResponse?.[0]?.league?.standings[0] || [];
  const homeTeamRank = standings.find(
    (s: any) => s.team.id === homeTeam.id
  )?.rank;
  const awayTeamRank = standings.find(
    (s: any) => s.team.id === awayTeam.id
  )?.rank;
  const customPrediction = calculateCustomPrediction(
    h2h,
    homeTeamStats,
    awayTeamStats,
    homeTeam.id,
    homeTeamRank,
    awayTeamRank,
    null,
    fixtureData.fixture.status.short
  );
  return {
    fixture: fixtureData,
    statistics,
    h2h,
    standings: standingsResponse,
    analytics: {
      homeTeamStats,
      awayTeamStats,
      customPrediction,
      bookmakerOdds,
    },
  };
});

// ===== src/lib/data/news.ts =====

import "server-only";
import dbConnect from "@/lib/dbConnect";
import Post, { IPost, NewsType, SportsCategory } from "@/models/Post";

const DEFAULT_LOCALE = "tr";

interface GetNewsParams {
  locale: string;
  sportsCategory?: SportsCategory;
  newsType?: NewsType;
  page?: number;
  limit?: number;
  linkedFixtureId?: number;
}

export async function getNews(
  params: GetNewsParams
): Promise<{
  posts: IPost[];
  pagination: { totalCount: number; totalPages: number };
}> {
  const {
    locale,
    sportsCategory,
    newsType,
    page = 1,
    limit = 10,
    linkedFixtureId,
  } = params;

  try {
    await dbConnect();

    const matchConditions: any[] = [{ status: "published" }];

    if (sportsCategory) {
      matchConditions.push({ sportsCategory: { $in: [sportsCategory] } });
    }

    if (newsType) {
      matchConditions.push({ newsType: newsType });
    }
    if (linkedFixtureId) {
      matchConditions.push({ linkedFixtureId: linkedFixtureId });
    }

    const matchStage = { $and: matchConditions };

    const skip = (page - 1) * limit;

    const initialPipeline = [
      { $match: matchStage },
      {
        $addFields: {
          effectiveGroupId: { $ifNull: ["$translationGroupId", "$_id"] },
        },
      },
      {
        $addFields: {
          langPriority: {
            $cond: {
              if: { $eq: ["$language", locale] },
              then: 1,
              else: {
                $cond: {
                  if: { $eq: ["$language", DEFAULT_LOCALE] },
                  then: 2,
                  else: 3,
                },
              },
            },
          },
        },
      },
      { $sort: { effectiveGroupId: 1, langPriority: 1 } },
      { $group: { _id: "$effectiveGroupId", document: { $first: "$$ROOT" } } },
      { $replaceRoot: { newRoot: "$document" } },
      { $sort: { createdAt: -1 } },
    ];

    const facetPipeline = [
      ...initialPipeline,
      {
        $facet: {
          paginatedResults: [{ $skip: skip }, { $limit: limit }],
          totalCount: [{ $count: "count" }],
        },
      },
    ];

    const results = await Post.aggregate(facetPipeline);

    const posts = results[0].paginatedResults;
    const totalCount = results[0].totalCount[0]
      ? results[0].totalCount[0].count
      : 0;
    const totalPages = Math.ceil(totalCount / limit);

    return {
      posts: JSON.parse(JSON.stringify(posts)),
      pagination: {
        totalCount,
        totalPages,
      },
    };
  } catch (error) {

    return { posts: [], pagination: { totalCount: 0, totalPages: 0 } };
  }
}

// ===== src/lib/data/team.ts =====

import axios from "axios";
import redis from "@/lib/redis";
import "server-only";

const STALE_CACHE_TTL_SECONDS = 60 * 60 * 24 * 7;

export async function fetchTeamDetails(teamId: string) {
  const season = new Date().getFullYear().toString();
  const cacheKey = `team-details:${teamId}:${season}`;

  try {
    const options = (endpoint: string, params: object) => ({
      method: "GET",
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
      params,
      headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
      timeout: 8000,
    });

    const results = await Promise.allSettled([
      axios.request(options("teams", { id: teamId })),
      axios.request(options("players/squads", { team: teamId })),
      axios.request(options("fixtures", { team: teamId, last: 10 })),
      axios.request(options("standings", { team: teamId, season: season })),
    ]);

    const teamInfoResponse =
      results[0].status === "fulfilled" ? results[0].value : null;
    const squadResponse =
      results[1].status === "fulfilled" ? results[1].value : null;
    const recentFixturesResponse =
      results[2].status === "fulfilled" ? results[2].value : null;
    const standingsResponse =
      results[3].status === "fulfilled" ? results[3].value : null;

    if (
      !teamInfoResponse ||
      !teamInfoResponse.data.response ||
      teamInfoResponse.data.response.length === 0
    ) {
      throw new Error(`No team info found for teamId: ${teamId}`);
    }

    const responseData = {
      teamInfo: teamInfoResponse.data.response[0],
      squad: squadResponse?.data.response[0]?.players ?? [],
      fixtures: recentFixturesResponse?.data.response ?? [],
      standings: standingsResponse?.data.response ?? [],
    };

    await redis.set(
      cacheKey,
      JSON.stringify(responseData),
      "EX",
      STALE_CACHE_TTL_SECONDS
    );

    return responseData;
  } catch (error: any) {

    console.error(
      `[data/team] API fetch failed for teamId ${teamId}:`,
      error.code || error.message
    );
    console.log(
      `[data/team] Attempting to serve stale data from cache for key: ${cacheKey}`
    );

    try {
      const cachedData = await redis.get(cacheKey);
      if (cachedData) {
        console.log(
          `[data/team]  Successfully served stale data for teamId ${teamId}.`
        );
        return JSON.parse(cachedData);
      } else {
        console.error(
          `[data/team]  No stale data available in cache for teamId ${teamId}. Returning null.`
        );
        return null;
      }
    } catch (cacheError) {
      console.error(
        `[data/team]  CRITICAL: Failed to access Redis during fallback for teamId ${teamId}.`,
        cacheError
      );
      return null;
    }

  }
}

// ===== src/lib/date-formatter.ts =====

import { formatInTimeZone } from "date-fns-tz";

export const formatZonedTime = (
  utcDateString: string | Date,
  timeZone: string,
  formatString: string = "HH:mm"
): string => {
  try {

    return formatInTimeZone(utcDateString, timeZone, formatString);
  } catch (error) {

    return "--:--";
  }
};

// ===== src/lib/dbConnect.ts =====

import mongoose from "mongoose";

const NEXT_PUBLIC_MONGODB_URI = process.env.NEXT_PUBLIC_MONGODB_URI;

if (!NEXT_PUBLIC_MONGODB_URI) {
  throw new Error(
    "Please define the NEXT_PUBLIC_MONGODB_URI environment variable inside .env.local"
  );
}

let cached: {
  promise: Promise<any> | null;
} = (global as any).mongoose;

if (!cached) {
  cached = (global as any).mongoose = { promise: null };
}

async function dbConnect() {

  if (cached.promise) {

    return await cached.promise;
  }

  const opts = {
    bufferCommands: false,
    serverSelectionTimeoutMS: 45000,
  };

  cached.promise = mongoose
    .connect(NEXT_PUBLIC_MONGODB_URI!, opts)
    .then((mongoose) => {

      return mongoose;
    })
    .catch((err) => {

      cached.promise = null;

      throw err;
    });

  try {

    return await cached.promise;
  } catch (e) {

    cached.promise = null;
    throw e;
  }
}

export default dbConnect;

// ===== src/lib/ga.ts =====

"use client";

import { sendGAEvent } from "@next/third-parties/google";

interface GAEvent {
  action: string;
  category: string;
  label?: string;
  value?: number;
}

export const trackEvent = ({ action, category, label, value }: GAEvent) => {
  sendGAEvent({ event: action, value: { category, label, value } });
};

// ===== src/lib/generate-league-slug.ts =====

import slugify from "slugify";

export function generateLeagueSlug(
  name: string,
  id: number,
  locale?: string
): any {
  const nameSlug = slugify(name, {
    lower: true,
    strict: true,
    trim: true,
    remove: /[*+~.()'"!:@]/g,
  });

  if (locale) return `/${locale}/football/league/${nameSlug}-${id}`;
  else return `/football/league/${nameSlug}-${id}`;
}

// ===== src/lib/generate-match-slug.ts =====

import slugify from "slugify";

interface Team {
  name: string;
}

export function generateMatchSlug(
  homeTeam: Team,
  awayTeam: Team,
  fixtureId: number
): string {
  const homeName = homeTeam?.name || "team";
  const awayName = awayTeam?.name || "team";

  const homeSlug = slugify(homeName, {
    lower: true,
    strict: true,
    remove: /[*+~.()'"!:@]/g,
  });
  const awaySlug = slugify(awayName, {
    lower: true,
    strict: true,
    remove: /[*+~.()'"!:@]/g,
  });

  return `/football/match/${homeSlug}-vs-${awaySlug}-${fixtureId}`;
}

// ===== src/lib/generate-standings-slug.ts =====

import slugify from "slugify";

export function generateStandingsSlug(name: string, id: number): string {
  const nameSlug = slugify(name, {
    lower: true,
    strict: true,
    trim: true,
    remove: /[*+~.()'"!:@]/g,
  });
  return `${nameSlug}-${id}`;
}

// ===== src/lib/generate-team-slug.ts =====

import slugify from "slugify";

export const generateTeamSlug = (
  teamName: string,
  teamId: number,
  locale?: string
) => {
  const slug = slugify(teamName, {
    lower: true,
    strict: true,
    remove: /[*+~.()'"!:@]/g,
  });
  if (locale) return `/${locale}/football/team/${slug}-${teamId}`;
  else return `/football/team/${slug}-${teamId}`;
};

// ===== src/lib/hreflang.ts =====

import { DEFAULT_LOCALE, SUPPORTED_LOCALES } from "./i18n/config";

const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

export type TranslationInfo = {
  slug: string;
  language: string;
};

export async function generateHreflangTags(
  basePath: string,
  currentSlug: string,
  currentLocale: string,
  translations?: TranslationInfo[]
) {
  const defaultLocale = DEFAULT_LOCALE;
  const alternates: {
    canonical: string;
    languages: { [key: string]: string };
  } = {
    canonical: "",
    languages: {},
  };

  const getUrlForLocale = (locale: string, slug: string) => {

    const pathSegments = [basePath, slug].filter(Boolean);
    let path = pathSegments.join("/");

    if (path === "/") {

      if (locale === defaultLocale) return `${BASE_URL}/`;
      return `${BASE_URL}/${locale}`;
    }

    const cleanPath = ("/" + path).replace(/\/+/g, "/").replace(/\/$/, "");

    if (locale === defaultLocale) {
      return `${BASE_URL}${cleanPath}`;
    }
    return `${BASE_URL}/${locale}${cleanPath}`;

  };

  if (translations && translations.length > 0) {
    translations.forEach((translation) => {
      alternates.languages[translation.language] = getUrlForLocale(
        translation.language,
        translation.slug
      );
    });
    const currentTranslation = translations.find(
      (t) => t.language === currentLocale
    );
    alternates.canonical = getUrlForLocale(
      currentLocale,
      currentTranslation ? currentTranslation.slug : currentSlug
    );
  } else {

    SUPPORTED_LOCALES.forEach((locale) => {
      alternates.languages[locale] = getUrlForLocale(locale, currentSlug);
    });
    alternates.canonical = getUrlForLocale(currentLocale, currentSlug);
  }

  const defaultTranslation = translations?.find(
    (t) => t.language === defaultLocale
  );
  alternates.languages["x-default"] = getUrlForLocale(
    defaultLocale,
    defaultTranslation ? defaultTranslation.slug : currentSlug
  );

  return alternates;
}

// ===== src/lib/i18n/client.tsx =====

"use client";

import React, { createContext, useContext, ReactNode } from "react";
import "client-only";

type Translations = Record<string, any>;

interface I18nContextType {
  translations: Translations;
  locale: string;
}

const I18nContext = createContext<I18nContextType | undefined>(undefined);

interface I18nProviderClientProps {
  locale: string;
  translations: Translations;
  children: ReactNode;
}

export function I18nProviderClient({
  locale,
  translations,
  children,
}: I18nProviderClientProps) {
  return (
    <I18nContext.Provider value={{ locale, translations }}>
      {children}
    </I18nContext.Provider>
  );
}

export function useI18n() {
  const context = useContext(I18nContext);

  if (context === undefined) {
    throw new Error("useI18n must be used within an I18nProviderClient");
  }

  const { translations, locale } = context;

  const t = (
    key: string,
    params?: { [key: string]: string | number }
  ): string => {
    let translation = translations[key] || key;

    if (params) {
      Object.keys(params).forEach((paramKey) => {
        const regex = new RegExp(`{${paramKey}}`, "g");
        translation = translation.replace(regex, String(params[paramKey]));
      });
    }
    return translation;
  };

  return { t, locale };
}

// ===== src/lib/i18n/config.ts =====

export const DEFAULT_LOCALE = "tr";

export const SUPPORTED_LOCALES = ["tr", "en", "fr", "es", "zu", "it"];

// ===== src/lib/i18n/i18n.cache.ts =====

import dbConnect from "@/lib/dbConnect";
import Language, { ILanguage } from "@/models/Language";
import Translation from "@/models/Translation";
import redis from "@/lib/redis";

const CACHE_TTL_SECONDS = 60 * 60 * 24;

const CACHE_KEYS = {
  LOCALES: "i18n:meta:locales",
  DEFAULT_LOCALE: "i18n:meta:default_locale",
  TRANSLATIONS_PREFIX: "i18n:translations:",
};

interface CachedLocaleData {
  language: ILanguage;
  translations: Record<string, any>;
}

const isProduction = process.env.NEXT_PUBLIC_NODE_ENV === "production";

export class I18nCache {
  private static instance: I18nCache;
  private cache: Map<string, CachedLocaleData> = new Map();
  private isInitialized = false;
  private defaultLocale: string = "tr";

  private constructor() {}

  public static getInstance(): I18nCache {
    if (!I18nCache.instance) {
      I18nCache.instance = new I18nCache();
    }
    return I18nCache.instance;
  }

  private async connectWithRetry(
    fn: () => Promise<any>,
    retries = 3,
    delay = 1000
  ) {
    for (let i = 1; i <= retries; i++) {
      try {
        return await fn();
      } catch (error: any) {
        console.warn(
          `[I18N_CACHE] DB Operation failed (Attempt ${i}/${retries}): ${error.message}`
        );
        if (i === retries) {

          throw error;
        }
        await new Promise((res) => setTimeout(res, delay * i));
      }
    }
  }

  public async initialize(): Promise<void> {
    if (this.isInitialized) return;

    if (isProduction) {
      try {
        console.log(
          "[I18N_CACHE] [PROD] Attempting to load translations from Redis..."
        );
        const cachedLocalesStr = await redis.get(CACHE_KEYS.LOCALES);
        const cachedDefaultLocale = await redis.get(CACHE_KEYS.DEFAULT_LOCALE);

        if (cachedLocalesStr && cachedDefaultLocale) {
          const locales: string[] = JSON.parse(cachedLocalesStr);
          const newCache = new Map<string, CachedLocaleData>();
          for (const locale of locales) {
            const translationsStr = await redis.get(
              `${CACHE_KEYS.TRANSLATIONS_PREFIX}${locale}`
            );
            if (translationsStr) {
              newCache.set(locale, JSON.parse(translationsStr));
            } else {
              throw new Error(
                `Inconsistent cache: Missing translations for locale '${locale}'.`
              );
            }
          }
          this.cache = newCache;
          this.defaultLocale = cachedDefaultLocale;
          this.isInitialized = true;
          console.log(
            `[I18N_CACHE] [PROD]  Successfully loaded translations for ${this.cache.size} locales from Redis.`
          );
          return;
        }

        console.log(
          "[I18N_CACHE] [PROD] Redis cache miss. Loading from database with retry logic..."
        );
        await this.loadDataFromDB();
        return;
      } catch (error) {
        console.warn(
          "[I18N_CACHE] [PROD] Could not load from Redis. Falling back to database.",
          error
        );
        await this.loadDataFromDB();
        return;
      }
    }

    console.log(
      "[I18N_CACHE] [DEV] Bypassing cache, loading directly from database with retry logic..."
    );
    await this.loadDataFromDB();
  }

  private async loadDataFromDB(): Promise<void> {
    const loadOperation = async () => {
      await dbConnect();

      const [activeLanguages, allTranslations] = await Promise.all([
        Language.find({ isActive: true }).lean(),
        Translation.find({}).lean(),
      ]);

      const newCache = new Map<string, CachedLocaleData>();
      let foundDefault = false;

      if (activeLanguages.length === 0) {
        this.isInitialized = !isProduction;
        return;
      }

      for (const lang of activeLanguages) {
        newCache.set(lang.code, { language: lang, translations: {} });
        if (lang.isDefault) {
          this.defaultLocale = lang.code;
          foundDefault = true;
        }
      }

      if (!foundDefault) {
        this.defaultLocale = activeLanguages[0].code;
        console.warn(
          `[I18N_CACHE] No default language set. Falling back to '${this.defaultLocale}'.`
        );
      }

      for (const translationDoc of allTranslations) {
        for (const [langCode, text] of Object.entries(
          translationDoc.translations
        )) {
          if (newCache.has(langCode)) {
            newCache.get(langCode)!.translations[translationDoc.key] = text;
          }
        }
      }

      if (isProduction) {
        const redisPipeline = redis.pipeline();
        redisPipeline.hset(
          CACHE_KEYS.LOCALES,
          JSON.stringify(Array.from(newCache.keys()))
        );
        redisPipeline.hset(CACHE_KEYS.DEFAULT_LOCALE, this.defaultLocale);
        for (const [locale, data] of newCache.entries()) {
          redisPipeline.hset(
            `${CACHE_KEYS.TRANSLATIONS_PREFIX}${locale}`,
            JSON.stringify(data),
            "EX",
            CACHE_TTL_SECONDS
          );
        }
        await redisPipeline.exec();
        console.log(
          "[I18N_CACHE] [PROD]  Populated Redis cache from database."
        );
      }

      this.cache = newCache;
      this.isInitialized = true;
      console.log(
        `[I18N_CACHE] Successfully loaded translations for ${this.cache.size} locales from DB.`
      );
    };

    try {
      await this.connectWithRetry(loadOperation);
    } catch (error) {
      console.error(
        "[I18N_CACHE] CRITICAL: Failed to load i18n data from database after multiple retries.",
        error
      );

      if (process.env.npm_lifecycle_script?.includes("build")) {
        throw error;
      }
      this.isInitialized = false;
    }
  }

  public async reload(): Promise<void> {
    if (isProduction) {
      const locales = await this.getLocales();
      const keysToDel = [
        CACHE_KEYS.LOCALES,
        CACHE_KEYS.DEFAULT_LOCALE,
        ...locales.map((l) => `${CACHE_KEYS.TRANSLATIONS_PREFIX}${l}`),
      ];
      if (keysToDel.length > 2) {
        await redis.del(...keysToDel);
      }
    }
    this.isInitialized = false;
    this.cache.clear();
    await this.initialize();
  }

  public async getLocales(): Promise<string[]> {
    await this.initialize();
    return Array.from(this.cache.keys());
  }

  public async getDefaultLocale(): Promise<string> {
    await this.initialize();
    return this.defaultLocale;
  }

  public async getTranslations(
    locale: string
  ): Promise<Record<string, any> | undefined> {
    await this.initialize();
    return this.cache.get(locale)?.translations;
  }
}

export const i18nCache = I18nCache.getInstance();

// ===== src/lib/i18n/server.ts =====

import "server-only";
import { i18nCache } from "./i18n.cache";

export async function getI18n(localeFromParams?: string) {
  const supportedLocales = await i18nCache.getLocales();
  const defaultLocale = await i18nCache.getDefaultLocale();

  const validatedLocale =
    localeFromParams && supportedLocales.includes(localeFromParams)
      ? localeFromParams
      : defaultLocale;

  const translations = (await i18nCache.getTranslations(validatedLocale)) || {};

  return function t(
    key: string,
    params?: { [key: string]: string | number }
  ): string {
    let translation: string = translations[key] || key;

    if (params) {
      Object.keys(params).forEach((paramKey) => {
        const regex = new RegExp(`{${paramKey}}`, "g");
        translation = translation.replace(regex, String(params[paramKey]));
      });
    }
    return translation;
  };
}

// ===== src/lib/image-processing-server.ts =====

import axios from "axios";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import sharp from "sharp";
import crypto from "crypto";
import slugify from "slugify";
import path from "path";

const s3Client = new S3Client({
  region: "auto",
  endpoint: process.env.NEXT_PUBLIC_R2_ENDPOINT as string,
  credentials: {
    accessKeyId: process.env.NEXT_PUBLIC_R2_ACCESS_KEY_ID as string,
    secretAccessKey: process.env.NEXT_PUBLIC_R2_SECRET_ACCESS_KEY as string,
  },
});

const R2_BUCKET_NAME = process.env.NEXT_PUBLIC_R2_BUCKET_NAME as string;
const R2_PUBLIC_URL = process.env.NEXT_PUBLIC_R2_PUBLIC_BUCKET_URL as string;

export async function proxyAndUploadImage(
  imageUrl: string,
  newPostTitle: string
): Promise<string | null> {
  try {

    const imageResponse = await axios.get(imageUrl, {
      responseType: "arraybuffer",
      timeout: 15000,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });

    const inputBuffer = Buffer.from(imageResponse.data, "binary");
    const originalContentType =
      imageResponse.headers["content-type"] || "image/jpeg";

    let finalBuffer: Buffer;
    let finalContentType: string;
    let fileExtension: string;

    if (originalContentType.includes("image/gif")) {

      finalBuffer = inputBuffer;
      finalContentType = "image/gif";
      fileExtension = ".gif";
    } else {

      console.log(
        "[Image Processor] Processing with Sharp (resize & convert to WebP)."
      );
      finalBuffer = await sharp(inputBuffer)
        .resize(1200, 630, { fit: "inside", withoutEnlargement: true })
        .webp({ quality: 80 })
        .toBuffer();
      finalContentType = "image/webp";
      fileExtension = ".webp";
    }

    const slug = slugify(newPostTitle, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });
    const uniqueSuffix = Date.now().toString().slice(-6);
    const newFileName = `fanskor-${slug.slice(
      0,
      50
    )}-${uniqueSuffix}${fileExtension}`;

    const putObjectCommand = new PutObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: newFileName,
      Body: finalBuffer,
      ContentType: finalContentType,
    });
    await s3Client.send(putObjectCommand);

    const r2Url = `${R2_PUBLIC_URL}/${newFileName}`;

    return r2Url;
  } catch (error: any) {
    console.error(
      `[Image Processor]  Failed to process image from URL (${imageUrl}):`,
      error.message
    );
    return null;
  }
}

// ===== src/lib/image-proxy.ts =====

const PLACEHOLDER_IMAGE = "/images/placeholder-logo.svg";

export function proxyImageUrl(url: string | null | undefined): string {

  if (!url || !url.startsWith("http")) {
    return PLACEHOLDER_IMAGE;
  }

  return `/api/image-proxy?url=${encodeURIComponent(url)}`;
}

// ===== src/lib/mongoClient.ts =====

import { MongoClient } from "mongodb";

if (!process.env.NEXT_PUBLIC_MONGODB_URI) {
  throw new Error('Invalid/Missing environment variable: "NEXT_PUBLIC_MONGODB_URI"');
}

const uri = process.env.NEXT_PUBLIC_MONGODB_URI;
const options = {};

let client: MongoClient;
let clientPromise: Promise<MongoClient>;

if (process.env.NODE_ENV === "development") {

  let globalWithMongo = global as typeof globalThis & {
    _mongoClientPromise?: Promise<MongoClient>;
  };

  if (!globalWithMongo._mongoClientPromise) {
    client = new MongoClient(uri, options);
    globalWithMongo._mongoClientPromise = client.connect();

  }
  clientPromise = globalWithMongo._mongoClientPromise;
} else {

  client = new MongoClient(uri, options);
  clientPromise = client.connect();
}

export default clientPromise;

// ===== src/lib/new-relic.ts =====

export const newRelicBrowserAgent = `
;window.NREUM||(NREUM={});NREUM.init={distributed_tracing:{enabled:true},privacy:{cookies_enabled:true},ajax:{deny_list:["bam.nr-data.net"]}};
;NREUM.loader_config={accountID:"6893491",trustKey:"6893491",agentID:"1120434250",licenseKey:"NRJS-b512b78ef4ca5a7f71f",applicationID:"1120434250"};
;NREUM.info={beacon:"bam.nr-data.net",errorBeacon:"bam.nr-data.net",licenseKey:"NRJS-b512b78ef4ca5a7f71f",applicationID:"1120434250",sa:1};
;
(()=>{var e,t,r={8122:(e,t,r)=>{"use strict";r.d(t,{a:()=>i});var n=r(944);function i(e,t){try{if(!e||"object"!=typeof e)return(0,n.R)(3);if(!t||"object"!=typeof t)return(0,n.R)(4);const r=Object.create(Object.getPrototypeOf(t),Object.getOwnPropertyDescriptors(t)),o=0===Object.keys(r).length?e:r;for(let a in o)if(void 0!==e[a])try{if(null===e[a]){r[a]=null;continue}Array.isArray(e[a])&&Array.isArray(t[a])?r[a]=Array.from(new Set([...e[a],...t[a]])):"object"==typeof e[a]&&"object"==typeof t[a]?r[a]=i(e[a],t[a]):r[a]=e[a]}catch(e){r[a]||(0,n.R)(1,e)}return r}catch(e){(0,n.R)(2,e)}}},2555:(e,t,r)=>{"use strict";r.d(t,{D:()=>s,f:()=>a});var n=r(384),i=r(8122);const o={beacon:n.NT.beacon,errorBeacon:n.NT.errorBeacon,licenseKey:void 0,applicationID:void 0,sa:void 0,queueTime:void 0,applicationTime:void 0,ttGuid:void 0,user:void 0,account:void 0,product:void 0,extra:void 0,jsAttributes:{},userAttributes:void 0,atts:void 0,transactionName:void 0,tNamePlain:void 0};function a(e){try{return!!e.licenseKey&&!!e.errorBeacon&&!!e.applicationID}catch(e){return!1}}const s=e=>(0,i.a)(e,o)},9324:(e,t,r)=>{"use strict";r.d(t,{F3:()=>i,Xs:()=>o,Yq:()=>a,xv:()=>n});const n="1.293.0",i="PROD",o="CDN",a="^2.0.0-alpha.18"},6154:(e,t,r)=>{"use strict";r.d(t,{A4:()=>s,OF:()=>d,RI:()=>i,WN:()=>h,bv:()=>o,gm:()=>a,lR:()=>f,m:()=>u,mw:()=>c,sb:()=>l});var n=r(1863);const i="undefined"!=typeof window&&!!window.document,o="undefined"!=typeof WorkerGlobalScope&&("undefined"!=typeof self&&self instanceof WorkerGlobalScope&&self.navigator instanceof WorkerNavigator||"undefined"!=typeof globalThis&&globalThis instanceof WorkerGlobalScope&&globalThis.navigator instanceof WorkerNavigator),a=i?window:"undefined"!=typeof WorkerGlobalScope&&("undefined"!=typeof self&&self instanceof WorkerGlobalScope&&self||"undefined"!=typeof globalThis&&globalThis instanceof WorkerGlobalScope&&globalThis),s="complete"===a?.document?.readyState,c=Boolean("hidden"===a?.document?.visibilityState),u=""+a?.location,d=/iPad|iPhone|iPod/.test(a.navigator?.userAgent),l=d&&"undefined"==typeof SharedWorker,f=(()=>{const e=a.navigator?.userAgent?.match(/Firefox[/\s](\d+\.\d+)/);return Array.isArray(e)&&e.length>=2?+e[1]:0})(),h=Date.now()-(0,n.t)()},7295:(e,t,r)=>{"use strict";r.d(t,{Xv:()=>a,gX:()=>i,iW:()=>o});var n=[];function i(e){if(!e||o(e))return!1;if(0===n.length)return!0;for(var t=0;t<n.length;t++){var r=n[t];if("*"===r.hostname)return!1;if(s(r.hostname,e.hostname)&&c(r.pathname,e.pathname))return!1}return!0}function o(e){return void 0===e.hostname}function a(e){if(n=[],e&&e.length)for(var t=0;t<e.length;t++){let r=e[t];if(!r)continue;0===r.indexOf("http://")?r=r.substring(7):0===r.indexOf("https://")&&(r=r.substring(8));const i=r.indexOf("/");let o,a;i>0?(o=r.substring(0,i),a=r.substring(i)):(o=r,a="");let[s]=o.split(":");n.push({hostname:s,pathname:a})}}function s(e,t){return!(e.length>t.length)&&t.indexOf(e)===t.length-e.length}function c(e,t){return 0===e.indexOf("/")&&(e=e.substring(1)),0===t.indexOf("/")&&(t=t.substring(1)),""===e||e===t}},3241:(e,t,r)=>{"use strict";r.d(t,{W:()=>o});var n=r(6154);const i="newrelic";function o(e={}){try{n.gm.dispatchEvent(new CustomEvent(i,{detail:e}))}catch(e){}}},1687:(e,t,r)=>{"use strict";r.d(t,{Ak:()=>u,Ze:()=>f,x3:()=>d});var n=r(3241),i=r(7836),o=r(3606),a=r(860),s=r(2646);const c={};function u(e,t){const r={staged:!1,priority:a.P3[t]||0};l(e),c[e].get(t)||c[e].set(t,r)}function d(e,t){e&&c[e]&&(c[e].get(t)&&c[e].delete(t),p(e,t,!1),c[e].size&&h(e))}function l(e){if(!e)throw new Error("agentIdentifier required");c[e]||(c[e]=new Map)}function f(e="",t="feature",r=!1){if(l(e),!e||!c[e].get(t)||r)return p(e,t);c[e].get(t).staged=!0,h(e)}function h(e){const t=Array.from(c[e]);t.every((([e,t])=>t.staged))&&(t.sort(((e,t)=>e[1].priority-t[1].priority)),t.forEach((([t])=>{c[e].delete(t),p(e,t)})))}function p(e,t,r=!0){const a=e?i.ee.get(e):i.ee,c=o.i.handlers;if(!a.aborted&&a.backlog&&c){if((0,n.W)({agentIdentifier:e,type:"lifecycle",name:"drain",feature:t}),r){const e=a.backlog[t],r=c[t];if(r){for(let t=0;e&&t<e.length;++t)g(e[t],r);Object.entries(r).forEach((([e,t])=>{Object.values(t||{}).forEach((t=>{t[0]?.on&&t[0]?.context()instanceof s.y&&t[0].on(e,t[1])}))}))}}a.isolatedBacklog||delete c[t],a.backlog[t]=null,a.emit("drain-"+t,[])}}function g(e,t){var r=e[1];Object.values(t[r]||{}).forEach((t=>{var r=e[0];if(t[0]===r){var n=t[1],i=e[3],o=e[2];n.apply(i,o)}}))}},7836:(e,t,r)=>{"use strict";r.d(t,{P:()=>s,ee:()=>c});var n=r(384),i=r(8990),o=r(2646),a=r(5607);const s="nr@context:".concat(a.W),c=function e(t,r){var n={},a={},d={},l=!1;try{l=16===r.length&&u.initializedAgents?.[r]?.runtime.isolatedBacklog}catch(e){}var f={on:p,addEventListener:p,removeEventListener:function(e,t){var r=n[e];if(!r)return;for(var i=0;i<r.length;i++)r[i]===t&&r.splice(i,1)},emit:function(e,r,n,i,o){!1!==o&&(o=!0);if(c.aborted&&!i)return;t&&o&&t.emit(e,r,n);for(var s=h(n),u=g(e),d=u.length,l=0;l<d;l++)u[l].apply(s,r);var p=v()[a[e]];p&&p.push([f,e,r,s]);return s},get:m,listeners:g,context:h,buffer:function(e,t){const r=v();if(t=t||"feature",f.aborted)return;Object.entries(e||{}).forEach((([e,n])=>{a[n]=t,t in r||(r[t]=[])}))},abort:function(){f._aborted=!0,Object.keys(f.backlog).forEach((e=>{delete f.backlog[e]}))},isBuffering:function(e){return!!v()[a[e]]},debugId:r,backlog:l?{}:t&&"object"==typeof t.backlog?t.backlog:{},isolatedBacklog:l};return Object.defineProperty(f,"aborted",{get:()=>{let e=f._aborted||!1;return e||(t&&(e=t.aborted),e)}}),f;function h(e){return e&&e instanceof o.y?e:e?(0,i.I)(e,s,(()=>new o.y(s))):new o.y(s)}function p(e,t){n[e]=g(e).concat(t)}function g(e){return n[e]||[]}function m(t){return d[t]=d[t]||e(f,t)}function v(){return f.backlog}}(void 0,"globalEE"),u=(0,n.Zm)();u.ee||(u.ee=c)},2646:(e,t,r)=>{"use strict";r.d(t,{y:()=>n});class n{constructor(e){this.contextId=e}}},9908:(e,t,r)=>{"use strict";r.d(t,{d:()=>n,p:()=>i});var n=r(7836).ee.get("handle");function i(e,t,r,i,o){o?(o.buffer([e],i),o.emit(e,t,r)):(n.buffer([e],i),n.emit(e,t,r))}},3606:(e,t,r)=>{"use strict";r.d(t,{i:()=>o});var n=r(9908);o.on=a;var i=o.handlers={};function o(e,t,r,o){a(o||n.d,i,e,t,r)}function a(e,t,r,i,o){o||(o="feature"),e||(e=n.d);var a=t[o]=t[o]||{};(a[r]=a[r]||[]).push([e,i])}},3878:(e,t,r)=>{"use strict";function n(e,t){return{capture:e,passive:!1,signal:t}}function i(e,t,r=!1,i){window.addEventListener(e,t,n(r,i))}function o(e,t,r=!1,i){document.addEventListener(e,t,n(r,i))}r.d(t,{DD:()=>o,jT:()=>n,sp:()=>i})},5607:(e,t,r)=>{"use strict";r.d(t,{W:()=>n});const n=(0,r(9566).bz)()},9566:(e,t,r)=>{"use strict";r.d(t,{LA:()=>s,ZF:()=>c,bz:()=>a,el:()=>u});var n=r(6154);const i="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";function o(e,t){return e?15&e[t]:16*Math.random()|0}function a(){const e=n.gm?.crypto||n.gm?.msCrypto;let t,r=0;return e&&e.getRandomValues&&(t=e.getRandomValues(new Uint8Array(30))),i.split("").map((e=>"x"===e?o(t,r++).toString(16):"y"===e?(3&o()|8).toString(16):e)).join("")}function s(e){const t=n.gm?.crypto||n.gm?.msCrypto;let r,i=0;t&&t.getRandomValues&&(r=t.getRandomValues(new Uint8Array(e)));const a=[];for(var s=0;s<e;s++)a.push(o(r,i++).toString(16));return a.join("")}function c(){return s(16)}function u(){return s(32)}},2614:(e,t,r)=>{"use strict";r.d(t,{BB:()=>a,H3:()=>n,g:()=>u,iL:()=>c,tS:()=>s,uh:()=>i,wk:()=>o});const n="NRBA",i="SESSION",o=144e5,a=18e5,s={STARTED:"session-started",PAUSE:"session-pause",RESET:"session-reset",RESUME:"session-resume",UPDATE:"session-update"},c={SAME_TAB:"same-tab",CROSS_TAB:"cross-tab"},u={OFF:0,FULL:1,ERROR:2}},1863:(e,t,r)=>{"use strict";function n(){return Math.floor(performance.now())}r.d(t,{t:()=>n})},7485:(e,t,r)=>{"use strict";r.d(t,{D:()=>i});var n=r(6154);function i(e){if(0===(e||"").indexOf("data:"))return{protocol:"data"};try{const t=new URL(e,location.href),r={port:t.port,hostname:t.hostname,pathname:t.pathname,search:t.search,protocol:t.protocol.slice(0,t.protocol.indexOf(":")),sameOrigin:t.protocol===n.gm?.location?.protocol&&t.host===n.gm?.location?.host};return r.port&&""!==r.port||("http:"===t.protocol&&(r.port="80"),"https:"===t.protocol&&(r.port="443")),r.pathname&&""!==r.pathname?r.pathname.startsWith("/")||(r.pathname="/".concat(r.pathname)):r.pathname="/",r}catch(e){return{}}}},944:(e,t,r)=>{"use strict";r.d(t,{R:()=>i});var n=r(3241);function i(e,t){"function"==typeof console.debug&&(,t),(0,n.W)({agentIdentifier:null,drained:null,type:"data",name:"warn",feature:"warn",data:{code:e,secondary:t}}))}},5701:(e,t,r)=>{"use strict";r.d(t,{B:()=>o,t:()=>a});var n=r(3241);const i=new Set,o={};function a(e,t){const r=t.agentIdentifier;o[r]??={},e&&"object"==typeof e&&(i.has(r)||(t.ee.emit("rumresp",[e]),o[r]=e,i.add(r),(0,n.W)({agentIdentifier:r,loaded:!0,drained:!0,type:"lifecycle",name:"load",feature:void 0,data:e})))}},8990:(e,t,r)=>{"use strict";r.d(t,{I:()=>i});var n=Object.prototype.hasOwnProperty;function i(e,t,r){if(n.call(e,t))return e[t];var i=r();if(Object.defineProperty&&Object.keys)try{return Object.defineProperty(e,t,{value:i,writable:!0,enumerable:!1}),i}catch(e){}return e[t]=i,i}},6389:(e,t,r)=>{"use strict";function n(e,t=500,r={}){const n=r?.leading||!1;let i;return(...r)=>{n&&void 0===i&&(e.apply(this,r),i=setTimeout((()=>{i=clearTimeout(i)}),t)),n||(clearTimeout(i),i=setTimeout((()=>{e.apply(this,r)}),t))}}function i(e){let t=!1;return(...r)=>{t||(t=!0,e.apply(this,r))}}r.d(t,{J:()=>i,s:()=>n})},3304:(e,t,r)=>{"use strict";r.d(t,{A:()=>o});var n=r(7836);const i=()=>{const e=new WeakSet;return(t,r)=>{if("object"==typeof r&&null!==r){if(e.has(r))return;e.add(r)}return r}};function o(e){try{return JSON.stringify(e,i())??""}catch(e){try{n.ee.emit("internal-error",[e])}catch(e){}return""}}},3496:(e,t,r)=>{"use strict";function n(e){return!e||!(!e.licenseKey||!e.applicationID)}function i(e,t){return!e||e.licenseKey===t.info.licenseKey&&e.applicationID===t.info.applicationID}r.d(t,{A:()=>i,I:()=>n})},5289:(e,t,r)=>{"use strict";r.d(t,{GG:()=>o,Qr:()=>s,sB:()=>a});var n=r(3878);function i(){return"undefined"==typeof document||"complete"===document.readyState}function o(e,t){if(i())return e();(0,n.sp)("load",e,t)}function a(e){if(i())return e();(0,n.DD)("DOMContentLoaded",e)}function s(e){if(i())return e();(0,n.sp)("popstate",e)}},384:(e,t,r)=>{"use strict";r.d(t,{NT:()=>o,US:()=>u,Zm:()=>a,bQ:()=>c,dV:()=>s,pV:()=>d});var n=r(6154),i=r(1863);const o={beacon:"bam.nr-data.net",errorBeacon:"bam.nr-data.net"};function a(){return n.gm.NREUM||(n.gm.NREUM={}),void 0===n.gm.newrelic&&(n.gm.newrelic=n.gm.NREUM),n.gm.NREUM}function s(){let e=a();return e.o||(e.o={ST:n.gm.setTimeout,SI:n.gm.setImmediate,CT:n.gm.clearTimeout,XHR:n.gm.XMLHttpRequest,REQ:n.gm.Request,EV:n.gm.Event,PR:n.gm.Promise,MO:n.gm.MutationObserver,FETCH:n.gm.fetch,WS:n.gm.WebSocket}),e}function c(e,t){let r=a();r.initializedAgents??={},t.initializedAt={ms:(0,i.t)(),date:new Date},r.initializedAgents[e]=t}function u(e,t){a()[e]=t}function d(){return function(){let e=a();const t=e.info||{};e.info={beacon:o.beacon,errorBeacon:o.errorBeacon,...t}}(),function(){let e=a();const t=e.init||{};e.init={...t}}(),s(),function(){let e=a();const t=e.loader_config||{};e.loader_config={...t}}(),a()}},2843:(e,t,r)=>{"use strict";r.d(t,{u:()=>i});var n=r(3878);function i(e,t=!1,r,i){(0,n.DD)("visibilitychange",(function(){if(t)return void("hidden"===document.visibilityState&&e());e(document.visibilityState)}),r,i)}},8139:(e,t,r)=>{"use strict";r.d(t,{u:()=>f});var n=r(7836),i=r(3434),o=r(8990),a=r(6154);const s={},c=a.gm.XMLHttpRequest,u="addEventListener",d="removeEventListener",l="nr@wrapped:".concat(n.P);function f(e){var t=function(e){return(e||n.ee).get("events")}(e);if(s[t.debugId]++)return t;s[t.debugId]=1;var r=(0,i.YM)(t,!0);function f(e){r.inPlace(e,[u,d],"-",p)}function p(e,t){return e[1]}return"getPrototypeOf"in Object&&(a.RI&&h(document,f),c&&h(c.prototype,f),h(a.gm,f)),t.on(u+"-start",(function(e,t){var n=e[1];if(null!==n&&("function"==typeof n||"object"==typeof n)){var i=(0,o.I)(n,l,(function(){var e={object:function(){if("function"!=typeof n.handleEvent)return;return n.handleEvent.apply(n,arguments)},function:n}[typeof n];return e?r(e,"fn-",null,e.name||"anonymous"):n}));this.wrapped=e[1]=i}})),t.on(d+"-start",(function(e){e[1]=this.wrapped||e[1]})),t}function h(e,t,...r){let n=e;for(;"object"==typeof n&&!Object.prototype.hasOwnProperty.call(n,u);)n=Object.getPrototypeOf(n);n&&t(n,...r)}},3434:(e,t,r)=>{"use strict";r.d(t,{Jt:()=>o,YM:()=>c});var n=r(7836),i=r(5607);const o="nr@original:".concat(i.W);var a=Object.prototype.hasOwnProperty,s=!1;function c(e,t){return e||(e=n.ee),r.inPlace=function(e,t,n,i,o){n||(n="");const a="-"===n.charAt(0);for(let s=0;s<t.length;s++){const c=t[s],u=e[c];d(u)||(e[c]=r(u,a?c+n:n,i,c,o))}},r.flag=o,r;function r(t,r,n,s,c){return d(t)?t:(r||(r=""),nrWrapper[o]=t,function(e,t,r){if(Object.defineProperty&&Object.keys)try{return Object.keys(e).forEach((function(r){Object.defineProperty(t,r,{get:function(){return e[r]},set:function(t){return e[r]=t,t}})})),t}catch(e){u([e],r)}for(var n in e)a.call(e,n)&&(t[n]=e[n])}(t,nrWrapper,e),nrWrapper);function nrWrapper(){var o,a,d,l;let f;try{a=this,o=[...arguments],d="function"==typeof n?n(o,a):n||{}}catch(t){u([t,"",[o,a,s],d],e)}i(r+"start",[o,a,s],d,c);const h=performance.now();let p=h;try{return l=t.apply(a,o),p=performance.now(),l}catch(e){throw p=performance.now(),i(r+"err",[o,a,e],d,c),f=e,f}finally{const e=p-h,t={duration:e,isLongTask:e>=50,methodName:s,thrownError:f};t.isLongTask&&i("long-task",[t],d,c),i(r+"end",[o,a,l,t],d,c)}}}function i(r,n,i,o){if(!s||t){var a=s;s=!0;try{e.emit(r,n,i,t,o)}catch(t){u([t,r,n,i],e)}s=a}}}function u(e,t){t||(t=n.ee);try{t.emit("internal-error",e)}catch(e){}}function d(e){return!(e&&"function"==typeof e&&e.apply&&!e[o])}},9300:(e,t,r)=>{"use strict";r.d(t,{T:()=>n});const n=r(860).K7.ajax},3333:(e,t,r)=>{"use strict";r.d(t,{$v:()=>u,TZ:()=>n,Zp:()=>i,kd:()=>c,mq:()=>s,nf:()=>a,qN:()=>o});const n=r(860).K7.genericEvents,i=["auxclick","click","copy","keydown","paste","scrollend"],o=["focus","blur"],a=4,s=1e3,c=["PageAction","UserAction","BrowserPerformance"],u={MARKS:"experimental.marks",MEASURES:"experimental.measures",RESOURCES:"experimental.resources"}},6774:(e,t,r)=>{"use strict";r.d(t,{T:()=>n});const n=r(860).K7.jserrors},993:(e,t,r)=>{"use strict";r.d(t,{A$:()=>o,ET:()=>a,TZ:()=>s,p_:()=>i});var n=r(860);const i={ERROR:"ERROR",WARN:"WARN",INFO:"INFO",DEBUG:"DEBUG",TRACE:"TRACE"},o={OFF:0,ERROR:1,WARN:2,INFO:3,DEBUG:4,TRACE:5},a="log",s=n.K7.logging},3785:(e,t,r)=>{"use strict";r.d(t,{R:()=>c,b:()=>u});var n=r(9908),i=r(1863),o=r(860),a=r(8154),s=r(993);function c(e,t,r={},c=s.p_.INFO,u,d=(0,i.t)()){(0,n.p)(a.xV,["API/logging/".concat(c.toLowerCase(),"/called")],void 0,o.K7.metrics,e),(0,n.p)(s.ET,[d,t,r,c,u],void 0,o.K7.logging,e)}function u(e){return"string"==typeof e&&Object.values(s.p_).some((t=>t===e.toUpperCase().trim()))}},8154:(e,t,r)=>{"use strict";r.d(t,{z_:()=>o,XG:()=>s,TZ:()=>n,rs:()=>i,xV:()=>a});r(6154),r(9566),r(384);const n=r(860).K7.metrics,i="sm",o="cm",a="storeSupportabilityMetrics",s="storeEventMetrics"},6630:(e,t,r)=>{"use strict";r.d(t,{T:()=>n});const n=r(860).K7.pageViewEvent},782:(e,t,r)=>{"use strict";r.d(t,{T:()=>n});const n=r(860).K7.pageViewTiming},6344:(e,t,r)=>{"use strict";r.d(t,{BB:()=>d,G4:()=>o,Qb:()=>l,TZ:()=>i,Ug:()=>a,_s:()=>s,bc:()=>u,yP:()=>c});var n=r(2614);const i=r(860).K7.sessionReplay,o={RECORD:"recordReplay",PAUSE:"pauseReplay",ERROR_DURING_REPLAY:"errorDuringReplay"},a=.12,s={DomContentLoaded:0,Load:1,FullSnapshot:2,IncrementalSnapshot:3,Meta:4,Custom:5},c={[n.g.ERROR]:15e3,[n.g.FULL]:3e5,[n.g.OFF]:0},u={RESET:{message:"Session was reset",sm:"Reset"},IMPORT:{message:"Recorder failed to import",sm:"Import"},TOO_MANY:{message:"429: Too Many Requests",sm:"Too-Many"},TOO_BIG:{message:"Payload was too large",sm:"Too-Big"},CROSS_TAB:{message:"Session Entity was set to OFF on another tab",sm:"Cross-Tab"},ENTITLEMENTS:{message:"Session Replay is not allowed and will not be started",sm:"Entitlement"}},d=5e3,l={API:"api"}},5270:(e,t,r)=>{"use strict";r.d(t,{Aw:()=>s,CT:()=>c,SR:()=>a,rF:()=>u});var n=r(384),i=r(7767),o=r(6154);function a(e){return!!(0,n.dV)().o.MO&&(0,i.V)(e)&&!0===e?.session_trace.enabled}function s(e){return!0===e?.session_replay.preload&&a(e)}function c(e,t){const r=t.correctAbsoluteTimestamp(e);return{originalTimestamp:e,correctedTimestamp:r,timestampDiff:e-r,originTime:o.WN,correctedOriginTime:t.correctedOriginTime,originTimeDiff:Math.floor(o.WN-t.correctedOriginTime)}}function u(e,t){try{if("string"==typeof t?.type){if("password"===t.type.toLowerCase())return"*".repeat(e?.length||0);if(void 0!==t?.dataset?.nrUnmask||t?.classList?.contains("nr-unmask"))return e}}catch(e){}return"string"==typeof e?e.replace(/[\S]/g,"*"):"*".repeat(e?.length||0)}},3738:(e,t,r)=>{"use strict";r.d(t,{He:()=>i,Kp:()=>s,Lc:()=>u,Rz:()=>d,TZ:()=>n,bD:()=>o,d3:()=>a,jx:()=>l,uP:()=>c});const n=r(860).K7.sessionTrace,i="bstResource",o="resource",a="-start",s="-end",c="fn"+a,u="fn"+s,d="pushState",l=1e3},3962:(e,t,r)=>{"use strict";r.d(t,{AM:()=>o,O2:()=>c,Qu:()=>u,TZ:()=>s,ih:()=>d,pP:()=>a,tC:()=>i});var n=r(860);const i=["click","keydown","submit","popstate"],o="api",a="initialPageLoad",s=n.K7.softNav,c={INITIAL_PAGE_LOAD:"",ROUTE_CHANGE:1,UNSPECIFIED:2},u={INTERACTION:1,AJAX:2,CUSTOM_END:3,CUSTOM_TRACER:4},d={IP:"in progress",FIN:"finished",CAN:"cancelled"}},7378:(e,t,r)=>{"use strict";r.d(t,{$p:()=>x,BR:()=>b,Kp:()=>R,L3:()=>y,Lc:()=>c,NC:()=>o,SG:()=>d,TZ:()=>i,U6:()=>p,UT:()=>m,d3:()=>w,dT:()=>f,e5:()=>A,gx:()=>v,l9:()=>l,oW:()=>h,op:()=>g,rw:()=>u,tH:()=>E,uP:()=>s,wW:()=>T,xq:()=>a});var n=r(384);const i=r(860).K7.spa,o=["click","submit","keypress","keydown","keyup","change"],a=999,s="fn-start",c="fn-end",u="cb-start",d="api-ixn-",l="remaining",f="interaction",h="spaNode",p="jsonpNode",g="fetch-start",m="fetch-done",v="fetch-body-",b="jsonp-end",y=(0,n.dV)().o.ST,w="-start",R="-end",x="-body",T="cb"+R,A="jsTime",E="fetch"},4234:(e,t,r)=>{"use strict";r.d(t,{W:()=>o});var n=r(7836),i=r(1687);class o{constructor(e,t){this.agentIdentifier=e,this.ee=n.ee.get(e),this.featureName=t,this.blocked=!1}deregisterDrain(){(0,i.x3)(this.agentIdentifier,this.featureName)}}},7767:(e,t,r)=>{"use strict";r.d(t,{V:()=>i});var n=r(6154);const i=e=>n.RI&&!0===e?.privacy.cookies_enabled},1741:(e,t,r)=>{"use strict";r.d(t,{W:()=>o});var n=r(944),i=r(4261);class o{#e(e,...t){if(this[e]!==o.prototype[e])return this[e](...t);(0,n.R)(35,e)}addPageAction(e,t){return this.#e(i.hG,e,t)}register(e){return this.#e(i.eY,e)}recordCustomEvent(e,t){return this.#e(i.fF,e,t)}setPageViewName(e,t){return this.#e(i.Fw,e,t)}setCustomAttribute(e,t,r){return this.#e(i.cD,e,t,r)}noticeError(e,t){return this.#e(i.o5,e,t)}setUserId(e){return this.#e(i.Dl,e)}setApplicationVersion(e){return this.#e(i.nb,e)}setErrorHandler(e){return this.#e(i.bt,e)}addRelease(e,t){return this.#e(i.k6,e,t)}log(e,t){return this.#e(i.$9,e,t)}start(){return this.#e(i.d3)}finished(e){return this.#e(i.BL,e)}recordReplay(){return this.#e(i.CH)}pauseReplay(){return this.#e(i.Tb)}addToTrace(e){return this.#e(i.U2,e)}setCurrentRouteName(e){return this.#e(i.PA,e)}interaction(){return this.#e(i.dT)}wrapLogger(e,t,r){return this.#e(i.Wb,e,t,r)}measure(e,t){return this.#e(i.V1,e,t)}}},4261:(e,t,r)=>{"use strict";r.d(t,{$9:()=>d,BL:()=>c,CH:()=>p,Dl:()=>R,Fw:()=>w,PA:()=>v,Pl:()=>n,Tb:()=>f,U2:()=>a,V1:()=>A,Wb:()=>T,bt:()=>y,cD:()=>b,d3:()=>x,dT:()=>u,eY:()=>g,fF:()=>h,hG:()=>o,hw:()=>i,k6:()=>s,nb:()=>m,o5:()=>l});const n="api-",i=n+"ixn-",o="addPageAction",a="addToTrace",s="addRelease",c="finished",u="interaction",d="log",l="noticeError",f="pauseReplay",h="recordCustomEvent",p="recordReplay",g="register",m="setApplicationVersion",v="setCurrentRouteName",b="setCustomAttribute",y="setErrorHandler",w="setPageViewName",R="setUserId",x="start",T="wrapLogger",A="measure"},5205:(e,t,r)=>{"use strict";r.d(t,{j:()=>S});var n=r(384),i=r(1741);var o=r(2555),a=r(3333);const s=e=>{if(!e||"string"!=typeof e)return!1;try{document.createDocumentFragment().querySelector(e)}catch{return!1}return!0};var c=r(2614),u=r(944),d=r(8122);const l="[data-nr-mask]",f=e=>(0,d.a)(e,(()=>{const e={feature_flags:[],experimental:{marks:!1,measures:!1,resources:!1},mask_selector:"*",block_selector:"[data-nr-block]",mask_input_options:{color:!1,date:!1,"datetime-local":!1,email:!1,month:!1,number:!1,range:!1,search:!1,tel:!1,text:!1,time:!1,url:!1,week:!1,textarea:!1,select:!1,password:!0}};return{ajax:{deny_list:void 0,block_internal:!0,enabled:!0,autoStart:!0},api:{allow_registered_children:!0,duplicate_registered_data:!1},distributed_tracing:{enabled:void 0,exclude_newrelic_header:void 0,cors_use_newrelic_header:void 0,cors_use_tracecontext_headers:void 0,allowed_origins:void 0},get feature_flags(){return e.feature_flags},set feature_flags(t){e.feature_flags=t},generic_events:{enabled:!0,autoStart:!0},harvest:{interval:30},jserrors:{enabled:!0,autoStart:!0},logging:{enabled:!0,autoStart:!0},metrics:{enabled:!0,autoStart:!0},obfuscate:void 0,page_action:{enabled:!0},page_view_event:{enabled:!0,autoStart:!0},page_view_timing:{enabled:!0,autoStart:!0},performance:{get capture_marks(){return e.feature_flags.includes(a.$v.MARKS)||e.experimental.marks},set capture_marks(t){e.experimental.marks=t},get capture_measures(){return e.feature_flags.includes(a.$v.MEASURES)||e.experimental.measures},set capture_measures(t){e.experimental.measures=t},capture_detail:!0,resources:{get enabled(){return e.feature_flags.includes(a.$v.RESOURCES)||e.experimental.resources},set enabled(t){e.experimental.resources=t},asset_types:[],first_party_domains:[],ignore_newrelic:!0}},privacy:{cookies_enabled:!0},proxy:{assets:void 0,beacon:void 0},session:{expiresMs:c.wk,inactiveMs:c.BB},session_replay:{autoStart:!0,enabled:!1,preload:!1,sampling_rate:10,error_sampling_rate:100,collect_fonts:!1,inline_images:!1,fix_stylesheets:!0,mask_all_inputs:!0,get mask_text_selector(){return e.mask_selector},set mask_text_selector(t){s(t)?e.mask_selector="".concat(t,",").concat(l):""===t||null===t?e.mask_selector=l:(0,u.R)(5,t)},get block_class(){return"nr-block"},get ignore_class(){return"nr-ignore"},get mask_text_class(){return"nr-mask"},get block_selector(){return e.block_selector},set block_selector(t){s(t)?e.block_selector+=",".concat(t):""!==t&&(0,u.R)(6,t)},get mask_input_options(){return e.mask_input_options},set mask_input_options(t){t&&"object"==typeof t?e.mask_input_options={...t,password:!0}:(0,u.R)(7,t)}},session_trace:{enabled:!0,autoStart:!0},soft_navigations:{enabled:!0,autoStart:!0},spa:{enabled:!0,autoStart:!0},ssl:void 0,user_actions:{enabled:!0,elementAttributes:["id","className","tagName","type"]}}})());var h=r(6154),p=r(9324);let g=0;const m={buildEnv:p.F3,distMethod:p.Xs,version:p.xv,originTime:h.WN},v={appMetadata:{},customTransaction:void 0,denyList:void 0,disabled:!1,entityManager:void 0,harvester:void 0,isolatedBacklog:!1,isRecording:!1,loaderType:void 0,maxBytes:3e4,obfuscator:void 0,onerror:void 0,ptid:void 0,releaseIds:{},session:void 0,timeKeeper:void 0,get harvestCount(){return++g}},b=e=>{const t=(0,d.a)(e,v),r=Object.keys(m).reduce(((e,t)=>(e[t]={value:m[t],writable:!1,configurable:!0,enumerable:!0},e)),{});return Object.defineProperties(t,r)};var y=r(5701);const w=e=>{const t=e.startsWith("http");e+="/",r.p=t?e:"https://"+e};var R=r(7836),x=r(3241);const T={accountID:void 0,trustKey:void 0,agentID:void 0,licenseKey:void 0,applicationID:void 0,xpid:void 0},A=e=>(0,d.a)(e,T),E=new Set;function S(e,t={},r,a){let{init:s,info:c,loader_config:u,runtime:d={},exposed:l=!0}=t;if(!c){const e=(0,n.pV)();s=e.init,c=e.info,u=e.loader_config}e.init=f(s||{}),e.loader_config=A(u||{}),c.jsAttributes??={},h.bv&&(c.jsAttributes.isWorker=!0),e.info=(0,o.D)(c);const p=e.init,g=[c.beacon,c.errorBeacon];E.has(e.agentIdentifier)||(p.proxy.assets&&(w(p.proxy.assets),g.push(p.proxy.assets)),p.proxy.beacon&&g.push(p.proxy.beacon),function(e){const t=(0,n.pV)();Object.getOwnPropertyNames(i.W.prototype).forEach((r=>{const n=i.W.prototype[r];if("function"!=typeof n||"constructor"===n)return;let o=t[r];e[r]&&!1!==e.exposed&&"micro-agent"!==e.runtime?.loaderType&&(t[r]=(...t)=>{const n=e[r](...t);return o?o(...t):n})}))}(e),(0,n.US)("activatedFeatures",y.B),e.runSoftNavOverSpa&&=!0===p.soft_navigations.enabled&&p.feature_flags.includes("soft_nav")),d.denyList=[...p.ajax.deny_list||[],...p.ajax.block_internal?g:[]],d.ptid=e.agentIdentifier,d.loaderType=r,e.runtime=b(d),E.has(e.agentIdentifier)||(e.ee=R.ee.get(e.agentIdentifier),e.exposed=l,(0,x.W)({agentIdentifier:e.agentIdentifier,drained:!!y.B?.[e.agentIdentifier],type:"lifecycle",name:"initialize",feature:void 0,data:e.config})),E.add(e.agentIdentifier)}},8374:(e,t,r)=>{r.nc=(()=>{try{return document?.currentScript?.nonce}catch(e){}return""})()},860:(e,t,r)=>{"use strict";r.d(t,{$J:()=>d,K7:()=>c,P3:()=>u,XX:()=>i,Yy:()=>s,df:()=>o,qY:()=>n,v4:()=>a});const n="events",i="jserrors",o="browser/blobs",a="rum",s="browser/logs",c={ajax:"ajax",genericEvents:"generic_events",jserrors:i,logging:"logging",metrics:"metrics",pageAction:"page_action",pageViewEvent:"page_view_event",pageViewTiming:"page_view_timing",sessionReplay:"session_replay",sessionTrace:"session_trace",softNav:"soft_navigations",spa:"spa"},u={[c.pageViewEvent]:1,[c.pageViewTiming]:2,[c.metrics]:3,[c.jserrors]:4,[c.spa]:5,[c.ajax]:6,[c.sessionTrace]:7,[c.softNav]:8,[c.sessionReplay]:9,[c.logging]:10,[c.genericEvents]:11},d={[c.pageViewEvent]:a,[c.pageViewTiming]:n,[c.ajax]:n,[c.spa]:n,[c.softNav]:n,[c.metrics]:i,[c.jserrors]:i,[c.sessionTrace]:o,[c.sessionReplay]:o,[c.logging]:s,[c.genericEvents]:"ins"}}},n={};function i(e){var t=n[e];if(void 0!==t)return t.exports;var o=n[e]={exports:{}};return r[e](o,o.exports,i),o.exports}i.m=r,i.d=(e,t)=>{for(var r in t)i.o(t,r)&&!i.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},i.f={},i.e=e=>Promise.all(Object.keys(i.f).reduce(((t,r)=>(i.f[r](e,t),t)),[])),i.u=e=>({212:"nr-spa-compressor",249:"nr-spa-recorder",478:"nr-spa"}[e]+"-1.293.0.min.js"),i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),e={},t="NRBA-1.293.0.PROD:",i.l=(r,n,o,a)=>{if(e[r])e[r].push(n);else{var s,c;if(void 0!==o)for(var u=document.getElementsByTagName("script"),d=0;d<u.length;d++){var l=u[d];if(l.getAttribute("src")==r||l.getAttribute("data-webpack")==t+o){s=l;break}}if(!s){c=!0;var f={478:"sha512-cEmCt/vG1anp3Npyuxwqcxqvx31FELkFrcLe6DJfvgis9d0YgKwX9/w90OQeoxYwWm4WLTxEpgIMR26NRroZwg==",249:"sha512-Wf8L4Tf/x6L4EHJaY6phnsZAgR7A/do7bPghfQXmosP4aSTn964TgjYKN+kdwsU9grVvyppZ4a3hCAX2HE05OA==",212:"sha512-Q/Dh/Hp0TZ2E9Rgmfnw7GzPv
`;

// ===== src/lib/odds-converter.ts =====

export const convertPercentageToOdds = (
  percent: number | undefined | null
): string => {
  if (percent === null || percent === undefined || percent <= 0) {
    return "N/A";
  }

  const safePercent = Math.max(1, Math.min(percent, 99));
  return (100 / safePercent).toFixed(2);
};

// ===== src/lib/prediction-engine.ts =====

"use server-only";

export const calculateCustomPrediction = (
  h2h: any[],
  homeTeamStats: any,
  awayTeamStats: any,
  homeTeamId: number,
  homeTeamRank: number | undefined,
  awayTeamRank: number | undefined,
  matchEvents: any[] | null,
  matchStatus: string
): { home: number; draw: number; away: number } => {
  const config = {
    weights: {
      homeAdvantage: 12,
      form: 1.5,
      h2h: 2.5,
      rankDifference: 0.8,
      goalDifference: 6.0,
      liveGoalMomentum: 15,
      liveRedCardPenalty: -20,
    },
    h2hMaxGames: 5,
    drawWeight: 0.85,
  };

  let homeScore = 0;
  let awayScore = 0;

  homeScore += config.weights.homeAdvantage;

  const calculateForm = (formString: string): number => {
    if (!formString) return 0;
    return (
      (formString.match(/W/g) || []).length * 3 +
      (formString.match(/D/g) || []).length * 1
    );
  };
  homeScore += calculateForm(homeTeamStats?.form || "") * config.weights.form;
  awayScore += calculateForm(awayTeamStats?.form || "") * config.weights.form;

  const homeGoalDiff =
    (homeTeamStats?.goals?.for?.average?.total ?? 0) -
    (homeTeamStats?.goals?.against?.average?.total ?? 0);
  const awayGoalDiff =
    (awayTeamStats?.goals?.for?.average?.total ?? 0) -
    (awayTeamStats?.goals?.against?.average?.total ?? 0);
  homeScore += homeGoalDiff * config.weights.goalDifference;
  awayScore += awayGoalDiff * config.weights.goalDifference;

  if (h2h && h2h.length > 0) {
    h2h.slice(0, config.h2hMaxGames).forEach((match) => {
      if (match.teams.home.winner) {
        homeTeamId === match.teams.home.id
          ? (homeScore += config.weights.h2h)
          : (awayScore += config.weights.h2h);
      } else if (match.teams.away.winner) {
        homeTeamId === match.teams.away.id
          ? (homeScore += config.weights.h2h)
          : (awayScore += config.weights.h2h);
      } else {
        homeScore += config.weights.h2h / 2;
        awayScore += config.weights.h2h / 2;
      }
    });
  }

  if (homeTeamRank != null && awayTeamRank != null) {
    const rankDiff = Math.abs(homeTeamRank - awayTeamRank);
    if (homeTeamRank < awayTeamRank) {
      homeScore += rankDiff * config.weights.rankDifference;
    } else if (awayTeamRank < homeTeamRank) {
      awayScore += rankDiff * config.weights.rankDifference;
    }
  }

  if (
    ["1H", "HT", "2H", "ET", "BT", "P", "LIVE"].includes(matchStatus) &&
    matchEvents
  ) {
    matchEvents.forEach((event) => {
      if (event.type === "Goal") {
        if (event.team.id === homeTeamId)
          homeScore += config.weights.liveGoalMomentum;
        else awayScore += config.weights.liveGoalMomentum;
      }
      if (event.type === "Card" && event.detail === "Red Card") {
        if (event.team.id === homeTeamId)
          homeScore += config.weights.liveRedCardPenalty;
        else awayScore += config.weights.liveRedCardPenalty;
      }
    });
  }

  homeScore = Math.max(1, homeScore);
  awayScore = Math.max(1, awayScore);
  const drawScore =
    (homeScore + awayScore) *
    (1 - Math.abs(homeScore - awayScore) / (homeScore + awayScore)) *
    config.drawWeight;
  const totalPoints = homeScore + awayScore + drawScore;

  if (totalPoints <= 1) {
    return { home: 33, draw: 34, away: 33 };
  }

  let homePercent = Math.round((homeScore / totalPoints) * 100);
  let awayPercent = Math.round((awayScore / totalPoints) * 100);
  let drawPercent = 100 - homePercent - awayPercent;

  if (homePercent + awayPercent + drawPercent !== 100) {
    const diff = 100 - (homePercent + awayPercent + drawPercent);
    if (homePercent >= awayPercent && homePercent >= drawPercent)
      homePercent += diff;
    else if (awayPercent >= homePercent && awayPercent >= drawPercent)
      awayPercent += diff;
    else drawPercent += diff;
  }

  return { home: homePercent, draw: drawPercent, away: awayPercent };
};

export const convertPercentageToOdds = (
  percent: number | undefined | null
): string => {
  if (percent === null || percent === undefined || percent <= 0) {
    return "N/A";
  }
  const safePercent = Math.max(1, Math.min(percent, 99));
  return (100 / safePercent).toFixed(2);
};

// ===== src/lib/redis.mock.ts =====

const mockStore: { [key: string]: string } = {};

const mockRedisClient = {
  get: async (key: string): Promise<string | null> => {

    return mockStore[key] || null;
  },
  set: async (
    key: string,
    value: string,
    ...args: any[]
  ): Promise<"OK" | null> => {

    mockStore[key] = value;
    return "OK";
  },

  del: async (...keys: string[]): Promise<number> => {
    }`);
    let count = 0;
    keys.forEach((key) => {
      if (mockStore[key] !== undefined) {
        delete mockStore[key];
        count++;
      }
    });
    return count;
  },

  keys: async (pattern: string): Promise<string[]> => {

    const regex = new RegExp(pattern.replace(/\*/g, ".*"));
    return Object.keys(mockStore).filter((key) => regex.test(key));
  },

  hgetall: async (key: string): Promise<Record<string, string>> => {

    return JSON.parse(mockStore[key] || "{}");
  },
  pipeline: () => ({
    hset: () => {},
    expire: () => {},
    exec: async () => {
      return [];
    },
  }),
  expire: async (key: string, seconds: number): Promise<number> => {

    return 1;
  },
};

export default mockRedisClient;

// ===== src/lib/redis.ts =====

import "dotenv/config";
import Redis from "ioredis";
import "server-only";
import mockRedisClient from "./redis.mock";

declare global {
  var redis: Redis | undefined;
}

let redisClient: Redis | typeof mockRedisClient;

if (
  process.env.NEXT_PUBLIC_NODE_ENV === "production" &&
  !process.env.NEXT_PUBLIC_CI
) {
  if (
    !process.env.NEXT_PUBLIC_REDIS_HOST ||
    !process.env.NEXT_PUBLIC_REDIS_PORT ||
    !process.env.NEXT_PUBLIC_REDIS_PASSWORD
  ) {
    throw new Error(
      "Production Redis connection details (REDIS_HOST, REDIS_PORT, REDIS_PASSWORD) are not defined for the running application."
    );
  }

  if (!global.redis) {
    global.redis = new Redis({
      host: process.env.NEXT_PUBLIC_REDIS_HOST,
      port: parseInt(process.env.NEXT_PUBLIC_REDIS_PORT, 10),
      password: process.env.NEXT_PUBLIC_REDIS_PASSWORD,
      enableOfflineQueue: false,
    });

    global.redis.on("connect", () => {

    });

    global.redis.on("error", (err) => {
      console.error(
        "[Redis] Production runtime connection Error:",
        err.message
      );
    });
  }
  redisClient = global.redis;
} else {

  if (process.env.CI) {
    console.log(
      "[Redis] Using MOCK Redis client for build process (CI environment)."
    );
  }
  redisClient = mockRedisClient;
}

export default redisClient;

// ===== src/lib/toc.ts =====

import * as cheerio from "cheerio";
import slugify from "slugify";

export interface TocEntry {
  level: "h2" | "h3";
  id: string;
  text: string;
}

export function generateTableOfContents(htmlContent: string): {
  processedHtml: string;
  toc: TocEntry[];
} {
  if (!htmlContent) {
    return { processedHtml: "", toc: [] };
  }

  const $ = cheerio.load(htmlContent);
  const toc: TocEntry[] = [];

  $("h2, h3").each((index, element) => {
    const el = $(element);
    const text = el.text();
    const level = el.is("h2") ? "h2" : "h3";

    const baseId = `toc-${slugify(text, { lower: true, strict: true })}`;
    let id = baseId;
    let counter = 1;

    while ($(`[id="${id}"]`).length > 0) {
      id = `${baseId}-${counter}`;
      counter++;
    }

    el.attr("id", id);

    toc.push({ level, id, text });
  });

  return {
    processedHtml: $.html(),
    toc,
  };
}

// ===== src/middleware.ts =====

import { NextRequest, NextResponse } from "next/server";
import { DEFAULT_LOCALE, SUPPORTED_LOCALES } from "./lib/i18n/config";

const I18N_COOKIE_NAME = "NEXT_LOCALE";

function getLocale(request: NextRequest): string {
  const cookieLocale = request.cookies.get(I18N_COOKIE_NAME)?.value;
  if (cookieLocale && SUPPORTED_LOCALES.includes(cookieLocale)) {
    return cookieLocale;
  }
  return DEFAULT_LOCALE;
}

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  const pathnameHasLocale = SUPPORTED_LOCALES.some(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  );

  if (pathnameHasLocale) {
    if (
      pathname.startsWith(`/${DEFAULT_LOCALE}/`) ||
      pathname === `/${DEFAULT_LOCALE}`
    ) {
      const newPath = pathname.replace(`/${DEFAULT_LOCALE}`, "");
      const url = new URL(newPath === "" ? "/" : newPath, request.url);
      return NextResponse.redirect(url);
    }
    return NextResponse.next();
  }

  const detectedLocale = getLocale(request);
  let response: NextResponse;

  if (detectedLocale === DEFAULT_LOCALE) {
    response = NextResponse.rewrite(
      new URL(`/${DEFAULT_LOCALE}${pathname}`, request.url)
    );
  } else {
    response = NextResponse.redirect(
      new URL(`/${detectedLocale}${pathname}`, request.url)
    );
  }

  response.cookies.set(I18N_COOKIE_NAME, detectedLocale, {
    path: "/",
    maxAge: 60 * 60 * 24 * 365,
  });

  return response;
}

export const config = {
  matcher: [

    "/((?!api|_next/static|_next/image|admin|login|favicon.ico|.*\\.).*)",
  ],
};

// ===== src/models/AIJournalist.ts =====

import mongoose, { Schema, Document } from "mongoose";

export interface IAIJournalist extends Document {
  name: string;
  description?: string;
  tonePrompt: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

const AIJournalistSchema: Schema = new Schema(
  {
    name: { type: String, required: true, unique: true, trim: true },
    description: { type: String, trim: true },

    tonePrompt: { type: String, required: true, trim: true },
    isActive: { type: Boolean, default: true },
  },
  {
    timestamps: true,
  }
);

const AIJournalist =
  mongoose.models.AIJournalist ||
  mongoose.model<IAIJournalist>("AIJournalist", AIJournalistSchema);

export default AIJournalist;

// ===== src/models/AIPrompt.ts =====

import mongoose, { Schema, Document } from "mongoose";

export type AIPromptType = "title" | "content" | "prediction_content";

export interface IAIPrompt extends Document {
  name: string;
  type: AIPromptType;
  prompt: string;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}

const AIPromptSchema: Schema = new Schema(
  {
    name: { type: String, required: true, trim: true },
    type: {
      type: String,
      enum: ["title", "content", "prediction_content"],
      required: true,
    },
    prompt: { type: String, required: true },
    description: { type: String, trim: true },
  },
  {
    timestamps: true,
  }
);

AIPromptSchema.index({ name: 1, type: 1 }, { unique: true });

export default (mongoose.models.AIPrompt as mongoose.Model<IAIPrompt>) ||
  mongoose.model<IAIPrompt>("AIPrompt", AIPromptSchema);

// ===== src/models/Banner.ts =====

import mongoose, { Document, Schema, Model } from "mongoose";

export interface IBanner extends Document {
  title: string;
  imageUrl: string;
  linkUrl: string;
  isActive: boolean;
  location: string;
  createdAt: Date;
  updatedAt: Date;
}

const BannerSchema: Schema<IBanner> = new Schema(
  {
    title: {
      type: String,
      required: [true, "Banner title is required."],
      trim: true,
    },
    imageUrl: {
      type: String,
      required: [true, "Image URL is required."],
    },
    linkUrl: {
      type: String,
      required: [true, "Link URL is required."],
    },
    isActive: {
      type: Boolean,
      default: true,
    },

    location: {
      type: String,
      required: [true, "A location must be specified for the banner."],
      index: true,
    },
  },
  {
    timestamps: true,
  }
);

const Banner: Model<IBanner> =
  mongoose.models.Banner || mongoose.model<IBanner>("Banner", BannerSchema);

export default Banner;

// ===== src/models/CasinoPartner.ts =====

import mongoose, { Schema, Document } from "mongoose";

export interface ICasinoPartner extends Document {
  name: string;
  logoUrl: string;
  redirectUrl: string;
  description?: string;
  isFeatured: boolean;
  isActive: boolean;
  order: number;
  createdAt: Date;
  updatedAt: Date;
}

const CasinoPartnerSchema: Schema = new Schema(
  {
    name: { type: String, required: true, unique: true, trim: true },
    logoUrl: { type: String, required: true, trim: true },
    redirectUrl: { type: String, required: true, trim: true },
    description: { type: String, trim: true },
    isFeatured: { type: Boolean, default: false },
    isActive: { type: Boolean, default: true },
    order: { type: Number, default: 0 },
  },
  {
    timestamps: true,
  }
);

const CasinoPartner =
  mongoose.models.CasinoPartner ||
  mongoose.model<ICasinoPartner>("CasinoPartner", CasinoPartnerSchema);

export default CasinoPartner;

// ===== src/models/ExternalNewsArticle.ts =====

import mongoose, { Schema, Document } from "mongoose";

export interface IExternalNewsArticle extends Document {
  articleId: string;
  title: string;
  link: string;
  keywords?: string[];

  creator?: string[];
  video_url?: string | null;
  description?: string | null;
  content?: string | null;
  pubDate: Date;
  imageUrl?: string | null;
  source_id?: string;
  source_priority?: number;
  source_url?: string;
  source_icon?: string | null;
  language?: string;
  country?: string[];
  category?: string[];
  sentiment?: string;
  status: "fetched" | "processing" | "processed" | "skipped" | "error";
  processedPostId?: mongoose.Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const ExternalNewsArticleSchema: Schema = new Schema(
  {
    articleId: { type: String, required: true, unique: true, index: true },
    title: { type: String, required: true },
    link: { type: String, required: true },
    keywords: [{ type: String }],

    creator: [{ type: String }],

    video_url: { type: String },
    description: { type: String },
    content: { type: String },
    pubDate: { type: Date, required: true, index: true },
    imageUrl: { type: String },
    source_id: { type: String },
    source_priority: { type: Number },
    source_url: { type: String },
    source_icon: { type: String },
    language: { type: String },
    country: [{ type: String }],
    category: [{ type: String }],
    sentiment: { type: String },
    status: {
      type: String,
      enum: ["fetched", "processing", "processed", "skipped", "error"],
      default: "fetched",
    },
    processedPostId: { type: Schema.Types.ObjectId, ref: "Post" },
  },
  {
    timestamps: true,
  }
);

const ExternalNewsArticle =
  mongoose.models.ExternalNewsArticle ||
  mongoose.model<IExternalNewsArticle>(
    "ExternalNewsArticle",
    ExternalNewsArticleSchema
  );

export default ExternalNewsArticle;

// ===== src/models/Faq.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

export interface IFaq extends Document {
  question: string;
  answer: string;

  category: string;
  order: number;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

const FaqSchema: Schema<IFaq> = new Schema(
  {
    question: {
      type: String,
      required: [true, "Question is required."],
      trim: true,
      unique: true,
    },
    answer: {
      type: String,
      required: [true, "Answer is required."],
    },

    category: {
      type: String,
      required: [true, "Category is required."],
      trim: true,
      index: true,
      default: "General Questions",
    },
    order: {
      type: Number,
      default: 0,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
  }
);

const Faq: Model<IFaq> =
  mongoose.models.Faq || mongoose.model<IFaq>("Faq", FaqSchema);

export default Faq;

// ===== src/models/Language.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

export interface ILanguage extends Document {
  name: string;
  code: string;
  isActive: boolean;
  isDefault: boolean;
  flagUrl?: string;
  createdAt: Date;
  updatedAt: Date;
}

const LanguageSchema: Schema<ILanguage> = new Schema(
  {
    name: {
      type: String,
      required: [true, "Language name is required."],
      unique: true,
      trim: true,
    },
    code: {
      type: String,
      required: [true, "Language code (e.g., 'en') is required."],
      unique: true,
      trim: true,
      lowercase: true,
      minlength: 2,
      maxlength: 5,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
    isDefault: {
      type: Boolean,
      default: false,
    },
    flagUrl: {
      type: String,
      trim: true,
    },
  },
  {
    timestamps: true,
  }
);

LanguageSchema.pre("save", async function (next) {
  if (this.isModified("isDefault") && this.isDefault) {

    await (this.constructor as Model<ILanguage>).updateMany(
      { _id: { $ne: this._id }, isDefault: true },
      { isDefault: false }
    );
  }
  next();
});

const Language: Model<ILanguage> =
  mongoose.models.Language ||
  mongoose.model<ILanguage>("Language", LanguageSchema);

export default Language;

// ===== src/models/League.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

export interface ILeague extends Document {
  leagueId: number;
  name: string;
  type: string;
  logoUrl: string;
  countryName: string;
  countryCode: string | null;
  countryFlagUrl: string | null;
  seasons: {
    year: number;
    start: string;
    end: string;
    current: boolean;
  }[];
}

const SeasonSchema: Schema = new Schema(
  {
    year: { type: Number, required: true },
    start: { type: String, required: true },
    end: { type: String, required: true },
    current: { type: Boolean, required: true },
  },
  { _id: false }
);

const LeagueSchema: Schema<ILeague> = new Schema(
  {
    leagueId: {
      type: Number,
      required: true,
      unique: true,
      index: true,
    },
    name: {
      type: String,
      required: true,
      trim: true,
    },
    type: {
      type: String,
      required: true,
      enum: ["League", "Cup"],
    },
    logoUrl: {
      type: String,
      required: true,
    },
    countryName: {
      type: String,
      required: true,
    },
    countryCode: {
      type: String,
    },
    countryFlagUrl: {
      type: String,
    },
    seasons: [SeasonSchema],
  },
  {
    timestamps: true,
  }
);

const League: Model<ILeague> =
  mongoose.models.League || mongoose.model<ILeague>("League", LeagueSchema);

export default League;

// ===== src/models/PageContent.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

export interface IPageContent extends Document {
  pageSlug: string;
  title: string;
  content: string;
  createdAt: Date;
  updatedAt: Date;
}

const PageContentSchema: Schema<IPageContent> = new Schema(
  {
    pageSlug: {
      type: String,
      required: true,
      unique: true,
      index: true,
      trim: true,
    },
    title: {
      type: String,
      required: true,
      trim: true,
    },
    content: {
      type: String,
      required: true,
    },
  },
  {
    timestamps: true,
  }
);

const PageContent: Model<IPageContent> =
  mongoose.models.PageContent ||
  mongoose.model<IPageContent>("PageContent", PageContentSchema);

export default PageContent;

// ===== src/models/Post.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

export type SportsCategory = "football" | "basketball" | "tennis" | "general";
export type NewsType =
  | "news"
  | "highlights"
  | "reviews"
  | "prediction"
  | "transfer"
  | "recent";

export interface IPost extends Document {
  title: string;
  content: string;
  slug: string;
  author: string;
  status: "draft" | "published";
  createdAt: Date;
  updatedAt: Date;
  featuredImage?: string;
  featuredImageTitle?: string;
  featuredImageAltText?: string;
  metaTitle?: string;
  metaDescription?: string;
  language: string;
  translationGroupId: mongoose.Types.ObjectId;
  sportsCategory: SportsCategory[];
  isAIGenerated?: boolean;
  originalExternalArticleId?: mongoose.Types.ObjectId;
  originalFixtureId?: number;
  newsType: NewsType;
  linkedFixtureId?: number;
  linkedLeagueId?: number;
  linkedTeamId?: number;
  originalSourceUrl?: string;
}

export interface IPostWithTranslations extends IPost {
  getTranslations: () => Promise<Pick<IPost, "slug" | "language">[]>;
}

const PostSchema: Schema = new Schema(
  {
    title: { type: String, required: true, trim: true },
    content: { type: String, required: true },
    slug: {
      type: String,
      required: true,
      lowercase: true,
      trim: true,
    },
    author: { type: String, default: "Admin" },
    status: { type: String, enum: ["draft", "published"], default: "draft" },
    featuredImage: { type: String, trim: true },
    featuredImageTitle: { type: String, trim: true },
    featuredImageAltText: { type: String, trim: true },
    metaTitle: { type: String, trim: true },
    metaDescription: { type: String, trim: true },
    language: {
      type: String,
      required: true,
      index: true,
    },
    translationGroupId: {
      type: Schema.Types.ObjectId,
      required: true,
      index: true,
    },
    sportsCategory: {
      type: [
        {
          type: String,
          enum: ["football", "basketball", "tennis", "general"],
        },
      ],
      default: ["general"],
      required: true,
    },
    isAIGenerated: { type: Boolean, default: false },
    originalExternalArticleId: {
      type: Schema.Types.ObjectId,
      ref: "ExternalNewsArticle",
      required: false,
    },
    originalFixtureId: {
      type: Number,
      required: false,
      unique: true,
      sparse: true,
    },
    newsType: {
      type: String,
      enum: [
        "news",
        "highlights",
        "reviews",
        "prediction",
        "transfer",
        "recent",
      ],
      default: "news",
      required: true,
    },

    originalSourceUrl: {
      type: String,
      trim: true,
    },

    linkedFixtureId: {
      type: Number,
      required: false,
      index: true,
    },
    linkedLeagueId: {
      type: Number,
      required: false,
      index: true,
    },
    linkedTeamId: {
      type: Number,
      required: false,
      index: true,
    },
  },
  {
    timestamps: true,
  }
);

PostSchema.index({ slug: 1, language: 1 }, { unique: true });

PostSchema.methods.getTranslations = async function () {
  if (!this.translationGroupId) return [];
  return mongoose.models.Post.find({
    translationGroupId: this.translationGroupId,
    status: "published",
  })
    .select("slug language")
    .lean();
};

export default (mongoose.models.Post as Model<IPostWithTranslations>) ||
  mongoose.model<IPostWithTranslations>("Post", PostSchema);

// ===== src/models/Prediction.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

interface ITeamInfo {
  id: number;
  name: string;
  logo: string;
}

interface ILeagueInfo {
  id: number;
  name: string;
  logo: string;
}

export interface IPrediction extends Document {
  fixtureId: number;
  fixtureDate: Date;
  status: string;
  teams: {
    home: ITeamInfo;
    away: ITeamInfo;
  };
  league: ILeagueInfo;
  prediction: {
    home: number;
    draw: number;
    away: number;
  };
  h2h?: any[];
  form?: {
    home: string | null;
    away: string | null;
  };
}

const TeamInfoSchema = new Schema(
  {
    id: { type: Number, required: true },
    name: { type: String, required: true },
    logo: { type: String, required: true },
  },
  { _id: false }
);

const LeagueInfoSchema = new Schema(
  {
    id: { type: Number, required: true },
    name: { type: String, required: true },
    logo: { type: String, required: true },
  },
  { _id: false }
);

const PredictionSchema: Schema<IPrediction> = new Schema(
  {
    fixtureId: { type: Number, required: true, unique: true, index: true },
    fixtureDate: { type: Date, required: true, index: true },
    status: { type: String, required: true },
    teams: {
      home: { type: TeamInfoSchema, required: true },
      away: { type: TeamInfoSchema, required: true },
    },
    league: { type: LeagueInfoSchema, required: true },
    prediction: {
      home: { type: Number, required: true },
      draw: { type: Number, required: true },
      away: { type: Number, required: true },
    },
    h2h: { type: Array, default: [] },
    form: {
      home: { type: String },
      away: { type: String },
    },
  },
  {
    timestamps: true,
  }
);

const Prediction: Model<IPrediction> =
  mongoose.models.Prediction ||
  mongoose.model<IPrediction>("Prediction", PredictionSchema);

export default Prediction;

// ===== src/models/RecentNews.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";
import { SportsCategory } from "./Post";

export interface IRecentNews extends Document {
  title: string;
  content: string;
  slug: string;
  author: string;
  featuredImage?: string;
  language: string;
  translationGroupId: mongoose.Types.ObjectId;
  sportsCategory: SportsCategory[];
  originalArticleLink: string;
  createdAt: Date;
  updatedAt: Date;
}

const RecentNewsSchema: Schema<IRecentNews> = new Schema(
  {
    title: { type: String, required: true, trim: true },
    content: { type: String, required: true },
    slug: {
      type: String,
      required: true,
      lowercase: true,
      trim: true,
    },
    author: { type: String, required: true },
    featuredImage: { type: String, trim: true },
    language: {
      type: String,
      required: true,
      index: true,
    },
    translationGroupId: {
      type: Schema.Types.ObjectId,
      required: true,
      index: true,
    },
    sportsCategory: {
      type: [
        {
          type: String,
          enum: ["football", "basketball", "tennis", "general"],
        },
      ],
      default: ["general"],
    },
    originalArticleLink: {
      type: String,
      required: true,
      trim: true,
    },
  },
  {
    timestamps: true,
  }
);

RecentNewsSchema.index({ slug: 1, language: 1 }, { unique: true });

const RecentNews: Model<IRecentNews> =
  mongoose.models.RecentNews ||
  mongoose.model<IRecentNews>("RecentNews", RecentNewsSchema);

export default RecentNews;

// ===== src/models/Team.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

export interface ITeam extends Document {
  teamId: number;
  name: string;
  code: string | null;
  country: string;
  founded: number | null;
  national: boolean;
  logoUrl: string;
  venueId: number | null;
  venueName: string | null;
  venueAddress: string | null;
  venueCity: string | null;
  venueCapacity: number | null;
  venueSurface: string | null;
  venueImageUrl: string | null;
}

const TeamSchema: Schema<ITeam> = new Schema(
  {
    teamId: {
      type: Number,
      required: true,
      unique: true,
      index: true,
    },
    name: {
      type: String,
      required: true,
      trim: true,
    },
    code: {
      type: String,
    },
    country: {
      type: String,
      required: true,
    },
    founded: {
      type: Number,
    },
    national: {
      type: Boolean,
      default: false,
    },
    logoUrl: {
      type: String,
      required: true,
    },
    venueId: {
      type: Number,
    },
    venueName: {
      type: String,
    },
    venueAddress: {
      type: String,
    },
    venueCity: {
      type: String,
    },
    venueCapacity: {
      type: Number,
    },
    venueSurface: {
      type: String,
    },
    venueImageUrl: {
      type: String,
    },
  },
  {
    timestamps: true,
  }
);

const Team: Model<ITeam> =
  mongoose.models.Team || mongoose.model<ITeam>("Team", TeamSchema);

export default Team;

// ===== src/models/TickerMessage.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

export interface ITickerMessage extends Document {
  message: string;
  language: string;
  translationGroupId: mongoose.Types.ObjectId;
  isActive: boolean;
  order: number;
  href?: string;
  createdAt: Date;
  updatedAt: Date;
}

const TickerMessageSchema: Schema<ITickerMessage> = new Schema(
  {
    message: {
      type: String,
      required: [true, "Message content is required."],
      trim: true,
    },
    language: {
      type: String,
      required: [true, "Language is required."],
      index: true,
    },
    translationGroupId: {
      type: Schema.Types.ObjectId,
      required: true,
      index: true,
    },
    isActive: {
      type: Boolean,
      default: true,
      index: true,
    },
    order: {
      type: Number,
      default: 0,
    },
  },
  {
    timestamps: true,
  }
);

const TickerMessage: Model<ITickerMessage> =
  mongoose.models.TickerMessage ||
  mongoose.model<ITickerMessage>("TickerMessage", TickerMessageSchema);

export default TickerMessage;

// ===== src/models/TitleTemplate.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

export interface ITitleTemplate extends Document {
  name: string;
  description?: string;
  template: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

const TitleTemplateSchema: Schema<ITitleTemplate> = new Schema(
  {
    name: {
      type: String,
      required: [true, "Template name is required."],
      unique: true,
      trim: true,
    },
    description: {
      type: String,
      trim: true,
    },
    template: {
      type: String,
      required: [true, "Template content is required."],
      trim: true,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
  }
);

const TitleTemplate: Model<ITitleTemplate> =
  mongoose.models.TitleTemplate ||
  mongoose.model<ITitleTemplate>("TitleTemplate", TitleTemplateSchema);

export default TitleTemplate;

// ===== src/models/Translation.ts =====

import mongoose, { Schema, Document, Model } from "mongoose";

export interface ITranslation extends Document {
  key: string;
  group: string;
  description?: string;
  translations: Map<string, string>;
  createdAt: Date;
  updatedAt: Date;
}

const TranslationSchema: Schema<ITranslation> = new Schema(
  {
    key: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      index: true,

      match: /^[a-z0-9_]+$/,
    },
    group: {
      type: String,
      required: true,
      trim: true,
      index: true,
      default: "general",
    },
    description: {
      type: String,
      trim: true,
    },
    translations: {
      type: Map,
      of: String,
      required: true,
    },
  },
  {
    timestamps: true,
  }
);

const Translation: Model<ITranslation> =
  mongoose.models.Translation ||
  mongoose.model<ITranslation>("Translation", TranslationSchema);

export default Translation;

// ===== src/models/User.ts =====

import mongoose, { Schema, models, model } from 'mongoose';

export interface IUser extends mongoose.Document {
  name?: string;
  email: string;
  image?: string;
  password?: string;
  role: 'user' | 'admin';
  favoriteTeams?: number[];
}

const UserSchema = new Schema<IUser>({
  name: String,
  email: {
    type: String,
    unique: true,
    required: true,
  },
  image: String,

  password: {
    type: String,
    select: false,
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user',
  },
  favoriteTeams: {
    type: [Number],
    default: [],
  },
}, { timestamps: true });

const User = models.User || model<IUser>('User', UserSchema);
export default User;

// ===== src/models/Vote.ts =====

import mongoose, { Schema, Document, models, Model } from 'mongoose';

export interface IVote extends Document {
  fixtureId: number;
  homeVotes: number;
  drawVotes: number;
  awayVotes: number;
}

const VoteSchema: Schema = new Schema(
  {
    fixtureId: {
        type: Number,
        required: true,
        unique: true,
        index: true
    },
    homeVotes: { type: Number, default: 0 },
    drawVotes: { type: Number, default: 0 },
    awayVotes: { type: Number, default: 0 },
  },
  {
    timestamps: true,
  }
);

const Vote: Model<IVote> = models.Vote || mongoose.model<IVote>('Vote', VoteSchema);

export default Vote;

// ===== src/services/sports/ISportService.ts =====

export interface ISportService {

  getCompetitions(params: { country?: string; type?: string; fetchAll?: boolean }): Promise<any[]>;

  getFixtures(params: { competitionId?: string; date?: string; season?: string; live?: boolean; teamId?: string }): Promise<any[]>;

  getMatchDetails(matchId: string): Promise<any | null>;

  getTeamDetails(teamId: string): Promise<any | null>;

  getStandings(params: { competitionId: string; season: string }): Promise<any | null>;

}

// ===== src/services/sports/football.service.ts =====

import axios from 'axios';
import { ISportService } from './ISportService';
import { format, addDays } from 'date-fns';

export class FootballApiService implements ISportService {
  private readonly apiKey = process.env.NEXT_PUBLIC_API_FOOTBALL_KEY;
  private readonly apiHost = process.env.NEXT_PUBLIC_API_FOOTBALL_HOST;

  private async request(endpoint: string, params: object) {
    const options = {
      method: 'GET',
      url: `${this.apiHost}/${endpoint}`,
      params,
      headers: { 'x-apisports-key': this.apiKey },
    };
    try {
      const response = await axios.request(options);
      return response.data.response;
    } catch (error) {

      throw new Error(`Failed to fetch data from ${endpoint}.`);
    }
  }

  async getCompetitions(params: { country?: string; type?: string; fetchAll?: boolean }): Promise<any[]> {

    const apiParams: any = { current: 'true' };
    if (params.country) apiParams.country = params.country;
    if (params.type) apiParams.type = params.type;

    let allLeagues = await this.request('leagues', apiParams);

    return allLeagues;
  }

  async getFixtures(params: { competitionId?: string; date?: string; teamId?: string }): Promise<any[]> {

    const apiParams: any = {};
    const season = new Date().getFullYear().toString();

    if (params.competitionId) apiParams.league = params.competitionId;
    if (params.date) apiParams.date = params.date;
    if (params.teamId) {
        apiParams.team = params.teamId;
        apiParams.last = 10;
    } else {

        apiParams.season = season;
        const today = format(new Date(), 'yyyy-MM-dd');
        apiParams.from = today;
        apiParams.to = format(addDays(new Date(), 1), 'yyyy-MM-dd');
    }

    return this.request('fixtures', apiParams);
  }

  async getMatchDetails(matchId: string): Promise<any | null> {

    const [fixture, events, stats, h2h, prediction] = await Promise.all([
        this.request('fixtures', { id: matchId }),
        this.request('fixtures/events', { fixture: matchId }),
        this.request('fixtures/statistics', { fixture: matchId }),
        this.request('fixtures/headtohead', { h2h: `...` }),
        this.request('predictions', { fixture: matchId })
    ]);

    return { fixture: fixture[0], events, statistics: stats,  };
  }

  async getTeamDetails(teamId: string): Promise<any | null> {

      return await this.request('teams', { id: teamId });
  }

  async getStandings(params: { competitionId: string; season: string; }): Promise<any | null> {
      return this.request('standings', { league: params.competitionId, season: params.season });
  }
}

// ===== src/services/sports/index.ts =====

import { ISportService } from './ISportService';
import { FootballApiService } from './football.service';

const services: { [key: string]: ISportService } = {
  football: new FootballApiService(),

};

export function getSportService(sport: string): ISportService {
  const service = services[sport];
  if (!service) {
    throw new Error(`Unsupported sport: ${sport}`);
  }
  return service;
}

// ===== src/services/sportsApi/allsportsApiService.ts =====

export interface ApiSportsTeam {
  id: number;
  name: string;
  logo: string;
  winner?: boolean | null;
}

export interface ApiSportsFixtureStatus {
  long: string;
  short: string;
  elapsed: number | null;
}

export interface ApiSportsLeague {
  id: number;
  name: string;
  type: string;
  logo: string;
  season?: number;
}

export interface ApiSportsGoals {
  home: number | null;
  away: number | null;
}

export interface ApiSportsFixture {
  fixture: {
    id: number;
    referee: string | null;
    timezone: string;
    date: string;
    timestamp: number;
    periods: { first: number | null; second: number | null };
    venue: { id: number; name: string; city: string };
    status: ApiSportsFixtureStatus;
  };
  league: ApiSportsLeague;
  teams: {
    home: ApiSportsTeam;
    away: ApiSportsTeam;
  };
  goals: ApiSportsGoals;
  score: {
    halftime: ApiSportsGoals;
    fulltime: ApiSportsGoals;
    extratime: ApiSportsGoals | null;
    penalty: ApiSportsGoals | null;
  };
  events?: any[];
  statistics?: any[];
  lineups?: any[];
}

export interface ApiSportsTeamStanding {
  rank: number;
  team: ApiSportsTeam;
  points: number;
  goalsDiff: number;
  group: string;
  form: string;
  status: string;
  description: string | null;
  all: {
    played: number;
    win: number;
    draw: number;
    lose: number;
    goals: { for: number; against: number };
  };
  home: {
    played: number;
    win: number;
    draw: number;
    lose: number;
    goals: { for: number; against: number };
  };
  away: {
    played: number;
    win: number;
    draw: number;
    lose: number;
    goals: { for: number; against: number };
  };
  update: string;
}

export interface ApiSportsStandings {
  league: {
    id: number;
    name: string;
    country: string;
    logo: string;
    flag: string;
    season: number;
    standings: ApiSportsTeamStanding[][];
  };
}

export interface CleanOdds {
  home: string | null;
  draw: string | null;
  away: string | null;
  handicap?: string | null;
  over?: string | null;
  under?: string | null;
}

export interface ApiSportsPlayer {
  id: number;
  name: string;
  firstname: string;
  lastname: string;
  age: number;
  birth: {
    date: string;
    place: string;
    country: string;
  };
  nationality: string;
  height: string;
  weight: string;
  injured: boolean;
  photo: string;
}

export interface ApiSportsPlayerStats {
  player: ApiSportsPlayer;
  statistics: {
    team: ApiSportsTeam;
    league: ApiSportsLeague;
    games: {
      appearences: number | null;
      lineups: number | null;
      minutes: number | null;
      number: number | null;
      position: string;
      rating: string | null;
      captain: boolean;
    };
    substitutes: {
      in: number | null;
      out: number | null;
      bench: number | null;
    };
    goals: {
      total: number | null;
      conceded: number | null;
      assists: number | null;
      saves: number | null;
    };
    passes: {
      total: number | null;
      key: number | null;
      accuracy: string | null;
    };
    tackles: {
      total: number | null;
      blocks: number | null;
      interceptions: number | null;
    };
    duels: {
      total: number | null;
      won: number | null;
    };
    dribbles: {
      attempts: number | null;
      success: number | null;
      past: number | null;
    };
    fouls: {
      drawn: number | null;
      committed: number | null;
    };
    cards: {
      yellow: number;
      red: number;
    };
    penalty: {
      won: number | null;
      commited: number | null;
      scored: number | null;
      missed: number | null;
      saved: number | null;
    };
  }[];
}

export interface Country {
  name: string;
  code: string | null;
  flagUrl: string;
}

// ===== src/types/api-football.ts =====

export interface League {
  id: number;
  name: string;
  logoUrl: string;
  countryName: string;
  countryFlagUrl: string,
  type: string,
  href: string;
}

export interface Country {
  name: string;
  code: string | null;
  flagUrl: string;
}

// ===== src/types/global.d.ts =====

import { Mongoose } from 'mongoose';

declare global {
  var mongoose: {
    conn: Mongoose | null;
    promise: Promise<Mongoose> | null;
  };
}

// ===== src/types/next-auth.d.ts =====

import 'next-auth';
import 'next-auth/jwt';

declare module 'next-auth' {

  interface Session {
    user: {
      id: string;
      role: 'user' | 'admin';
    } & DefaultSession['user'];
  }

  interface User {
    role: 'user' | 'admin';
  }
}

declare module 'next-auth/jwt' {

  interface JWT {
    id: string;
    role: 'user' | 'admin';
  }
}

// ===== src/types/translations.d.ts =====

export type TranslationKey =

  | "live"
  | "matches"
  | "yesterday"
  | "today"
  | "tomorrow"
  | "standings"
  | "news"
  | "analytics"
  | "global"
  | "loading"
  | "leagues"
  | "teams"
  | "transfers"
  | "football"
  | "tennis"
  | "basketball"
  | "rugby"
  | "badminton"
  | "cancel"
  | "saving"
  | "previous"
  | "next"
  | "page_of"
  | "actions"
  | "advertisement"

  | "admin_login"
  | "email"
  | "password"
  | "sign_in"
  | "invalid_credentials"
  | "register"
  | "user"
  | "role"
  | "your_profile"
  | "view_account_settings"

  | "admin_dashboard"
  | "welcome_to_admin_area"
  | "manage_users"
  | "view_and_edit_user_roles"
  | "manage_matches"
  | "update_match_details"
  | "view_analytics"
  | "check_site_traffic"
  | "dashboard"
  | "users"
  | "settings"
  | "admin_panel"
  | "sign_out"

  | "create_new_post"
  | "edit_post"
  | "manage_news"
  | "new_post"
  | "back_to_news_list"
  | "loading_post_data"
  | "failed_to_load_post_data"
  | "save_post"
  | "save_changes"
  | "featured_image"
  | "uploading"
  | "upload_a_file"
  | "or_drag_and_drop"
  | "image_upload_formats"
  | "image_title_tooltip"
  | "image_title_placeholder"
  | "image_alt_text_label"
  | "image_alt_text_placeholder"
  | "image_alt_text_description"
  | "title"
  | "content"
  | "created_at"
  | "seo_settings"
  | "meta_title"
  | "meta_title_placeholder"
  | "meta_title_recommendation"
  | "meta_description"
  | "meta_description_placeholder"
  | "meta_description_recommendation"
  | "status"
  | "draft"
  | "published"
  | "latest_news"

  | "match_details"
  | "view_match_details"
  | "finished"
  | "vote_and_see_poll"
  | "hide_panel"
  | "no_matches_for_day"
  | "check_another_day"
  | "match_not_found"
  | "match_not_found_description"
  | "team_not_found"
  | "events"
  | "lineups"
  | "h2h"
  | "statistics"
  | "prediction"
  | "head_to_head"
  | "wins"
  | "draws"
  | "no_previous_encounters"
  | "recent_result"
  | "upcoming_match"
  | "no_matches_live"
  | "live_matches"
  | "info"
  | "fixtures"
  | "top_scorers"
  | "back_to_global_view"
  | "standings_not_applicable_for_cups"
  | "season"
  | "competition_name"
  | "country"
  | "current_season"
  | "season_coverage"
  | "rank_short"
  | "team"
  | "matches_played_short"
  | "wins_short"
  | "draws_short"
  | "losses_short"
  | "goal_difference_short"
  | "points_short"
  | "league_standings"
  | "select_league_for_standings"
  | "next_league"
  | "versus"

  | "popular_leagues"
  | "popular_cups"
  | "popular_teams"

  | "published_by_on"
  | "share_this_article"

  | "total_goals_today"
  | "matches_today"
  | "match_spotlight"
  | "highest_scoring_match"

  | "show_odds"
  | "hide_odds"
  | "exclusive_welcome_offer"
  | "bonus_description"
  | "claim_your_bonus"
  | "gambling_disclaimer"
  | "leagues_description"
  | "teams_description"
  | "news_description"
  | "transfers_description";
