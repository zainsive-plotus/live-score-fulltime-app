// ===== src/app/admin/ai-journalists/page.tsx =====

// ===== src\app\admin\ai-journalists\page.tsx =====
// src/app/admin/ai-journalists/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  PlusCircle,
  Edit,
  Trash2,
  User,
  CheckCircle,
  XCircle,
  Loader2,
} from "lucide-react";

// Assuming IAIJournalist interface is defined, otherwise define it here
interface IAIJournalist {
  _id: string;
  name: string;
  description?: string;
  tonePrompt: string;
  isActive: boolean;
  createdAt: string; // ISO date string
  updatedAt: string; // ISO date string
}

// Reusable form modal for creating/editing AI Journalists
interface AIJournalistFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  journalist?: IAIJournalist | null; // Optional: for editing
}

const AIJournalistFormModal: React.FC<AIJournalistFormModalProps> = ({
  isOpen,
  onClose,
  journalist,
}) => {
  const queryClient = useQueryClient();
  const [name, setName] = useState(journalist?.name || "");
  const [description, setDescription] = useState(journalist?.description || "");
  // --- MODIFIED: Default tonePrompt to Turkish ---
  const [tonePrompt, setTonePrompt] = useState(
    journalist?.tonePrompt ||
      "Daima Türkçe bir ton kullanın, esprili yorumlarla ve derinlemesine analitik ve teknik yorumlarla makaleleri şekillendirin."
  );
  const [isActive, setIsActive] = useState(journalist?.isActive ?? true); // Default to true for new

  useEffect(() => {
    // Reset form fields when journalist prop changes (for editing)
    if (journalist) {
      setName(journalist.name);
      setDescription(journalist.description || "");
      setTonePrompt(journalist.tonePrompt);
      setIsActive(journalist.isActive);
    } else {
      // Clear form for new creation and set Turkish default
      setName("");
      setDescription("");
      setTonePrompt(
        "Daima Türkçe bir ton kullanın, esprili yorumlarla ve derinlemesine analitik ve teknik yorumlarla makaleleri şekillendirin."
      );
      setIsActive(true);
    }
  }, [journalist]);

  const createMutation = useMutation({
    mutationFn: (newJournalist: Partial<IAIJournalist>) =>
      axios.post("/api/admin/ai-journalists", newJournalist),
    onSuccess: () => {
      toast.success("AI Journalist created successfully!");
      queryClient.invalidateQueries({ queryKey: ["aiJournalists"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to create journalist.");
    },
  });

  const updateMutation = useMutation({
    mutationFn: (updatedJournalist: Partial<IAIJournalist>) =>
      axios.put(
        `/api/admin/ai-journalists/${journalist?._id}`,
        updatedJournalist
      ),
    onSuccess: () => {
      toast.success("AI Journalist updated successfully!");
      queryClient.invalidateQueries({ queryKey: ["aiJournalists"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to update journalist.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !tonePrompt.trim()) {
      toast.error("Name and Tone Prompt are required.");
      return;
    }

    const payload = { name, description, tonePrompt, isActive };

    if (journalist) {
      updateMutation.mutate(payload);
    } else {
      createMutation.mutate(payload);
    }
  };

  const isPending = createMutation.isPending || updateMutation.isPending;

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl overflow-hidden">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {journalist ? "Edit AI Journalist" : "Create New AI Journalist"}
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label
              htmlFor="name"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Journalist Name
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
          </div>
          <div>
            <label
              htmlFor="description"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Description (Optional)
            </label>
            <input
              id="description"
              type="text"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              disabled={isPending}
            />
          </div>
          <div>
            <label
              htmlFor="tonePrompt"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Tone Prompt Segment (Turkish Language)
            </label>
            <textarea
              id="tonePrompt"
              value={tonePrompt}
              onChange={(e) => setTonePrompt(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
              rows={6}
              required
              disabled={isPending}
              placeholder="e.g., 'Daima Türkçe bir ton kullanın, esprili yorumlarla ve derinlemesine analitik ve teknik yorumlarla makaleleri şekillendirin.'"
            />
            <p className="text-xs text-brand-muted mt-1">
              Bu istem segmenti, gazetecinin stilini tanımlamak için ana makale
              oluşturma istemine eklenecektir. Makalelerin daima Türkçe
              oluşturulduğundan emin olun.
            </p>
          </div>
          <div className="flex items-center">
            <input
              id="isActive"
              type="checkbox"
              checked={isActive}
              onChange={(e) => setIsActive(e.target.checked)}
              className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
              disabled={isPending}
            />
            <label
              htmlFor="isActive"
              className="ml-2 text-sm font-medium text-brand-light"
            >
              Active (Can be used for generation)
            </label>
          </div>
          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
              disabled={isPending}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={isPending}
            >
              {isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {isPending
                ? journalist
                  ? "Updating..."
                  : "Creating..."
                : journalist
                ? "Save Changes"
                : "Create Journalist"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

// --- Main AI Journalists Page Component (UNCHANGED) ---
export default function AdminAIJournalistsPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingJournalist, setEditingJournalist] =
    useState<IAIJournalist | null>(null);

  const {
    data: journalists,
    isLoading,
    error,
  } = useQuery<IAIJournalist[]>({
    queryKey: ["aiJournalists"],
    queryFn: async () => {
      const { data } = await axios.get("/api/admin/ai-journalists");
      return data;
    },
    staleTime: 1000 * 60 * 5, // Cache for 5 minutes
  });

  const deleteMutation = useMutation({
    mutationFn: (journalistId: string) =>
      axios.delete(`/api/admin/ai-journalists/${journalistId}`),
    onSuccess: () => {
      toast.success("AI Journalist deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["aiJournalists"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete journalist.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingJournalist(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (journalist: IAIJournalist) => {
    setEditingJournalist(journalist);
    setIsModalOpen(true);
  };

  const handleDelete = (journalistId: string, journalistName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete AI Journalist "${journalistName}"? This action cannot be undone.`
      )
    ) {
      deleteMutation.mutate(journalistId);
    }
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading AI Journalists...</p>;
  if (error)
    return <p className="text-red-400">Failed to load AI Journalists.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <User size={28} /> Manage AI Journalists
        </h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Journalist</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Name</th>
              <th className="p-4">Description</th>
              <th className="p-4">Tone Prompt Preview</th>
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {journalists?.map((journalist) => (
              <tr key={journalist._id} className="border-t border-gray-700/50">
                <td className="p-4 font-medium">{journalist.name}</td>
                <td
                  className="p-4 text-brand-muted text-sm max-w-[200px] truncate"
                  title={journalist.description}
                >
                  {journalist.description || "N/A"}
                </td>
                <td
                  className="p-4 text-brand-muted text-sm max-w-[300px] truncate"
                  title={journalist.tonePrompt}
                >
                  {journalist.tonePrompt}
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      journalist.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {journalist.isActive ? "Active" : "Inactive"}
                  </span>
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <button
                    onClick={() => handleOpenEditModal(journalist)}
                    className="text-blue-400 hover:text-blue-300"
                    title="Edit Journalist"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() =>
                      handleDelete(journalist._id, journalist.name)
                    }
                    className="text-red-400 hover:text-red-300"
                    title="Delete Journalist"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {journalists?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No AI Journalists found. Click "New Journalist" to create one.
          </p>
        )}
      </div>

      <AIJournalistFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        journalist={editingJournalist}
      />
    </div>
  );
}


// ===== src/app/admin/auto-news/page.tsx =====

// src/app/admin/auto-news/page.tsx
"use client";

import { useState, useMemo, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  Newspaper,
  Settings,
  DownloadCloud,
  Sparkles,
  AlertCircle,
  RefreshCw,
  Trash2,
  ExternalLink,
  Copy,
  Loader2,
  Hourglass,
  CheckCircle,
  XCircle,
  User, // Added User icon for dropdown
} from "lucide-react";
import { format, parseISO } from "date-fns";
import Image from "next/image";
import Link from "next/link";
import Pagination from "@/components/Pagination";
import PredictionGenerationTab from "./PredictionGenerationTab"; // <-- NEW IMPORT

// Define interfaces for API responses (ensure these match your models/API)
interface IExternalNewsArticle {
  _id: string; // MongoDB's _id
  articleId: string; // ID from newsdata.io
  title: string;
  link: string;
  pubDate: string; // Will be ISO string, convert to Date
  imageUrl?: string | null;
  status: "fetched" | "processing" | "processed" | "skipped" | "error";
  processedPostId?: string; // MongoDB ObjectId as string
  createdAt: string;
  updatedAt: string;
}

interface ExternalNewsResponse {
  articles: IExternalNewsArticle[];
  totalCount: number;
  currentPage: number;
  perPage: number;
}

// --- Modified IAIPrompt for type field (UPDATED HERE) ---
interface IAIPrompt {
  _id: string;
  name: string;
  prompt: string;
  description?: string;
  type: "title" | "content" | "prediction_content"; // <-- Added prediction_content type
}

// Assuming IAIJournalist interface is defined
interface IAIJournalist {
  _id: string;
  name: string;
  description?: string;
  tonePrompt: string;
  isActive: boolean;
  createdAt: string; // ISO date string
  updatedAt: string; // ISO date string
}

// --- Fetcher functions ---
const fetchExternalNews = async (
  page: number,
  limit: number,
  statusFilter: string
): Promise<ExternalNewsResponse> => {
  const { data } = await axios.get(
    `/api/admin/external-news?limit=${limit}&skip=${
      (page - 1) * limit
    }&status=${statusFilter}`
  );
  return data;
};

// --- Updated fetchAIPrompt to optionally fetch by type ---
const fetchAIPrompt = async (
  name: string,
  type: "title" | "content" | "prediction_content" // Updated type for new prompt
): Promise<IAIPrompt> => {
  const { data } = await axios.get(
    `/api/admin/ai-prompt?name=${encodeURIComponent(name)}&type=${type}`
  );
  return data;
};

// Fetcher for AI Journalists (re-used by Prediction Tab)
const fetchAIJournalists = async (): Promise<IAIJournalist[]> => {
  const { data } = await axios.get("/api/admin/ai-journalists");
  return data;
};

// --- Define the fixed names for prompts ---
const TITLE_PROMPT_NAME = "AI Title Generation";
const CONTENT_PROMPT_NAME = "AI Content Generation";
const PREDICTION_PROMPT_NAME = "AI Prediction Content Generation"; // <-- NEW PROMPT NAME

export default function AdminAutoNewsPage() {
  const queryClient = useQueryClient();

  // --- New state for active tab ---
  const [activeTab, setActiveTab] = useState<
    "settings" | "external_news" | "prediction_generation"
  >("settings"); // Default to settings

  // --- State for News Fetching Form ---
  const [newsQuery, setNewsQuery] = useState("football OR soccer");
  const [newsLanguage, setNewsLanguage] = useState("en");
  const [newsCountry, setNewsCountry] = useState<string[]>(["gb", "us"]); // Default to UK and US
  const [newsCategory, setNewsCategory] = useState<string[]>(["sports"]); // Default to sports

  // --- State for AI Prompt Management ---
  const [titlePromptContent, setTitlePromptContent] = useState("");
  const [titlePromptDescription, setTitlePromptDescription] = useState("");
  const [isEditingTitlePrompt, setIsEditingTitlePrompt] = useState(false);

  const [contentPromptContent, setContentPromptContent] = useState("");
  const [contentPromptDescription, setContentPromptDescription] = useState("");
  const [isEditingContentPrompt, setIsEditingContentPrompt] = useState(false);

  // --- NEW: State for Prediction Prompt Management ---
  const [predictionPromptContent, setPredictionPromptContent] = useState("");
  const [predictionPromptDescription, setPredictionPromptDescription] =
    useState("");
  const [isEditingPredictionPrompt, setIsEditingPredictionPrompt] =
    useState(false);

  // --- State for External News List Pagination/Filters ---
  const [currentPage, setCurrentPage] = useState(1);
  const [articlesPerPage, setArticlesPerPage] = useState(10);
  const [statusFilter, setStatusFilter] = useState("fetched");

  // --- AI Journalist Selection (used by External News and Prediction Tabs) ---
  const [selectedJournalistId, setSelectedJournalistId] = useState<
    string | null
  >(null);

  // --- Track pending mutations for UI feedback (External News Tab) ---
  const [processingArticleId, setProcessingArticleId] = useState<string | null>(
    null
  );
  const [deletingArticleId, setDeletingArticleId] = useState<string | null>(
    null
  );

  // --- API Calls using TanStack Query ---

  // Query for external news articles (External News Tab)
  const {
    data: externalNewsData,
    isLoading: isLoadingNews,
    error: newsError,
    refetch: refetchExternalNews,
  } = useQuery<ExternalNewsResponse>({
    queryKey: ["externalNews", currentPage, articlesPerPage, statusFilter],
    queryFn: () =>
      fetchExternalNews(currentPage, articlesPerPage, statusFilter),
    staleTime: 1000 * 60,
    placeholderData: (previousData) => previousData,
    enabled: activeTab === "external_news", // Only fetch if this tab is active
  });

  // Query for AI Title Prompt (Settings Tab)
  const {
    data: titlePromptData,
    isLoading: isLoadingTitlePrompt,
    error: titlePromptError,
  } = useQuery<IAIPrompt>({
    queryKey: ["aiPrompt", TITLE_PROMPT_NAME, "title"],
    queryFn: () => fetchAIPrompt(TITLE_PROMPT_NAME, "title"),
    staleTime: 1000 * 60 * 5,
    enabled: activeTab === "settings", // Only fetch if this tab is active
  });

  // Query for AI Content Prompt (Settings Tab)
  const {
    data: contentPromptData,
    isLoading: isLoadingContentPrompt,
    error: contentPromptError,
  } = useQuery<IAIPrompt>({
    queryKey: ["aiPrompt", CONTENT_PROMPT_NAME, "content"],
    queryFn: () => fetchAIPrompt(CONTENT_PROMPT_NAME, "content"),
    staleTime: 1000 * 60 * 5,
    enabled: activeTab === "settings", // Only fetch if this tab is active
  });

  // --- NEW: Query for AI Prediction Content Prompt (Settings Tab) ---
  const {
    data: predictionPromptData,
    isLoading: isLoadingPredictionPrompt,
    error: predictionPromptError,
  } = useQuery<IAIPrompt>({
    queryKey: ["aiPrompt", PREDICTION_PROMPT_NAME, "prediction_content"],
    queryFn: () => fetchAIPrompt(PREDICTION_PROMPT_NAME, "prediction_content"),
    staleTime: 1000 * 60 * 5,
    enabled: activeTab === "settings", // Only fetch if this tab is active
  });

  // Query for AI Journalists (shared by External News and Prediction Tabs)
  const {
    data: journalists,
    isLoading: isLoadingJournalists,
    error: journalistsError,
  } = useQuery<IAIJournalist[]>({
    queryKey: ["aiJournalists"],
    queryFn: fetchAIJournalists,
    staleTime: 1000 * 60 * 5,
  });

  // Set initial selected journalist to the first active one, or null
  useEffect(() => {
    if (journalists && selectedJournalistId === null) {
      const firstActive = journalists.find((j) => j.isActive);
      if (firstActive) {
        setSelectedJournalistId(firstActive._id);
      }
    }
  }, [journalists, selectedJournalistId]);

  // Sync title prompt data to state
  useEffect(() => {
    if (titlePromptData) {
      setTitlePromptContent(titlePromptData.prompt);
      setTitlePromptDescription(titlePromptData.description || "");
    }
  }, [titlePromptData]);

  // Sync content prompt data to state
  useEffect(() => {
    if (contentPromptData) {
      setContentPromptContent(contentPromptData.prompt);
      setContentPromptDescription(contentPromptData.description || "");
    }
  }, [contentPromptData]);

  // --- NEW: Sync prediction prompt data to state ---
  useEffect(() => {
    if (predictionPromptData) {
      setPredictionPromptContent(predictionPromptData.prompt);
      setPredictionPromptDescription(predictionPromptData.description || "");
    }
  }, [predictionPromptData]);

  // --- Mutations ---

  // Mutation to fetch news from newsdata.io (External News Tab)
  const fetchNewsMutation = useMutation({
    mutationFn: (payload: {
      query: string;
      language: string;
      country: string[];
      category: string[];
    }) => axios.post("/api/admin/fetch-external-news", payload),
    onSuccess: (data) => {
      toast.success(`Fetched ${data.data.newArticlesCount} new articles.`);
      queryClient.invalidateQueries({ queryKey: ["externalNews"] });
      setCurrentPage(1);
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to fetch news.");
    },
  });

  // --- Mutations for separate prompts (Settings Tab) ---
  const updateTitlePromptMutation = useMutation({
    mutationFn: (payload: { prompt: string; description?: string }) =>
      axios.put(
        `/api/admin/ai-prompt?name=${encodeURIComponent(
          TITLE_PROMPT_NAME
        )}&type=title`,
        payload
      ),
    onSuccess: (data) => {
      toast.success("AI Title Prompt updated successfully!");
      setTitlePromptContent(data.data.prompt);
      setTitlePromptDescription(data.data.description || "");
      setIsEditingTitlePrompt(false);
      queryClient.invalidateQueries({
        queryKey: ["aiPrompt", TITLE_PROMPT_NAME, "title"],
      });
    },
    onError: (err: any) => {
      toast.error(
        err.response?.data?.error || "Failed to update title prompt."
      );
    },
  });

  const updateContentPromptMutation = useMutation({
    mutationFn: (payload: { prompt: string; description?: string }) =>
      axios.put(
        `/api/admin/ai-prompt?name=${encodeURIComponent(
          CONTENT_PROMPT_NAME
        )}&type=content`,
        payload
      ),
    onSuccess: (data) => {
      toast.success("AI Content Prompt updated successfully!");
      setContentPromptContent(data.data.prompt);
      setContentPromptDescription(data.data.description || "");
      setIsEditingContentPrompt(false);
      queryClient.invalidateQueries({
        queryKey: ["aiPrompt", CONTENT_PROMPT_NAME, "content"],
      });
    },
    onError: (err: any) => {
      toast.error(
        err.response?.data?.error || "Failed to update content prompt."
      );
    },
  });

  // --- NEW: Mutation for Prediction Content Prompt (Settings Tab) ---
  const updatePredictionPromptMutation = useMutation({
    mutationFn: (payload: { prompt: string; description?: string }) =>
      axios.put(
        `/api/admin/ai-prompt?name=${encodeURIComponent(
          PREDICTION_PROMPT_NAME
        )}&type=prediction_content`,
        payload
      ),
    onSuccess: (data) => {
      toast.success("AI Prediction Prompt updated successfully!");
      setPredictionPromptContent(data.data.prompt);
      setPredictionPromptDescription(data.data.description || "");
      setIsEditingPredictionPrompt(false);
      queryClient.invalidateQueries({
        queryKey: ["aiPrompt", PREDICTION_PROMPT_NAME, "prediction_content"],
      });
    },
    onError: (err: any) => {
      toast.error(
        err.response?.data?.error || "Failed to update prediction prompt."
      );
    },
  });

  // Mutation to process an external news article with AI (External News Tab)
  const processArticleMutation = useMutation({
    mutationFn: (payload: {
      articleId: string;
      sportCategory: string;
      journalistId?: string | null;
    }) => {
      setProcessingArticleId(payload.articleId);
      return axios.post("/api/admin/process-external-news", payload);
    },
    onSuccess: (data) => {
      toast.success(data.data.message || "Article processed successfully!");
      queryClient.invalidateQueries({ queryKey: ["externalNews"] });
      queryClient.invalidateQueries({ queryKey: ["adminPosts"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to process article.");
    },
    onSettled: () => {
      setProcessingArticleId(null);
    },
  });

  // Mutation to delete an external news article (External News Tab)
  const deleteArticleMutation = useMutation({
    mutationFn: (articleId: string) => {
      setDeletingArticleId(articleId);
      return axios.delete(`/api/admin/external-news?articleId=${articleId}`);
    },
    onSuccess: () => {
      toast.success("Article deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["externalNews"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete journalist.");
    },
    onSettled: () => {
      setDeletingArticleId(null);
    },
  });

  // --- Handlers ---
  const handleFetchNews = (e: React.FormEvent) => {
    e.preventDefault();
    fetchNewsMutation.mutate({
      query: newsQuery,
      language: newsLanguage,
      country: newsCountry,
      category: newsCategory,
    });
  };

  const handleUpdateTitlePrompt = (e: React.FormEvent) => {
    e.preventDefault();
    if (titlePromptContent.trim() === "") {
      toast.error("Title Prompt cannot be empty.");
      return;
    }
    updateTitlePromptMutation.mutate({
      prompt: titlePromptContent,
      description: titlePromptDescription,
    });
  };

  const handleUpdateContentPrompt = (e: React.FormEvent) => {
    e.preventDefault();
    if (contentPromptContent.trim() === "") {
      toast.error("Content Prompt cannot be empty.");
      return;
    }
    updateContentPromptMutation.mutate({
      prompt: contentPromptContent,
      description: contentPromptDescription,
    });
  };

  // --- NEW: Handle Update Prediction Prompt ---
  const handleUpdatePredictionPrompt = (e: React.FormEvent) => {
    e.preventDefault();
    if (predictionPromptContent.trim() === "") {
      toast.error("Prediction Prompt cannot be empty.");
      return;
    }
    updatePredictionPromptMutation.mutate({
      prompt: predictionPromptContent,
      description: predictionPromptDescription,
    });
  };

  const handleProcessArticle = (articleId: string) => {
    if (!selectedJournalistId) {
      toast.error("Please select an AI Journalist before processing.");
      return;
    }
    processArticleMutation.mutate({
      articleId,
      sportCategory: "football",
      journalistId: selectedJournalistId,
    });
  };

  const handleDeleteArticle = (articleId: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete this external article? This cannot be undone.`
      )
    ) {
      deleteArticleMutation.mutate(articleId);
    }
  };

  const copyPromptToClipboard = (promptText: string) => {
    if (promptText) {
      navigator.clipboard.writeText(promptText);
      toast.success("Prompt copied to clipboard!");
    }
  };

  const totalPages = externalNewsData
    ? Math.ceil(externalNewsData.totalCount / articlesPerPage)
    : 0;

  // Country and Category options (simplified for now, could be dynamic from an API)
  const availableCountries = [
    { code: "us", name: "United States" },
    { code: "gb", name: "United Kingdom" },
    { code: "tr", name: "Turkey" },
    { code: "fr", name: "France" },
    { code: "de", name: "Germany" },
    { code: "es", name: "Spain" },
    { code: "it", name: "Italy" },
    { code: "br", name: "Brazil" },
    { code: "ar", name: "Argentina" },
    { code: "mx", name: "Mexico" },
    { code: "ca", name: "Canada" },
  ];
  const availableCategories = [
    { code: "sports", name: "Sports" },
    { code: "business", name: "Business" },
    { code: "health", name: "Health" },
    { code: "technology", name: "Technology" },
    { code: "entertainment", name: "Entertainment" },
    { code: "science", name: "Science" },
    { code: "politics", name: "Politics" },
    { code: "world", name: "World" },
  ];

  const handleCountryChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const options = Array.from(
      e.target.selectedOptions,
      (option) => option.value
    );
    setNewsCountry(options);
  };

  const handleCategoryChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const options = Array.from(
      e.target.selectedOptions,
      (option) => option.value
    );
    setNewsCategory(options);
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Newspaper size={28} /> Automated News Engine
        </h1>
      </div>

      {/* Tab Navigation */}
      <div className="flex border-b border-gray-700 mb-8">
        <button
          onClick={() => setActiveTab("settings")}
          className={`px-6 py-3 text-lg font-semibold ${
            activeTab === "settings"
              ? "text-brand-purple border-b-2 border-brand-purple"
              : "text-brand-muted hover:text-white"
          }`}
        >
          <Settings className="inline-block mr-2" size={20} /> AI Settings
        </button>
        <button
          onClick={() => setActiveTab("external_news")}
          className={`px-6 py-3 text-lg font-semibold ${
            activeTab === "external_news"
              ? "text-brand-purple border-b-2 border-brand-purple"
              : "text-brand-muted hover:text-white"
          }`}
        >
          <DownloadCloud className="inline-block mr-2" size={20} /> External
          News Processing
        </button>
        <button
          onClick={() => setActiveTab("prediction_generation")}
          className={`px-6 py-3 text-lg font-semibold ${
            activeTab === "prediction_generation"
              ? "text-brand-purple border-b-2 border-brand-purple"
              : "text-brand-muted hover:text-white"
          }`}
        >
          <Sparkles className="inline-block mr-2" size={20} /> Prediction
          Generation
        </button>
      </div>

      {/* Tab Content */}
      {activeTab === "settings" && (
        <div className="space-y-8">
          {/* --- AI PROMPT MANAGEMENT SECTION --- */}
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
            <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
              <Settings size={24} /> AI Prompts Configuration
            </h2>

            {/* Title Prompt Subsection */}
            <div className="mb-8 border border-gray-700 rounded-lg p-4">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-xl font-semibold text-white">
                  Title Generation Prompt
                </h3>
                <div className="flex gap-2">
                  <button
                    onClick={() => copyPromptToClipboard(titlePromptContent)}
                    className="text-brand-light hover:text-white flex items-center gap-1 bg-gray-700 py-1.5 px-3 rounded-md text-sm"
                    disabled={
                      !titlePromptContent ||
                      updateTitlePromptMutation.isPending ||
                      isLoadingTitlePrompt
                    }
                  >
                    <Copy size={16} /> Copy
                  </button>
                  <button
                    onClick={() =>
                      setIsEditingTitlePrompt(!isEditingTitlePrompt)
                    }
                    className="text-brand-purple hover:text-brand-purple/80 flex items-center gap-1 bg-gray-700 py-1.5 px-3 rounded-md text-sm"
                    disabled={
                      isLoadingTitlePrompt ||
                      updateTitlePromptMutation.isPending
                    }
                  >
                    {isEditingTitlePrompt ? "Cancel" : "Edit"}
                  </button>
                </div>
              </div>
              {isLoadingTitlePrompt ? (
                <p className="text-brand-muted">Loading title prompt...</p>
              ) : titlePromptError ? (
                <p className="text-red-400">Error loading title prompt.</p>
              ) : (
                <form onSubmit={handleUpdateTitlePrompt} className="space-y-4">
                  <div>
                    <label
                      htmlFor="titlePromptContent"
                      className="block text-sm font-medium text-brand-light mb-1"
                    >
                      Prompt Content:
                    </label>
                    <textarea
                      id="titlePromptContent"
                      value={titlePromptContent}
                      onChange={(e) => setTitlePromptContent(e.target.value)}
                      className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
                      rows={8}
                      disabled={
                        !isEditingTitlePrompt ||
                        updateTitlePromptMutation.isPending
                      }
                      placeholder="Enter the AI title generation prompt. Explain how to create a unique, plain-text title."
                    />
                    <p className="text-xs text-brand-muted mt-1">
                      This prompt guides the AI in generating a unique,
                      plain-text article title.
                    </p>
                  </div>
                  <div>
                    <label
                      htmlFor="titlePromptDescription"
                      className="block text-sm font-medium text-brand-light mb-1"
                    >
                      Description (Optional):
                    </label>
                    <input
                      id="titlePromptDescription"
                      type="text"
                      value={titlePromptDescription}
                      onChange={(e) =>
                        setTitlePromptDescription(e.target.value)
                      }
                      className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                      disabled={
                        !isEditingTitlePrompt ||
                        updateTitlePromptMutation.isPending
                      }
                      placeholder="Describe the purpose of this title prompt (e.g., 'Aggressive SEO titles')"
                    />
                  </div>
                  {isEditingTitlePrompt && (
                    <div className="flex justify-end">
                      <button
                        type="submit"
                        className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                        disabled={updateTitlePromptMutation.isPending}
                      >
                        {updateTitlePromptMutation.isPending ? (
                          <Loader2 size={18} className="animate-spin" />
                        ) : (
                          <CheckCircle size={18} />
                        )}
                        {updateTitlePromptMutation.isPending
                          ? "Saving..."
                          : "Save Title Prompt"}
                      </button>
                    </div>
                  )}
                </form>
              )}
            </div>

            {/* Content Prompt Subsection */}
            <div className="mb-8 border border-gray-700 rounded-lg p-4">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-xl font-semibold text-white">
                  Content Generation Prompt
                </h3>
                <div className="flex gap-2">
                  <button
                    onClick={() => copyPromptToClipboard(contentPromptContent)}
                    className="text-brand-light hover:text-white flex items-center gap-1 bg-gray-700 py-1.5 px-3 rounded-md text-sm"
                    disabled={
                      !contentPromptContent ||
                      updateContentPromptMutation.isPending ||
                      isLoadingContentPrompt
                    }
                  >
                    <Copy size={16} /> Copy
                  </button>
                  <button
                    onClick={() =>
                      setIsEditingContentPrompt(!isEditingContentPrompt)
                    }
                    className="text-brand-purple hover:text-brand-purple/80 flex items-center gap-1 bg-gray-700 py-1.5 px-3 rounded-md text-sm"
                    disabled={
                      isLoadingContentPrompt ||
                      updateContentPromptMutation.isPending
                    }
                  >
                    {isEditingContentPrompt ? "Cancel" : "Edit"}
                  </button>
                </div>
              </div>
              {isLoadingContentPrompt ? (
                <p className="text-brand-muted">Loading content prompt...</p>
              ) : contentPromptError ? (
                <p className="text-red-400">Error loading content prompt.</p>
              ) : (
                <form
                  onSubmit={handleUpdateContentPrompt}
                  className="space-y-4"
                >
                  <div>
                    <label
                      htmlFor="contentPromptContent"
                      className="block text-sm font-medium text-brand-light mb-1"
                    >
                      Prompt Content:
                    </label>
                    <textarea
                      id="contentPromptContent"
                      value={contentPromptContent}
                      onChange={(e) => setContentPromptContent(e.target.value)}
                      className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
                      rows={8}
                      disabled={
                        !isEditingContentPrompt ||
                        updateContentPromptMutation.isPending
                      }
                      placeholder="Enter the AI content generation prompt. Explain how to create expanded, humanized HTML content."
                    />
                    <p className="text-xs text-brand-muted mt-1">
                      This prompt guides the AI in generating humanized HTML
                      article content.
                    </p>
                  </div>
                  <div>
                    <label
                      htmlFor="contentPromptDescription"
                      className="block text-sm font-medium text-brand-light mb-1"
                    >
                      Description (Optional):
                    </label>
                    <input
                      id="contentPromptDescription"
                      type="text"
                      value={contentPromptDescription}
                      onChange={(e) =>
                        setContentPromptDescription(e.target.value)
                      }
                      className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                      disabled={
                        !isEditingContentPrompt ||
                        updateContentPromptMutation.isPending
                      }
                      placeholder="Describe the purpose of this content prompt (e.g., 'Detailed analysis with examples')"
                    />
                  </div>
                  {isEditingContentPrompt && (
                    <div className="flex justify-end">
                      <button
                        type="submit"
                        className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                        disabled={updateContentPromptMutation.isPending}
                      >
                        {updateContentPromptMutation.isPending ? (
                          <Loader2 size={18} className="animate-spin" />
                        ) : (
                          <CheckCircle size={18} />
                        )}
                        {updateContentPromptMutation.isPending
                          ? "Saving..."
                          : "Save Content Prompt"}
                      </button>
                    </div>
                  )}
                </form>
              )}
            </div>

            {/* --- NEW: Prediction Prompt Subsection --- */}
            <div className="border border-gray-700 rounded-lg p-4">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-xl font-semibold text-white">
                  Prediction Content Prompt
                </h3>
                <div className="flex gap-2">
                  <button
                    onClick={() =>
                      copyPromptToClipboard(predictionPromptContent)
                    }
                    className="text-brand-light hover:text-white flex items-center gap-1 bg-gray-700 py-1.5 px-3 rounded-md text-sm"
                    disabled={
                      !predictionPromptContent ||
                      updatePredictionPromptMutation.isPending ||
                      isLoadingPredictionPrompt
                    }
                  >
                    <Copy size={16} /> Copy
                  </button>
                  <button
                    onClick={() =>
                      setIsEditingPredictionPrompt(!isEditingPredictionPrompt)
                    }
                    className="text-brand-purple hover:text-brand-purple/80 flex items-center gap-1 bg-gray-700 py-1.5 px-3 rounded-md text-sm"
                    disabled={
                      isLoadingPredictionPrompt ||
                      updatePredictionPromptMutation.isPending
                    }
                  >
                    {isEditingPredictionPrompt ? "Cancel" : "Edit"}
                  </button>
                </div>
              </div>
              {isLoadingPredictionPrompt ? (
                <p className="text-brand-muted">Loading prediction prompt...</p>
              ) : predictionPromptError ? (
                <p className="text-red-400">Error loading prediction prompt.</p>
              ) : (
                <form
                  onSubmit={handleUpdatePredictionPrompt}
                  className="space-y-4"
                >
                  <div>
                    <label
                      htmlFor="predictionPromptContent"
                      className="block text-sm font-medium text-brand-light mb-1"
                    >
                      Prompt Content:
                    </label>
                    <textarea
                      id="predictionPromptContent"
                      value={predictionPromptContent}
                      onChange={(e) =>
                        setPredictionPromptContent(e.target.value)
                      }
                      className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
                      rows={8}
                      disabled={
                        !isEditingPredictionPrompt ||
                        updatePredictionPromptMutation.isPending
                      }
                      placeholder="Enter the AI prediction generation prompt. Explain how to create a detailed match prediction based on provided data."
                    />
                    <p className="text-xs text-brand-muted mt-1">
                      This prompt guides the AI in generating a detailed match
                      prediction article based on fixture data, statistics, and
                      the predicted outcome.
                    </p>
                  </div>
                  <div>
                    <label
                      htmlFor="predictionPromptDescription"
                      className="block text-sm font-medium text-brand-light mb-1"
                    >
                      Description (Optional):
                    </label>
                    <input
                      id="predictionPromptDescription"
                      type="text"
                      value={predictionPromptDescription}
                      onChange={(e) =>
                        setPredictionPromptDescription(e.target.value)
                      }
                      className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                      disabled={
                        !isEditingPredictionPrompt ||
                        updatePredictionPromptMutation.isPending
                      }
                      placeholder="Describe the purpose of this prediction prompt (e.g., 'In-depth match preview and betting tips')"
                    />
                  </div>
                  {isEditingPredictionPrompt && (
                    <div className="flex justify-end">
                      <button
                        type="submit"
                        className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                        disabled={updatePredictionPromptMutation.isPending}
                      >
                        {updatePredictionPromptMutation.isPending ? (
                          <Loader2 size={18} className="animate-spin" />
                        ) : (
                          <CheckCircle size={18} />
                        )}
                        {updatePredictionPromptMutation.isPending
                          ? "Saving..."
                          : "Save Prediction Prompt"}
                      </button>
                    </div>
                  )}
                </form>
              )}
            </div>
          </div>
        </div>
      )}

      {activeTab === "external_news" && (
        <div className="space-y-8">
          {/* --- FETCH EXTERNAL NEWS SECTION --- */}
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl">
            <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
              <DownloadCloud size={24} /> Fetch News from Newsdata.io
            </h2>
            <form
              onSubmit={handleFetchNews}
              className="grid grid-cols-1 md:grid-cols-2 gap-4"
            >
              <div>
                <label
                  htmlFor="newsQuery"
                  className="block text-sm font-medium text-brand-light mb-1"
                >
                  Keywords (qInTitle):
                </label>
                <input
                  type="text"
                  id="newsQuery"
                  value={newsQuery}
                  onChange={(e) => setNewsQuery(e.target.value)}
                  className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                  placeholder="e.g., 'football OR soccer' (searches in title)"
                />
                <p className="text-xs text-brand-muted mt-1">
                  Keywords to search for in article titles. Use OR for multiple
                  terms.
                </p>
              </div>
              <div>
                <label
                  htmlFor="newsLanguage"
                  className="block text-sm font-medium text-brand-light mb-1"
                >
                  Language:
                </label>
                <select
                  id="newsLanguage"
                  value={newsLanguage}
                  onChange={(e) => setNewsLanguage(e.target.value)}
                  className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                >
                  <option value="en">English</option>
                  <option value="tr">Turkish</option>
                  {/* Add more languages as supported by newsdata.io */}
                </select>
              </div>
              <div>
                <label
                  htmlFor="newsCountry"
                  className="block text-sm font-medium text-brand-light mb-1"
                >
                  Countries (Multi-select):
                </label>
                <select
                  id="newsCountry"
                  multiple
                  value={newsCountry}
                  onChange={handleCountryChange}
                  className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple h-28"
                >
                  {availableCountries.map((c) => (
                    <option key={c.code} value={c.code}>
                      {c.name}
                    </option>
                  ))}
                </select>
                <p className="text-xs text-brand-muted mt-1">
                  Select one or more countries for news sources.
                </p>
              </div>
              <div>
                <label
                  htmlFor="newsCategory"
                  className="block text-sm font-medium text-brand-light mb-1"
                >
                  Categories (Multi-select):
                </label>
                <select
                  id="newsCategory"
                  multiple
                  value={newsCategory}
                  onChange={handleCategoryChange}
                  className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple h-28"
                >
                  {availableCategories.map((c) => (
                    <option key={c.code} value={c.code}>
                      {c.name}
                    </option>
                  ))}
                </select>
                <p className="text-xs text-brand-muted mt-1">
                  Select one or more categories for news sources.
                </p>
              </div>
              <div className="md:col-span-2 flex justify-end gap-3">
                <button
                  type="button"
                  onClick={() => refetchExternalNews()}
                  className="flex items-center gap-2 bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled={
                    isLoadingNews ||
                    fetchNewsMutation.isPending ||
                    processArticleMutation.isPending
                  }
                >
                  <RefreshCw
                    size={18}
                    className={isLoadingNews ? "animate-spin" : ""}
                  />
                  Refresh List
                </button>
                <button
                  type="submit"
                  className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled={fetchNewsMutation.isPending}
                >
                  {fetchNewsMutation.isPending ? (
                    <Loader2 size={20} className="animate-spin" />
                  ) : (
                    <DownloadCloud size={20} />
                  )}
                  {fetchNewsMutation.isPending
                    ? "Fetching..."
                    : "Fetch New Articles"}
                </button>
              </div>
            </form>
          </div>

          {/* --- EXTERNAL NEWS ARTICLES LIST --- */}
          <div className="bg-brand-secondary rounded-lg overflow-hidden shadow-xl">
            <div className="p-6">
              <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
                <Newspaper size={24} /> External News Articles
              </h2>
              <div className="flex items-center justify-between gap-4 mb-4">
                <div className="flex items-center gap-4">
                  <span className="text-brand-light text-sm">
                    Filter by Status:
                  </span>
                  <select
                    value={statusFilter}
                    onChange={(e) => {
                      setStatusFilter(e.target.value);
                      setCurrentPage(1);
                    }}
                    className="p-2 rounded bg-gray-700 text-white border border-gray-600 text-sm"
                  >
                    <option value="fetched">Fetched (Ready to Process)</option>
                    <option value="processed">Processed</option>
                    <option value="skipped">Skipped</option>
                    <option value="error">Error</option>
                    <option value="">All</option>
                  </select>
                </div>
                {/* --- AI Journalist Dropdown --- */}
                <div className="flex items-center gap-2">
                  <User size={18} className="text-brand-muted" />
                  <select
                    value={selectedJournalistId || ""}
                    onChange={(e) =>
                      setSelectedJournalistId(e.target.value || null)
                    }
                    className="p-2 rounded bg-gray-700 text-white border border-gray-600 text-sm"
                    disabled={isLoadingJournalists}
                  >
                    <option value="">
                      {isLoadingJournalists
                        ? "Loading Journalists..."
                        : "Select AI Journalist"}
                    </option>
                    {journalists
                      ?.filter((j) => j.isActive)
                      .map((j) => (
                        <option key={j._id} value={j._id}>
                          {j.name}
                        </option>
                      ))}
                  </select>
                </div>
                {/* End AI Journalist Dropdown */}
                <span className="text-brand-muted text-sm ml-auto">
                  Total Articles: {externalNewsData?.totalCount ?? 0}
                </span>
              </div>
            </div>

            <div className="overflow-x-auto">
              <table className="w-full text-left text-brand-light">
                <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
                  <tr>
                    <th className="p-4">Preview</th>
                    <th className="p-4">Title</th>
                    <th className="p-4">Source</th>
                    <th className="p-4">Published Date</th>
                    <th className="p-4">Status</th>
                    <th className="p-4">Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {isLoadingNews ? (
                    Array.from({ length: articlesPerPage }).map((_, i) => (
                      <tr
                        key={i}
                        className="border-t border-gray-700/50 animate-pulse"
                      >
                        <td className="p-4">
                          <div className="w-20 h-10 bg-gray-700 rounded"></div>
                        </td>
                        <td className="p-4">
                          <div className="h-4 bg-gray-700 rounded w-4/5"></div>
                        </td>
                        <td className="p-4">
                          <div className="h-4 bg-gray-700 rounded w-1/2"></div>
                        </td>
                        <td className="p-4">
                          <div className="h-4 bg-gray-700 rounded w-1/3"></div>
                        </td>
                        <td className="p-4 flex gap-2">
                          <div className="w-8 h-8 bg-gray-700 rounded-full"></div>
                          <div className="w-8 h-8 bg-gray-700 rounded-full"></div>
                        </td>
                      </tr>
                    ))
                  ) : externalNewsData?.articles?.length === 0 ? (
                    <tr>
                      <td
                        colSpan={6}
                        className="p-8 text-center text-brand-muted"
                      >
                        No external articles found with the current filter. Try
                        fetching new ones!
                      </td>
                    </tr>
                  ) : (
                    externalNewsData?.articles?.map((article) => (
                      <tr
                        key={article._id}
                        className={`border-t border-gray-700/50 transition-colors
                                ${
                                  processingArticleId === article.articleId ||
                                  deletingArticleId === article.articleId
                                    ? "bg-brand-dark/50 animate-pulse"
                                    : "hover:bg-gray-800"
                                }`}
                      >
                        <td className="p-4">
                          {article.imageUrl ? (
                            <Image
                              src={article.imageUrl}
                              alt={article.title}
                              width={80}
                              height={45}
                              objectFit="cover"
                              className="rounded-md"
                            />
                          ) : (
                            <div className="w-20 h-10 bg-gray-700 flex items-center justify-center text-xs text-brand-muted rounded-md">
                              No Image
                            </div>
                          )}
                        </td>
                        <td
                          className="p-4 font-medium max-w-xs overflow-hidden text-ellipsis whitespace-nowrap"
                          title={article.title}
                        >
                          {article.title}
                        </td>
                        <td className="p-4 text-brand-muted">
                          {article.link ? (
                            <a
                              href={article.link}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="hover:text-white flex items-center gap-1 text-sm"
                            >
                              {article.link.split("/")[2].replace("www.", "")}{" "}
                              <ExternalLink size={14} />
                            </a>
                          ) : (
                            "N/A"
                          )}
                        </td>
                        <td className="p-4 text-brand-muted text-sm">
                          {format(
                            parseISO(article.pubDate),
                            "dd MMM yyyy HH:mm"
                          )}
                        </td>
                        <td className="p-4">
                          <span
                            className={`px-2 py-1 text-xs font-semibold rounded-full min-w-[75px] inline-flex justify-center items-center gap-1
                          ${
                            article.status === "processed"
                              ? "bg-green-500/20 text-green-400"
                              : article.status === "fetched"
                              ? "bg-blue-500/20 text-blue-400"
                              : article.status === "skipped"
                              ? "bg-yellow-500/20 text-yellow-400"
                              : "bg-red-500/20 text-red-400"
                          }`}
                          >
                            {processingArticleId === article.articleId ? (
                              <Loader2 size={12} className="animate-spin" />
                            ) : deletingArticleId === article.articleId ? (
                              <Hourglass size={12} className="animate-spin" />
                            ) : article.status === "processed" ? (
                              <CheckCircle size={12} />
                            ) : article.status === "error" ? (
                              <XCircle size={12} />
                            ) : null}
                            {article.status.charAt(0).toUpperCase() +
                              article.status.slice(1)}
                          </span>
                        </td>
                        <td className="p-4 flex gap-2 items-center h-full">
                          <a
                            href={article.link}
                            target="_blank"
                            rel="noopener noreferrer"
                            className="text-brand-muted hover:text-white p-1 rounded-full bg-brand-dark"
                            title="View Original Article"
                          >
                            <ExternalLink size={18} />
                          </a>
                          {article.status === "fetched" && (
                            <button
                              onClick={() =>
                                handleProcessArticle(article.articleId)
                              }
                              className="text-brand-purple hover:text-brand-purple/80 p-1 rounded-full bg-brand-dark"
                              title="Process with AI"
                              disabled={
                                processArticleMutation.isPending ||
                                deletingArticleId === article.articleId ||
                                !selectedJournalistId
                              } // Disable if no journalist selected
                            >
                              {processingArticleId === article.articleId ? (
                                <Loader2 size={18} className="animate-spin" />
                              ) : (
                                <Sparkles size={18} />
                              )}
                            </button>
                          )}
                          {article.status === "processed" &&
                            article.processedPostId && (
                              <Link
                                href={`/admin/news/edit/${article.processedPostId}`}
                                className="text-blue-400 hover:text-blue-300 p-1 rounded-full bg-brand-dark"
                                title="View Processed Post"
                              >
                                <ExternalLink size={18} />
                              </Link>
                            )}
                          {(article.status === "error" ||
                            article.status === "skipped") && (
                            <button
                              onClick={() =>
                                handleProcessArticle(article.articleId)
                              } // Allow reprocessing
                              className="text-yellow-400 hover:text-yellow-300 p-1 rounded-full bg-brand-dark"
                              title="Retry Processing"
                              disabled={
                                processArticleMutation.isPending ||
                                deletingArticleId === article.articleId ||
                                !selectedJournalistId
                              } // Disable if no journalist selected
                            >
                              {processingArticleId === article.articleId ? (
                                <Loader2 size={18} className="animate-spin" />
                              ) : (
                                <RefreshCw size={18} />
                              )}
                            </button>
                          )}
                          <button
                            onClick={() =>
                              handleDeleteArticle(article.articleId)
                            }
                            className="text-red-400 hover:text-red-300 p-1 rounded-full bg-brand-dark"
                            title="Delete External Article"
                            disabled={
                              deleteArticleMutation.isPending ||
                              processingArticleId === article.articleId
                            }
                          >
                            {deletingArticleId === article.articleId ? (
                              <Loader2 size={18} className="animate-spin" />
                            ) : (
                              <Trash2 size={18} />
                            )}
                          </button>
                        </td>
                      </tr>
                    ))
                  )}
                </tbody>
              </table>
            </div>

            {externalNewsData && externalNewsData.articles.length > 0 && (
              <div className="p-6">
                <Pagination
                  currentPage={currentPage}
                  totalPages={totalPages}
                  onPageChange={setCurrentPage}
                />
              </div>
            )}
          </div>
        </div>
      )}

      {activeTab === "prediction_generation" && <PredictionGenerationTab />}
    </div>
  );
}


// ===== src/app/admin/auto-news/PredictionGenerationTab.tsx =====

// src/app/admin/auto-news/PredictionGenerationTab.tsx
"use client";

import { useEffect, useState, useMemo } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  Calendar,
  Sparkles,
  RefreshCw,
  Loader2,
  User,
  Info,
  CheckCircle,
  ExternalLink,
  Eye,
} from "lucide-react";
import { format, parseISO } from "date-fns";
import Pagination from "@/components/Pagination";

// --- Interfaces (duplicated for now, ideally moved to a shared types/ folder) ---
interface IAIJournalist {
  _id: string;
  name: string;
  description?: string;
  tonePrompt: string;
  isActive: boolean;
  createdAt: string; // ISO date string
  updatedAt: string; // ISO date string
}

// Simplified fixture type for display purposes, will expand as needed for API calls
interface UpcomingFixture {
  fixture: {
    id: number;
    date: string; // ISO date string
    timezone: string;
    status: {
      long: string;
      short: string;
      elapsed: number | null;
    };
  };
  league: {
    id: number;
    name: string;
    logo: string;
  };
  teams: {
    home: { id: number; name: string; logo: string };
    away: { id: number; name: string; logo: string };
  };
  // Add a property to track if a prediction post has already been created for this fixture
  processedPostId?: string; // MongoDB ObjectId as string, refers to the Post
}

interface UpcomingFixturesResponse {
  fixtures: UpcomingFixture[];
  totalCount: number;
  currentPage: number;
  perPage: number;
}

// --- Fetcher functions ---

// Fetcher for AI Journalists (re-used)
const fetchAIJournalists = async (): Promise<IAIJournalist[]> => {
  const { data } = await axios.get("/api/admin/ai-journalists");
  return data;
};

// New fetcher for upcoming fixtures for prediction
const fetchUpcomingFixturesForPrediction = async (
  page: number,
  limit: number
): Promise<UpcomingFixturesResponse> => {
  const { data } = await axios.get(
    `/api/admin/upcoming-fixtures-for-prediction?limit=${limit}&skip=${
      (page - 1) * limit
    }`
  );
  return data;
};

const ITEMS_PER_PAGE = 10;

export default function PredictionGenerationTab() {
  const queryClient = useQueryClient();
  const [currentPage, setCurrentPage] = useState(1);
  const [selectedJournalistId, setSelectedJournalistId] = useState<
    string | null
  >(null);

  // Track pending mutations for UI feedback
  const [processingFixtureId, setProcessingFixtureId] = useState<number | null>(
    null
  );

  // Query for AI Journalists
  const {
    data: journalists,
    isLoading: isLoadingJournalists,
    error: journalistsError,
  } = useQuery<IAIJournalist[]>({
    queryKey: ["aiJournalists"],
    queryFn: fetchAIJournalists,
    staleTime: 1000 * 60 * 5,
  });

  // Query for Upcoming Fixtures
  const {
    data: fixturesData,
    isLoading: isLoadingFixtures,
    error: fixturesError,
    refetch: refetchFixtures,
  } = useQuery<UpcomingFixturesResponse>({
    queryKey: ["upcomingFixturesForPrediction", currentPage, ITEMS_PER_PAGE],
    queryFn: () =>
      fetchUpcomingFixturesForPrediction(currentPage, ITEMS_PER_PAGE),
    staleTime: 1000 * 60, // Cache for 1 minute
    placeholderData: (previousData) => previousData,
  });

  // Set initial selected journalist to the first active one, or null
  useEffect(() => {
    if (journalists && selectedJournalistId === null) {
      const firstActive = journalists.find((j) => j.isActive);
      if (firstActive) {
        setSelectedJournalistId(firstActive._id);
      }
    }
  }, [journalists, selectedJournalistId]);

  // Mutation to generate prediction news
  const generatePredictionNewsMutation = useMutation({
    mutationFn: (payload: {
      fixtureId: number;
      journalistId: string;
      sportCategory: string;
    }) => axios.post("/api/admin/generate-prediction-news", payload),
    onSuccess: (data) => {
      toast.success(data.data.message || "Prediction news generated!");
      queryClient.invalidateQueries({
        queryKey: ["upcomingFixturesForPrediction"],
      }); // Refetch to update status
      queryClient.invalidateQueries({ queryKey: ["adminPosts"] }); // Invalidate admin news list
    },
    onError: (err: any) => {
      toast.error(
        err.response?.data?.error || "Failed to generate prediction news."
      );
    },
    onSettled: (data, error, variables) => {
      // Find the specific fixture and update its status client-side temporarily
      // while query invalidation is pending
      queryClient.setQueryData(
        ["upcomingFixturesForPrediction", currentPage, ITEMS_PER_PAGE],
        (oldData: UpcomingFixturesResponse | undefined) => {
          if (!oldData) return oldData;
          return {
            ...oldData,
            fixtures: oldData.fixtures.map((f) =>
              f.fixture.id === variables.fixtureId
                ? {
                    ...f,
                    processedPostId: data?.data.postId || f.processedPostId,
                  } // Mark as processed
                : f
            ),
          };
        }
      );
      setProcessingFixtureId(null);
    },
  });

  const handleGeneratePrediction = (fixture: UpcomingFixture) => {
    if (!selectedJournalistId) {
      toast.error("Please select an AI Journalist before generating.");
      return;
    }
    setProcessingFixtureId(fixture.fixture.id);
    generatePredictionNewsMutation.mutate({
      fixtureId: fixture.fixture.id,
      journalistId: selectedJournalistId,
      sportCategory: "football", // For now, predictions are assumed football
    });
  };

  const totalPages = fixturesData
    ? Math.ceil(fixturesData.totalCount / ITEMS_PER_PAGE)
    : 0;

  return (
    <div className="bg-brand-secondary p-6 rounded-lg mb-8 shadow-xl">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2">
          <Sparkles size={24} /> Generate Prediction News
        </h2>
        <button
          onClick={() => refetchFixtures()}
          className="flex items-center gap-2 bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed"
          disabled={
            isLoadingFixtures || generatePredictionNewsMutation.isPending
          }
        >
          <RefreshCw
            size={18}
            className={isLoadingFixtures ? "animate-spin" : ""}
          />
          Refresh Matches
        </button>
      </div>

      <div className="flex items-center justify-between gap-4 mb-4">
        {/* --- AI Journalist Dropdown --- */}
        <div className="flex items-center gap-2">
          <User size={18} className="text-brand-muted" />
          <select
            value={selectedJournalistId || ""}
            onChange={(e) => setSelectedJournalistId(e.target.value || null)}
            className="p-2 rounded bg-gray-700 text-white border border-gray-600 text-sm"
            disabled={
              isLoadingJournalists || generatePredictionNewsMutation.isPending
            }
          >
            <option value="">
              {isLoadingJournalists
                ? "Loading Journalists..."
                : "Select AI Journalist"}
            </option>
            {journalists
              ?.filter((j) => j.isActive)
              .map((j) => (
                <option key={j._id} value={j._id}>
                  {j.name}
                </option>
              ))}
          </select>
        </div>
        {/* End AI Journalist Dropdown */}
        <span className="text-brand-muted text-sm ml-auto">
          Total Upcoming Matches: {fixturesData?.totalCount ?? 0}
        </span>
      </div>

      <div className="overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Match</th>
              <th className="p-4">League</th>
              <th className="p-4">Date & Time</th>
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {isLoadingFixtures ? (
              Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
                <tr
                  key={i}
                  className="border-t border-gray-700/50 animate-pulse"
                >
                  <td className="p-4">
                    <div className="h-4 bg-gray-700 rounded w-full"></div>
                  </td>
                  <td className="p-4">
                    <div className="h-4 bg-gray-700 rounded w-3/4"></div>
                  </td>
                  <td className="p-4">
                    <div className="h-4 bg-gray-700 rounded w-1/2"></div>
                  </td>
                  <td className="p-4">
                    <div className="h-4 bg-gray-700 rounded w-1/3"></div>
                  </td>
                  <td className="p-4">
                    <div className="w-10 h-10 bg-gray-700 rounded-full"></div>
                  </td>
                </tr>
              ))
            ) : fixturesData?.fixtures?.length === 0 ? (
              <tr>
                <td colSpan={5} className="p-8 text-center text-brand-muted">
                  No upcoming matches found for prediction.
                </td>
              </tr>
            ) : (
              fixturesData?.fixtures?.map((fixture) => (
                <tr
                  key={fixture.fixture.id}
                  className={`border-t border-gray-700/50 transition-colors 
                                ${
                                  processingFixtureId === fixture.fixture.id
                                    ? "bg-brand-dark/50 animate-pulse"
                                    : fixture.processedPostId
                                    ? "bg-green-900/20"
                                    : "hover:bg-gray-800"
                                }`}
                >
                  <td className="p-4 font-medium flex items-center gap-3">
                    <img
                      src={fixture.teams.home.logo}
                      alt={fixture.teams.home.name}
                      className="w-6 h-6"
                    />
                    {fixture.teams.home.name} vs {fixture.teams.away.name}
                    <img
                      src={fixture.teams.away.logo}
                      alt={fixture.teams.away.name}
                      className="w-6 h-6"
                    />
                  </td>
                  <td className="p-4 text-brand-muted text-sm flex items-center gap-2">
                    <img
                      src={fixture.league.logo}
                      alt={fixture.league.name}
                      className="w-4 h-4"
                    />
                    {fixture.league.name}
                  </td>
                  <td className="p-4 text-brand-muted text-sm">
                    {format(
                      parseISO(fixture.fixture.date),
                      "dd MMM yyyy HH:mm"
                    )}
                  </td>
                  <td className="p-4">
                    <span
                      className={`px-2 py-1 text-xs font-semibold rounded-full min-w-[75px] inline-flex justify-center items-center gap-1
                          ${
                            fixture.processedPostId
                              ? "bg-green-500/20 text-green-400"
                              : "bg-blue-500/20 text-blue-400"
                          }`}
                    >
                      {processingFixtureId === fixture.fixture.id ? (
                        <Loader2 size={12} className="animate-spin" />
                      ) : fixture.processedPostId ? (
                        <CheckCircle size={12} />
                      ) : (
                        <Info size={12} />
                      )}
                      {processingFixtureId === fixture.fixture.id
                        ? "Generating..."
                        : fixture.processedPostId
                        ? "Generated"
                        : "Not Generated"}
                    </span>
                  </td>
                  <td className="p-4 flex gap-2 items-center h-full">
                    {fixture.processedPostId ? (
                      <a
                        href={`/admin/news/edit/${fixture.processedPostId}`}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-blue-400 hover:text-blue-300 p-1 rounded-full bg-brand-dark"
                        title="View Generated Post"
                      >
                        <Eye size={18} />
                      </a>
                    ) : (
                      <button
                        onClick={() => handleGeneratePrediction(fixture)}
                        className="text-brand-purple hover:text-brand-purple/80 p-1 rounded-full bg-brand-dark"
                        title="Generate Prediction News"
                        disabled={
                          generatePredictionNewsMutation.isPending ||
                          !selectedJournalistId
                        }
                      >
                        <Sparkles size={18} />
                      </button>
                    )}
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>

      {fixturesData && fixturesData.fixtures.length > 0 && (
        <div className="p-6">
          <Pagination
            currentPage={currentPage}
            totalPages={totalPages}
            onPageChange={setCurrentPage}
          />
        </div>
      )}
    </div>
  );
}


// ===== src/app/admin/banners/page.tsx =====

// src/app/admin/banners/page.tsx
"use client";

import { useMemo, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { PlusCircle, Edit, Trash2 } from "lucide-react";
import Image from "next/image";
import { IBanner } from "@/models/Banner";
import BannerFormModal from "@/components/admin/BannerFormModal";
import { AD_SLOTS } from "@/config/adSlots";
import { proxyImageUrl } from "@/lib/image-proxy";

const fetchBanners = async (): Promise<IBanner[]> => {
  const { data } = await axios.get("/api/banners");
  return data;
};

export default function AdminBannersPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingBanner, setEditingBanner] = useState<IBanner | null>(null);

  // Create a lookup map for user-friendly location names
  const locationNameMap = useMemo(
    () => new Map(AD_SLOTS.map((s) => [s.id, s.name])),
    []
  );

  const {
    data: banners,
    isLoading,
    error,
  } = useQuery<IBanner[]>({
    queryKey: ["adminBanners"],
    queryFn: fetchBanners,
  });

  const deleteMutation = useMutation({
    mutationFn: (bannerId: string) => axios.delete(`/api/banners/${bannerId}`),
    onSuccess: () => {
      toast.success("Banner deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["adminBanners"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete banner.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingBanner(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (banner: IBanner) => {
    setEditingBanner(banner);
    setIsModalOpen(true);
  };

  const handleDelete = (bannerId: string) => {
    if (
      window.confirm(
        "Are you sure you want to delete this banner? This action cannot be undone."
      )
    ) {
      deleteMutation.mutate(bannerId);
    }
  };

  if (isLoading) return <p className="text-brand-muted">Loading banners...</p>;
  if (error) return <p className="text-red-400">Failed to load banners.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Manage Ad Banners</h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Banner</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Preview</th>
              <th className="p-4">Title</th>
              <th className="p-4">Location</th> {/* <-- NEW COLUMN */}
              <th className="p-4">Status</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {banners?.map((banner) => (
              <tr
                key={banner._id as string}
                className="border-t border-gray-700/50"
              >
                <td className="p-4">
                  {/* --- THE FIX IS HERE --- */}
                  <Image
                    src={banner.imageUrl}
                    alt={banner.title}
                    width={120}
                    height={60}
                    // Add the objectFit="contain" property here as well.
                    // This was the missing piece from my previous implementation.
                    objectFit="contain"
                    className="rounded-md bg-gray-700"
                  />
                </td>
                <td className="p-4 font-medium">{banner.title}</td>
                <td className="p-4 font-semibold text-brand-light">
                  {locationNameMap.get(banner.location) || banner.location}
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      banner.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {banner.isActive ? "Active" : "Inactive"}
                  </span>
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <button
                    onClick={() => handleOpenEditModal(banner)}
                    className="text-blue-400 hover:text-blue-300"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() => handleDelete(banner._id as string)}
                    className="text-red-400 hover:text-red-300"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {banners?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No banners found. Click "New Banner" to create one.
          </p>
        )}
      </div>

      <BannerFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        banner={editingBanner}
      />
    </div>
  );
}


// ===== src/app/admin/casino-partners/page.tsx =====

// ===== src\app\admin\casino-partners\page.tsx (CORRECTED) =====
"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  PlusCircle,
  Edit,
  Trash2,
  Crown,
  Link as LinkIcon,
  ExternalLink,
  Loader2,
  CheckCircle,
  XCircle,
} from "lucide-react";
import Image from "next/image";

interface ICasinoPartner {
  _id: string;
  name: string;
  logoUrl: string;
  redirectUrl: string;
  description?: string;
  isFeatured: boolean;
  isActive: boolean;
  order: number;
  createdAt: string;
  updatedAt: string;
}

interface CasinoPartnerFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  partner?: ICasinoPartner | null;
}

const CasinoPartnerFormModal: React.FC<CasinoPartnerFormModalProps> = ({
  isOpen,
  onClose,
  partner,
}) => {
  const queryClient = useQueryClient();
  const [name, setName] = useState(partner?.name || "");
  const [logoUrl, setLogoUrl] = useState(partner?.logoUrl || "");
  const [redirectUrl, setRedirectUrl] = useState(partner?.redirectUrl || "");
  const [description, setDescription] = useState(partner?.description || "");
  const [isFeatured, setIsFeatured] = useState(partner?.isFeatured ?? false);
  const [isActive, setIsActive] = useState(partner?.isActive ?? true);
  const [order, setOrder] = useState(partner?.order ?? 0);

  useEffect(() => {
    if (partner) {
      setName(partner.name);
      setLogoUrl(partner.logoUrl);
      setRedirectUrl(partner.redirectUrl);
      setDescription(partner.description || "");
      setIsFeatured(partner.isFeatured);
      setIsActive(partner.isActive);
      setOrder(partner.order);
    } else {
      setName("");
      setLogoUrl("");
      setRedirectUrl("");
      setDescription("");
      setIsFeatured(false);
      setIsActive(true);
      setOrder(0);
    }
  }, [partner]);

  const createMutation = useMutation({
    mutationFn: (newPartner: Partial<ICasinoPartner>) =>
      axios.post("/api/admin/casino-partners", newPartner),
    onSuccess: () => {
      toast.success("Casino Partner created successfully!");
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersAdmin"] });
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersPublic"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to create partner.");
    },
  });

  const updateMutation = useMutation({
    mutationFn: (updatedPartner: Partial<ICasinoPartner>) =>
      axios.put(`/api/admin/casino-partners/${partner?._id}`, updatedPartner),
    onSuccess: () => {
      toast.success("Casino Partner updated successfully!");
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersAdmin"] });
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersPublic"] });
      onClose();
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to update partner.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !logoUrl.trim() || !redirectUrl.trim()) {
      toast.error("Name, Logo URL, and Redirect URL are required.");
      return;
    }

    const payload = {
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured,
      isActive,
      order: Number(order),
    };

    if (partner) {
      updateMutation.mutate(payload);
    } else {
      createMutation.mutate(payload);
    }
  };

  const isPending = createMutation.isPending || updateMutation.isPending;

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg shadow-xl w-full max-w-2xl overflow-hidden">
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {partner ? "Edit Casino Partner" : "Create New Casino Partner"}
          </h2>
          <button
            onClick={onClose}
            className="text-brand-muted hover:text-white"
          >
            <XCircle size={24} />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6 space-y-5">
          <div>
            <label
              htmlFor="name"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Partner Name
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
          </div>
          <div>
            <label
              htmlFor="logoUrl"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Logo URL
            </label>
            {/* ===== THE FIX IS HERE ===== */}
            <input
              id="logoUrl"
              type="url" // Changed from "url" to "text" to allow relative paths
              value={logoUrl}
              onChange={(e) => setLogoUrl(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
            {logoUrl && (
              <div className="mt-2 text-center">
                <Image
                  src={logoUrl}
                  alt="Logo Preview"
                  width={80}
                  height={40}
                  objectFit="contain"
                  className="rounded-md bg-gray-800 p-1"
                  // Next/Image handles both relative and absolute URLs correctly
                />
              </div>
            )}
          </div>
          <div>
            <label
              htmlFor="redirectUrl"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Redirect URL (Affiliate Link)
            </label>
            <input
              id="redirectUrl"
              type="url"
              value={redirectUrl}
              onChange={(e) => setRedirectUrl(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              required
              disabled={isPending}
            />
            <p className="text-xs text-brand-muted mt-1">
              This is the link users will be redirected to.
            </p>
          </div>
          <div>
            <label
              htmlFor="description"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Description (Optional)
            </label>
            <textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
              rows={3}
              disabled={isPending}
              placeholder="A short internal description of the partner."
            />
          </div>
          <div className="flex flex-col sm:flex-row sm:items-center sm:gap-4 space-y-3 sm:space-y-0">
            <div className="flex items-center">
              <input
                id="isFeatured"
                type="checkbox"
                checked={isFeatured}
                onChange={(e) => setIsFeatured(e.target.checked)}
                className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
                disabled={isPending}
              />
              <label
                htmlFor="isFeatured"
                className="ml-2 text-sm font-medium text-brand-light"
              >
                Featured (Prominent Styling)
              </label>
            </div>
            <div className="flex items-center">
              <input
                id="isActive"
                type="checkbox"
                checked={isActive}
                onChange={(e) => setIsActive(e.target.checked)}
                className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple"
                disabled={isPending}
              />
              <label
                htmlFor="isActive"
                className="ml-2 text-sm font-medium text-brand-light"
              >
                Active (Display on site)
              </label>
            </div>
            <div className="flex-grow">
              <label
                htmlFor="order"
                className="block text-sm font-medium text-brand-light mb-1 sm:mb-0"
              >
                Order
              </label>
              <input
                id="order"
                type="number"
                value={order}
                onChange={(e) => setOrder(Number(e.target.value))}
                className="w-20 p-2 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
                disabled={isPending}
                min="0"
              />
              <p className="text-xs text-brand-muted mt-1">
                Lower number = higher priority.
              </p>
            </div>
          </div>

          <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50"
              disabled={isPending}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={isPending}
            >
              {isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {isPending
                ? partner
                  ? "Updating..."
                  : "Creating..."
                : partner
                ? "Save Changes"
                : "Create Partner"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

// --- Main Casino Partners Page Component ---
export default function AdminCasinoPartnersPage() {
  const queryClient = useQueryClient();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingPartner, setEditingPartner] = useState<ICasinoPartner | null>(
    null
  );

  const {
    data: partners,
    isLoading,
    error,
  } = useQuery<ICasinoPartner[]>({
    queryKey: ["casinoPartnersAdmin"],
    queryFn: async () => {
      const { data } = await axios.get("/api/admin/casino-partners");
      return data;
    },
    staleTime: 1000 * 60 * 5,
  });

  const deleteMutation = useMutation({
    mutationFn: (partnerId: string) =>
      axios.delete(`/api/admin/casino-partners/${partnerId}`),
    onSuccess: () => {
      toast.success("Casino Partner deleted successfully!");
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersAdmin"] });
      queryClient.invalidateQueries({ queryKey: ["casinoPartnersPublic"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete partner.");
    },
  });

  const handleOpenCreateModal = () => {
    setEditingPartner(null);
    setIsModalOpen(true);
  };

  const handleOpenEditModal = (partner: ICasinoPartner) => {
    setEditingPartner(partner);
    setIsModalOpen(true);
  };

  const handleDelete = (partnerId: string, partnerName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete Casino Partner "${partnerName}"? This action cannot be undone.`
      )
    ) {
      deleteMutation.mutate(partnerId);
    }
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading Casino Partners...</p>;
  if (error)
    return <p className="text-red-400">Failed to load Casino Partners.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <Crown size={28} /> Manage Casino Partners
        </h1>
        <button
          onClick={handleOpenCreateModal}
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
        >
          <PlusCircle size={20} />
          <span>New Partner</span>
        </button>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-x-auto">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Logo</th>
              <th className="p-4">Name</th>
              <th className="p-4">Featured</th>
              <th className="p-4">Active</th>
              <th className="p-4">Order</th>
              <th className="p-4">Description</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {partners?.map((partner) => (
              <tr key={partner._id} className="border-t border-gray-700/50">
                <td className="p-4">
                  {partner.logoUrl && (
                    <Image
                      src={partner.logoUrl}
                      alt={partner.name}
                      width={60}
                      height={30}
                      objectFit="contain"
                      className="rounded-md bg-gray-700 p-1"
                    />
                  )}
                </td>
                <td className="p-4 font-medium">{partner.name}</td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      partner.isFeatured
                        ? "bg-yellow-500/20 text-yellow-400"
                        : "bg-gray-600/20 text-gray-400"
                    }`}
                  >
                    {partner.isFeatured ? "Yes" : "No"}
                  </span>
                </td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      partner.isActive
                        ? "bg-green-500/20 text-green-400"
                        : "bg-red-500/20 text-red-400"
                    }`}
                  >
                    {partner.isActive ? "Yes" : "No"}
                  </span>
                </td>
                <td className="p-4 text-brand-muted">{partner.order}</td>
                <td
                  className="p-4 text-brand-muted text-sm max-w-[200px] truncate"
                  title={partner.description}
                >
                  {partner.description || "N/A"}
                </td>
                <td className="p-4 flex gap-3 items-center h-full">
                  <a
                    href={partner.redirectUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-brand-muted hover:text-white"
                    title="Go to Partner Site"
                  >
                    <ExternalLink size={18} />
                  </a>
                  <button
                    onClick={() => handleOpenEditModal(partner)}
                    className="text-blue-400 hover:text-blue-300"
                    title="Edit Partner"
                  >
                    <Edit size={18} />
                  </button>
                  <button
                    onClick={() => handleDelete(partner._id, partner.name)}
                    className="text-red-400 hover:text-red-300"
                    title="Delete Partner"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {partners?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No Casino Partners found. Click "New Partner" to create one.
          </p>
        )}
      </div>

      <CasinoPartnerFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        partner={editingPartner}
      />
    </div>
  );
}


// ===== src/app/admin/dashboard/page.tsx =====

"use client"
import { useTranslation } from '@/hooks/useTranslation';

// This can be a simple server component for now
export default function AdminDashboardPage() {
  const { t } = useTranslation();

  return (
    <div>
      <h1 className="text-3xl font-bold text-white mb-4">{t('admin_dashboard')}</h1>
      <p className="text-brand-muted">{t('welcome_to_admin_area')}</p>
      <div className="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6">
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t('manage_users')}</h3>
          <p className="text-sm text-brand-muted mt-2">{t('view_and_edit_user_roles')}</p>
        </div>
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t('manage_matches')}</h3>
          <p className="text-sm text-brand-muted mt-2">{t('update_match_details')}</p>
        </div>
        <div className="p-6 bg-brand-secondary rounded-lg">
          <h3 className="font-bold text-white">{t('view_analytics')}</h3>
          <p className="text-sm text-brand-muted mt-2">{t('check_site_traffic')}</p>
        </div>
      </div>
    </div>
  );
}

// ===== src/app/admin/file-manager/page.tsx =====

// src/app/admin/file-manager/page.tsx
"use client";

import { useState, useRef, useEffect } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import {
  UploadCloud,
  CheckCircle,
  XCircle,
  Loader2,
  Link as LinkIcon,
  FileText,
  Download,
  Copy,
  Trash2,
  RefreshCw,
} from "lucide-react"; // Add Trash2
import Image from "next/image";

// Type for a simplified uploaded file representation
interface UploadedFile {
  name: string; // Original file name (or name used on S3) - this is the S3 Key
  url: string; // Public URL
  type: string; // Mime type
  size: number; // Size in bytes
}

// Fetcher function for listing files from S3
const fetchUploadedFiles = async (): Promise<UploadedFile[]> => {
  const { data } = await axios.get("/api/upload"); // Call the new GET endpoint
  return data;
};

export default function AdminFileManagerPage() {
  const queryClient = useQueryClient();
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const [downloadUrl, setDownloadUrl] = useState("");
  const [downloadFileName, setDownloadFileName] = useState("");

  console.log("process.env.NEXT_PUBLIC_R2_PUBLIC_BUCKET_URL");

  console.log(process.env.NEXT_PUBLIC_R2_PUBLIC_BUCKET_URL);

  const {
    data: existingFiles,
    isLoading: isLoadingFiles,
    error: filesError,
    refetch: refetchFiles,
  } = useQuery<UploadedFile[]>({
    queryKey: ["uploadedFiles"],
    queryFn: fetchUploadedFiles,
    staleTime: 1000 * 60 * 5,
  });

  const [currentUploadedFiles, setCurrentUploadedFiles] = useState<
    UploadedFile[]
  >([]);

  useEffect(() => {
    if (existingFiles) {
      setCurrentUploadedFiles(existingFiles);
    }
  }, [existingFiles]);

  const uploadMutation = useMutation({
    mutationFn: (formData: FormData) => axios.post("/api/upload", formData),
    onSuccess: (data) => {
      toast.success("File uploaded successfully!");
      setCurrentUploadedFiles((prev) => [
        {
          name: data.data.name || selectedFile?.name || "Unknown File",
          url: data.data.url,
          type:
            data.data.type || selectedFile?.type || "application/octet-stream",
          size: data.data.size || selectedFile?.size || 0,
        },
        ...prev.filter((f) => f.url !== data.data.url),
      ]);
      setSelectedFile(null);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
      queryClient.invalidateQueries({ queryKey: ["uploadedFiles"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to upload file.");
      setSelectedFile(null);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    },
  });

  const downloadFromUrlMutation = useMutation({
    mutationFn: (payload: { url: string; fileName?: string }) =>
      axios.post("/api/admin/file-manager/download-from-url", payload),
    onSuccess: (data) => {
      toast.success("File downloaded from URL and uploaded!");
      setCurrentUploadedFiles((prev) => [
        {
          name: data.data.name,
          url: data.data.url,
          type: data.data.type,
          size: data.data.size,
        },
        ...prev.filter((f) => f.url !== data.data.url),
      ]);
      setDownloadUrl("");
      setDownloadFileName("");
      queryClient.invalidateQueries({ queryKey: ["uploadedFiles"] });
    },
    onError: (err: any) => {
      toast.error(
        err.response?.data?.error || "Failed to download file from URL."
      );
    },
  });

  // --- NEW: Delete mutation ---
  const deleteFileMutation = useMutation({
    mutationFn: (fileKey: string) => axios.delete(`/api/upload?key=${fileKey}`),
    onSuccess: (_, fileKey) => {
      toast.success("File deleted successfully!");
      // Optimistically update the list
      setCurrentUploadedFiles((prev) => prev.filter((f) => f.name !== fileKey));
      queryClient.invalidateQueries({ queryKey: ["uploadedFiles"] });
    },
    onError: (err: any) => {
      toast.error(err.response?.data?.error || "Failed to delete file.");
    },
  });

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setSelectedFile(file);
    } else {
      setSelectedFile(null);
    }
  };

  const handleUpload = (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedFile) {
      toast.error("Please select a file to upload.");
      return;
    }
    const formData = new FormData();
    formData.append("file", selectedFile);
    uploadMutation.mutate(formData);
  };

  const handleDownloadFromUrl = (e: React.FormEvent) => {
    e.preventDefault();
    if (!downloadUrl.trim()) {
      toast.error("Please enter a URL.");
      return;
    }
    downloadFromUrlMutation.mutate({
      url: downloadUrl,
      fileName: downloadFileName.trim() || undefined,
    });
  };

  const handleDeleteFile = (fileKey: string, fileName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete "${fileName}"? This action cannot be undone.`
      )
    ) {
      deleteFileMutation.mutate(fileKey);
    }
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
    toast.success("URL copied to clipboard!");
  };

  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  };

  const isUploading =
    uploadMutation.isPending || downloadFromUrlMutation.isPending;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white flex items-center gap-2">
          <FileText size={28} /> File Manager
        </h1>
      </div>

      {/* File Upload Section */}
      <div className="bg-brand-secondary p-6 rounded-lg mb-8 shadow-xl">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
          <UploadCloud size={24} /> Upload New File
        </h2>
        <form onSubmit={handleUpload} className="space-y-4">
          <div>
            <label
              htmlFor="file-upload"
              className="block text-sm font-medium text-brand-light mb-2"
            >
              Select File
            </label>
            <input
              id="file-upload"
              type="file"
              ref={fileInputRef}
              onChange={handleFileChange}
              className="w-full text-brand-light bg-gray-700 border border-gray-600 rounded-lg p-3 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-brand-purple file:text-white hover:file:opacity-90 cursor-pointer"
              disabled={isUploading}
            />
            {selectedFile && (
              <p className="mt-2 text-sm text-brand-muted">
                Selected: {selectedFile.name} (
                {formatFileSize(selectedFile.size)})
              </p>
            )}
          </div>
          <div className="flex justify-end">
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={!selectedFile || isUploading}
            >
              {uploadMutation.isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <CheckCircle size={18} />
              )}
              {uploadMutation.isPending ? "Uploading..." : "Upload File"}
            </button>
          </div>
        </form>
      </div>

      {/* Download from URL Section */}
      <div className="bg-brand-secondary p-6 rounded-lg mb-8 shadow-xl">
        <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
          <Download size={24} /> Download from URL
        </h2>
        <form onSubmit={handleDownloadFromUrl} className="space-y-4">
          <div>
            <label
              htmlFor="download-url"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              File URL
            </label>
            <input
              id="download-url"
              type="url"
              value={downloadUrl}
              onChange={(e) => setDownloadUrl(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              placeholder="e.g., https://example.com/image.jpg"
              required
              disabled={isUploading}
            />
          </div>
          <div>
            <label
              htmlFor="download-filename"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Optional File Name (on S3)
            </label>
            <input
              id="download-filename"
              type="text"
              value={downloadFileName}
              onChange={(e) => setDownloadFileName(e.target.value)}
              className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              placeholder="e.g., my-custom-image (extension will be added automatically)"
              disabled={isUploading}
            />
          </div>
          <div className="flex justify-end">
            <button
              type="submit"
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
              disabled={!downloadUrl.trim() || isUploading}
            >
              {downloadFromUrlMutation.isPending ? (
                <Loader2 size={18} className="animate-spin" />
              ) : (
                <Download size={18} />
              )}
              {downloadFromUrlMutation.isPending
                ? "Downloading..."
                : "Download & Upload"}
            </button>
          </div>
        </form>
      </div>

      {/* Uploaded Files List */}
      <div className="bg-brand-secondary rounded-lg overflow-hidden shadow-xl">
        <div className="p-6">
          <h2 className="text-2xl font-bold text-white flex items-center gap-2 mb-4">
            <LinkIcon size={24} /> Uploaded Files
            <button
              onClick={() => refetchFiles()}
              className="ml-auto text-brand-muted hover:text-white flex items-center gap-1 text-sm"
              disabled={isLoadingFiles || deleteFileMutation.isPending}
            >
              <RefreshCw
                size={16}
                className={isLoadingFiles ? "animate-spin" : ""}
              />{" "}
              Refresh
            </button>
          </h2>
        </div>

        {isLoadingFiles ? (
          <p className="text-center p-8 text-brand-muted">
            Loading files from S3...
          </p>
        ) : filesError ? (
          <p className="text-center p-8 text-red-400">
            Failed to load files from S3: {filesError.message}
          </p>
        ) : currentUploadedFiles.length === 0 ? (
          <p className="text-center p-8 text-brand-muted">
            No files uploaded yet.
          </p>
        ) : (
          <div className="overflow-x-auto">
            <table className="w-full text-left text-brand-light">
              <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
                <tr>
                  <th className="p-4">Preview</th>
                  <th className="p-4">File Name</th>
                  <th className="p-4">Type</th>
                  <th className="p-4">Size</th>
                  <th className="p-4">Public URL</th>
                  <th className="p-4">Actions</th>
                </tr>
              </thead>
              <tbody>
                {currentUploadedFiles.map(
                  (
                    file // Removed 'index' as key, using file.url
                  ) => (
                    <tr key={file.url} className="border-t border-gray-700/50">
                      <td className="p-4">
                        {file.type.startsWith("image/") ? (
                          <Image
                            src={file.url}
                            alt={file.name}
                            width={80}
                            height={45}
                            objectFit="contain"
                            className="rounded-md bg-gray-700"
                          />
                        ) : (
                          <div className="w-20 h-10 bg-gray-700 flex items-center justify-center text-xs text-brand-muted rounded-md">
                            File
                          </div>
                        )}
                      </td>
                      <td
                        className="p-4 font-medium max-w-xs truncate"
                        title={file.name}
                      >
                        {file.name}
                      </td>
                      <td className="p-4 text-brand-muted text-sm">
                        {file.type.split("/")[1] || file.type}
                      </td>
                      <td className="p-4 text-brand-muted text-sm">
                        {formatFileSize(file.size)}
                      </td>
                      <td className="p-4 max-w-sm truncate">
                        <a
                          href={file.url}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="text-blue-400 hover:underline text-sm"
                          title={file.url}
                        >
                          {file.url}
                        </a>
                      </td>
                      <td className="p-4 flex gap-2 items-center">
                        <button
                          onClick={() => copyToClipboard(file.url)}
                          className="text-brand-purple hover:text-brand-purple/80 p-1 rounded-full bg-brand-dark"
                          title="Copy URL"
                        >
                          <Copy size={18} />
                        </button>
                        <button
                          onClick={() => handleDeleteFile(file.name, file.name)} // Pass file.name (which is the S3 Key) for deletion
                          className="text-red-400 hover:text-red-300 p-1 rounded-full bg-brand-dark"
                          title="Delete File"
                          disabled={
                            deleteFileMutation.isPending &&
                            deleteFileMutation.variables === file.name
                          } // Disable if this specific file is pending deletion
                        >
                          {deleteFileMutation.isPending &&
                          deleteFileMutation.variables === file.name ? (
                            <Loader2 size={18} className="animate-spin" />
                          ) : (
                            <Trash2 size={18} />
                          )}
                        </button>
                      </td>
                    </tr>
                  )
                )}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}


// ===== src/app/admin/layout.tsx =====

// src/app/admin/layout.tsx

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { redirect } from "next/navigation";
import AdminSidebar from "@/components/admin/AdminSidebar";
import { LanguageProvider } from "@/context/LanguageContext";

export default async function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await getServerSession(authOptions);

  // 1. UNCOMMENT THIS BLOCK
  if (!session) {
    // Redirect to the login page with an error message indicating forbidden access
    redirect("/login?error=Forbidden");
  }

  // 2. If user is an admin, render the layout...
  return (
     <LanguageProvider>
    <div className="flex min-h-screen">
      <AdminSidebar />
      <main className="flex-1 p-8 bg-brand-dark">
        {children}
      </main>
    </div>
    </LanguageProvider>
  );
}

// ===== src/app/admin/news/create/page.tsx =====

// src/app/admin/news/create/page.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useMutation } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import Link from "@/components/StyledLink";
import Image from "next/image";
import { UploadCloud, XCircle } from "lucide-react";

import RichTextEditor from "@/components/admin/RichTextEditor";
import { PostCategory } from "@/models/Post"; // Import PostCategory type

// Define available categories for the UI
const availableCategories: { id: PostCategory; label: string }[] = [
  { id: "football", label: "Football News" },
  { id: "basketball", label: "Basketball News" },
  { id: "tennis", label: "Tennis News" },
  { id: "general", label: "General Sports News" },
  { id: "prediction", label: "Prediction" },
  { id: "match_reports", label: "Match Reports" },
];

export default function CreateNewsPostPage() {
  const router = useRouter();
  // --- STATE FOR NEW FIELDS ---
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");
  const [status, setStatus] = useState<"draft" | "published">("draft");
  const [metaTitle, setMetaTitle] = useState("");
  const [metaDescription, setMetaDescription] = useState("");
  const [featuredImage, setFeaturedImage] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [imageTitle, setImageTitle] = useState("");
  const [imageAltText, setImageAltText] = useState("");
  // --- MODIFIED: State for multiple categories ---
  const [selectedCategories, setSelectedCategories] = useState<PostCategory[]>([
    "general",
  ]);

  // --- MODIFIED: Handler for checkbox changes ---
  const handleCategoryChange = (category: PostCategory) => {
    setSelectedCategories((prev) => {
      const isSelected = prev.includes(category);
      if (isSelected) {
        // If it's already selected, remove it, but ensure at least one category remains.
        const newCategories = prev.filter((c) => c !== category);
        return newCategories.length > 0 ? newCategories : prev; // Prevent removing the last category
      } else {
        // If not selected, add it.
        return [...prev, category];
      }
    });
  };

  // --- IMAGE UPLOAD HANDLER ---
  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setIsUploading(true);
    const formData = new FormData();
    formData.append("file", file);
    formData.append("uploadType", "newsFeaturedImage"); // Indicate type for specific processing if needed

    try {
      const { data } = await axios.post("/api/upload", formData);
      setFeaturedImage(data.url);
      toast.success("Image uploaded!");
    } catch (error) {
      toast.error("Image upload failed.");
    } finally {
      setIsUploading(false);
    }
  };

  // --- MUTATION TO CREATE POST (NOW ACCEPTS CATEGORY ARRAY) ---
  const createPostMutation = useMutation({
    mutationFn: (newPost: {
      title: string;
      content: string;
      status: string;
      metaTitle?: string;
      metaDescription?: string;
      featuredImage?: string | null;
      featuredImageTitle?: string;
      featuredImageAltText?: string;
      sport: PostCategory[]; // Expect an array of categories
    }) => {
      return axios.post("/api/posts", newPost);
    },
    onSuccess: () => {
      toast.success("Post created successfully!");
      router.push("/admin/news");
      router.refresh();
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.error || "Failed to create post.");
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!title.trim() || !content.trim()) {
      toast.error("Title and content cannot be empty.");
      return;
    }
    createPostMutation.mutate({
      title,
      content,
      status,
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle: imageTitle,
      featuredImageAltText: imageAltText,
      sport: selectedCategories, // Pass the array of selected categories
    });
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Create New Post</h1>
      </div>

      <form
        onSubmit={handleSubmit}
        className="bg-brand-secondary p-6 rounded-lg space-y-6"
      >
        {/* --- FEATURED IMAGE SECTION (UNCHANGED) --- */}
        <div className="p-4 border border-gray-600 rounded-lg">
          <label className="block text-sm font-medium text-brand-light mb-2">
            Featured Image
          </label>
          <div className="mt-2 flex justify-center rounded-lg border border-dashed border-gray-600 px-6 py-10">
            {featuredImage ? (
              <div className="relative group w-full h-64">
                <Image
                  src={featuredImage}
                  alt={imageAltText || "Featured preview"}
                  layout="fill"
                  objectFit="contain"
                />
                <button
                  type="button"
                  onClick={() => setFeaturedImage(null)}
                  className="absolute top-2 right-2 bg-red-600 rounded-full p-1 text-white opacity-0 group-hover:opacity-100 transition-opacity"
                >
                  <XCircle size={20} />
                </button>
              </div>
            ) : (
              <div className="text-center">
                <UploadCloud className="mx-auto h-12 w-12 text-gray-500" />
                <div className="mt-4 flex text-sm leading-6 text-gray-400">
                  <label
                    htmlFor="file-upload"
                    className="relative cursor-pointer rounded-md font-semibold text-brand-purple focus-within:outline-none focus-within:ring-2 focus-within:ring-brand-purple focus-within:ring-offset-2 focus-within:ring-offset-brand-dark hover:text-brand-purple/80"
                  >
                    <span>
                      {isUploading ? "Uploading..." : "Upload a file"}
                    </span>
                    <input
                      id="file-upload"
                      name="file-upload"
                      type="file"
                      className="sr-only"
                      onChange={handleImageUpload}
                      disabled={isUploading}
                      accept="image/*"
                    />
                  </label>
                  <p className="pl-1">or drag and drop</p>
                </div>
                <p className="text-xs leading-5 text-gray-500">
                  PNG, JPG, GIF up to 10MB
                </p>
              </div>
            )}
          </div>
        </div>

        {featuredImage && (
          <div className="mt-4 space-y-4">
            <div>
              <label
                htmlFor="imageTitle"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                Image Title (Tooltip)
              </label>
              <input
                id="imageTitle"
                type="text"
                value={imageTitle}
                onChange={(e) => setImageTitle(e.target.value)}
                placeholder="e.g., Team celebrating a goal"
                className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
            </div>
            <div>
              <label
                htmlFor="imageAltText"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                Image Alt Text (Accessibility & SEO)
              </label>
              <input
                id="imageAltText"
                type="text"
                value={imageAltText}
                onChange={(e) => setImageAltText(e.target.value)}
                placeholder="e.g., Player in red jersey kicking a football"
                className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
              <p className="text-xs text-brand-muted mt-1">
                Describe the image for screen readers and search engines.
              </p>
            </div>
          </div>
        )}

        {/* Title Field (UNCHANGED) */}
        <div>
          <label
            htmlFor="title"
            className="block text-sm font-medium text-brand-light mb-2"
          >
            Title
          </label>
          <input
            id="title"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            required
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
        </div>

        {/* Content Field (UNCHANGED) */}
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">
            Content
          </label>
          <RichTextEditor value={content} onChange={setContent} />
        </div>

        {/* --- SEO & META FIELDS SECTION (UNCHANGED) --- */}
        <div className="space-y-4 p-4 border border-gray-600 rounded-lg">
          <h3 className="text-lg font-semibold text-white">SEO Settings</h3>
          <div>
            <label
              htmlFor="metaTitle"
              className="block text-sm font-medium text-brand-light mb-2"
            >
              Meta Title
            </label>
            <input
              id="metaTitle"
              type="text"
              value={metaTitle}
              onChange={(e) => setMetaTitle(e.target.value)}
              placeholder="e.g., Ultimate Guide to Sunday's Match"
              className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
            <p className="text-xs text-brand-muted mt-1">
              Recommended: 50-60 characters.
            </p>
          </div>
          <div>
            <label
              htmlFor="metaDescription"
              className="block text-sm font-medium text-brand-light mb-2"
            >
              Meta Description
            </label>
            <textarea
              id="metaDescription"
              rows={3}
              value={metaDescription}
              onChange={(e) => setMetaDescription(e.target.value)}
              placeholder="A brief summary for search engines..."
              className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
            <p className="text-xs text-brand-muted mt-1">
              Recommended: 150-160 characters.
            </p>
          </div>
        </div>

        {/* Status Field (UNCHANGED) */}
        <div>
          <label
            htmlFor="status"
            className="block text-sm font-medium text-brand-light mb-2"
          >
            Status
          </label>
          <select
            id="status"
            value={status}
            onChange={(e) => setStatus(e.target.value as "draft" | "published")}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          >
            <option value="draft">Draft</option>
            <option value="published">Published</option>
          </select>
        </div>

        {/* --- MODIFIED: Content Category - Now Checkboxes --- */}
        <div className="p-4 border border-gray-600 rounded-lg">
          <label className="block text-sm font-medium text-brand-light mb-3">
            Content Categories
          </label>
          <div className="grid grid-cols-2 sm:grid-cols-3 gap-4">
            {availableCategories.map((category) => (
              <div key={category.id} className="flex items-center">
                <input
                  id={`category-${category.id}`}
                  type="checkbox"
                  checked={selectedCategories.includes(category.id)}
                  onChange={() => handleCategoryChange(category.id)}
                  className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple focus:ring-offset-brand-secondary"
                />
                <label
                  htmlFor={`category-${category.id}`}
                  className="ml-3 text-sm font-medium text-brand-light"
                >
                  {category.label}
                </label>
              </div>
            ))}
          </div>
          <p className="text-xs text-brand-muted mt-3">
            Select one or more relevant categories for this post.
          </p>
        </div>

        {/* Action Buttons (UNCHANGED) */}
        <div className="flex justify-end gap-4 pt-4 border-t border-gray-600">
          <Link
            href="/admin/news"
            className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
          >
            Cancel
          </Link>
          <button
            type="submit"
            disabled={createPostMutation.isPending || isUploading}
            className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {createPostMutation.isPending ? "Saving..." : "Save Post"}
          </button>
        </div>
      </form>
    </div>
  );
}


// ===== src/app/admin/news/edit/[postId]/page.tsx =====

// src/app/admin/news/edit/[postId]/page.tsx
"use client";

import { useState, useEffect } from "react";
import { useRouter, useParams } from "next/navigation";
import { useQuery, useMutation } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import Link from "@/components/StyledLink";
import Image from "next/image";
import { UploadCloud, XCircle, Loader2, CheckCircle } from "lucide-react";

import RichTextEditor from "@/components/admin/RichTextEditor";
import { IPost, PostCategory } from "@/models/Post";

// Define available categories for the UI, consistent with the create page
const availableCategories: { id: PostCategory; label: string }[] = [
  { id: "football", label: "Football News" },
  { id: "basketball", label: "Basketball News" },
  { id: "tennis", label: "Tennis News" },
  { id: "general", label: "General Sports News" },
  { id: "prediction", label: "Prediction" },
  { id: "match_reports", label: "Match Reports" },
];

// Fetcher function for a single post
const fetchPost = async (postId: string): Promise<IPost> => {
  const { data } = await axios.get(`/api/posts/${postId}`);
  return data;
};

export default function EditNewsPostPage() {
  const router = useRouter();
  const params = useParams();
  const postId = params.postId as string;

  // --- STATE MANAGEMENT ---
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");
  const [status, setStatus] = useState<"draft" | "published">("draft");
  const [metaTitle, setMetaTitle] = useState("");
  const [metaDescription, setMetaDescription] = useState("");
  const [featuredImage, setFeaturedImage] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [imageTitle, setImageTitle] = useState("");
  const [imageAltText, setImageAltText] = useState("");
  // --- MODIFIED: State for multiple categories ---
  const [selectedCategories, setSelectedCategories] = useState<PostCategory[]>(
    []
  );

  // Fetch the existing post data
  const {
    data: postData,
    isLoading,
    isError,
  } = useQuery<IPost>({
    queryKey: ["post", postId],
    queryFn: () => fetchPost(postId),
    enabled: !!postId,
  });

  // Pre-fill the form once data is fetched
  useEffect(() => {
    if (postData) {
      setTitle(postData.title);
      setContent(postData.content);
      setStatus(postData.status);
      setMetaTitle(postData.metaTitle || "");
      setMetaDescription(postData.metaDescription || "");
      setFeaturedImage(postData.featuredImage || null);
      setImageTitle(postData.featuredImageTitle || "");
      setImageAltText(postData.featuredImageAltText || "");
      // --- MODIFIED: Ensure `sport` is always an array ---
      setSelectedCategories(
        Array.isArray(postData.sport) && postData.sport.length > 0
          ? postData.sport
          : ["general"]
      );
    }
  }, [postData]);

  // --- MODIFIED: Handler for checkbox changes ---
  const handleCategoryChange = (category: PostCategory) => {
    setSelectedCategories((prev) => {
      const isSelected = prev.includes(category);
      if (isSelected) {
        const newCategories = prev.filter((c) => c !== category);
        return newCategories.length > 0 ? newCategories : prev;
      } else {
        return [...prev, category];
      }
    });
  };

  // --- IMAGE UPLOAD HANDLER ---
  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setIsUploading(true);
    const formData = new FormData();
    formData.append("file", file);
    formData.append("uploadType", "newsFeaturedImage");

    try {
      const { data } = await axios.post("/api/upload", formData);
      setFeaturedImage(data.url);
      toast.success("Image uploaded!");
    } catch (error) {
      toast.error("Image upload failed.");
    } finally {
      setIsUploading(false);
    }
  };

  // Mutation to update the post
  const updatePostMutation = useMutation({
    mutationFn: (updatedPost: Partial<IPost>) => {
      return axios.put(`/api/posts/${postId}`, updatedPost);
    },
    onSuccess: () => {
      toast.success("Post updated successfully!");
      router.push("/admin/news");
      router.refresh();
    },
    onError: (error: any) => {
      const errorMessage =
        error.response?.data?.error || "Failed to update post.";
      toast.error(errorMessage);
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!title.trim() || !content.trim()) {
      toast.error("Title and content cannot be empty.");
      return;
    }
    updatePostMutation.mutate({
      title,
      content,
      status,
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle: imageTitle,
      featuredImageAltText: imageAltText,
      sport: selectedCategories, // Pass the array of selected categories
    });
  };

  if (isLoading)
    return <p className="text-brand-muted">Loading post data...</p>;
  if (isError) return <p className="text-red-400">Failed to load post data.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Edit Post</h1>
        <Link
          href="/admin/news"
          className="text-sm text-brand-muted hover:text-white"
        >
          ← Back to News List
        </Link>
      </div>

      <form
        onSubmit={handleSubmit}
        className="bg-brand-secondary p-6 rounded-lg space-y-6"
      >
        {/* --- FEATURED IMAGE SECTION (UNCHANGED) --- */}
        <div className="p-4 border border-gray-600 rounded-lg">
          <label className="block text-sm font-medium text-brand-light mb-2">
            Featured Image
          </label>
          <div className="mt-2 flex justify-center rounded-lg border border-dashed border-gray-600 px-6 py-10">
            {featuredImage ? (
              <div className="relative group w-full h-64">
                <Image
                  src={featuredImage}
                  alt={imageAltText || "Featured preview"}
                  layout="fill"
                  objectFit="contain"
                />
                <button
                  type="button"
                  onClick={() => setFeaturedImage(null)}
                  className="absolute top-2 right-2 bg-red-600 rounded-full p-1 text-white opacity-0 group-hover:opacity-100 transition-opacity"
                >
                  <XCircle size={20} />
                </button>
              </div>
            ) : (
              <div className="text-center">
                <UploadCloud className="mx-auto h-12 w-12 text-gray-500" />
                <div className="mt-4 flex text-sm leading-6 text-gray-400">
                  <label
                    htmlFor="file-upload"
                    className="relative cursor-pointer rounded-md font-semibold text-brand-purple focus-within:outline-none focus-within:ring-2 focus-within:ring-brand-purple focus-within:ring-offset-2 focus-within:ring-offset-brand-dark hover:text-brand-purple/80"
                  >
                    <span>
                      {isUploading ? "Uploading..." : "Upload a file"}
                    </span>
                    <input
                      id="file-upload"
                      name="file-upload"
                      type="file"
                      className="sr-only"
                      onChange={handleImageUpload}
                      disabled={isUploading}
                      accept="image/*"
                    />
                  </label>
                  <p className="pl-1">or drag and drop</p>
                </div>
                <p className="text-xs leading-5 text-gray-500">
                  PNG, JPG, GIF up to 10MB
                </p>
              </div>
            )}
          </div>
        </div>

        {featuredImage && (
          <div className="mt-4 space-y-4">
            <div>
              <label
                htmlFor="imageTitle"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                Image Title (Tooltip)
              </label>
              <input
                id="imageTitle"
                type="text"
                value={imageTitle}
                onChange={(e) => setImageTitle(e.target.value)}
                placeholder="e.g., Team celebrating a goal"
                className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
            </div>
            <div>
              <label
                htmlFor="imageAltText"
                className="block text-sm font-medium text-brand-light mb-2"
              >
                Image Alt Text (Accessibility & SEO)
              </label>
              <input
                id="imageAltText"
                type="text"
                value={imageAltText}
                onChange={(e) => setImageAltText(e.target.value)}
                placeholder="e.g., Player in red jersey kicking a football"
                className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
              <p className="text-xs text-brand-muted mt-1">
                Describe the image for screen readers and search engines.
              </p>
            </div>
          </div>
        )}

        {/* Title Field (UNCHANGED) */}
        <div>
          <label
            htmlFor="title"
            className="block text-sm font-medium text-brand-light mb-2"
          >
            Title
          </label>
          <input
            id="title"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            required
          />
        </div>

        {/* Content Field (UNCHANGED) */}
        <div>
          <label className="block text-sm font-medium text-brand-light mb-2">
            Content
          </label>
          {content && <RichTextEditor value={content} onChange={setContent} />}
        </div>

        {/* SEO & META FIELDS SECTION (UNCHANGED) */}
        <div className="space-y-4 p-4 border border-gray-600 rounded-lg">
          <h3 className="text-lg font-semibold text-white">SEO Settings</h3>
          <div>
            <label
              htmlFor="metaTitle"
              className="block text-sm font-medium text-brand-light mb-2"
            >
              Meta Title
            </label>
            <input
              id="metaTitle"
              type="text"
              value={metaTitle}
              onChange={(e) => setMetaTitle(e.target.value)}
              placeholder="e.g., Ultimate Guide to Sunday's Match"
              className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
          </div>
          <div>
            <label
              htmlFor="metaDescription"
              className="block text-sm font-medium text-brand-light mb-2"
            >
              Meta Description
            </label>
            <textarea
              id="metaDescription"
              rows={3}
              value={metaDescription}
              onChange={(e) => setMetaDescription(e.target.value)}
              placeholder="A brief summary for search engines..."
              className="w-full p-3 rounded bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
          </div>
        </div>

        {/* Status Field (UNCHANGED) */}
        <div>
          <label
            htmlFor="status"
            className="block text-sm font-medium text-brand-light mb-2"
          >
            Status
          </label>
          <select
            id="status"
            value={status}
            onChange={(e) => setStatus(e.target.value as "draft" | "published")}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          >
            <option value="draft">Draft</option>
            <option value="published">Published</option>
          </select>
        </div>

        {/* --- MODIFIED: Content Category - Now Checkboxes --- */}
        <div className="p-4 border border-gray-600 rounded-lg">
          <label className="block text-sm font-medium text-brand-light mb-3">
            Content Categories
          </label>
          <div className="grid grid-cols-2 sm:grid-cols-3 gap-4">
            {availableCategories.map((category) => (
              <div key={category.id} className="flex items-center">
                <input
                  id={`category-${category.id}`}
                  type="checkbox"
                  checked={selectedCategories.includes(category.id)}
                  onChange={() => handleCategoryChange(category.id)}
                  className="w-4 h-4 text-brand-purple bg-gray-700 border-gray-600 rounded focus:ring-brand-purple focus:ring-offset-brand-secondary"
                />
                <label
                  htmlFor={`category-${category.id}`}
                  className="ml-3 text-sm font-medium text-brand-light"
                >
                  {category.label}
                </label>
              </div>
            ))}
          </div>
          <p className="text-xs text-brand-muted mt-3">
            Select one or more relevant categories for this post.
          </p>
        </div>

        {/* Action Buttons */}
        <div className="flex justify-end gap-4">
          <Link
            href="/admin/news"
            className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 transition-opacity"
          >
            Cancel
          </Link>
          <button
            type="submit"
            disabled={updatePostMutation.isPending || isUploading}
            className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 transition-opacity disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
          >
            {updatePostMutation.isPending ? (
              <Loader2 size={18} className="animate-spin" />
            ) : (
              <CheckCircle size={18} />
            )}
            {updatePostMutation.isPending ? "Saving..." : "Save Changes"}
          </button>
        </div>
      </form>
    </div>
  );
}


// ===== src/app/admin/news/page.tsx =====

"use client";

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import Link from "@/components/StyledLink";
import { PlusCircle, Edit, Trash2, Lightbulb } from "lucide-react";
import { format } from "date-fns";
import { IPost } from "@/models/Post";
import toast from "react-hot-toast";
import Image from "next/image"; // <-- NEW IMPORT

// Fetcher function
const fetchPosts = async (): Promise<IPost[]> => {
  const { data } = await axios.get("/api/posts");
  return data;
};

export default function AdminNewsPage() {
  const queryClient = useQueryClient();

  const {
    data: posts,
    isLoading,
    error,
  } = useQuery<IPost[]>({
    queryKey: ["adminPosts"],
    queryFn: fetchPosts,
  });

  const deleteMutation = useMutation({
    mutationFn: (postId: string) => axios.delete(`/api/posts/${postId}`),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["adminPosts"] });
      // BEFORE: alert('Post deleted!');
      toast.success("Post deleted successfully!"); //
    },
    onError: (error: any) => {
      // BEFORE: alert('Error deleting post.');
      const message = error.response?.data?.message || "Error deleting post.";
      toast.error(message); //
    },
  });

  const handleDelete = (postId: string) => {
    if (window.confirm("Are you sure you want to delete this post?")) {
      deleteMutation.mutate(postId);
    }
  };

  if (isLoading) return <p className="text-brand-muted">Loading posts...</p>;
  if (error) return <p className="text-red-400">Failed to load posts.</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-white">Manage News</h1>
        <Link
          href="/admin/news/create"
          className="flex items-center gap-2 bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 transition-opacity"
        >
          <PlusCircle size={20} />
          <span>New Post</span>
        </Link>
      </div>

      <div className="bg-brand-secondary rounded-lg overflow-hidden">
        <table className="w-full text-left text-brand-light">
          <thead className="bg-gray-800/50 text-sm text-brand-muted uppercase">
            <tr>
              <th className="p-4">Preview</th> {/* <-- NEW COLUMN HEADER */}
              <th className="p-4">Title</th>
              <th className="p-4">Status</th>
              <th className="p-4">Type</th>
              <th className="p-4">Created At</th>
              <th className="p-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {posts?.map((post) => (
              <tr
                key={post._id as string}
                className="border-t border-gray-700/50"
              >
                {/* --- NEW COLUMN CONTENT --- */}
                <td className="p-4">
                  {post.featuredImage ? (
                    <Image
                      src={post.featuredImage}
                      alt={post.title}
                      width={100} // Adjust width as needed for preview
                      height={56} // Maintain aspect ratio for common image sizes (16:9)
                      objectFit="cover" // Cover the area, cropping if necessary
                      className="rounded-md bg-gray-700"
                    />
                  ) : (
                    <div className="w-[100px] h-[56px] bg-gray-700 rounded-md flex items-center justify-center text-xs text-brand-muted">
                      No Image
                    </div>
                  )}
                </td>
                <td className="p-4 font-medium">{post.title}</td>
                <td className="p-4">
                  <span
                    className={`px-2 py-1 text-xs font-semibold rounded-full ${
                      post.status === "published"
                        ? "bg-green-500/20 text-green-400"
                        : "bg-yellow-500/20 text-yellow-400"
                    }`}
                  >
                    {post.status}
                  </span>
                </td>
                <td className="p-4">
                  {post.isAIGenerated && (
                    <span className="flex items-center gap-1 px-2 py-1 text-xs font-semibold rounded-full bg-blue-500/20 text-blue-400">
                      <Lightbulb size={12} /> AI
                    </span>
                  )}
                  {!post.isAIGenerated && (
                    <span className="px-2 py-1 text-xs font-semibold rounded-full bg-gray-600/20 text-gray-400">
                      Manual
                    </span>
                  )}
                </td>
                <td className="p-4 text-brand-muted">
                  {format(new Date(post.createdAt), "dd MMM yyyy")}
                </td>
                <td className="p-4 flex gap-3">
                  <Link
                    href={`/admin/news/edit/${post._id}`}
                    className="text-blue-400 hover:text-blue-300"
                  >
                    <Edit size={18} />
                  </Link>
                  <button
                    onClick={() => handleDelete(post._id as string)}
                    className="text-red-400 hover:text-red-300"
                  >
                    <Trash2 size={18} />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {/* Optional: Message if no posts found */}
        {posts?.length === 0 && (
          <p className="text-center p-8 text-brand-muted">
            No news posts found. Create one manually or process an external
            article using the Automated News Engine.
          </p>
        )}
      </div>
    </div>
  );
}


// ===== src/app/api/active-leagues/route.ts =====

// src/app/api/active-leagues/route.ts
import { NextResponse } from "next/server";
import axios from "axios";
import { format, addDays } from "date-fns";

// A curated list of leagues to check for activity.
// Checking EVERY single league would be too slow and hit API rate limits.
// This list should contain leagues you generally expect to be active.
const LEAGUES_TO_CHECK = [
  39,
  140,
  135,
  78,
  61,
  2,
  3,
  88,
  94,
  253,
  45,
  48,
  71,
  62,
  144,
  203,
  197,
  218, // Premier League, La Liga, Serie A, Bundesliga, Ligue 1, UCL, UEL, Eredivisie, etc.
];

export async function GET() {
  const today = format(new Date(), "yyyy-MM-dd");
  const nextSevenDays = format(addDays(new Date(), 7), "yyyy-MM-dd");

  const options = (leagueId: number) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: {
      league: leagueId,
      season: new Date().getFullYear().toString(),
      from: today,
      to: nextSevenDays,
    },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    // Create an array of promises, one for each league check
    const fixtureChecks = LEAGUES_TO_CHECK.map((id) =>
      axios.request(options(id)).then((response) => ({
        leagueId: id,
        hasFixtures: response.data.results > 0,
      }))
    );

    // Execute all checks in parallel
    const results = await Promise.allSettled(fixtureChecks);

    // Filter out failed requests and leagues with no fixtures
    const activeLeagueIds = results
      .filter(
        (result) => result.status === "fulfilled" && result.value.hasFixtures
      )
      .map(
        (result) =>
          (result as PromiseFulfilledResult<{ leagueId: number }>).value
            .leagueId
      );

    return NextResponse.json(activeLeagueIds);
  } catch (error) {
    console.error("Error fetching active leagues:", error);
    return NextResponse.json(
      { error: "Failed to determine active leagues." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/admin/ai-journalists/route.ts =====

// src/app/api/admin/ai-journalists/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import AIJournalist, { IAIJournalist } from "@/models/AIJournalist";

// GET handler to retrieve a list of all AI Journalists
export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const journalists = await AIJournalist.find({}).sort({ name: 1 }).lean();
    return NextResponse.json(journalists, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching AI Journalists:", error.message);
    return NextResponse.json(
      { error: "Server error fetching AI Journalists." },
      { status: 500 }
    );
  }
}

// POST handler to create a new AI Journalist
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body: Partial<IAIJournalist> = await request.json();
    const { name, description, tonePrompt, isActive } = body;

    if (!name || !tonePrompt) {
      return NextResponse.json(
        { error: "Name and Tone Prompt are required." },
        { status: 400 }
      );
    }

    const newJournalist = new AIJournalist({
      name,
      description,
      tonePrompt,
      isActive: isActive !== undefined ? isActive : true, // Default to active
    });

    await newJournalist.save();
    return NextResponse.json(newJournalist, { status: 201 });
  } catch (error: any) {
    console.error("Error creating AI Journalist:", error.message);
    if (error.code === 11000) {
      // Duplicate key error
      return NextResponse.json(
        { error: "Journalist with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error creating AI Journalist." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/admin/ai-journalists/[journalistId]/route.ts =====

// src/app/api/admin/ai-journalists/[journalistId]/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import AIJournalist, { IAIJournalist } from "@/models/AIJournalist";

interface Params {
  params: { journalistId: string };
}

// GET handler to retrieve a single AI Journalist (optional, but good for editing)
export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { journalistId } = params;
    const journalist = await AIJournalist.findById(journalistId).lean();

    if (!journalist) {
      return NextResponse.json(
        { error: "AI Journalist not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(journalist, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error fetching AI Journalist ${params.journalistId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching AI Journalist." },
      { status: 500 }
    );
  }
}

// PUT handler to update an existing AI Journalist
export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { journalistId } = params;
    const body: Partial<IAIJournalist> = await request.json();
    const { name, description, tonePrompt, isActive } = body;

    // Optional: Basic validation if all fields are sent in PUT
    // If only partial updates are expected, this validation might be too strict.
    // Assuming a full form submission for update.
    if (!name || !tonePrompt) {
      return NextResponse.json(
        { error: "Name and Tone Prompt are required." },
        { status: 400 }
      );
    }

    const updatedJournalist = await AIJournalist.findByIdAndUpdate(
      journalistId,
      { name, description, tonePrompt, isActive },
      { new: true, runValidators: true } // Return the updated document, run schema validators
    );

    if (!updatedJournalist) {
      return NextResponse.json(
        { error: "AI Journalist not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(updatedJournalist, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error updating AI Journalist ${params.journalistId}:`,
      error.message
    );
    if (error.code === 11000) {
      // Duplicate key error
      return NextResponse.json(
        { error: "Journalist with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error updating AI Journalist." },
      { status: 500 }
    );
  }
}

// DELETE handler to delete an AI Journalist
export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { journalistId } = params;
    const deletedJournalist = await AIJournalist.findByIdAndDelete(
      journalistId
    );

    if (!deletedJournalist) {
      return NextResponse.json(
        { error: "AI Journalist not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { message: "AI Journalist deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      `Error deleting AI Journalist ${params.journalistId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error deleting AI Journalist." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/admin/ai-prompt/route.ts =====

// src/app/api/admin/ai-journalists/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import AIJournalist, { IAIJournalist } from "@/models/AIJournalist";

// GET handler to retrieve a list of all AI Journalists (UNCHANGED)
export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const journalists = await AIJournalist.find({}).sort({ name: 1 }).lean();
    return NextResponse.json(journalists, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching AI Journalists:", error.message);
    return NextResponse.json(
      { error: "Server error fetching AI Journalists." },
      { status: 500 }
    );
  }
}

// POST handler to create a new AI Journalist
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body: Partial<IAIJournalist> = await request.json();
    const { name, description, tonePrompt, isActive } = body;

    if (!name || !tonePrompt) {
      return NextResponse.json(
        { error: "Name and Tone Prompt are required." },
        { status: 400 }
      );
    }

    const newJournalist = new AIJournalist({
      name,
      description,
      tonePrompt,
      isActive: isActive !== undefined ? isActive : true, // Default to active
    });

    await newJournalist.save();
    return NextResponse.json(newJournalist, { status: 201 });
  } catch (error: any) {
    console.error("Error creating AI Journalist:", error.message);
    if (error.code === 11000) {
      // Duplicate key error
      return NextResponse.json(
        { error: "Journalist with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error creating AI Journalist." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/admin/casino-partners/route.ts =====

// src/app/api/admin/casino-partners/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import CasinoPartner, { ICasinoPartner } from "@/models/CasinoPartner";

// GET handler to retrieve a list of all Casino Partners for admin
export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    // Sort by 'order' ascending, then by 'createdAt' descending (newest first for same order)
    const partners = await CasinoPartner.find({})
      .sort({ order: 1, createdAt: -1 })
      .lean();
    return NextResponse.json(partners, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching Casino Partners (Admin):", error.message);
    return NextResponse.json(
      { error: "Server error fetching Casino Partners." },
      { status: 500 }
    );
  }
}

// POST handler to create a new Casino Partner
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const body: Partial<ICasinoPartner> = await request.json();
    const {
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured,
      isActive,
      order,
    } = body;

    if (!name || !logoUrl || !redirectUrl) {
      return NextResponse.json(
        { error: "Name, Logo URL, and Redirect URL are required." },
        { status: 400 }
      );
    }

    const newPartner = new CasinoPartner({
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured: isFeatured !== undefined ? isFeatured : false,
      isActive: isActive !== undefined ? isActive : true, // Default to active
      order: order !== undefined ? order : 0, // Default order
    });

    await newPartner.save();
    return NextResponse.json(newPartner, { status: 201 });
  } catch (error: any) {
    console.error("Error creating Casino Partner:", error.message);
    if (error.code === 11000) {
      // Duplicate key error
      return NextResponse.json(
        { error: "Partner with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error creating Casino Partner." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/admin/casino-partners/[partnerId]/route.ts =====

// src/app/api/admin/casino-partners/[partnerId]/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import CasinoPartner, { ICasinoPartner } from "@/models/CasinoPartner";

interface Params {
  params: { partnerId: string };
}

// GET handler to retrieve a single Casino Partner (optional, but good for editing)
export async function GET(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { partnerId } = params;
    const partner = await CasinoPartner.findById(partnerId).lean();

    if (!partner) {
      return NextResponse.json(
        { error: "Casino Partner not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(partner, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error fetching Casino Partner ${params.partnerId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching Casino Partner." },
      { status: 500 }
    );
  }
}

// PUT handler to update an existing Casino Partner
export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { partnerId } = params;
    const body: Partial<ICasinoPartner> = await request.json();
    const {
      name,
      logoUrl,
      redirectUrl,
      description,
      isFeatured,
      isActive,
      order,
    } = body;

    // Basic validation
    if (!name || !logoUrl || !redirectUrl) {
      return NextResponse.json(
        { error: "Name, Logo URL, and Redirect URL are required." },
        { status: 400 }
      );
    }

    const updatedPartner = await CasinoPartner.findByIdAndUpdate(
      partnerId,
      { name, logoUrl, redirectUrl, description, isFeatured, isActive, order },
      { new: true, runValidators: true } // Return the updated document, run schema validators
    );

    if (!updatedPartner) {
      return NextResponse.json(
        { error: "Casino Partner not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(updatedPartner, { status: 200 });
  } catch (error: any) {
    console.error(
      `Error updating Casino Partner ${params.partnerId}:`,
      error.message
    );
    if (error.code === 11000) {
      // Duplicate key error
      return NextResponse.json(
        { error: "Partner with this name already exists." },
        { status: 409 }
      );
    }
    return NextResponse.json(
      { error: "Server error updating Casino Partner." },
      { status: 500 }
    );
  }
}

// DELETE handler to delete a Casino Partner
export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { partnerId } = params;
    const deletedPartner = await CasinoPartner.findByIdAndDelete(partnerId);

    if (!deletedPartner) {
      return NextResponse.json(
        { error: "Casino Partner not found." },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { message: "Casino Partner deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      `Error deleting Casino Partner ${params.partnerId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Server error deleting Casino Partner." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/admin/external-news/route.ts =====

// src/app/api/admin/process-external-news/route.ts
// This file now orchestrates the entire AI news generation process directly.

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle, {
  IExternalNewsArticle,
} from "@/models/ExternalNewsArticle";
import Post from "@/models/Post";
import AIPrompt from "@/models/AIPrompt";
import AIJournalist from "@/models/AIJournalist";
import { GoogleGenerativeAI } from "@google/generative-ai";
import axios from "axios";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import sharp from "sharp";
import crypto from "crypto";
import slugify from "slugify";
import * as cheerio from "cheerio";
import MarkdownIt from "markdown-it";
import path from "path";

// Initialize markdown-it for HTML conversion
const md = new MarkdownIt({
  html: true,
  linkify: true,
  typographer: true,
});

// --- R2/S3 Client Configuration ---
const s3Client = new S3Client({
  region: "auto", // R2's region is 'auto'
  endpoint: process.env.NEXT_PUBLIC_R2_ENDPOINT as string,
  credentials: {
    accessKeyId: process.env.NEXT_PUBLIC_R2_ACCESS_KEY_ID as string,
    secretAccessKey: process.env.NEXT_PUBLIC_R2_SECRET_ACCESS_KEY as string,
  },
});

const R2_BUCKET_NAME = process.env.NEXT_PUBLIC_R2_BUCKET_NAME as string;
const R2_PUBLIC_URL = process.env.NEXT_PUBLIC_R2_PUBLIC_BUCKET_URL as string;

const generateFileName = (bytes = 32) =>
  crypto.randomBytes(bytes).toString("hex");

// --- REWRITTEN: proxyAndUploadOriginalImage function for R2 (UNCHANGED) ---
async function proxyAndUploadOriginalImage(
  imageUrl: string,
  newPostTitle: string
): Promise<string | null> {
  try {
    console.log(
      `[Image Processing] Attempting to proxy original image: ${imageUrl}`
    );
    const imageResponse = await axios.get(imageUrl, {
      responseType: "arraybuffer",
      timeout: 15000,
      maxRedirects: 5,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });

    const inputBuffer = Buffer.from(imageResponse.data, "binary");
    const originalContentType =
      imageResponse.headers["content-type"] || "image/jpeg";

    let finalBuffer: Buffer;
    let finalContentType: string = originalContentType;
    let fileExtension: string; // Will be set based on processing

    if (originalContentType.includes("image/gif")) {
      finalBuffer = inputBuffer;
      finalContentType = "image/gif";
      fileExtension = ".gif";
      console.log(
        `[Image Processing] GIF detected, bypassing Sharp for ${imageUrl}.`
      );
    } else {
      try {
        finalBuffer = await sharp(inputBuffer)
          .resize(1200, 630, {
            fit: "inside", // Changed from "cover" to "inside" to prevent cropping
            withoutEnlargement: true, // Prevents upscaling
          })
          .webp({ quality: 80 })
          .toBuffer();
        finalContentType = "image/webp";
        fileExtension = ".webp";
        console.log(
          `[Image Processing] Resized and converted original image to WebP (fit:inside) for ${imageUrl}.`
        );
      } catch (sharpError: any) {
        // Fallback if Sharp processing fails for non-GIFs (e.g., corrupted image, unsupported format)
        console.error(
          `[Image Processing] Sharp processing failed for image ${imageUrl} (non-GIF):`,
          sharpError.message
        );
        finalBuffer = inputBuffer; // Use original buffer as fallback
        finalContentType = originalContentType; // Keep original content type
        fileExtension = path.extname(new URL(imageUrl).pathname) || ".jpg"; // Try to get original extension or default
        console.warn(
          `[Image Processing] Using original image buffer as fallback (without sharp processing) for ${imageUrl}.`
        );
      }
    }

    const slug = slugify(newPostTitle, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });
    const uniqueSuffix = Date.now().toString().slice(-6);
    const newFileName = `fanskor-${slug}-${uniqueSuffix}${fileExtension}`;

    const putObjectCommand = new PutObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: newFileName,
      Body: finalBuffer,
      ContentType: finalContentType,
    });

    await s3Client.send(putObjectCommand);
    const r2Url = `${R2_PUBLIC_URL}/${newFileName}`;
    console.log(
      `[Image Processing] Original image successfully uploaded to R2: ${r2Url}`
    );

    return r2Url;
  } catch (imageError: any) {
    console.error(
      `[Image Processing] Failed to process/upload original image (URL: ${imageUrl}):`,
      imageError.message
    );
    return null;
  }
}

// --- Initialize Google Generative AI (UNCHANGED) ---
const genAI = new GoogleGenerativeAI(
  process.env.NEXT_PUBLIC_GEMINI_API_KEY as string
);
const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash-latest" }); // Changed back to flash for general news

// Fixed names for the AI prompts (UNCHANGED)
const TITLE_PROMPT_NAME = "AI Title Generation";
const CONTENT_PROMPT_NAME = "AI Content Generation";

// --- AI Prompt Interface (UNCHANGED) ---
interface IAIPrompt {
  _id: string;
  name: string;
  prompt: string;
  description?: string;
  type: "title" | "content" | "prediction_content";
}

// --- Helper Functions (calculateJaccardSimilarity, fetchAndExtractWebpageContent) (UNCHANGED) ---
function calculateJaccardSimilarity(str1: string, str2: string): number {
  const words1 = new Set(str1.toLowerCase().split(/\s+/).filter(Boolean));
  const words2 = new Set(str2.toLowerCase().split(/\s+/).filter(Boolean));
  if (words1.size === 0 && words2.size === 0) return 1.0;
  if (words1.size === 0 || words2.size === 0) return 0.0;
  const intersection = new Set([...words1].filter((word) => words2.has(word)));
  const union = new Set([...words1, ...words2]);
  return intersection.size / union.size;
}

async function fetchAndExtractWebpageContent(
  url: string
): Promise<string | null> {
  try {
    const response = await axios.get(url, {
      timeout: 10000,
      maxRedirects: 5,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });
    if (response.status !== 200) {
      return null;
    }
    const $ = cheerio.load(response.data);
    const contentSelectors = [
      "article",
      "main",
      ".article-content",
      ".post-content",
      ".entry-content",
      ".story-content",
      ".body-content",
      "#article-body",
      "#main-content",
      "#content",
      "p",
    ];
    let extractedText = "";
    for (const selector of contentSelectors) {
      const element = $(selector);
      if (element.length > 0) {
        element
          .find(
            "script, style, header, footer, nav, aside, form, iframe, .ad-unit"
          )
          .remove();
        extractedText = element.text();
        if (extractedText.length > 200) break;
      }
    }
    extractedText = extractedText.replace(/\s\s+/g, " ").trim();
    return extractedText.length > 0 ? extractedText : null;
  } catch (error: any) {
    console.error(
      `[Content Extraction Helper] Error fetching or extracting content from ${url}:`,
      error.message
    );
    return null;
  }
}

/**
 * Generates an AI-driven article title.
 * @param originalTitle The original news title.
 * @param originalDescription The original news description.
 * @param journalistId Optional ID of the AI Journalist to use.
 * @returns The AI-generated new title.
 * @throws Error if title generation fails or output is invalid.
 */
async function generateTitle(
  originalTitle: string,
  originalDescription: string,
  journalistId?: string
): Promise<string> {
  const titlePromptDoc = await AIPrompt.findOne({
    name: TITLE_PROMPT_NAME,
    type: "title", // <-- IMPORTANT: Query by type
  });
  if (!titlePromptDoc) {
    console.warn(
      `[AI Generate Title - Func] Title prompt "${TITLE_PROMPT_NAME}" (type 'title') not found. Using default internal prompt.`
    );
  }

  // --- MODIFIED: Added Turkish language instruction ---
  const defaultTitlePrompt =
    "YOUR ONLY TASK IS TO GENERATE A NEWS ARTICLE TITLE IN TURKISH. Output MUST be plain text only, on a single line. NO HTML, NO Markdown. NO preambles. NO prefixes like 'Title: '.\n\n" +
    "You are an expert sports journalist. Generate a **new, original, SEO-friendly title in TURKISH** for a news article based on the following original title and description. The new title MUST be highly distinct from the original, capture a fresh angle, and avoid simply rephrasing original keywords.\n\n" +
    "Original Title: {original_title}\nOriginal Description: {original_description}\n\n" +
    "Generated Title:";

  let finalTitlePrompt = titlePromptDoc?.prompt || defaultTitlePrompt;

  let journalistTonePrompt = "";
  if (journalistId) {
    const journalist = await AIJournalist.findById(journalistId);
    if (journalist && journalist.isActive) {
      journalistTonePrompt = `As "${journalist.name}", your unique journalistic voice and tone should be: ${journalist.tonePrompt}\n\n`;
      console.log(
        `[AI Generate Title - Func] Using AI Journalist: ${journalist.name}`
      );
    }
  }

  const fullPrompt = `${journalistTonePrompt}${finalTitlePrompt}`
    .replace("{original_title}", originalTitle)
    .replace("{original_description}", originalDescription);

  // AI Call
  let aiResponseText: string = "";
  const MAX_RETRIES = 3;
  const RETRY_DELAY_MS = 2000;
  const AI_CALL_TIMEOUT_MS = 20000; // 20 seconds for title generation

  for (let i = 0; i < MAX_RETRIES; i++) {
    try {
      console.log(
        `[AI Generate Title - Func] Calling Gemini for title (Attempt ${
          i + 1
        })...`
      );
      const result: any = await Promise.race([
        model.generateContent(fullPrompt),
        new Promise((_, reject) =>
          setTimeout(
            () => reject(new Error("AI title generation timed out.")),
            AI_CALL_TIMEOUT_MS
          )
        ),
      ]);
      aiResponseText = (await result.response).text();
      console.log(
        `[AI Generate Title - Func] Received raw AI response. Length: ${aiResponseText.length}.`
      );
      break;
    } catch (aiError: any) {
      console.error(
        `[AI Generate Title - Func] Error in Gemini API call for title (Attempt ${
          i + 1
        }/${MAX_RETRIES}):`,
        aiError.message
      );
      if (
        i < MAX_RETRIES - 1 &&
        (aiError.message.includes("timed out.") ||
          aiError.status === 429 ||
          (aiError.status >= 500 && aiError.status < 600))
      ) {
        console.warn(
          `[AI Generate Title - Func] Retrying AI title generation in ${
            RETRY_DELAY_MS / 1000
          } seconds...`
        );
        await new Promise((res) => setTimeout(res, RETRY_DELAY_MS));
      } else {
        throw new Error(
          `AI title generation failed after ${MAX_RETRIES} retries: ${aiError.message}`
        );
      }
    }
  }

  if (!aiResponseText) {
    throw new Error("AI title generation failed to produce a response.");
  }

  // --- Aggressive Title Cleanup and Validation ---
  let generatedTitle = aiResponseText.trim();
  generatedTitle = generatedTitle
    .replace(/^```(?:html|text|json)?\n?|```$/g, "")
    .trim();
  generatedTitle = generatedTitle
    .replace(
      /<!DOCTYPE html>[\s\S]*?<body[^>]*>|(?<=<\/body>)[\s\S]*$|<\/body>|<\/html>|<\/head>|<\/title>|<\/meta>|<\/link>|<\/style>|<style[^>]*>[\s\S]*?<\/style>|<script[^>]*>[\s\S]*?<\/script>/g,
      ""
    )
    .trim();
  generatedTitle = generatedTitle
    .replace(/<html[^>]*>|<body[^>]*>/g, "")
    .trim();
  generatedTitle = generatedTitle.replace(/^\s*\n/gm, "").trim();
  generatedTitle = generatedTitle
    .replace(/^(AI JOURNALIST TONE & STYLE:[\s\S]*?\n\n)?/i, "")
    .trim();
  generatedTitle = generatedTitle
    .replace(
      /^(Here's the (title|article|rewritten title|news article|requested article|response)|Article Title|Generated Title|Title):?\s*\n*/i,
      ""
    )
    .trim();
  generatedTitle = generatedTitle.replace(/<[^>]*>?/gm, "");
  generatedTitle = generatedTitle.replace(/[\*_`#\[\]\n]/g, "");
  generatedTitle = generatedTitle.trim();

  console.log(
    `[AI Generate Title - Func] Cleaned generated title: "${generatedTitle}"`
  );

  // Strict validation
  const originalTitleLower = originalTitle.toLowerCase();
  const generatedTitleLower = generatedTitle.toLowerCase();
  const jaccardSimilarity = calculateJaccardSimilarity(
    originalTitleLower,
    generatedTitleLower
  );
  const SIMILARITY_THRESHOLD = 0.4;

  if (
    generatedTitle.length < 10 ||
    jaccardSimilarity > SIMILARITY_THRESHOLD ||
    generatedTitleLower === originalTitleLower
  ) {
    console.error(
      `[AI Generate Title - Func] Generated Title: "${generatedTitle}" (Original: "${originalTitle}")`
    );
    console.error(
      `[AI Generate Title - Func] Jaccard Similarity: ${jaccardSimilarity.toFixed(
        2
      )} (Threshold: ${SIMILARITY_THRESHOLD})`
    );
    throw new Error(
      `Generated title failed strict validation (too short, not unique, or too similar).`
    );
  }

  return generatedTitle;
}

/**
 * Generates an AI-driven article content.
 * @param originalTitle The original news title.
 * @param originalDescription The original news description.
 * @param originalContent The external article's content field.
 * @param articleLink The external article's link for scraping.
 * @param generatedTitle The title already generated by AI.
 * @param journalistId Optional ID of the AI Journalist to use.
 * @returns The AI-generated HTML content.
 * @throws Error if content generation fails or output is invalid.
 */
async function generateContent(
  originalTitle: string,
  originalDescription: string,
  originalContent: string | null,
  articleLink: string,
  generatedTitle: string,
  journalistId?: string
): Promise<string> {
  const contentPromptDoc = await AIPrompt.findOne({
    name: CONTENT_PROMPT_NAME,
    type: "content", // <-- IMPORTANT: Query by type
  });
  if (!contentPromptDoc) {
    console.warn(
      `[AI Generate Content - Func] Content prompt "${CONTENT_PROMPT_NAME}" (type 'content') not found. Using default internal prompt.`
    );
  }

  // --- MODIFIED: Added Turkish language instruction ---
  const defaultContentPrompt =
    "Your ONLY task is to generate a news article content in TURKISH HTML. NO Markdown, NO preambles, NO extra text, NO code block wrappers (```html). DO NOT INCLUDE `<!DOCTYPE html>`, `<html>`, `<head>`, `<body>`, `<h1>`, or any other full document tags. \n\n" +
    "You are an expert sports journalist. Analyze the following news title, description, and provided context. Your goal is to generate a comprehensive, human-like, SEO-optimized HTML article, approximately 700 words long. Focus on deep insights, storytelling, and compelling analysis.\n\n" +
    "**GUIDELINES:**\n" +
    "1.  **HTML CONTENT:** Provide valid HTML. Use `<h2>` for main headings (optimized for keywords), `<p>` for paragraphs, `<strong>`, `<em>`, `<ul>`, `<li>`, `<a>`. Ensure natural flow, rich detail, and human tone. Integrate relevant keywords naturally throughout the article for SEO, but avoid stuffing.\n\n" +
    "**HTML Example Structure:**\n" +
    "<h2>Giriş Başlığı</h2><p>Bu, makale içeriğinin zeminini hazırlayan etkileyici giriş paragrafıdır...</p>\n" +
    "<h2>Ana Gelişmeler</h2><p>İşte belirli bir yönüyle ilgili detaylı bir paragraf...</p><ul><li>...</li></ul><p>...</p><h2>Sonuç</h2><p>Sonuç paragrafı, makalenin ana noktalarını özetler...</p>\n\n" +
    "**IMPORTANT:** If the provided content is too short or lacks sufficient detail for a 700-word SEO-optimized expansion, respond ONLY with 'CONTENT INSUFFICIENT FOR EXPANSION: [brief reason]'. No other text.\n\n" +
    "Generated Article Title: {generated_title}\nOriginal News Title: {original_title}\nOriginal News Description: {original_description}\nAdditional Context: {additional_context}";

  let finalContentPrompt = contentPromptDoc?.prompt || defaultContentPrompt;

  let journalistTonePrompt = "";
  if (journalistId) {
    const journalist = await AIJournalist.findById(journalistId);
    if (journalist && journalist.isActive) {
      journalistTonePrompt = `As "${journalist.name}", your unique journalistic voice and tone should be: ${journalist.tonePrompt}\n\n`;
      console.log(
        `[AI Generate Content - Func] Using AI Journalist: ${journalist.name}`
      );
    }
  }

  // --- Content Gathering for AI Input (UNCHANGED) ---
  let combinedArticleContext = "";
  const MIN_TOTAL_CONTEXT_FOR_GENERATION = 100;

  if (originalTitle) combinedArticleContext += `Title: ${originalTitle}\n`;
  if (originalDescription)
    combinedArticleContext += `Description: ${originalDescription}\n`;
  if (originalContent && originalContent.length > 50) {
    combinedArticleContext += `\nFull Content: ${originalContent}\n`;
  }

  if (
    articleLink &&
    combinedArticleContext.length < MIN_TOTAL_CONTEXT_FOR_GENERATION
  ) {
    console.log(
      `[Content Gathering - Func] Combined context too short (${combinedArticleContext.length}), attempting to fetch from link: ${articleLink}`
    );
    const fetchedWebContent = await fetchAndExtractWebpageContent(articleLink);
    if (fetchedWebContent && fetchedWebContent.length > 50) {
      combinedArticleContext += `\nWebpage Context: ${fetchedWebContent}\n`;
      console.log(
        `[Content Gathering - Func] Successfully fetched and appended web content (total context length: ${combinedArticleContext.length})`
      );
    } else {
      console.log(
        "[Content Gathering - Func] No substantial web content extracted from link."
      );
    }
  }

  if (
    !combinedArticleContext ||
    combinedArticleContext.length < MIN_TOTAL_CONTEXT_FOR_GENERATION
  ) {
    throw new Error(
      "Article content (title, description, or external content) too short or missing to generate content."
    );
  }

  const MAX_CONTENT_LENGTH_TO_SEND = 8000;
  if (combinedArticleContext.length > MAX_CONTENT_LENGTH_TO_SEND) {
    combinedArticleContext =
      combinedArticleContext.substring(0, MAX_CONTENT_LENGTH_TO_SEND) +
      "... (truncated for AI processing)";
    console.warn(
      `[Content Gathering - Func] Article context truncated to ${MAX_CONTENT_LENGTH_TO_SEND} characters for AI.`
    );
  }

  const fullPrompt = `${journalistTonePrompt}${finalContentPrompt}`
    .replace("{generated_title}", generatedTitle)
    .replace("{original_title}", originalTitle)
    .replace("{original_description}", originalDescription)
    .replace("{additional_context}", combinedArticleContext);

  // AI Call
  let aiResponseText: string = "";
  const MAX_RETRIES = 3;
  const RETRY_DELAY_MS = 3000;
  const AI_CALL_TIMEOUT_MS = 90000; // 90 seconds for content generation

  for (let i = 0; i < MAX_RETRIES; i++) {
    try {
      console.log(
        `[AI Generate Content - Func] Calling Gemini for content (Attempt ${
          i + 1
        })...`
      );
      const result: any = await Promise.race([
        model.generateContent(fullPrompt),
        new Promise((_, reject) =>
          setTimeout(
            () => reject(new Error("AI content generation timed out.")),
            AI_CALL_TIMEOUT_MS
          )
        ),
      ]);
      aiResponseText = (await result.response).text();
      console.log(
        `[AI Generate Content - Func] Received raw AI response. Length: ${aiResponseText.length}.`
      );
      break;
    } catch (aiError: any) {
      console.error(
        `[AI Generate Content - Func] Error in Gemini API call for content (Attempt ${
          i + 1
        }/${MAX_RETRIES}):`,
        aiError.message
      );
      if (
        i < MAX_RETRIES - 1 &&
        (aiError.message.includes("timed out.") ||
          aiError.status === 429 ||
          (aiError.status >= 500 && aiError.status < 600))
      ) {
        console.warn(
          `[AI Generate Content - Func] Retrying AI content generation in ${
            RETRY_DELAY_MS / 1000
          } seconds...`
        );
        await new Promise((res) => setTimeout(res, RETRY_DELAY_MS));
      } else {
        throw new Error(
          `AI content generation failed after ${MAX_RETRIES} retries: ${aiError.message}`
        );
      }
    }
  }

  if (!aiResponseText) {
    throw new Error("AI content generation failed to produce a response.");
  }

  // --- Aggressive Content Cleanup and Validation ---
  let generatedContent = aiResponseText.trim();
  generatedContent = generatedContent
    .replace(/^```(?:html|text|json)?\n?|```$/g, "")
    .trim();
  generatedContent = generatedContent
    .replace(
      /<!DOCTYPE html>[\s\S]*?<body[^>]*>|(?<=<\/body>)[\s\S]*$|<\/body>|<\/html>|<\/head>|<\/title>|<\/meta>|<\/link>|<\/style>|<style[^>]*>[\s\S]*?<\/style>|<script[^>]*>[\s\S]*?<\/script>/g,
      ""
    )
    .trim();
  generatedContent = generatedContent
    .replace(/<html[^>]*>|<body[^>]*>/g, "")
    .trim();
  generatedContent = generatedContent.replace(/^\s*\n/gm, "").trim();
  generatedContent = generatedContent
    .replace(/^(AI JOURNALIST TONE & STYLE:[\s\S]*?\n\n)?/i, "")
    .trim();
  generatedContent = generatedContent
    .replace(
      /^(Here's the (article|rewritten article|news article|requested article|response)|Article|News Article|Your Article|Generated Article|Title):?\s*\n*/i,
      ""
    )
    .trim();
  if (generatedContent.includes("---START_CONTENT---")) {
    // Remove separator if AI accidentally includes it
    generatedContent =
      generatedContent.split("---START_CONTENT---")[1] || generatedContent;
    console.warn(
      "[AI Generate Content - Func] Stripped unexpected title separator from content."
    );
  }

  // Check for AI's own "insufficient content" flag (case-insensitive and partial match)
  if (
    generatedContent
      .toUpperCase()
      .includes("CONTENT INSUFFICIENT FOR EXPANSION")
  ) {
    throw new Error("AI determined content insufficient for expansion.");
  }

  // --- HTML Post-processing (markdown-it) and Validation ---
  let finalContent = md.render(generatedContent);

  const hasHtmlTags = /<[a-z][\s\S]*>/i.test(finalContent);
  const hasMarkdownChars = /[*_`#\[\]]/.test(finalContent);

  if (!hasHtmlTags || hasMarkdownChars) {
    throw new Error(
      `AI output format error: Content is not valid HTML after post-processing or still contains Markdown.`
    );
  }
  if (finalContent.includes("<h1")) {
    throw new Error(
      `AI output format error: Content unexpectedly contains <h1> tags.`
    );
  }

  return finalContent;
}

// POST handler to orchestrate the AI processing pipeline (UNCHANGED LOGIC)
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  let externalArticle: IExternalNewsArticle | null = null;
  let journalistName = "AI Auto-Generator";

  try {
    const {
      articleId,
      sportCategory,
      journalistId,
    }: { articleId: string; sportCategory?: string; journalistId?: string } =
      await request.json();

    if (!articleId) {
      console.error("[Process Article Orchestrator] Missing Article ID.");
      return NextResponse.json(
        { error: "Article ID is required." },
        { status: 400 }
      );
    }

    externalArticle = await ExternalNewsArticle.findOne({ articleId });

    if (!externalArticle) {
      console.error(
        `[Process Article Orchestrator] External news article not found: ${articleId}`
      );
      return NextResponse.json(
        { error: "External news article not found." },
        { status: 404 }
      );
    }

    if (externalArticle.status === "processed") {
      console.log(
        `[Process Article Orchestrator] Article ${articleId} already processed. Skipping.`
      );
      return NextResponse.json(
        { message: "Article already processed." },
        { status: 200 }
      );
    }
    if (externalArticle.status === "processing") {
      console.warn(
        `[Process Article Orchestrator] Article ${articleId} is already in 'processing' state. Aborting duplicate request.`
      );
      return NextResponse.json(
        { error: "Article is already being processed. Please wait." },
        { status: 409 }
      );
    }

    externalArticle.status = "processing";
    await externalArticle.save();
    console.log(
      `[Process Article Orchestrator] Starting processing for article: ${externalArticle.articleId}, current status updated to 'processing'.`
    );

    // --- Fetch Journalist Name (for author field later) ---
    if (journalistId) {
      const journalist = await AIJournalist.findById(journalistId);
      if (journalist && journalist.isActive) {
        journalistName = journalist.name;
      }
    }

    // 1. Generate Title via dedicated function call
    let newPostTitle: string = "";
    try {
      console.log(
        `[Orchestrator] Calling local generateTitle function for article ${externalArticle.articleId}...`
      );
      newPostTitle = await generateTitle(
        externalArticle.title,
        externalArticle.description || "",
        journalistId
      );
      console.log(
        `[Orchestrator] Successfully generated title: "${newPostTitle}"`
      );
      if (!newPostTitle)
        throw new Error("AI Title Generation returned no title.");
    } catch (titleError: any) {
      console.error(
        `[Orchestrator] Title generation failed for article ${externalArticle.articleId}:`,
        titleError.message
      );
      throw new Error(`Title generation failed: ${titleError.message}`);
    }

    // 2. Generate Content via dedicated function call
    let rewrittenContent: string = "";
    try {
      console.log(
        `[Orchestrator] Calling local generateContent function for article ${externalArticle.articleId}...`
      );
      rewrittenContent = await generateContent(
        externalArticle.title,
        externalArticle.description || "",
        externalArticle.content,
        externalArticle.link,
        newPostTitle,
        journalistId
      );
      console.log(
        `[Orchestrator] Successfully generated content. Length: ${rewrittenContent.length}`
      );
      if (!rewrittenContent)
        throw new Error("AI Content Generation returned no content.");
    } catch (contentError: any) {
      console.error(
        `[Orchestrator] Content generation failed for article ${externalArticle.articleId}:`,
        contentError.message
      );
      throw new Error(`Content generation failed: ${contentError.message}`);
    }

    // 3. Process/Generate Featured Image (Existing logic)
    let featuredImageUrl: string | null = null;
    let featuredImageTitle: string | undefined = undefined;
    let featuredImageAltText: string | undefined = undefined;

    // Fallback: Use the original external article's image and proxy it to R2.
    if (externalArticle.imageUrl) {
      try {
        console.log(
          `[Orchestrator] Proxying original image for article ${externalArticle.articleId}...`
        );
        featuredImageUrl = await proxyAndUploadOriginalImage(
          externalArticle.imageUrl,
          newPostTitle
        );
        if (featuredImageUrl) {
          console.log(
            `[Orchestrator] Original image proxied successfully: ${featuredImageUrl}`
          );
        } else {
          console.warn(
            `[Orchestrator] Failed to proxy original image for article ${externalArticle.articleId}. No featured image will be set.`
          );
        }
      } catch (proxyError: any) {
        console.error(
          `[Orchestrator] Error proxying original image for article ${externalArticle.articleId}:`,
          proxyError.message
        );
      }
    } else {
      console.log(
        `[Orchestrator] No image URL found in external article ${externalArticle.articleId}. Skipping image processing.`
      );
    }

    featuredImageTitle = newPostTitle;
    featuredImageAltText = `${newPostTitle} image`;

    // 4. Save the rewritten article as a new Post
    const postSlug = slugify(newPostTitle, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });

    const existingPostWithSlug = await Post.findOne({ slug: postSlug });
    let finalSlug = postSlug;
    if (existingPostWithSlug) {
      finalSlug = `${postSlug}-${Date.now().toString().slice(-5)}`;
      console.warn(
        `[Orchestrator - Post Save] Post with slug '${postSlug}' already exists, new slug: '${finalSlug}'`
      );
    }

    const plainTextContent = rewrittenContent.replace(/<[^>]*>?/gm, "");

    const newPost = new Post({
      title: newPostTitle,
      content: rewrittenContent,
      status: "draft",
      slug: finalSlug,
      author: journalistName,
      featuredImage: featuredImageUrl,
      featuredImageTitle: featuredImageTitle,
      featuredImageAltText: featuredImageAltText,
      sport: sportCategory || externalArticle.category?.[0] || "general",
      metaTitle: `${newPostTitle} - Sports News`,
      metaDescription: plainTextContent.substring(0, 150) + "...",
      isAIGenerated: true,
      originalExternalArticleId: externalArticle._id,
    });

    console.log(
      `[Orchestrator - Post Save] Attempting to save new Post with title: "${
        newPost.title
      }", slug: "${newPost.slug}", image: ${!!newPost.featuredImage}`
    );
    await newPost.save();
    console.log(
      `[Orchestrator - Post Save] Post saved successfully. New Post ID: ${newPost._id}`
    );

    // 5. Final Status Update and Success Response
    externalArticle.status = "processed";
    externalArticle.processedPostId = newPost._id;
    await externalArticle.save();
    console.log(
      `[Orchestrator - Status Update] ExternalNewsArticle ${externalArticle.articleId} status updated to 'processed'.`
    );

    return NextResponse.json(
      {
        message: "Article processed and new post created successfully.",
        postId: newPost._id,
        postSlug: newPost.slug,
      },
      { status: 201 }
    );
  } catch (error: any) {
    // --- Centralized Error Handling and Status Update ---
    let errorMessage = "Server error processing external news.";
    let clientStatus = 500;

    const isCustomError = error instanceof Error;
    let finalArticleStatus: "skipped" | "error" = "error";

    if (isCustomError) {
      errorMessage = error.message;
      if (errorMessage.includes("AI determined content insufficient")) {
        clientStatus = 200;
        finalArticleStatus = "skipped";
      } else if (
        errorMessage.includes("AI output format error") ||
        errorMessage.includes("AI-generated title failed strict validation") ||
        errorMessage.includes("Content generation failed") ||
        errorMessage.includes("Title generation failed")
      ) {
        clientStatus = 422;
      } else if (errorMessage.includes("AI generation timed out")) {
        clientStatus = 504;
      } else if (
        errorMessage.includes("Article has no content") ||
        errorMessage.includes("content too short")
      ) {
        clientStatus = 400;
        finalArticleStatus = "skipped";
      } else if (errorMessage.includes("AI generation failed after")) {
        clientStatus = 500;
      } else if (errorMessage.includes("quota")) {
        errorMessage =
          "Gemini API Quota Exceeded. Please check your usage in Google AI Studio.";
        clientStatus = 429;
      } else if (
        errorMessage.includes("not found") ||
        errorMessage.includes("Network Error") ||
        errorMessage.includes("Failed to fetch content")
      ) {
        clientStatus = 404;
      } else if (axios.isAxiosError(error) && error.response) {
        errorMessage = `External API error: ${
          error.response.data?.error ||
          error.response?.data?.results?.message ||
          error.message
        }`;
        clientStatus = error.response.status || 500;
      } else if (
        error.message.includes("MongooseError") ||
        error.message.includes("MongoNetworkError")
      ) {
        errorMessage = `Database error: ${error.message}`;
        clientStatus = 500;
      }
    } else {
      errorMessage = `An unexpected error occurred: ${JSON.stringify(error)}`;
    }

    console.error(
      `[Process Article Orchestrator] Critical error processing external news article ${
        externalArticle?.articleId || "unknown"
      }: ${errorMessage}`,
      "\nFull Error Object:",
      error
    );

    if (externalArticle && externalArticle.status === "processing") {
      console.error(
        `[Process Article Orchestrator] Marking external article ${externalArticle.articleId} as '${finalArticleStatus}' due to critical failure.`
      );
      externalArticle.status = finalArticleStatus;
      try {
        await externalArticle.save();
      } catch (dbSaveError) {
        console.error(
          `[Process Article Orchestrator] Failed to save final external article status to '${finalArticleStatus}':`,
          dbSaveError
        );
      }
    } else if (externalArticle && externalArticle.status !== "processed") {
      console.error(
        `[Process Article Orchestrator] Marking external article ${externalArticle.articleId} as 'error' due to unhandled failure (status was ${externalArticle.status}).`
      );
      externalArticle.status = "error";
      try {
        await externalArticle.save();
      } catch (dbSaveError) {
        console.error(
          `[Orchestrator] Failed to save external article status to 'error':`,
          dbSaveError
        );
      }
    }

    return NextResponse.json({ error: errorMessage }, { status: clientStatus });
  }
}


// ===== src/app/api/admin/fetch-external-news/route.ts =====

// src/app/api/admin/fetch-external-news/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle from "@/models/ExternalNewsArticle";
import axios from "axios";

// Define the expected structure of a newsdata.io article
interface NewsDataItem {
  article_id: string;
  title: string;
  link: string;
  keywords?: string[] | null;
  creator?: string | null;
  video_url?: string | null;
  description?: string | null;
  content?: string | null;
  pubDate: string; // ISO 8601 string
  image_url?: string | null;
  source_id?: string;
  source_priority?: number;
  source_url?: string;
  source_icon?: string | null;
  language?: string;
  country?: string[];
  category?: string[];
  sentiment?: string;
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  try {
    const { query, language, country, category, count } = await request.json(); // Allow client to specify filters and count

    const newsDataApiKey = process.env.NEXT_PUBLIC_NEWSDATA_IO_API_KEY;
    if (!newsDataApiKey) {
      console.error("NEWSDATA_IO_API_KEY is not set in environment variables.");
      return NextResponse.json(
        { error: "Server configuration error: News API key missing." },
        { status: 500 }
      );
    }

    const apiUrl = "https://newsdata.io/api/1/news";
    const params: Record<string, string | number> = {
      apikey: newsDataApiKey,
      // We are only using qInTitle to avoid the 'TooManyQueryFilter' error.
      qInTitle: query || "football OR soccer", // Use qInTitle as the primary query filter
      language: language || "en", // Default language
    };

    if (country && country.length > 0) {
      params.country = country.join(",");
    }
    if (category && category.length > 0) {
      params.category = category.join(",");
    }

    console.log(
      `[Fetch External News] Fetching news from newsdata.io with params: ${JSON.stringify(
        params
      )}`
    );
    const response = await axios.get(apiUrl, { params });
    const newsItems: NewsDataItem[] = response.data.results || [];
    console.log(
      `[Fetch External News] Received ${newsItems.length} articles from newsdata.io`
    );

    let newArticlesCount = 0;
    let skippedArticlesCount = 0;

    for (const item of newsItems) {
      try {
        // Only save if the article_id is unique
        const existingArticle = await ExternalNewsArticle.findOne({
          articleId: item.article_id,
        });
        if (existingArticle) {
          skippedArticlesCount++;
          console.warn(
            `[Fetch External News] Duplicate article ID found, skipping: ${item.article_id}`
          );
          continue; // Skip if article already exists
        }

        const newArticle = new ExternalNewsArticle({
          articleId: item.article_id,
          title: item.title,
          link: item.link,
          keywords: item.keywords || undefined,
          creator: item.creator,
          video_url: item.video_url,
          description: item.description,
          content: item.content,
          pubDate: new Date(item.pubDate), // Convert to Date object
          imageUrl: item.image_url,
          source_id: item.source_id,
          source_priority: item.source_priority,
          source_url: item.source_url,
          source_icon: item.source_icon,
          language: item.language,
          country: item.country || undefined,
          category: item.category || undefined,
          sentiment: item.sentiment,
          status: "fetched", // Initial status
        });

        await newArticle.save();
        newArticlesCount++;
        console.log(`[Fetch External News] Saved new article: ${item.title}`);
      } catch (saveError: any) {
        // Handle duplicate key errors or other save errors gracefully
        if (saveError.code === 11000) {
          // MongoDB duplicate key error
          skippedArticlesCount++;
          console.warn(
            `[Fetch External News] Duplicate article ID found during save, skipping: ${item.article_id}`
          );
        } else {
          console.error(
            `[Fetch External News] Error saving article ${item.article_id}:`,
            saveError
          );
        }
      }
    }

    return NextResponse.json(
      {
        message: `Successfully fetched and saved ${newArticlesCount} new articles. Skipped ${skippedArticlesCount} existing articles.`,
        newArticlesCount,
        skippedArticlesCount,
      },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      "[Fetch External News] Error fetching external news:",
      error.message
    );
    if (axios.isAxiosError(error)) {
      console.error("newsdata.io API error response:", error.response?.data);
      return NextResponse.json(
        {
          error: `Failed to fetch news from external API: ${
            error.response?.data?.results?.message || error.message
          }`,
        },
        { status: error.response?.status || 500 }
      );
    }
    return NextResponse.json(
      { error: "Server error fetching external news." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/admin/file-manager/download-from-url/route.ts =====

// ===== src\app\api\admin\file-manager\download-from-url\route.ts =====
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import axios from "axios";
import crypto from "crypto";
import path from "path";
import slugify from "slugify";
import { promises as fs } from "fs";

// Re-use the UPLOAD_DIR definition and helper function
const UPLOAD_DIR = path.join(process.cwd(), "public/uploads");

const ensureUploadDirExists = async () => {
  try {
    await fs.mkdir(UPLOAD_DIR, { recursive: true });
  } catch (error) {
    console.error("Error creating upload directory:", error);
    throw new Error("Could not create upload directory on the server.");
  }
};

const generateFileName = (bytes = 32) =>
  crypto.randomBytes(bytes).toString("hex");

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const {
      url,
      fileName: providedFileName,
    }: { url: string; fileName?: string } = await request.json();

    if (!url) {
      return NextResponse.json({ error: "URL is required." }, { status: 400 });
    }

    console.log(
      `[File Manager - Download URL] Attempting to download from URL: ${url}`
    );

    // 1. Download the file from the external URL
    const response = await axios.get(url, {
      responseType: "arraybuffer", // Get as binary data
      timeout: 30000, // 30-second timeout for download
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });

    const fileBuffer = Buffer.from(response.data, "binary");
    const contentType =
      response.headers["content-type"] || "application/octet-stream"; // Get content type from response
    const contentLength = response.headers["content-length"]
      ? parseInt(response.headers["content-length"])
      : fileBuffer.length;

    if (contentLength === 0) {
      throw new Error("Downloaded file is empty.");
    }
    if (contentLength > 20 * 1024 * 1024) {
      // Max 20MB limit for direct download, adjust as needed
      throw new Error("File size exceeds 20MB limit for direct download.");
    }

    // Determine file extension and final file name
    let fileExtension = "";
    const mimeMap: { [key: string]: string } = {
      "image/jpeg": ".jpg",
      "image/png": ".png",
      "image/gif": ".gif",
      "image/webp": ".webp",
      "application/pdf": ".pdf",
      // Add more as needed
    };
    fileExtension =
      mimeMap[contentType.toLowerCase()] ||
      path.extname(new URL(url).pathname) ||
      ""; // Try mime type then URL path extension

    const uniqueBaseName = generateFileName();
    const finalFileName = providedFileName
      ? `${slugify(providedFileName, {
          lower: true,
          strict: true,
        })}${fileExtension}`
      : `${uniqueBaseName}${fileExtension}`;

    // 2. Save the file to the local filesystem
    const filePath = path.join(UPLOAD_DIR, finalFileName);
    await ensureUploadDirExists();
    await fs.writeFile(filePath, fileBuffer);

    // 3. Return the relative public URL
    const publicUrl = `/uploads/${finalFileName}`;
    console.log(
      `[File Manager - Download URL] File successfully saved locally: ${publicUrl}`
    );

    return NextResponse.json({
      message: "File downloaded and saved successfully",
      url: publicUrl,
      name: finalFileName,
      type: contentType,
      size: contentLength,
    });
  } catch (error: any) {
    console.error(
      `[File Manager - Download URL] Failed to download or save from URL: ${error.message}`,
      "\nFull Error:",
      error
    );
    let errorMessage = "Failed to download and upload file from URL.";
    let clientStatus = 500;

    if (axios.isAxiosError(error)) {
      if (error.response) {
        errorMessage = `External URL error: Status ${error.response.status} - ${error.response.statusText}`;
        clientStatus = error.response.status;
      } else if (error.request) {
        errorMessage = `Network error: Could not reach external URL.`;
        clientStatus = 502; // Bad Gateway
      } else {
        errorMessage = `Request setup error: ${error.message}`;
      }
    } else if (error instanceof Error) {
      errorMessage = error.message;
      if (errorMessage.includes("File size exceeds")) clientStatus = 413; // Payload Too Large
      if (errorMessage.includes("Downloaded file is empty")) clientStatus = 400; // Bad Request
    }

    return NextResponse.json({ error: errorMessage }, { status: clientStatus });
  }
}


// ===== src/app/api/admin/generate-prediction-news/route.ts =====

// src/app/api/admin/generate-prediction-news/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post from "@/models/Post";
import AIPrompt from "@/models/AIPrompt";
import AIJournalist from "@/models/AIJournalist";
import { GoogleGenerativeAI } from "@google/generative-ai";
import axios from "axios";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import sharp from "sharp";
import crypto from "crypto";
import slugify from "slugify";
import { generateSimplePrediction } from "@/lib/prediction-engine";
import path from "path";

const s3Client = new S3Client({
  region: "auto",
  endpoint: process.env.NEXT_PUBLIC_R2_ENDPOINT as string,
  credentials: {
    accessKeyId: process.env.NEXT_PUBLIC_R2_ACCESS_KEY_ID as string,
    secretAccessKey: process.env.NEXT_PUBLIC_R2_SECRET_ACCESS_KEY as string,
  },
});
const R2_BUCKET_NAME = process.env.NEXT_PUBLIC_R2_BUCKET_NAME as string;
const R2_PUBLIC_URL = process.env.NEXT_PUBLIC_R2_PUBLIC_BUCKET_URL as string;
const generateFileName = (bytes = 32) =>
  crypto.randomBytes(bytes).toString("hex");

async function uploadImageToR2(
  imageUrl: string,
  fileNamePrefix: string
): Promise<string | null> {
  try {
    const imageResponse = await axios.get(imageUrl, {
      responseType: "arraybuffer",
      timeout: 15000,
      maxRedirects: 5,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });
    const inputBuffer = Buffer.from(imageResponse.data, "binary");
    const originalContentType =
      imageResponse.headers["content-type"] || "image/jpeg";
    let finalBuffer: Buffer;
    let finalContentType: string = originalContentType;
    let fileExtension: string;
    if (originalContentType.includes("image/gif")) {
      finalBuffer = inputBuffer;
      finalContentType = "image/gif";
      fileExtension = ".gif";
    } else {
      try {
        finalBuffer = await sharp(inputBuffer)
          .resize(1200, 630, { fit: "inside", withoutEnlargement: true })
          .webp({ quality: 80 })
          .toBuffer();
        finalContentType = "image/webp";
        fileExtension = ".webp";
      } catch (sharpError: any) {
        finalBuffer = inputBuffer;
        finalContentType = originalContentType;
        fileExtension = path.extname(new URL(imageUrl).pathname) || ".jpg";
      }
    }
    const slug = slugify(fileNamePrefix, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });
    const uniqueSuffix = Date.now().toString().slice(-6);
    const newFileName = `fanskor-${slug}-${uniqueSuffix}${fileExtension}`;
    const putObjectCommand = new PutObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: newFileName,
      Body: finalBuffer,
      ContentType: finalContentType,
    });
    await s3Client.send(putObjectCommand);
    return `${R2_PUBLIC_URL}/${newFileName}`;
  } catch (imageError: any) {
    console.error(
      `[Image Upload] Failed to upload image (URL: ${imageUrl}):`,
      imageError.message
    );
    return null;
  }
}
const genAI = new GoogleGenerativeAI(
  process.env.NEXT_PUBLIC_GEMINI_API_KEY as string
);
const model = genAI.getGenerativeModel({ model: "gemini-1.5-pro-latest" });
const TITLE_PROMPT_NAME = "AI Title Generation";
const PREDICTION_PROMPT_NAME = "AI Prediction Content Generation";
interface IAIPrompt {
  _id: string;
  name: string;
  prompt: string;
  description?: string;
  type: "title" | "content" | "prediction_content";
}

async function generatePredictionTitle(
  homeTeamName: string,
  awayTeamName: string,
  leagueName: string,
  predictedOutcome: string,
  journalistId?: string
): Promise<string> {
  const titlePromptDoc = await AIPrompt.findOne({
    name: TITLE_PROMPT_NAME,
    type: "title",
  });
  const defaultTitlePrompt =
    "YOUR ONLY TASK IS TO GENERATE A NEWS ARTICLE TITLE IN TURKISH. Output MUST be plain text only, on a single line. NO HTML, NO Markdown. NO preambles. NO prefixes like 'Title: '.\\n\\nYou are an expert sports journalist. Generate a **new, original, SEO-friendly title in TURKISH** for a news article based on the following original title and description. The new title MUST be highly distinct from the original, capture a fresh angle, and avoid simply rephrasing original keywords.\\n\\nMatch: {home_team} vs {away_team}\\nLeague: {league_name}\\nPredicted Outcome: {predicted_outcome}\\n\\nGenerated Title:";
  let finalTitlePrompt = titlePromptDoc?.prompt || defaultTitlePrompt;
  let journalistTonePrompt = "";
  if (journalistId) {
    const journalist = await AIJournalist.findById(journalistId);
    if (journalist && journalist.isActive) {
      journalistTonePrompt = `As "${journalist.name}", your unique journalistic voice and tone should be: ${journalist.tonePrompt}\n\n`;
    }
  }
  const fullPrompt = `${journalistTonePrompt}${finalTitlePrompt}`
    .replace("{home_team}", homeTeamName)
    .replace("{away_team}", awayTeamName)
    .replace("{league_name}", leagueName)
    .replace("{predicted_outcome}", predictedOutcome);
  let aiResponseText: string = "";
  for (let i = 0; i < 3; i++) {
    try {
      const result: any = await Promise.race([
        model.generateContent(fullPrompt),
        new Promise((_, reject) =>
          setTimeout(
            () =>
              reject(new Error("AI prediction title generation timed out.")),
            20000
          )
        ),
      ]);
      aiResponseText = (await result.response).text();
      break;
    } catch (aiError: any) {
      if (
        i < 2 &&
        (aiError.message.includes("timed out.") ||
          aiError.status === 429 ||
          (aiError.status >= 500 && aiError.status < 600))
      ) {
        await new Promise((res) => setTimeout(res, 2000));
      } else {
        throw new Error(
          `AI prediction title generation failed after 3 retries: ${aiError.message}`
        );
      }
    }
  }
  if (!aiResponseText) {
    throw new Error(
      "AI prediction title generation failed to produce a response."
    );
  }
  let generatedTitle = aiResponseText
    .trim()
    .replace(/^```(?:html|text|json)?\n?|```$/g, "")
    .trim()
    .replace(
      /<!DOCTYPE html>[\s\S]*?<body[^>]*>|(?<=<\/body>)[\s\S]*$|<\/body>|<\/html>|<\/head>|<\/title>|<\/meta>|<\/link>|<\/style>|<style[^>]*>[\s\S]*?<\/style>|<script[^>]*>[\s\S]*?<\/script>/g,
      ""
    )
    .trim()
    .replace(/<html[^>]*>|<body[^>]*>/g, "")
    .trim()
    .replace(/^\s*\n/gm, "")
    .trim()
    .replace(/^(AI JOURNALIST TONE & STYLE:[\s\S]*?\n\n)?/i, "")
    .trim()
    .replace(
      /^(Here's the (title|article|rewritten title|news article|requested article|response)|Article Title|Generated Title|Title):?\s*\n*/i,
      ""
    )
    .trim()
    .replace(/<[^>]*>?/gm, "")
    .replace(/[\*_`#\[\]\n]/g, "")
    .trim();
  if (generatedTitle.length < 10) {
    throw new Error(
      `Generated prediction title failed strict validation (too short).`
    );
  }
  return generatedTitle;
}

async function generatePredictionContent(
  predictionData: any,
  journalistId?: string
): Promise<string> {
  const contentPromptDoc = await AIPrompt.findOne({
    name: PREDICTION_PROMPT_NAME,
    type: "prediction_content",
  });
  if (!contentPromptDoc) {
    console.warn(
      `[AI Generate Content - Func] Prediction prompt "${PREDICTION_PROMPT_NAME}" (type 'prediction_content') not found. Using default internal prompt.`
    );
  }
  const defaultPredictionPrompt = `
You are an expert sports journalist and a charismatic storyteller. Your task is to transform the provided raw match data into a compelling, conversational, and humanized narrative in **PURE HTML** and **TURKISH**. Your writing should be engaging, insightful, and optimized for readability and SEO.

**CRITICAL INSTRUCTIONS:**
1.  **HTML ONLY:** Your entire response **MUST** be pure, valid HTML. Use tags like \`<h2>\`, \`<p>\`, \`<strong>\`, \`<em>\`, \`<ul>\`, and \`<li>\`.
2.  **NO MARKDOWN:** **ABSOLUTELY NO MARKDOWN SYNTAX** is allowed.
3.  **NO PREAMBLE:** Your response must start directly with an HTML tag (e.g., \`<h2>\`).
4.  **LANGUAGE & TONE:** The entire article **MUST** be in Turkish. Adopt a conversational, authoritative, and engaging tone. Ask rhetorical questions to the reader. Use vivid language and analogies to make statistics interesting.

**CONTENT & SEO GUIDELINES:**
*   **Narrative Flow:** Don't just list data. Weave the stats, H2H, and form into a story about the upcoming match.
*   **Subheadings:** Use descriptive \`<h2>\` tags that naturally include keywords (e.g., "Takımların Son Form Durumu," "Kritik Mücadele Alanları").
*   **Keyword Integration:** Naturally use the team names, league name, and related terms like "maç tahmini," "analiz," "kadrolar," and "puan durumu" throughout the text.
*   **Provide Value:** Your analysis should give the reader a deeper understanding of what to expect, beyond just the numbers.

**ARTICLE STRUCTURE (Example Flow):**
1.  **Etkileyici Giriş (Engaging Intro):** Start with a hook. "Futbolseverler nefeslerini tuttu, çünkü {league_name} sahnesinde {home_team_name} ile {away_team_name} arasında nefes kesecek bir mücadele bizleri bekliyor. Peki bu kritik 90 dakikada bizleri neler bekliyor? Gelin, hep birlikte bu dev maçın şifrelerini çözelim."
2.  **Takımların Form Durumu (Team Form):** Analyze the recent form (e.g., "WWDLW"). "Ev sahibi {home_team_name}, son haftalarda {home_form_string} gibi bir form grafiği çizerek rakiplerine gözdağı verdi. Peki bu seri, zorlu rakipleri karşısında devam edebilecek mi?"
3.  **Geçmişin İzleri: H2H Analizi (H2H Analysis):** Discuss past encounters. "İki ekip arasındaki rekabette geçmiş ne söylüyor? Son beş maçlık seriye baktığımızda, dengelerin ne kadar hassas olduğunu görebiliyoruz."
4.  **Puan Durumundaki Yansımalar (Standings Impact):** Explain the stakes. "Bu maç sadece bir galibiyetten çok daha fazlası anlamına geliyor. {home_team_name} için zirve yarışında kalma, {away_team_name} için ise Avrupa potasından kopmama mücadelesi..."
5.  **Fanskor'un Gözünden Maçın Kaderi (Fanskor's Prediction):** State the prediction clearly and justify it conversationally. "Tüm bu verileri bir araya getirdiğimizde, Fanskor'un tescilli analiz motoru ibreyi {predicted_outcome} tarafına çeviriyor. %{confidence} oranındaki bu tahminimizin arkasında, özellikle ev sahibinin form grafiği ve rakibine karşı kurduğu psikolojik üstünlük yatıyor."
6.  **Sonuç ve Beklentiler (Conclusion):** Summarize and look ahead. "Sonuç olarak, taktiksel bir satranç mücadelesi ve bol gollü bir karşılaşma bizleri bekliyor olabilir. Sizce maçın yıldızı kim olacak? Yorumlarınızı bekliyoruz!"

**Provided Match Data:**
\`\`\`json
{match_data}
\`\`\`

**Prediction Article Content (Must start with an HTML tag):**
`;
  let finalContentPrompt = contentPromptDoc?.prompt || defaultPredictionPrompt;
  finalContentPrompt = finalContentPrompt.replace(
    "{match_data}",
    JSON.stringify(predictionData, null, 2)
  );
  let journalistTonePrompt = "";
  if (journalistId) {
    const journalist = await AIJournalist.findById(journalistId);
    if (journalist && journalist.isActive) {
      journalistTonePrompt = `As "${journalist.name}", your unique journalistic voice and tone should be: ${journalist.tonePrompt}\n\n`;
    }
  }
  const fullPrompt = `${journalistTonePrompt}${finalContentPrompt}`;
  let aiResponseText: string = "";
  for (let i = 0; i < 3; i++) {
    try {
      const result: any = await Promise.race([
        model.generateContent(fullPrompt),
        new Promise((_, reject) =>
          setTimeout(
            () =>
              reject(new Error("AI prediction content generation timed out.")),
            120000
          )
        ),
      ]);
      aiResponseText = (await result.response).text();
      break;
    } catch (aiError: any) {
      if (
        i < 2 &&
        (aiError.message.includes("timed out.") ||
          aiError.status === 429 ||
          (aiError.status >= 500 && aiError.status < 600))
      ) {
        await new Promise((res) => setTimeout(res, 3000));
      } else {
        throw new Error(
          `AI prediction content generation failed after 3 retries: ${aiError.message}`
        );
      }
    }
  }
  if (!aiResponseText) {
    throw new Error(
      "AI prediction content generation failed to produce a response."
    );
  }
  let generatedContent = aiResponseText
    .trim()
    .replace(/^```(?:html|text|json)?\n?|```$/g, "")
    .trim()
    .replace(/^(AI JOURNALIST TONE & STYLE:[\s\S]*?\n\n)?/i, "")
    .trim()
    .replace(
      /^(Here's the (article|HTML content|response)|Article):?\s*\n*/i,
      ""
    )
    .trim();
  const hasHtmlTags = /<[a-z][\s\S]*>/i.test(generatedContent);
  const hasMarkdownChars = /[*_`#\[\]]/.test(generatedContent);
  if (!hasHtmlTags || hasMarkdownChars) {
    throw new Error(
      `AI output format error: Content is not valid HTML or still contains Markdown.`
    );
  }
  let finalContent = generatedContent;
  if (finalContent.includes("<h1")) {
    throw new Error(
      `AI output format error: Content unexpectedly contains <h1> tags.`
    );
  }
  return finalContent;
}

// --- POST handler to orchestrate the AI prediction news generation pipeline ---
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }
  await dbConnect();
  let fixtureId: number | null = null;
  let journalistName = "AI Auto-Generator";
  try {
    const {
      fixtureId: inputFixtureId,
      journalistId,
      sportCategory,
    }: {
      fixtureId: number;
      journalistId: string;
      sportCategory?: string;
    } = await request.json();
    fixtureId = inputFixtureId;
    if (!fixtureId || !journalistId) {
      return NextResponse.json(
        { error: "Fixture ID and Journalist ID are required." },
        { status: 400 }
      );
    }
    const existingPost = await Post.findOne({
      originalFixtureId: fixtureId,
      sport: "prediction",
    });
    if (existingPost) {
      return NextResponse.json(
        {
          message: "Prediction post already exists for this fixture.",
          postId: existingPost._id,
        },
        { status: 200 }
      );
    }
    const options = (endpoint: string, params: object) => ({
      method: "GET",
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
      params,
      headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    });
    const [fixtureRes, h2hRes, standingsRes, homeFormRes, awayFormRes] =
      await Promise.all([
        axios.request(options("fixtures", { id: fixtureId })),
        axios.request(
          options("fixtures/headtohead", {
            h2h: `${
              (
                await axios.request(options("fixtures", { id: fixtureId }))
              ).data.response[0].teams.home.id
            }-${
              (
                await axios.request(options("fixtures", { id: fixtureId }))
              ).data.response[0].teams.away.id
            }`,
          })
        ),
        axios.request(
          options("standings", {
            league: (
              await axios.request(options("fixtures", { id: fixtureId }))
            ).data.response[0].league.id,
            season: (
              await axios.request(options("fixtures", { id: fixtureId }))
            ).data.response[0].league.season,
          })
        ),
        axios.request(
          options("fixtures", {
            team: (
              await axios.request(options("fixtures", { id: fixtureId }))
            ).data.response[0].teams.home.id,
            last: 5,
            season: (
              await axios.request(options("fixtures", { id: fixtureId }))
            ).data.response[0].league.season,
          })
        ),
        axios.request(
          options("fixtures", {
            team: (
              await axios.request(options("fixtures", { id: fixtureId }))
            ).data.response[0].teams.away.id,
            last: 5,
            season: (
              await axios.request(options("fixtures", { id: fixtureId }))
            ).data.response[0].league.season,
          })
        ),
      ]);
    const fixtureData = fixtureRes.data.response[0];
    if (!fixtureData) {
      throw new Error(`Fixture data not found for ID: ${fixtureId}`);
    }
    const { home: homeTeam, away: awayTeam } = fixtureData.teams;
    const league = fixtureData.league;
    const predictionResult = generateSimplePrediction({
      fixture: fixtureData,
      h2h: h2hRes.data.response || [],
      standings: standingsRes.data.response || [],
      homeTeamForm: homeFormRes.data.response || [],
      awayTeamForm: awayFormRes.data.response || [],
    });
    const fullPredictionDataForAI = {
      fixture: fixtureData,
      h2h: h2hRes.data.response,
      standings: standingsRes.data.response,
      homeTeamForm: homeFormRes.data.response,
      awayTeamForm: awayFormRes.data.response,
      fanskorPrediction: predictionResult,
    };
    const journalist = await AIJournalist.findById(journalistId);
    if (journalist && journalist.isActive) {
      journalistName = journalist.name;
    }
    const newPostTitle = await generatePredictionTitle(
      homeTeam.name,
      awayTeam.name,
      league.name,
      predictionResult.text,
      journalistId
    );
    const predictionContent = await generatePredictionContent(
      fullPredictionDataForAI,
      journalistId
    );
    let featuredImageUrl: string | null = null;
    let featuredImageTitle: string | undefined = undefined;
    let featuredImageAltText: string | undefined = undefined;
    const teamLogoUrls = [homeTeam.logo, awayTeam.logo].filter(Boolean);
    if (teamLogoUrls.length > 0) {
      featuredImageUrl = await uploadImageToR2(
        homeTeam.logo || awayTeam.logo,
        `${homeTeam.name}-vs-${awayTeam.name}-prediction`
      );
    }
    featuredImageTitle = `${homeTeam.name} vs ${awayTeam.name} Maç Tahmini`;
    featuredImageAltText = `${homeTeam.name} ve ${awayTeam.name} arasındaki maç tahmini kapak görseli`;
    const postSlug = slugify(newPostTitle, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });
    const existingPostWithSlug = await Post.findOne({ slug: postSlug });
    let finalSlug = postSlug;
    if (existingPostWithSlug) {
      finalSlug = `${postSlug}-${Date.now().toString().slice(-5)}`;
    }
    const plainTextContent = predictionContent.replace(/<[^>]*>?/gm, "");
    const newPost = new Post({
      title: newPostTitle,
      content: predictionContent,
      status: "draft",
      slug: finalSlug,
      author: journalistName,
      featuredImage: featuredImageUrl,
      featuredImageTitle: featuredImageTitle,
      featuredImageAltText: featuredImageAltText,
      // --- MODIFIED: Assign multiple categories ---
      sport: ["prediction", sportCategory || "football"] as PostCategory[],
      metaTitle: `${newPostTitle} | Maç Tahmini`,
      metaDescription: plainTextContent.substring(0, 150) + "...",
      isAIGenerated: true,
      originalFixtureId: fixtureId,
    });

    await newPost.save();
    return NextResponse.json(
      {
        message: "Prediction news generated successfully!",
        postId: newPost._id,
        postSlug: newPost.slug,
      },
      { status: 201 }
    );
  } catch (error: any) {
    let errorMessage = "Server error generating prediction news.";
    let clientStatus = 500;
    if (error instanceof Error) {
      errorMessage = error.message;
      if (errorMessage.includes("AI determined content insufficient")) {
        clientStatus = 200;
      } else if (
        errorMessage.includes("AI output format error") ||
        errorMessage.includes("AI prediction title generation failed") ||
        errorMessage.includes("AI prediction content generation failed")
      ) {
        clientStatus = 422;
      } else if (errorMessage.includes("AI generation timed out")) {
        clientStatus = 504;
      } else if (errorMessage.includes("Fixture data not found")) {
        clientStatus = 404;
      } else if (axios.isAxiosError(error) && error.response) {
        errorMessage = `External API error: ${
          error.response.data?.error ||
          error.response?.data?.errors?.requests ||
          error.message
        }`;
        clientStatus = error.response.status || 500;
      } else if (errorMessage.includes("quota")) {
        errorMessage =
          "Gemini API Quota Exceeded. Please check your usage in Google AI Studio.";
        clientStatus = 429;
      }
    }
    console.error(
      `[Process Prediction Orchestrator] Critical error for fixture ${
        fixtureId || "unknown"
      }: ${errorMessage}`,
      "\nFull Error Object:",
      error
    );
    return NextResponse.json({ error: errorMessage }, { status: clientStatus });
  }
}


// ===== src/app/api/admin/process-external-news/route.ts =====

// src/app/api/admin/process-external-news/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import ExternalNewsArticle, {
  IExternalNewsArticle,
} from "@/models/ExternalNewsArticle";
import Post, { PostCategory } from "@/models/Post";
import AIPrompt from "@/models/AIPrompt";
import AIJournalist from "@/models/AIJournalist";
import { GoogleGenerativeAI } from "@google/generative-ai";
import axios from "axios";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import sharp from "sharp";
import crypto from "crypto";
import slugify from "slugify";
import path from "path";

const s3Client = new S3Client({
  region: "auto",
  endpoint: process.env.NEXT_PUBLIC_R2_ENDPOINT as string,
  credentials: {
    accessKeyId: process.env.NEXT_PUBLIC_R2_ACCESS_KEY_ID as string,
    secretAccessKey: process.env.NEXT_PUBLIC_R2_SECRET_ACCESS_KEY as string,
  },
});
const R2_BUCKET_NAME = process.env.NEXT_PUBLIC_R2_BUCKET_NAME as string;
const R2_PUBLIC_URL = process.env.NEXT_PUBLIC_R2_PUBLIC_BUCKET_URL as string;
const generateFileName = (bytes = 32) =>
  crypto.randomBytes(bytes).toString("hex");

async function proxyAndUploadOriginalImage(
  imageUrl: string,
  newPostTitle: string
): Promise<string | null> {
  try {
    const imageResponse = await axios.get(imageUrl, {
      responseType: "arraybuffer",
      timeout: 15000,
      maxRedirects: 5,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });
    const inputBuffer = Buffer.from(imageResponse.data, "binary");
    const originalContentType =
      imageResponse.headers["content-type"] || "image/jpeg";
    let finalBuffer: Buffer;
    let finalContentType: string = originalContentType;
    let fileExtension: string;
    if (originalContentType.includes("image/gif")) {
      finalBuffer = inputBuffer;
      finalContentType = "image/gif";
      fileExtension = ".gif";
    } else {
      try {
        finalBuffer = await sharp(inputBuffer)
          .resize(1200, 630, { fit: "inside", withoutEnlargement: true })
          .webp({ quality: 80 })
          .toBuffer();
        finalContentType = "image/webp";
        fileExtension = ".webp";
      } catch (sharpError: any) {
        finalBuffer = inputBuffer;
        finalContentType = originalContentType;
        fileExtension = path.extname(new URL(imageUrl).pathname) || ".jpg";
      }
    }
    const slug = slugify(newPostTitle, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });
    const uniqueSuffix = Date.now().toString().slice(-6);
    const newFileName = `fanskor-${slug}-${uniqueSuffix}${fileExtension}`;
    const putObjectCommand = new PutObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: newFileName,
      Body: finalBuffer,
      ContentType: finalContentType,
    });
    await s3Client.send(putObjectCommand);
    return `${R2_PUBLIC_URL}/${newFileName}`;
  } catch (imageError: any) {
    console.error(
      `[Image Processing] Failed to process/upload original image (URL: ${imageUrl}):`,
      imageError.message
    );
    return null;
  }
}
const genAI = new GoogleGenerativeAI(
  process.env.NEXT_PUBLIC_GEMINI_API_KEY as string
);
const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });
const TITLE_PROMPT_NAME = "AI Title Generation";
const CONTENT_PROMPT_NAME = "AI Content Generation";
interface IAIPrompt {
  _id: string;
  name: string;
  prompt: string;
  description?: string;
  type: "title" | "content" | "prediction_content";
}

function calculateJaccardSimilarity(str1: string, str2: string): number {
  const words1 = new Set(str1.toLowerCase().split(/\s+/).filter(Boolean));
  const words2 = new Set(str2.toLowerCase().split(/\s+/).filter(Boolean));
  if (words1.size === 0 && words2.size === 0) return 1.0;
  if (words1.size === 0 || words2.size === 0) return 0.0;
  const intersection = new Set([...words1].filter((word) => words2.has(word)));
  const union = new Set([...words1, ...words2]);
  return intersection.size / union.size;
}
async function fetchAndExtractWebpageContent(
  url: string
): Promise<string | null> {
  try {
    const response = await axios.get(url, {
      timeout: 10000,
      maxRedirects: 5,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
      },
    });
    if (response.status !== 200) {
      return null;
    }
    const cheerio = require("cheerio");
    const $ = cheerio.load(response.data);
    const contentSelectors = [
      "article",
      "main",
      ".article-content",
      ".post-content",
      ".entry-content",
      ".story-content",
      ".body-content",
      "#article-body",
      "#main-content",
      "#content",
      "p",
    ];
    let extractedText = "";
    for (const selector of contentSelectors) {
      const element = $(selector);
      if (element.length > 0) {
        element
          .find(
            "script, style, header, footer, nav, aside, form, iframe, .ad-unit"
          )
          .remove();
        extractedText = element.text();
        if (extractedText.length > 200) break;
      }
    }
    extractedText = extractedText.replace(/\s\s+/g, " ").trim();
    return extractedText.length > 0 ? extractedText : null;
  } catch (error: any) {
    console.error(
      `[Content Extraction Helper] Error fetching or extracting content from ${url}:`,
      error.message
    );
    return null;
  }
}
async function generateTitle(
  originalTitle: string,
  originalDescription: string,
  journalistId?: string
): Promise<string> {
  const titlePromptDoc = await AIPrompt.findOne({
    name: TITLE_PROMPT_NAME,
    type: "title",
  });
  const defaultTitlePrompt =
    "YOUR ONLY TASK IS TO GENERATE A NEWS ARTICLE TITLE IN TURKISH. Output MUST be plain text only, on a single line. NO HTML, NO Markdown. NO preambles. NO prefixes like 'Title: '.\\n\\nYou are an expert sports journalist. Generate a **new, original, SEO-friendly title in TURKISH** for a news article based on the following original title and description. The new title MUST be highly distinct from the original, capture a fresh angle, and avoid simply rephrasing original keywords.\\n\\nOriginal Title: {original_title}\\nOriginal Description: {original_description}\\n\\nGenerated Title:";
  let finalTitlePrompt = titlePromptDoc?.prompt || defaultTitlePrompt;
  let journalistTonePrompt = "";
  if (journalistId) {
    const journalist = await AIJournalist.findById(journalistId);
    if (journalist && journalist.isActive) {
      journalistTonePrompt = `As "${journalist.name}", your unique journalistic voice and tone should be: ${journalist.tonePrompt}\n\n`;
    }
  }
  const fullPrompt = `${journalistTonePrompt}${finalTitlePrompt}`
    .replace("{original_title}", originalTitle)
    .replace("{original_description}", originalDescription);
  let aiResponseText: string = "";
  for (let i = 0; i < 3; i++) {
    try {
      const result: any = await Promise.race([
        model.generateContent(fullPrompt),
        new Promise((_, reject) =>
          setTimeout(
            () => reject(new Error("AI title generation timed out.")),
            20000
          )
        ),
      ]);
      aiResponseText = (await result.response).text();
      break;
    } catch (aiError: any) {
      if (
        i < 2 &&
        (aiError.message.includes("timed out.") ||
          aiError.status === 429 ||
          (aiError.status >= 500 && aiError.status < 600))
      ) {
        await new Promise((res) => setTimeout(res, 2000));
      } else {
        throw new Error(
          `AI title generation failed after 3 retries: ${aiError.message}`
        );
      }
    }
  }
  if (!aiResponseText) {
    throw new Error("AI title generation failed to produce a response.");
  }
  let generatedTitle = aiResponseText
    .trim()
    .replace(/^```(?:html|text|json)?\n?|```$/g, "")
    .trim()
    .replace(
      /<!DOCTYPE html>[\s\S]*?<body[^>]*>|(?<=<\/body>)[\s\S]*$|<\/body>|<\/html>|<\/head>|<\/title>|<\/meta>|<\/link>|<\/style>|<style[^>]*>[\s\S]*?<\/style>|<script[^>]*>[\s\S]*?<\/script>/g,
      ""
    )
    .trim()
    .replace(/<html[^>]*>|<body[^>]*>/g, "")
    .trim()
    .replace(/^\s*\n/gm, "")
    .trim()
    .replace(/^(AI JOURNALIST TONE & STYLE:[\s\S]*?\n\n)?/i, "")
    .trim()
    .replace(
      /^(Here's the (title|article|rewritten title|news article|requested article|response)|Article Title|Generated Title|Title):?\s*\n*/i,
      ""
    )
    .trim()
    .replace(/<[^>]*>?/gm, "")
    .replace(/[\*_`#\[\]\n]/g, "")
    .trim();
  const originalTitleLower = originalTitle.toLowerCase();
  const generatedTitleLower = generatedTitle.toLowerCase();
  const jaccardSimilarity = calculateJaccardSimilarity(
    originalTitleLower,
    generatedTitleLower
  );
  if (
    generatedTitle.length < 10 ||
    jaccardSimilarity > 0.4 ||
    generatedTitleLower === originalTitleLower
  ) {
    throw new Error(
      `Generated title failed strict validation (too short, not unique, or too similar).`
    );
  }
  return generatedTitle;
}
async function generateContent(
  originalTitle: string,
  originalDescription: string,
  originalContent: string | null,
  articleLink: string,
  generatedTitle: string,
  journalistId?: string
): Promise<string> {
  const contentPromptDoc = await AIPrompt.findOne({
    name: CONTENT_PROMPT_NAME,
    type: "content",
  });
  const defaultContentPrompt =
    "Your ONLY task is to generate a news article content in TURKISH HTML. NO Markdown, NO preambles, NO extra text, NO code block wrappers (```html). DO NOT INCLUDE `<!DOCTYPE html>`, `<html>`, `<head>`, `<body>`, `<h1>`, or any other full document tags. \\n\\nYou are an expert sports journalist. Analyze the following news title, description, and provided context. Your goal is to generate a comprehensive, human-like, SEO-optimized HTML article, approximately 700 words long. Focus on deep insights, storytelling, and compelling analysis.\\n\\n**GUIDELINES:**\\n1.  **HTML CONTENT:** Provide valid HTML. Use `<h2>` for main headings (optimized for keywords), `<p>` for paragraphs, `<strong>`, `<em>`, `<ul>`, `<li>`, `<a>`. Ensure natural flow, rich detail, and human tone. Integrate relevant keywords naturally throughout the article for SEO, but avoid stuffing.\\n\\n**HTML Example Structure:**\\n<h2>Giriş Başlığı</h2><p>Bu, makale içeriğinin zeminini hazırlayan etkileyici giriş paragrafıdır...</p>\\n<h2>Ana Gelişmeler</h2><p>İşte belirli bir yönüyle ilgili detaylı bir paragraf...</p><ul><li>...</li></ul><p>...</p><h2>Sonuç</h2><p>Sonuç paragrafı, makalenin ana noktalarını özetler ve ileriye dönük etkileyici bir bakış açısı sunar.</p>\\n\\n**ÖNEMLİ:** Sağlanan içerik 700 kelimelik SEO optimize edilmiş bir genişletme için çok kısaysa veya yeterli ayrıntıdan yoksunsa, SADECE 'GENİŞLETME İÇİN İÇERİK YETERSİZ: [kısa neden]' yanıtını verin. Başka hiçbir metin kullanmayın.\\n\\nGenerated Article Title: {generated_title}\\nOriginal News Title: {original_title}\\nOriginal News Description: {original_description}\\nAdditional Context: {additional_context}";
  let finalContentPrompt = contentPromptDoc?.prompt || defaultContentPrompt;
  let journalistTonePrompt = "";
  if (journalistId) {
    const journalist = await AIJournalist.findById(journalistId);
    if (journalist && journalist.isActive) {
      journalistTonePrompt = `As "${journalist.name}", your unique journalistic voice and tone should be: ${journalist.tonePrompt}\n\n`;
    }
  }
  let combinedArticleContext = "";
  if (originalTitle) combinedArticleContext += `Title: ${originalTitle}\\n`;
  if (originalDescription)
    combinedArticleContext += `Description: ${originalDescription}\\n`;
  if (originalContent && originalContent.length > 50) {
    combinedArticleContext += `\\nFull Content: ${originalContent}\\n`;
  }
  if (articleLink && combinedArticleContext.length < 100) {
    const fetchedWebContent = await fetchAndExtractWebpageContent(articleLink);
    if (fetchedWebContent && fetchedWebContent.length > 50) {
      combinedArticleContext += `\\nWebpage Context: ${fetchedWebContent}\\n`;
    }
  }
  if (!combinedArticleContext || combinedArticleContext.length < 100) {
    throw new Error(
      "Article content (title, description, or external content) too short or missing to generate content."
    );
  }
  if (combinedArticleContext.length > 8000) {
    combinedArticleContext =
      combinedArticleContext.substring(0, 8000) +
      "... (truncated for AI processing)";
  }
  const fullPrompt = `${journalistTonePrompt}${finalContentPrompt}`
    .replace("{generated_title}", generatedTitle)
    .replace("{original_title}", originalTitle)
    .replace("{original_description}", originalDescription)
    .replace("{additional_context}", combinedArticleContext);
  let aiResponseText: string = "";
  for (let i = 0; i < 3; i++) {
    try {
      const result: any = await Promise.race([
        model.generateContent(fullPrompt),
        new Promise((_, reject) =>
          setTimeout(
            () => reject(new Error("AI content generation timed out.")),
            90000
          )
        ),
      ]);
      aiResponseText = (await result.response).text();
      break;
    } catch (aiError: any) {
      if (
        i < 2 &&
        (aiError.message.includes("timed out.") ||
          aiError.status === 429 ||
          (aiError.status >= 500 && aiError.status < 600))
      ) {
        await new Promise((res) => setTimeout(res, 3000));
      } else {
        throw new Error(
          `AI content generation failed after 3 retries: ${aiError.message}`
        );
      }
    }
  }
  if (!aiResponseText) {
    throw new Error("AI content generation failed to produce a response.");
  }
  let generatedContent = aiResponseText
    .trim()
    .replace(/^```(?:html|text|json)?\n?|```$/g, "")
    .trim()
    .replace(
      /<!DOCTYPE html>[\s\S]*?<body[^>]*>|(?<=<\/body>)[\s\S]*$|<\/body>|<\/html>|<\/head>|<\/title>|<\/meta>|<\/link>|<\/style>|<style[^>]*>[\s\S]*?<\/style>|<script[^>]*>[\s\S]*?<\/script>/g,
      ""
    )
    .trim()
    .replace(/<html[^>]*>|<body[^>]*>/g, "")
    .trim()
    .replace(/^\s*\n/gm, "")
    .trim()
    .replace(/^(AI JOURNALIST TONE & STYLE:[\s\S]*?\n\n)?/i, "")
    .trim()
    .replace(
      /^(Here's the (article|rewritten article|news article|requested article|response)|Article|News Article|Your Article|Generated Article|Title):?\s*\n*/i,
      ""
    )
    .trim();
  if (generatedContent.includes("---START_CONTENT---")) {
    generatedContent =
      generatedContent.split("---START_CONTENT---")[1] || generatedContent;
  }
  if (
    generatedContent
      .toUpperCase()
      .includes("CONTENT INSUFFICIENT FOR EXPANSION")
  ) {
    throw new Error("AI determined content insufficient for expansion.");
  }
  const MarkdownIt = require("markdown-it");
  const md = new MarkdownIt({ html: true, linkify: true, typographer: true });
  let finalContent = md.render(generatedContent);
  const hasHtmlTags = /<[a-z][\s\S]*>/i.test(finalContent);
  const hasMarkdownChars = /[*_`#\[\]]/.test(finalContent);
  if (!hasHtmlTags || hasMarkdownChars) {
    throw new Error(
      `AI output format error: Content is not valid HTML after post-processing or still contains Markdown.`
    );
  }
  if (finalContent.includes("<h1")) {
    throw new Error(
      `AI output format error: Content unexpectedly contains <h1> tags.`
    );
  }
  return finalContent;
}

// POST handler to orchestrate the AI processing pipeline
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  let externalArticle: IExternalNewsArticle | null = null;
  let journalistName = "AI Auto-Generator";

  try {
    const {
      articleId,
      sportCategory, // This is the single category passed from the UI
      journalistId,
    }: { articleId: string; sportCategory?: string; journalistId?: string } =
      await request.json();

    if (!articleId) {
      console.error("[Process Article Orchestrator] Missing Article ID.");
      return NextResponse.json(
        { error: "Article ID is required." },
        { status: 400 }
      );
    }

    externalArticle = await ExternalNewsArticle.findOne({ articleId });

    if (!externalArticle) {
      return NextResponse.json(
        { error: "External news article not found." },
        { status: 404 }
      );
    }
    if (externalArticle.status === "processed") {
      return NextResponse.json(
        { message: "Article already processed." },
        { status: 200 }
      );
    }
    if (externalArticle.status === "processing") {
      return NextResponse.json(
        { error: "Article is already being processed. Please wait." },
        { status: 409 }
      );
    }

    externalArticle.status = "processing";
    await externalArticle.save();

    if (journalistId) {
      const journalist = await AIJournalist.findById(journalistId);
      if (journalist && journalist.isActive) {
        journalistName = journalist.name;
      }
    }

    const newPostTitle = await generateTitle(
      externalArticle.title,
      externalArticle.description || "",
      journalistId
    );
    const rewrittenContent = await generateContent(
      externalArticle.title,
      externalArticle.description || "",
      externalArticle.content,
      externalArticle.link,
      newPostTitle,
      journalistId
    );

    let featuredImageUrl: string | null = null;
    if (externalArticle.imageUrl) {
      featuredImageUrl = await proxyAndUploadOriginalImage(
        externalArticle.imageUrl,
        newPostTitle
      );
    }
    const featuredImageTitle = newPostTitle;
    const featuredImageAltText = `${newPostTitle} image`;

    const postSlug = slugify(newPostTitle, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });
    const existingPostWithSlug = await Post.findOne({ slug: postSlug });
    let finalSlug = postSlug;
    if (existingPostWithSlug) {
      finalSlug = `${postSlug}-${Date.now().toString().slice(-5)}`;
    }

    const plainTextContent = rewrittenContent.replace(/<[^>]*>?/gm, "");

    // --- MODIFIED: Create categories array ---
    // Start with the category passed from the UI (e.g., 'football').
    // Then, add the category from the external source if it exists and is valid.
    const categories: PostCategory[] = [];
    if (
      sportCategory &&
      ["football", "basketball", "tennis", "general"].includes(sportCategory)
    ) {
      categories.push(sportCategory as PostCategory);
    }

    const sourceCategory = externalArticle.category?.[0];
    if (
      sourceCategory &&
      ["football", "basketball", "tennis", "general"].includes(
        sourceCategory
      ) &&
      !categories.includes(sourceCategory as PostCategory)
    ) {
      categories.push(sourceCategory as PostCategory);
    }

    // If no valid category was found, default to 'general'.
    if (categories.length === 0) {
      categories.push("general");
    }

    const newPost = new Post({
      title: newPostTitle,
      content: rewrittenContent,
      status: "draft",
      slug: finalSlug,
      author: journalistName,
      featuredImage: featuredImageUrl,
      featuredImageTitle: featuredImageTitle,
      featuredImageAltText: featuredImageAltText,
      // --- MODIFIED: Assign the new categories array ---
      sport: categories,
      metaTitle: `${newPostTitle} - Sports News`,
      metaDescription: plainTextContent.substring(0, 150) + "...",
      isAIGenerated: true,
      originalExternalArticleId: externalArticle._id,
    });

    await newPost.save();

    externalArticle.status = "processed";
    externalArticle.processedPostId = newPost._id;
    await externalArticle.save();

    return NextResponse.json(
      {
        message: "Article processed and new post created successfully.",
        postId: newPost._id,
        postSlug: newPost.slug,
      },
      { status: 201 }
    );
  } catch (error: any) {
    // --- Centralized Error Handling (Unchanged) ---
    let errorMessage = "Server error processing external news.";
    let clientStatus = 500;
    let finalArticleStatus: "skipped" | "error" = "error";

    if (error instanceof Error) {
      errorMessage = error.message;
      if (errorMessage.includes("AI determined content insufficient")) {
        clientStatus = 200;
        finalArticleStatus = "skipped";
      } else if (
        errorMessage.includes("AI output format error") ||
        errorMessage.includes("AI-generated title failed strict validation") ||
        errorMessage.includes("Content generation failed") ||
        errorMessage.includes("Title generation failed")
      ) {
        clientStatus = 422;
      } else if (errorMessage.includes("AI generation timed out")) {
        clientStatus = 504;
      } else if (
        errorMessage.includes("Article has no content") ||
        errorMessage.includes("content too short")
      ) {
        clientStatus = 400;
        finalArticleStatus = "skipped";
      } else if (errorMessage.includes("AI generation failed after")) {
        clientStatus = 500;
      } else if (errorMessage.includes("quota")) {
        errorMessage =
          "Gemini API Quota Exceeded. Please check your usage in Google AI Studio.";
        clientStatus = 429;
      } else if (axios.isAxiosError(error) && error.response) {
        errorMessage = `External API error: ${
          error.response.data?.error ||
          error.response?.data?.results?.message ||
          error.message
        }`;
        clientStatus = error.response.status || 500;
      }
    }

    if (externalArticle && externalArticle.status === "processing") {
      externalArticle.status = finalArticleStatus;
      await externalArticle.save();
    }

    return NextResponse.json({ error: errorMessage }, { status: clientStatus });
  }
}


// ===== src/app/api/admin/upcoming-fixtures-for-prediction/route.ts =====

// src/app/api/admin/upcoming-fixtures-for-prediction/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post from "@/models/Post";
import axios from "axios";
import { format, addDays } from "date-fns";

// The list of leagues we want to generate predictions for.
const LEAGUES_TO_PREDICT = new Set([
  // Using a Set for efficient O(1) lookups.
  // Top 5 European Leagues
  39, 140, 135, 78, 61,
  // Major UEFA Competitions
  2, 3, 848,
  // Other Popular European Leagues
  88, 94, 203, 197, 218, 144,
  // Americas
  253, 262, 71, 128,
  // Key National Cups
  45, 143, 137, 81,
  // Other Active Leagues
  98, 292, 179,
  // International Club Competitions
  11, 13, 4,
]);

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  await dbConnect();

  const { searchParams } = new URL(request.url);
  const limit = parseInt(searchParams.get("limit") || "10");
  const skip = parseInt(searchParams.get("skip") || "0");

  // --- NEW, MORE RELIABLE STRATEGY ---
  // Create an array of API calls, one for each of the next 7 days.
  const datePromises = [];
  for (let i = 0; i < 7; i++) {
    const date = format(addDays(new Date(), i), "yyyy-MM-dd");
    const apiOptions = {
      method: "GET",
      url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
      params: { date: date, timezone: "Europe/Istanbul" }, // Query for ALL matches on a specific date.
      headers: {
        "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
      },
    };
    datePromises.push(axios.request(apiOptions));
  }

  try {
    const responses = await Promise.allSettled(datePromises);

    // Aggregate all fixtures from all successful daily requests.
    const allFetchedFixtures: any[] = responses
      .filter(
        (result) => result.status === "fulfilled" && result.value.data.response
      )
      .flatMap(
        (result) => (result as PromiseFulfilledResult<any>).value.data.response
      );

    console.log(
      `[API/upcoming-fixtures] Fetched a total of ${allFetchedFixtures.length} fixtures from the API across the next 7 days.`
    );

    // Now, filter this large list on our server.
    const finishedOrCancelledStatuses = new Set([
      "FT",
      "AET",
      "PEN",
      "PST",
      "CANC",
      "ABD",
      "AWD",
      "WO",
    ]);

    const upcomingFixtures = allFetchedFixtures.filter(
      (fixture) =>
        // 1. Must be from a league we care about.
        LEAGUES_TO_PREDICT.has(fixture.league.id) &&
        // 2. Must not be finished or cancelled.
        !finishedOrCancelledStatuses.has(fixture.fixture.status.short) &&
        // 3. Must have valid data.
        fixture.fixture &&
        fixture.fixture.id &&
        fixture.teams?.home &&
        fixture.teams?.away
    );

    console.log(
      `[API/upcoming-fixtures] Filtered down to ${upcomingFixtures.length} valid upcoming fixtures from our target leagues.`
    );

    // --- The rest of the logic remains the same ---

    // Fetch existing prediction posts to mark processed fixtures
    const fixtureIds = upcomingFixtures.map((f) => f.fixture.id);
    const processedPredictions = await Post.find({
      sport: "prediction",
      originalFixtureId: { $in: fixtureIds },
    })
      .select("originalFixtureId _id")
      .lean();

    const processedMap = new Map(
      processedPredictions.map((post) => [post.originalFixtureId, post._id])
    );

    const enhancedFixtures = upcomingFixtures.map((fixture) => ({
      ...fixture,
      processedPostId:
        processedMap.get(fixture.fixture.id)?.toString() || undefined,
    }));

    enhancedFixtures.sort((a, b) => {
      const dateA = new Date(a.fixture.date).getTime();
      const dateB = new Date(b.fixture.date).getTime();
      return dateA - dateB;
    });

    const paginatedFixtures = enhancedFixtures.slice(skip, skip + limit);

    return NextResponse.json(
      {
        fixtures: paginatedFixtures,
        totalCount: enhancedFixtures.length,
        currentPage: Math.floor(skip / limit) + 1,
        perPage: limit,
      },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      "[API/admin/upcoming-fixtures-for-prediction] Error fetching upcoming fixtures:",
      error.message
    );
    return NextResponse.json(
      { error: "Server error fetching upcoming fixtures for prediction." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/auth/[...nextauth]/route.ts =====

// src/app/api/auth/[...nextauth]/route.ts

import NextAuth, { NextAuthOptions } from "next-auth";
// --- Adapter Imports ---
import { MongoDBAdapter } from "@auth/mongodb-adapter";
import clientPromise from "@/lib/mongoClient";

// --- Provider Imports ---
import GoogleProvider from "next-auth/providers/google";
import CredentialsProvider from "next-auth/providers/credentials";

// --- Mongoose Imports (for Credentials Provider) ---
import dbConnect from "@/lib/dbConnect";
import User, { IUser } from "@/models/User"; // <-- Import IUser
import bcrypt from "bcrypt";

export const authOptions: NextAuthOptions = {
  adapter: MongoDBAdapter(clientPromise),

  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
    CredentialsProvider({
      name: 'Credentials',
      credentials: { },
      async authorize(credentials: any) {
        if (!credentials?.email || !credentials.password) {
          throw new Error('Please enter an email and password');
        }
        
        await dbConnect(); 
        
        const user = await User.findOne({ email: credentials.email }).select('+password');
        
        if (!user || !user.password) {
          throw new Error('Invalid credentials');
        }

        const isPasswordCorrect = await bcrypt.compare(
          credentials.password,
          user.password
        );

        if (!isPasswordCorrect) {
          throw new Error('Invalid credentials');
        }

        // Return the full user object on success
        return user;
      }
    })
  ],
  
  session: { strategy: "jwt" },

  // --- THIS IS THE NEW/UPDATED PART ---
  callbacks: {
    // This callback is called whenever a JWT is created or updated.
    // We want to add the user's role and ID to the token.
    jwt: async ({ token, user }) => {
      if (user) {
        const u = user as IUser; // Cast to our user type
        token.role = u.role;
        token.id = u.id;
      }
      return token;
    },

    // This callback is called whenever a session is checked.
    // We want to add the role and ID from the token to the session object.
    session: async ({ session, token }) => {
      if (session?.user) {
        session.user.role = token.role as 'user' | 'admin';
        session.user.id = token.id as string;
      }
      return session;
    },
  },
  // --- END OF NEW/UPDATED PART ---

  pages: { signIn: "/login" },
  secret: process.env.NEXT_PUBLIC_NEXTAUTH_SECRET,
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };

// ===== src/app/api/banners/route.ts =====

// src/app/api/banners/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Banner, { IBanner } from "@/models/Banner";

// GET handler remains the same...
export async function GET(request: Request) {
  // ... no changes here
  const { searchParams } = new URL(request.url);
  const activeOnly = searchParams.get("active") === "true";
  const location = searchParams.get("location");

  const query: { isActive?: boolean; location?: string } = {};
  if (activeOnly) {
    query.isActive = true;
  }
  if (location) {
    query.location = location;
  }

  try {
    await dbConnect();
    const banners = await Banner.find(query).sort({ createdAt: -1 });
    return NextResponse.json(banners);
  } catch (error) {
    console.error("Failed to fetch banners:", error);
    return NextResponse.json(
      { error: "Server error fetching banners" },
      { status: 500 }
    );
  }
}

// --- POST a New Banner ---
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body: Partial<IBanner> = await request.json();

    console.log(
      "[API/Banners] Received POST request with body:",
      JSON.stringify(body, null, 2)
    );

    const { title, imageUrl, linkUrl, isActive, location } = body;

    if (!title || !imageUrl || !linkUrl || !location) {
      console.error(
        "[API/Banners] Validation failed. Missing required fields."
      );
      return NextResponse.json(
        { error: "Title, Image URL, Link URL, and Location are required" },
        { status: 400 }
      );
    }

    await dbConnect();

    // Mongoose will now correctly use the schema that includes 'location'
    const newBanner = new Banner({
      title,
      imageUrl,
      linkUrl,
      isActive,
      location,
    });

    await newBanner.save(); // This would throw an error if location was missing and the schema was loaded correctly
    console.log("[API/Banners] New banner created successfully:", newBanner);
    return NextResponse.json(newBanner, { status: 201 });
  } catch (error: any) {
    console.error("[API/Banners] Failed to create banner:", error.message);
    return NextResponse.json(
      { error: "Server error creating banner" },
      { status: 500 }
    );
  }
}


// ===== src/app/api/banners/[bannerId]/route.ts =====

// src/app/api/banners/[bannerId]/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Banner, { IBanner } from "@/models/Banner";

interface Params {
  params: { bannerId: string };
}

// --- PUT (Update) a Banner ---
// Protected: Only admins can update.
export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { bannerId } = params;
  try {
    const body: Partial<IBanner> = await request.json();
    // --- THE FIX IS HERE ---
    // Destructure ALL fields from the body that you intend to update.
    const { title, imageUrl, linkUrl, isActive, location } = body;

    await dbConnect();

    const updatedBanner = await Banner.findByIdAndUpdate(
      bannerId,
      {
        // Pass an explicit object with all the fields to Mongoose.
        // This ensures 'location' is included in the update.
        title,
        imageUrl,
        linkUrl,
        isActive,
        location,
      },
      { new: true, runValidators: true }
    );

    if (!updatedBanner) {
      return NextResponse.json({ error: "Banner not found" }, { status: 404 });
    }

    return NextResponse.json(updatedBanner);
  } catch (error) {
    console.error("Error updating banner:", error);
    return NextResponse.json(
      { error: "Server error updating banner" },
      { status: 500 }
    );
  }
}

// --- DELETE a Banner ---
// (No changes needed for the DELETE handler)
export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { bannerId } = params;
  try {
    await dbConnect();
    const deletedBanner = await Banner.findByIdAndDelete(bannerId);
    if (!deletedBanner) {
      return NextResponse.json({ error: "Banner not found" }, { status: 404 });
    }
    return NextResponse.json({ message: "Banner deleted successfully" });
  } catch (error) {
    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}


// ===== src/app/api/batch-predictions/route.ts =====

// src/app/api/batch-predictions/route.ts
import { NextResponse } from "next/server";
import axios from "axios";
import {
  generateSimplePrediction,
  PredictionResult,
} from "@/lib/prediction-engine";
import { convertPercentageToOdds } from "@/lib/odds-converter";
import {
  ApiSportsFixture,
  ApiSportsStandings,
} from "@/services/sportsApi/allsportsApiService";

type FanskorOdds = {
  home: string;
  draw: string;
  away: string;
};

// Reusable helper for making API-Football requests
const apiRequest = async (endpoint: string, params: object): Promise<any> => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };
  try {
    const response = await axios.request(options);
    return response.data.response;
  } catch (error) {
    console.error(
      `Error fetching from API-Football endpoint '${endpoint}':`,
      error
    );
    return []; // Return empty array on error to not break the entire batch
  }
};

/**
 * This API endpoint takes an array of fixture IDs, fetches all necessary data
 * for each fixture, runs the custom prediction engine, and returns a map
 * of fixture IDs to their calculated "Fanskor Odds".
 */
export async function POST(request: Request) {
  try {
    const { fixtureIds }: { fixtureIds: number[] } = await request.json();

    if (!Array.isArray(fixtureIds) || fixtureIds.length === 0) {
      return NextResponse.json(
        { error: "An array of fixture IDs is required." },
        { status: 400 }
      );
    }

    // 1. Fetch all fixture details in one batch
    const fixtures: ApiSportsFixture[] = await apiRequest("fixtures", {
      ids: fixtureIds.join("-"),
    });

    if (!fixtures || fixtures.length === 0) {
      return NextResponse.json({}, { status: 200 }); // Return empty if no valid fixtures found
    }

    // 2. Create an array of promises to fetch all necessary data for each fixture concurrently
    const dataPromises = fixtures.map(async (fixture) => {
      const { teams, league } = fixture;
      const [h2h, standings, homeTeamForm, awayTeamForm] = await Promise.all([
        apiRequest("fixtures/headtohead", {
          h2h: `${teams.home.id}-${teams.away.id}`,
        }),
        apiRequest("standings", { league: league.id, season: league.season }),
        apiRequest("fixtures", {
          team: teams.home.id,
          last: 5,
          season: league.season,
        }),
        apiRequest("fixtures", {
          team: teams.away.id,
          last: 5,
          season: league.season,
        }),
      ]);

      return {
        fixtureId: fixture.fixture.id,
        predictionData: {
          fixture,
          h2h,
          standings,
          homeTeamForm,
          awayTeamForm,
        },
      };
    });

    const allData = await Promise.all(dataPromises);

    // 3. Run the prediction engine for each fixture and create the final odds map
    const oddsMap: Record<number, FanskorOdds> = {};

    allData.forEach((data) => {
      if (data) {
        // Run the prediction engine
        const predictionResult: PredictionResult = generateSimplePrediction(
          data.predictionData
        );

        // Convert the raw prediction scores to percentages
        const totalScore =
          predictionResult.homeScore +
          predictionResult.awayScore +
          predictionResult.drawScore;
        const homePercent = (predictionResult.homeScore / totalScore) * 100;
        const awayPercent = (predictionResult.awayScore / totalScore) * 100;
        const drawPercent = (predictionResult.drawScore / totalScore) * 100;

        // Convert percentages to decimal odds
        oddsMap[data.fixtureId] = {
          home: convertPercentageToOdds(homePercent),
          draw: convertPercentageToOdds(drawPercent),
          away: convertPercentageToOdds(awayPercent),
        };
      }
    });

    return NextResponse.json(oddsMap);
  } catch (error) {
    console.error("[API/batch-predictions] Critical error:", error);
    return NextResponse.json(
      { error: "Failed to generate batch predictions." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/casino-partners/route.ts =====

// src/app/api/casino-partners/route.ts
import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import CasinoPartner from "@/models/CasinoPartner";

// GET handler to retrieve active Casino Partners for public display
export async function GET(request: Request) {
  await dbConnect();

  try {
    const { searchParams } = new URL(request.url);
    const featuredOnly = searchParams.get("featured") === "true";

    const query: { isActive: boolean; isFeatured?: boolean } = {
      isActive: true,
    };
    if (featuredOnly) {
      query.isFeatured = true;
    }

    // Sort by 'order' ascending (lower numbers first), then 'isFeatured' (true first), then random fallback
    // Random fallback helps if multiple partners have the same order/featured status, provides variety
    const partners = await CasinoPartner.aggregate([
      { $match: query }, // Filter by active and optionally featured
      { $addFields: { __rand: { $rand: {} } } }, // Add a random field for tie-breaking
      { $sort: { order: 1, isFeatured: -1, __rand: 1 } }, // Sort by order, then featured (desc), then random
      { $project: { __rand: 0 } }, // Remove the random field from output
      { $limit: 10 }, // Limit the number of partners returned to a reasonable amount
    ]);

    return NextResponse.json(partners, { status: 200 });
  } catch (error: any) {
    console.error("Error fetching Casino Partners (Public):", error.message);
    return NextResponse.json(
      { error: "Server error fetching Casino Partners." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/contact/route.ts =====

// src/app/api/contact/route.ts
import { NextResponse } from "next/server";

interface ContactFormData {
  name: string;
  email: string;
  subject: string;
  message: string;
}

export async function POST(request: Request) {
  try {
    const { name, email, subject, message }: ContactFormData =
      await request.json();

    // Basic validation
    if (!name || !email || !subject || !message) {
      return NextResponse.json(
        { error: "All fields are required." },
        { status: 400 }
      );
    }
    if (!email.includes("@") || !email.includes(".")) {
      return NextResponse.json(
        { error: "Please enter a valid email address." },
        { status: 400 }
      );
    }

    console.log("[Contact API] New contact form submission:");
    console.log(`- Name: ${name}`);
    console.log(`- Email: ${email}`);
    console.log(`- Subject: ${subject}`);
    console.log(`- Message: ${message}`);

    // --- Placeholder for actual email sending logic ---
    // In a real application, you would integrate with an email sending service here, e.g.:
    // - Nodemailer (for SMTP)
    // - SendGrid, Mailgun, Resend, AWS SES (for transactional emails)
    // - Saving to a database for CRM integration
    // Example:
    /*
    const sendEmailResult = await sendEmailService.send({
      to: 'your-support-email@fanskor.com',
      from: 'noreply@fanskor.com',
      subject: `Fanskor Contact Form: ${subject}`,
      html: `
        <p><strong>Name:</strong> ${name}</p>
        <p><strong>Email:</strong> ${email}</p>
        <p><strong>Subject:</strong> ${subject}</p>
        <p><strong>Message:</strong></p>
        <p>${message}</p>
      `,
    });
    if (!sendEmailResult.success) {
        console.error('[Contact API] Failed to send email:', sendEmailResult.error);
        return NextResponse.json({ error: 'Failed to send message. Please try again later.' }, { status: 500 });
    }
    */
    // --- End Placeholder ---

    return NextResponse.json(
      { message: "Your message has been sent successfully!" },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(
      "[Contact API] Error processing contact form submission:",
      error.message
    );
    return NextResponse.json(
      { error: "An unexpected error occurred." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/countries/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';
import { Country } from '@/types/api-football'; // We will define this type

// This function handles GET requests to /api/countries
export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/countries`,
    headers: {
      // Securely read API key and host from environment variables
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };


  try {
    const response = await axios.request(options);

    // --- Data Transformation ---
    // We will clean and simplify the data before sending it to the frontend.
    const transformedCountries: Country[] = response.data.response
      // 1. Filter out any countries that are missing essential data
      .filter((country: any) => country.name && country.code && country.flag)
      // 2. Map the raw data to our clean, simplified `Country` type
      .map((country: any) => ({
        name: country.name,
        code: country.code,
        flagUrl: country.flag,
      }));

    // 3. Sort the countries alphabetically for a better user experience
    transformedCountries.sort((a, b) => a.name.localeCompare(b.name));
    

    return NextResponse.json(transformedCountries);

  } catch (error) {
    console.error("Error fetching countries:", error);
    return NextResponse.json(
      { error: 'Failed to fetch country data.' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/country-stats/route.ts =====

// src/app/api/country-stats/route.ts
import { NextResponse } from "next/server";
import axios from "axios";

// A curated list of popular league IDs to source teams from.
const POPULAR_LEAGUE_IDS = [
  39, 140, 135, 78, 61, 88, 94, 253, 2, 3, 45, 48, 71, 62, 144, 203, 197, 218,
];
const season = new Date().getFullYear();

export async function GET() {
  const options = (leagueId: number) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
    params: { league: leagueId, season: season },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    const teamPromises = POPULAR_LEAGUE_IDS.map((id) =>
      axios.request(options(id))
    );
    const responses = await Promise.allSettled(teamPromises);

    const allTeamsResponses = responses
      .filter(
        (result) => result.status === "fulfilled" && result.value.data.response
      )
      .flatMap(
        (result) => (result as PromiseFulfilledResult<any>).value.data.response
      );

    // --- THIS IS THE FIX ---
    // 1. De-duplicate the teams first using a Map based on the unique team ID.
    // This ensures that a team like "Manchester City" which is in both the Premier League (39)
    // and the Champions League (2) is only processed once.
    const uniqueTeams = Array.from(
      new Map(allTeamsResponses.map((item) => [item.team.id, item])).values()
    );

    // 2. Now, count the de-duplicated teams.
    const countryTeamCounts: { [key: string]: number } = {};
    uniqueTeams.forEach((item) => {
      const countryName = item.team.country;
      if (countryName) {
        if (!countryTeamCounts[countryName]) {
          countryTeamCounts[countryName] = 0;
        }
        countryTeamCounts[countryName]++;
      }
    });

    return NextResponse.json(countryTeamCounts);
  } catch (error) {
    console.error("Error fetching country stats:", error);
    return NextResponse.json(
      { error: "Failed to fetch country statistics." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/directory/countries/route.ts =====

// src/app/api/directory/countries/route.ts
import { NextResponse, NextRequest } from "next/server"; // Import NextRequest
import axios from "axios";

// The GET function now accepts the 'request' object
export async function GET(request: NextRequest) {
  try {
    // --- THIS IS THE FIX ---
    // 1. Get the protocol (http or https) and host (localhost:3000 or your domain)
    //    from the incoming request headers. This is the most reliable method.
    const protocol = request.headers.get("x-forwarded-proto") || "http";
    const host = request.headers.get("host");

    // 2. Construct the absolute URL for the internal API call.
    const internalApiUrl = `${protocol}://${host}/api/leagues?fetchAll=true`;

    // 3. Make the internal API call using the constructed URL.
    const leaguesResponse = await axios.get(internalApiUrl);
    const allLeagues = leaguesResponse.data;

    if (!allLeagues || allLeagues.length === 0) {
      return NextResponse.json([]);
    }

    const leagueCounts: { [key: string]: number } = {};
    allLeagues.forEach((league: any) => {
      if (league.countryName) {
        leagueCounts[league.countryName] =
          (leagueCounts[league.countryName] || 0) + 1;
      }
    });

    const countriesResponse = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/countries`,
      {
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );

    const allCountries = countriesResponse.data.response;

    let enrichedCountries = allCountries
      .map((country: any) => ({
        name: country.name,
        code: country.code,
        flagUrl: country.flag,
        leagueCount: leagueCounts[country.name] || 0,
      }))
      .filter(
        (country: any) =>
          country.leagueCount > 0 &&
          country.name &&
          country.code &&
          country.flagUrl
      );

    enrichedCountries.sort((a, b) => a.name.localeCompare(b.name));

    return NextResponse.json(enrichedCountries);
  } catch (error) {
    console.error("Error building country directory from all leagues:", error);
    if (axios.isAxiosError(error)) {
      console.error("Axios error details:", error.response?.data);
    }
    return NextResponse.json(
      { error: "Failed to build country directory." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/directory/teams/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

// A curated list of popular league IDs to source teams from.
const POPULAR_LEAGUE_IDS = [
  39,  // England - Premier League
  140, // Spain - La Liga
  135, // Italy - Serie A
  78,  // Germany - Bundesliga
  61,  // France - Ligue 1
  88,  // Netherlands - Eredivisie
  94,  // Portugal - Primeira Liga
  253, // USA - MLS
  2,   // UEFA Champions League
];

const season = new Date().getFullYear();

// This function handles GET requests to /api/directory/teams
export async function GET() {
  const options = (leagueId: number) => ({
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
    params: { league: leagueId, season: season },
    headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    // 1. Fetch all teams from all popular leagues in parallel
    const teamPromises = POPULAR_LEAGUE_IDS.map(id => axios.request(options(id)));
    const responses = await Promise.allSettled(teamPromises);

    // 2. Aggregate all teams and filter out any failed requests
    const allTeamsResponses = responses
      .filter(result => result.status === 'fulfilled')
      .flatMap(result => (result as PromiseFulfilledResult<any>).value.data.response);

    // 3. De-duplicate the teams using a Map (a team can be in a league and a cup)
    const uniqueTeams = Array.from(new Map(allTeamsResponses.map(item => [item.team.id, item])).values());

    // 4. Sort the final list alphabetically for a better user experience
    uniqueTeams.sort((a, b) => a.team.name.localeCompare(b.team.name));
    
    return NextResponse.json(uniqueTeams);

  } catch (error) {
    console.error("Error fetching teams for directory:", error);
    return NextResponse.json(
      { error: 'Failed to fetch teams data.' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/find-live-matches/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

// This function handles GET requests to /api/live-matches
export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: { live: 'all' },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    // Directly return the array of live fixtures
    
    return NextResponse.json(response.data.response);
  } catch (error) {
    console.error("Error fetching live matches:", error);
    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src/app/api/fixtures/route.ts =====

import { NextResponse } from "next/server";
import axios from "axios";
import { format, addDays } from "date-fns";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get("league");
  const date = searchParams.get("date");
  const season = searchParams.get("season");

  // Base options for axios requests
  const axiosOptions = (params: object) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params,
    headers: {
      "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  });

  try {
    // --- PATTERN 1: Get all fixtures for a specific LEAGUE and SEASON ---
    // Used by the new "Season View" in the LeagueFixturesTab.
    if (leagueId && season) {
      console.log(
        `API: Fetching all fixtures for league ${leagueId}, season ${season}`
      );
      const response = await axios.request(
        axiosOptions({
          league: leagueId,
          season: season,
        })
      );
      // Sort matches by date, as the API might not return them in chronological order
      const sortedMatches = response.data.response.sort(
        (a: any, b: any) =>
          new Date(a.fixture.date).getTime() -
          new Date(b.fixture.date).getTime()
      );
      return NextResponse.json(sortedMatches);
    }

    // --- PATTERN 2: Get all fixtures for a specific LEAGUE and DATE ---
    // Used by the original day-by-day fixtures tab.
    if (leagueId && date) {
      console.log(
        `API: Fetching fixtures for league ${leagueId}, date ${date}`
      );
      const response = await axios.request(
        axiosOptions({
          league: leagueId,
          season: new Date(date).getFullYear().toString(), // Use the year from the date for the season
          date: date,
        })
      );
      return NextResponse.json(response.data.response);
    }

    // --- PATTERN 3: Get upcoming matches for a specific LEAGUE ---
    // Used by the homepage slider when a league is selected.
    if (leagueId) {
      console.log(`API: Fetching upcoming fixtures for league ${leagueId}`);
      const today = format(new Date(), "yyyy-MM-dd");
      const nextSevenDays = format(addDays(new Date(), 7), "yyyy-MM-dd");
      const response = await axios.request(
        axiosOptions({
          league: leagueId,
          season: new Date().getFullYear().toString(),
          from: today,
          to: nextSevenDays,
        })
      );
      return NextResponse.json(response.data.response);
    }

    // --- PATTERN 4: Get GLOBAL matches (live, today, tomorrow) if no league is specified ---
    // This is the default for the homepage.
    if (!leagueId) {
      // If a specific date is provided for the global view, use it.
      if (date) {
        console.log(`API: Fetching global fixtures for date ${date}`);
        const response = await axios.request(axiosOptions({ date: date }));
        return NextResponse.json(response.data.response);
      }

      // Fallback to the original "live, today, tomorrow" logic if no date is provided.
      console.log("API: Fetching global matches (live, today, tomorrow)");
      const todayStr = format(new Date(), "yyyy-MM-dd");
      const tomorrowStr = format(addDays(new Date(), 1), "yyyy-MM-dd");

      const [liveResponse, todayResponse, tomorrowResponse] = await Promise.all(
        [
          axios.request(axiosOptions({ live: "all" })),
          axios.request(axiosOptions({ date: todayStr })),
          axios.request(axiosOptions({ date: tomorrowStr })),
        ]
      );

      const allMatches = [
        ...liveResponse.data.response,
        ...todayResponse.data.response,
        ...tomorrowResponse.data.response,
      ];

      const uniqueMatches = Array.from(
        new Map(allMatches.map((m) => [m.fixture.id, m])).values()
      );
      return NextResponse.json(uniqueMatches);
    }

    return NextResponse.json([]);
  } catch (error) {
    console.error("Error in /api/fixtures:", error);
    return NextResponse.json(
      { error: "Failed to fetch fixture data." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/global-live/route.ts =====

// src/app/api/global-live/route.ts
import { NextResponse } from 'next/server';
import axios from 'axios';

// This function handles GET requests to /api/global-live
export async function GET() {
  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    // The key is to use the `live: 'all'` parameter
    params: { live: 'all' },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    // Directly return the array of live fixtures
    return NextResponse.json(response.data.response);
  } catch (error) {
    console.error("Error fetching global live matches:", error);
    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src/app/api/image-proxy/route.ts =====

// src/app/api/image-proxy/route.ts

import { NextRequest, NextResponse } from "next/server";
import axios from "axios";

// --- SECURITY: A whitelist of allowed domains to prevent abuse ---
// This ensures our proxy can only be used to fetch images from trusted sources.
const ALLOWED_DOMAINS = [
  "media.api-sports.io",
  // Add other trusted image source domains here if needed in the future
];

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const imageUrl = searchParams.get("url");

  // 1. Validate input
  if (!imageUrl) {
    return NextResponse.json(
      { error: "Image URL is required" },
      { status: 400 }
    );
  }

  // 2. Security Check: Ensure the requested URL is from an allowed domain
  try {
    const urlObject = new URL(imageUrl);
    if (!ALLOWED_DOMAINS.includes(urlObject.hostname)) {
      return NextResponse.json(
        { error: "Domain not allowed" },
        { status: 403 }
      );
    }
  } catch (error) {
    return NextResponse.json({ error: "Invalid URL format" }, { status: 400 });
  }

  try {
    // 3. Fetch the image from the external source
    const response = await axios.get(imageUrl, {
      responseType: "arraybuffer", // Fetch as raw data
    });

    const imageBuffer = Buffer.from(response.data, "binary");
    const contentType = response.headers["content-type"] || "image/png";

    // 4. Return the image with our custom, strong caching headers
    return new NextResponse(imageBuffer, {
      status: 200,
      headers: {
        "Content-Type": contentType,
        // Cache for 7 days, immutable means the browser won't even check for updates
        "Cache-Control": "public, max-age=604800, immutable",
      },
    });
  } catch (error) {
    console.error(`[Image Proxy] Failed to fetch ${imageUrl}:`, error);
    // You could return a placeholder image here if you wanted
    return NextResponse.json(
      { error: "Failed to fetch image" },
      { status: 502 }
    ); // 502 Bad Gateway
  }
}


// ===== src/app/api/leagues/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';
import { League } from '@/types/api-football';
import { generateLeagueSlug } from '@/lib/generate-league-slug';

// --- DEFINE CURATED LISTS OF POPULAR COMPETITIONS ---
// This is a list of well-known league IDs used for the sidebar's default view.
const POPULAR_LEAGUE_IDS = new Set([
  39,  // England - Premier League
  140, // Spain - La Liga
  135, // Italy - Serie A
  78,  // Germany - Bundesliga
  61,  // France - Ligue 1
  88,  // Netherlands - Eredivisie
  94,  // Portugal - Primeira Liga
  253, // USA - MLS
  203, // Turkey - Süper Lig
]);

const POPULAR_CUP_IDS = new Set([
  2,   // UEFA Champions League
  3,   // UEFA Europa League
  531, // UEFA Conference League
  45,  // England - FA Cup
  9,   // Copa Libertadores
  11,  // Copa Sudamericana
]);

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const country = searchParams.get('country');
  const type = searchParams.get('type'); // Can be 'league' or 'cup'
  const fetchAll = searchParams.get('fetchAll'); // <-- NEW PARAMETER

  const params: { current: string; country?: string, type?: string } = {
    current: 'true',
  };

  if (country) {
    params.country = country;
  }
  if (type) {
    params.type = type;
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/leagues`,
    params: params, 
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    let allLeagues = response.data.response;

    // --- UPDATED FILTERING LOGIC ---
    // If we are on the global view (no country selected) AND we are NOT fetching for a directory page,
    // then filter the results to only show popular competitions.
    if (!country && !fetchAll) {
      const popularIds = type === 'cup' ? POPULAR_CUP_IDS : POPULAR_LEAGUE_IDS;
      allLeagues = allLeagues.filter((item: any) => popularIds.has(item.league.id));
    }
    
    // Perform data transformation for all cases
    const transformedData: League[] = allLeagues
      .filter((item: any) => item.league.id && item.league.name && item.league.logo)
      .map((item: any) => ({
        id: item.league.id,
        name: item.league.name,
        logoUrl: item.league.logo,
        countryName: item.country.name,
        countryFlagUrl: item.country.flag,
        type: item.league.type,    
        href: generateLeagueSlug(item.league.name, item.league.id),
      }));
    
    // Sort the results alphabetically for a consistent order
    transformedData.sort((a, b) => a.name.localeCompare(b.name));

    return NextResponse.json(transformedData);

  } catch (error) {
    console.error("Error fetching leagues:", error);
    return NextResponse.json(
      { error: 'Failed to fetch league data.' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/live-matches/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');

  if (!leagueId) {
    return NextResponse.json({ error: 'League ID is required' }, { status: 400 });
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params: {
      league: leagueId,
      live: 'all',
    },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    // Directly return the response data, which is an array of live fixtures
    return NextResponse.json(response.data.response);
  } catch (error) {
    console.error("Error fetching live matches:", error);
    return NextResponse.json({ error: 'Failed to fetch live matches' }, { status: 500 });
  }
}

// ===== src/app/api/live-odds/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

/**
 * API route to fetch LIVE odds for all currently live matches.
 * This is a bulk fetch operation. It returns a map-like object
 * where keys are fixture IDs and values are the odds for that match.
 * This is far more efficient than fetching odds for each live match individually.
 */
export async function GET() {
    // Configure the request to the external API.
    // We are optimizing by only asking for the "Match Winner" bet type (id: 1).
    const options = {
        method: 'GET',
        url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds/live`,
        params: { bet: '1' }, 
        headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    };

    try {
        const response = await axios.request(options);

        // If the external API returns no live odds, we successfully found that out.
        // Return a 200 OK status with an empty object.
        if (!response.data.response || response.data.response.length === 0) {
            return NextResponse.json({}, { status: 200 });
        }

        // Transform the array response into a more efficient key-value object (a map).
        // This allows our frontend to look up odds by fixture ID in O(1) time.
        // The final object will look like: { "12345": { home: "1.50", ... }, "67890": { ... } }
        const liveOddsObject = response.data.response.reduce((acc: any, fixtureData: any) => {
            const fixtureId = fixtureData.fixture.id;
            const bookmaker = fixtureData.bookmakers?.[0]; // Get the first available bookmaker
            const matchWinnerBet = bookmaker?.bets.find((bet: any) => bet.id === 1);

            // Ensure we found a valid "Match Winner" bet
            if (matchWinnerBet) {
                const odds = matchWinnerBet.values.reduce((oddAcc: any, curr: any) => {
                    if (curr.value === 'Home') oddAcc.home = curr.odd;
                    if (curr.value === 'Draw') oddAcc.draw = curr.odd;
                    if (curr.value === 'Away') oddAcc.away = curr.odd;
                    return oddAcc;
                }, {});
                acc[fixtureId] = odds;
            }
            return acc;
        }, {});

        // Return the successfully transformed odds object.
        return NextResponse.json(liveOddsObject, { status: 200 });

    } catch (error) {
        console.error('[API/LIVE-ODDS] Error fetching live odds:', error);
        return NextResponse.json(
            { error: 'Failed to fetch live odds data from the provider.' },
            { status: 500 }
        );
    }
}

// ===== src/app/api/live-odds-by-fixture/route.ts =====

// src/app/api/live-odds-by-fixture/route.ts
import { NextResponse } from "next/server";
import axios from "axios";

// --- Data Transformation Helper ---
// This function finds a specific bet type by its ID and extracts the main odds.
const extractMainOdds = (odds: any[], betId: number, valueKeys: string[]) => {
  const betData = odds.find((o) => o.id === betId);
  if (!betData) return null;

  // Prefer the 'main' market if available, otherwise take the first valid one.
  let targetValues = betData.values.find((v: any) => v.main === true)
    ? betData.values.filter((v: any) => v.main === true)
    : betData.values;

  const result: { [key: string]: string | null } = {};
  valueKeys.forEach((key) => {
    result[key.toLowerCase()] =
      targetValues.find((v: any) => v.value === key)?.odd || null;
  });

  // Also extract the handicap if present
  result.handicap = targetValues[0]?.handicap || null;

  // Check if we found any valid odds
  const hasValues = Object.values(result).some(
    (v) => v !== null && v !== undefined
  );
  return hasValues ? result : null;
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get("fixture");

  if (!fixtureId) {
    return NextResponse.json(
      { error: "Fixture ID is required" },
      { status: 400 }
    );
  }

  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds/live`,
    params: { fixture: fixtureId },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };

  try {
    const response = await axios.request(options);
    const liveData = response.data.response[0];

    if (!liveData || !liveData.odds) {
      return NextResponse.json(null); // Return null if no live odds are available
    }

    const odds = liveData.odds;

    // Curate and simplify the data before sending to the frontend
    const curatedOdds = {
      asianHandicap: extractMainOdds(odds, 33, ["Home", "Away"]),
      overUnder: extractMainOdds(odds, 36, ["Over", "Under"]),
      matchCorners: extractMainOdds(odds, 20, ["Over", "Under"]),
      nextGoal: extractMainOdds(odds, 85, ["1", "No goal", "2"]),
    };

    return NextResponse.json(curatedOdds);
  } catch (error) {
    console.error(`Error fetching live odds for fixture ${fixtureId}:`, error);
    return NextResponse.json(
      { error: "Failed to fetch live odds" },
      { status: 500 }
    );
  }
}


// ===== src/app/api/match-details/route.ts =====

// src/app/api/match-details/route.ts

import { NextResponse } from "next/server";
import axios from "axios";

// ====================================================================
// --- FANSKOR PREDICTION ENGINE V3.0 (Weather Removed) ---
// ====================================================================
const calculateCustomPrediction = (
  h2h: any[],
  homeTeamStats: any,
  awayTeamStats: any,
  homeTeamId: number,
  homeTeamRank: number | undefined,
  awayTeamRank: number | undefined,
  // weatherData parameter removed
  matchEvents: any[],
  matchStatus: string
) => {
  const config = {
    weights: {
      homeAdvantage: 12,
      form: 1.5,
      h2h: 2.5,
      rankDifference: 0.8,
      goalDifference: 6,
      xGInfluence: 3,
      // weatherInfluence config removed
      matchActivity: 0.5,
      liveMatchBonus: 5,
    },
    h2hMaxGames: 5,
    drawWeight: 0.85,
  };

  let homeScore = 0;
  let awayScore = 0;

  // 1. Home Advantage
  homeScore += config.weights.homeAdvantage;

  // 2. Momentum (Recent Form)
  const calculateForm = (formString: string): number => {
    return (
      (formString.match(/W/g) || []).length * 3 +
      (formString.match(/D/g) || []).length * 1
    );
  };
  const homeFormString = homeTeamStats?.form || "";
  const awayFormString = awayTeamStats?.form || "";
  homeScore += calculateForm(homeFormString) * config.weights.form;
  awayScore += calculateForm(awayFormString) * config.weights.form;

  // 3. Goal Form (Average Goal Difference)
  const homeGoalsForAvg = homeTeamStats?.goals?.for?.average?.total ?? 0;
  const homeGoalsAgainstAvg =
    homeTeamStats?.goals?.against?.average?.total ?? 0;
  const awayGoalsForAvg = awayTeamStats?.goals?.for?.average?.total ?? 0;
  const awayGoalsAgainstAvg =
    awayTeamStats?.goals?.against?.average?.total ?? 0;

  const homeGoalDiff = homeGoalsForAvg - homeGoalsAgainstAvg;
  const awayGoalDiff = awayGoalsForAvg - awayGoalsAgainstAvg;
  homeScore += homeGoalDiff * config.weights.goalDifference;
  awayScore += awayGoalDiff * config.weights.goalDifference;

  // 4. Simulated Expected Goals (xG)
  const simulateXG = (avgGoals: number) => Math.min(avgGoals * 1.1, 3.0);
  const homeXG = simulateXG(homeGoalsForAvg);
  const awayXG = simulateXG(awayGoalsForAvg);

  const xgDiff = homeXG - awayXG;
  homeScore += xgDiff * config.weights.xGInfluence;
  awayScore -= xgDiff * config.weights.xGInfluence;

  // 5. Head-to-Head (H2H) Records
  if (h2h && h2h.length > 0) {
    h2h.slice(0, config.h2hMaxGames).forEach((match) => {
      if (match.teams.home.winner) {
        homeTeamId === match.teams.home.id
          ? (homeScore += config.weights.h2h)
          : (awayScore += config.weights.h2h);
      } else if (match.teams.away.winner) {
        homeTeamId === match.teams.away.id
          ? (homeScore += config.weights.h2h)
          : (awayScore += config.weights.h2h);
      } else {
        // It was a draw
        homeScore += config.weights.h2h / 2;
        awayScore += config.weights.h2h / 2;
      }
    });
  }

  // 6. League Rank Difference
  if (homeTeamRank != null && awayTeamRank != null) {
    const rankDiff = Math.abs(homeTeamRank - awayTeamRank);
    if (homeTeamRank < awayTeamRank) {
      homeScore += rankDiff * config.weights.rankDifference;
    } else if (awayTeamRank < homeTeamRank) {
      awayScore += rankDiff * config.weights.rankDifference;
    }
  }

  // 7. Weather Conditions (Logic removed)
  // The weather influence logic is entirely removed.

  // 8. Match Activity Analysis
  const isLiveMatch = ["1H", "HT", "2H", "ET", "BT", "P", "LIVE"].includes(
    matchStatus
  );
  if (isLiveMatch) {
    homeScore += config.weights.liveMatchBonus;
    awayScore += config.weights.liveMatchBonus;
    const recentEventsCount = matchEvents.filter(
      (event: any) =>
        (event.type === "Goal" || event.type === "Card") &&
        event.time.elapsed > (matchStatus === "1H" ? 1 : 45)
    ).length;
    homeScore += recentEventsCount * config.weights.matchActivity;
    awayScore += recentEventsCount * config.weights.matchActivity;
  }

  // --- Final Calculation & Normalization ---
  homeScore = Math.max(1, homeScore);
  awayScore = Math.max(1, awayScore);
  const drawScore =
    (homeScore + awayScore) *
    (1 - Math.abs(homeScore - awayScore) / (homeScore + awayScore)) *
    config.drawWeight;
  const totalPoints = homeScore + awayScore + drawScore;

  if (totalPoints <= 1) {
    return { home: 33, draw: 34, away: 33 };
  }

  let homePercent = Math.round((homeScore / totalPoints) * 100);
  let awayPercent = Math.round((awayScore / totalPoints) * 100);
  let drawPercent = 100 - homePercent - awayPercent;

  if (homePercent + awayPercent + drawPercent !== 100) {
    const diff = 100 - (homePercent + awayPercent + drawPercent);
    if (homePercent >= awayPercent && homePercent >= drawPercent) {
      homePercent += diff;
    } else if (awayPercent >= homePercent && awayPercent >= drawPercent) {
      awayPercent += diff;
    } else {
      drawPercent += diff;
    }
  }

  return {
    home: homePercent,
    draw: drawPercent,
    away: awayPercent,
  };
};

// --- Helper to convert percentages to decimal odds (Unchanged) ---
const convertPercentageToOdds = (percent: number): string => {
  if (percent <= 0) return "INF";
  return (100 / percent).toFixed(2);
};

// --- The main data fetching function ---
const fetchAllDataForFixture = async (fixtureId: string | number) => {
  const options = (endpoint: string, params: object) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  const fixtureResponse = await axios.request(
    options("fixtures", { id: fixtureId })
  );
  const fixtureData = fixtureResponse.data.response[0];

  if (!fixtureData) {
    throw new Error(`Fixture not found with ID: ${fixtureId}`);
  }

  const { league, teams } = fixtureData;
  const { home: homeTeam, away: awayTeam } = teams;
  // venueLat and venueLon extraction removed

  const [
    eventsResponse,
    statsResponse,
    h2hResponse,
    predictionResponse,
    homeStatsResponse,
    awayStatsResponse,
    oddsResponse,
    standingsResponse,
  ] = await Promise.all([
    axios.request(options("fixtures/events", { fixture: fixtureId })),
    axios.request(options("fixtures/statistics", { fixture: fixtureId })),
    axios.request(
      options("fixtures/headtohead", { h2h: `${homeTeam.id}-${awayTeam.id}` })
    ),
    axios.request(options("predictions", { fixture: fixtureId })),
    axios.request(
      options("teams/statistics", {
        league: league.id,
        season: league.season,
        team: homeTeam.id,
      })
    ),
    axios.request(
      options("teams/statistics", {
        league: league.id,
        season: league.season,
        team: awayTeam.id,
      })
    ),
    axios.request(options("odds", { fixture: fixtureId, bet: "1" })),
    axios.request(
      options("standings", { league: league.id, season: league.season })
    ),
    // Weather API request removed
  ]);

  const standings =
    standingsResponse.data.response[0]?.league?.standings[0] || [];
  const homeTeamRank = standings.find(
    (s: any) => s.team.id === homeTeam.id
  )?.rank;
  const awayTeamRank = standings.find(
    (s: any) => s.team.id === awayTeam.id
  )?.rank;

  const customPredictionPercentages = calculateCustomPrediction(
    h2hResponse.data.response,
    homeStatsResponse.data.response,
    awayStatsResponse.data.response,
    homeTeam.id,
    homeTeamRank,
    awayTeamRank,
    // null, // weatherData parameter removed
    eventsResponse.data.response,
    fixtureData.fixture.status.short
  );

  const customPredictionOdds = customPredictionPercentages
    ? {
        home: convertPercentageToOdds(customPredictionPercentages.home),
        draw: convertPercentageToOdds(customPredictionPercentages.draw),
        away: convertPercentageToOdds(customPredictionPercentages.away),
      }
    : null;

  return {
    fixture: fixtureData,
    events: eventsResponse.data.response,
    statistics: statsResponse.data.response,
    h2h: h2hResponse.data.response,
    analytics: {
      prediction: predictionResponse.data.response[0] ?? null,
      homeTeamStats: homeStatsResponse.data.response ?? null,
      awayTeamStats: awayStatsResponse.data.response ?? null,
      customPrediction: customPredictionPercentages,
      customOdds: customPredictionOdds,
      bookmakerOdds: oddsResponse.data.response[0]?.bookmakers ?? [],
    },
  };
};

// --- The GET handler that the frontend calls ---
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get("fixture");

  if (!fixtureId) {
    return NextResponse.json(
      { error: "Fixture ID is required" },
      { status: 400 }
    );
  }

  try {
    const matchDetails = await fetchAllDataForFixture(fixtureId);
    return NextResponse.json(matchDetails);
  } catch (error: any) {
    console.error(
      `[API /match-details] Error for fixture ${fixtureId}:`,
      error.message
    );
    return NextResponse.json(
      { error: "Failed to fetch match details." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/odds/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

/**
 * API route to fetch pre-match odds for a specific fixture.
 * It is optimized to only request the "Match Winner" bet from a single, major bookmaker
 * to ensure a fast response and minimal data transfer.
 */
export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);
    const fixtureId = searchParams.get('fixture');

    // 1. Validate input: Ensure a fixture ID was provided.
    if (!fixtureId) {
        return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
    }

    // 2. Configure the optimized request to the external API.
    const options = {
        method: 'GET',
        url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/odds`,
        params: { 
            fixture: fixtureId, 
            bookmaker: '8', // A major, commonly available bookmaker (e.g., Bet365)
            bet: '1'        // The ID for the "Match Winner" bet (1X2)
        },
        headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    };

    try {
        // 3. Make the external API call.
        const response = await axios.request(options);
        
        // 4. Handle the "No Data" case gracefully.
        // If the external API has no odds, it's not an error. We successfully found that there's no data.
        // We return a 200 OK status with a null body to signal this to the frontend.
        if (!response.data.response || response.data.response.length === 0) {
            console.log(`No odds found for fixture ${fixtureId}. Returning null.`);
            return NextResponse.json(null, { status: 200 }); 
        }
        
        const bookmaker = response.data.response[0].bookmakers[0];
        
        const matchWinnerBet = bookmaker.bets.find((bet: any) => bet.id === 1);

        // Also handle the case where the bookmaker doesn't offer this specific bet type.
        if (!matchWinnerBet || !matchWinnerBet.values) {
            console.log(`"Match Winner" odds not available for fixture ${fixtureId}. Returning null.`);
            return NextResponse.json(null, { status: 200 });
        }

        // 5. Transform the data into a clean, simple object for the frontend.
        // The API returns an array, but the frontend just needs a { home, draw, away } object.
        const odds = matchWinnerBet.values.reduce((acc: any, curr: any) => {
            if (curr.value === 'Home') acc.home = curr.odd;
            if (curr.value === 'Draw') acc.draw = curr.odd;
            if (curr.value === 'Away') acc.away = curr.odd;
            return acc;
        }, {});
        
        // 6. Return the successfully transformed odds.
        return NextResponse.json(odds, { status: 200 });

    } catch (error) {
        // 7. Handle actual server or network errors.
        console.error(`[API/ODDS] Error fetching odds for fixture ${fixtureId}:`, error);
        return NextResponse.json(
            { error: 'Failed to fetch odds data from the provider.' }, 
            { status: 500 }
        );
    }
}

// ===== src/app/api/posts/route.ts =====

// src/app/api/posts/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post, { IPost, PostCategory } from "@/models/Post";
import slugify from "slugify";
import ExternalNewsArticle from "@/models/ExternalNewsArticle";

// --- GET All Posts (No change needed) ---
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const status = searchParams.get("status");
  const limit = searchParams.get("limit");

  const query: { status?: string } = {};
  if (status) {
    query.status = status;
  }

  try {
    await dbConnect();
    let postsQuery = Post.find(query).sort({ createdAt: -1 }).populate({
      path: "originalExternalArticleId",
      model: ExternalNewsArticle,
      select: "title link",
    });

    const posts = await postsQuery;
    return NextResponse.json(posts);
  } catch (error) {
    console.error("Failed to fetch posts:", error);
    return NextResponse.json(
      { error: "Server error fetching posts" },
      { status: 500 }
    );
  }
}

// --- POST a New Post (Updated to handle category array) ---
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const body: Partial<IPost> = await request.json();
    const {
      title,
      content,
      status,
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle,
      featuredImageAltText,
      sport, // This will now be an array
    } = body;

    if (!title || !content) {
      return NextResponse.json(
        { error: "Title and content are required" },
        { status: 400 }
      );
    }

    // --- MODIFIED: Validate that `sport` is a non-empty array ---
    if (!Array.isArray(sport) || sport.length === 0) {
      return NextResponse.json(
        { error: "At least one category is required." },
        { status: 400 }
      );
    }

    await dbConnect();

    const slug = slugify(title, { lower: true, strict: true });
    const slugExists = await Post.findOne({ slug });
    if (slugExists) {
      return NextResponse.json(
        {
          error: `A post with the slug '${slug}' already exists. Please use a different title.`,
        },
        { status: 409 }
      );
    }

    const newPost = new Post({
      title,
      content,
      status,
      slug,
      author: session.user.name || "Admin",
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle,
      featuredImageAltText,
      sport: sport as PostCategory[], // --- MODIFIED: Save the array
    });

    await newPost.save();
    return NextResponse.json(newPost, { status: 201 });
  } catch (error: any) {
    if (error.name === "ValidationError") {
      return NextResponse.json({ error: error.message }, { status: 400 });
    }
    console.error("Failed to create post:", error);
    return NextResponse.json(
      { error: "Server error creating post" },
      { status: 500 }
    );
  }
}


// ===== src/app/api/posts/[postId]/route.ts =====

// src/app/api/posts/[postId]/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/dbConnect";
import Post, { IPost, PostCategory } from "@/models/Post";

interface Params {
  params: { postId: string };
}

// --- GET a Single Post (by ID) (No change needed) ---
export async function GET(request: Request, { params }: Params) {
  const { postId } = params;
  try {
    await dbConnect();
    const post = await Post.findById(postId);
    if (!post) {
      return NextResponse.json({ error: "Post not found" }, { status: 404 });
    }
    return NextResponse.json(post);
  } catch (error) {
    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}

// --- PUT (Update) a Post (Updated to handle category array) ---
// Protected: Only admins can update.
export async function PUT(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { postId } = params;
  try {
    const body: Partial<IPost> = await request.json();
    const {
      title,
      content,
      status,
      featuredImage,
      metaTitle,
      metaDescription,
      featuredImageTitle,
      featuredImageAltText,
      sport, // This will now be an array
    } = body;

    // --- MODIFIED: Validate that `sport` is a non-empty array ---
    if (!Array.isArray(sport) || sport.length === 0) {
      return NextResponse.json(
        { error: "At least one category is required." },
        { status: 400 }
      );
    }

    await dbConnect();

    const updatedPost = await Post.findByIdAndUpdate(
      postId,
      {
        title,
        content,
        status,
        featuredImage,
        metaTitle,
        metaDescription,
        featuredImageTitle,
        featuredImageAltText,
        sport: sport as PostCategory[], // --- MODIFIED: Save the array
      },
      { new: true, runValidators: true }
    );

    if (!updatedPost) {
      return NextResponse.json({ error: "Post not found" }, { status: 404 });
    }

    return NextResponse.json(updatedPost);
  } catch (error: any) {
    if (error.name === "ValidationError") {
      return NextResponse.json({ error: error.message }, { status: 400 });
    }
    console.error("Error updating post:", error);
    return NextResponse.json(
      { error: "Server error updating post" },
      { status: 500 }
    );
  }
}

// --- DELETE a Post (No change needed) ---
export async function DELETE(request: Request, { params }: Params) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { postId } = params;
  try {
    await dbConnect();
    const deletedPost = await Post.findByIdAndDelete(postId);
    if (!deletedPost) {
      return NextResponse.json({ error: "Post not found" }, { status: 404 });
    }
    return NextResponse.json({ message: "Post deleted successfully" });
  } catch (error) {
    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}


// ===== src/app/api/predictions/route.ts =====

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const fixtureId = searchParams.get('fixture');

  if (!fixtureId) {
    return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/predictions`,
    params: { fixture: fixtureId },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    if (!response.data.response || response.data.response.length === 0) {
      return NextResponse.json({ error: 'No prediction available.' }, { status: 404 });
    }

    const predictionData = response.data.response[0];

    // --- THE FIX ---
    // We now extract and return the entire `teams` object from the prediction,
    // along with the percentages.
    const transformedPrediction = {
      teams: {
        home: {
          id: predictionData.teams.home.id,
          name: predictionData.teams.home.name,
          logo: predictionData.teams.home.logo, // <-- Pass the logo URL
        },
        away: {
          id: predictionData.teams.away.id,
          name: predictionData.teams.away.name,
          logo: predictionData.teams.away.logo, // <-- Pass the logo URL
        }
      },
      percent: {
        home: parseInt(predictionData.predictions.percent.home.replace('%', '')),
        draw: parseInt(predictionData.predictions.percent.draw.replace('%', '')),
        away: parseInt(predictionData.predictions.percent.away.replace('%', '')),
      }
    };

    return NextResponse.json(transformedPrediction);

  } catch (error) {
    console.error("Error fetching prediction:", error);
    return NextResponse.json({ error: 'Failed to fetch prediction data.' }, { status: 500 });
  }
}

// ===== src/app/api/sports/[sport]/fixtures/route.ts =====

import { NextResponse } from 'next/server';
import { getSportService } from '@/services/sports';

export async function GET(
  request: Request,
  { params }: { params: { sport: string } }
) {
  const { searchParams } = new URL(request.url);
  const sport = params.sport;
  
  // Convert searchParams to a plain object
  const queryParams: { [key: string]: any } = {};
  searchParams.forEach((value, key) => {
    queryParams[key] = value;
  });

  try {
    // 1. Get the correct service for the requested sport
    const sportService = getSportService(sport);
    
    // 2. Call the generic method
    const fixtures = await sportService.getFixtures(queryParams);

    // 3. Return the data
    return NextResponse.json(fixtures);

  } catch (error: any) {
    console.error(`[API /${sport}/fixtures] Error:`, error.message);
    return NextResponse.json(
      { error: `Failed to fetch fixture data for ${sport}.` },
      { status: 500 }
    );
  }
}

// ===== src/app/api/standings/route.ts =====

// src/app/api/standings/route.ts

import { NextResponse } from "next/server";
import axios from "axios";
import { generateLeagueSlug } from "@/lib/generate-league-slug"; // <-- IMPORT

// TeamStanding type definition remains the same
type TeamStanding = {
  rank: number;
  team: { id: number; name: string; logo: string };
  points: number;
  goalsDiff: number;
  all: { played: number; win: number; draw: number; lose: number };
  description: string | null;
  group: string; // <-- Make sure group is part of the type
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get("league");
  const season =
    searchParams.get("season") || new Date().getFullYear().toString();

  if (!leagueId) {
    return NextResponse.json(
      { error: "League ID is required" },
      { status: 400 }
    );
  }

  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/standings`,
    params: { league: leagueId, season: season },
    headers: {
      "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    if (!response.data.response || response.data.response.length === 0) {
      return NextResponse.json({ league: null, standings: [] });
    }

    const data = response.data.response[0];

    // --- ENHANCED TRANSFORMATION ---
    // We now add the href to the league info object
    const leagueInfo = {
      id: data.league.id,
      name: data.league.name,
      logo: data.league.logo,
      type: data.league.type, // Good to have for context
      href: generateLeagueSlug(data.league.name, data.league.id), // <-- ADD THE HREF
    };

    // Ensure we are selecting the correct standings array
    const standings: TeamStanding[][] = data.league.standings;

    return NextResponse.json({ league: leagueInfo, standings });
  } catch (error) {
    console.error("Error fetching standings:", error);
    return NextResponse.json(
      { error: "Failed to fetch standings data" },
      { status: 500 }
    );
  }
}


// ===== src/app/api/team-details/route.ts =====

// src/app/api/team-details/route.ts
import { NextResponse } from 'next/server';
import { fetchTeamDetails } from '@/lib/data/team'; // <-- IMPORT THE NEW FUNCTION

export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);
    const teamId = searchParams.get('team');

    if (!teamId) {
        return NextResponse.json({ error: 'Team ID is required' }, { status: 400 });
    }

    // Call the reusable function
    const teamData = await fetchTeamDetails(teamId);

    if (!teamData) {
        // This handles cases where the team isn't found or an error occurred in the lib function.
        return NextResponse.json({ error: 'Failed to fetch team details or team not found' }, { status: 500 });
    }

    return NextResponse.json(teamData);
}

// ===== src/app/api/team-trophies/route.ts =====

// src/app/api/team-trophies/route.ts
import { NextResponse } from "next/server";
import axios from "axios";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const teamId = searchParams.get("team");

  if (!teamId) {
    return NextResponse.json({ error: "Team ID is required" }, { status: 400 });
  }

  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/trophies`,
    params: { team: teamId },
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };

  try {
    const response = await axios.request(options);
    // Sort trophies by season, newest first
    const sortedTrophies = response.data.response.sort((a: any, b: any) => {
      const seasonB = parseInt(b.season.split("-")[0]);
      const seasonA = parseInt(a.season.split("-")[0]);
      return seasonB - seasonA;
    });
    return NextResponse.json(sortedTrophies);
  } catch (error) {
    console.error("Error fetching team trophies:", error);
    return NextResponse.json(
      { error: "Failed to fetch trophies" },
      { status: 500 }
    );
  }
}


// ===== src/app/api/teams/route.ts =====

// src/app/api/teams/route.ts
import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');
  const season = searchParams.get('season');

  if (!leagueId || !season) {
    return NextResponse.json(
      { error: 'League ID and season are required' },
      { status: 400 }
    );
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams`,
    params: {
      league: leagueId,
      season: season,
    },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    
    // The response is an array of objects, each containing a `team` and `venue` object.
    // We can pass it directly to the frontend.
    return NextResponse.json(response.data.response);

  } catch (error) {
    console.error("Error fetching teams:", error);
    return NextResponse.json(
      { error: 'Failed to fetch teams data.' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/teams-by-country/route.ts =====

// src/app/api/teams-by-country/route.ts
import { NextResponse } from "next/server";
import axios from "axios";

const season = new Date().getFullYear();

// This is a reusable helper for making requests to the external API
const apiRequest = async (endpoint: string, params: object) => {
  const options = {
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  };
  const response = await axios.request(options);
  return response.data.response;
};

// This function now returns both the list of teams AND the count
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const country = searchParams.get("country");

  if (!country) {
    return NextResponse.json(
      { error: "Country parameter is required" },
      { status: 400 }
    );
  }

  try {
    // 1. First, find all leagues for the specified country.
    const leagues = await apiRequest("leagues", { country: country });
    if (!leagues || leagues.length === 0) {
      // Return a structured response even if there are no teams
      return NextResponse.json({ teams: [], count: 0 });
    }

    const leagueIds = leagues.map((l: any) => l.league.id);

    // 2. Fetch all teams from all found leagues in parallel.
    const teamPromises = leagueIds.map((id: any) =>
      apiRequest("teams", { league: id, season: season })
    );
    const responses = await Promise.allSettled(teamPromises);

    // 3. Aggregate all teams from successful requests.
    const allTeamsResponses = responses
      .filter((result) => result.status === "fulfilled" && result.value)
      .flatMap((result) => (result as PromiseFulfilledResult<any>).value);

    // 4. De-duplicate the teams using a Map (very important).
    const uniqueTeams = Array.from(
      new Map(allTeamsResponses.map((item) => [item.team.id, item])).values()
    );

    // 5. Sort the final list alphabetically.
    uniqueTeams.sort((a, b) => a.team.name.localeCompare(b.team.name));

    // 6. Return the enhanced response object
    return NextResponse.json({
      teams: uniqueTeams,
      count: uniqueTeams.length, // The accurate count of unique teams
    });
  } catch (error) {
    console.error(`Error fetching teams for country "${country}":`, error);
    return NextResponse.json(
      { error: "Failed to fetch teams data for this country." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/top-scorers/route.ts =====

// src/app/api/top-scorers/route.ts

import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');
  const season = searchParams.get('season');

  if (!leagueId || !season) {
    return NextResponse.json(
      { error: 'League ID and season are required' },
      { status: 400 }
    );
  }

  const options = {
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/players/topscorers`,
    params: {
      league: leagueId,
      season: season,
    },
    headers: {
      'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
    },
  };

  try {
    const response = await axios.request(options);
    
    // The API returns an array of players with their stats. We can pass it directly.
    return NextResponse.json(response.data.response);

  } catch (error) {
    console.error("Error fetching top scorers:", error);
    return NextResponse.json(
      { error: 'Failed to fetch top scorers data.' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/upcoming-matches/route.ts =====

// src/app/api/upcoming-matches/route.ts
import { NextResponse } from 'next/server';
import axios from 'axios';
import { format, subDays, addDays } from 'date-fns';

// This is your existing API route for upcoming matches. Let's rename it
// to something more generic as it will now handle more than just "upcoming".
// The file path remains the same for backward compatibility.
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const leagueId = searchParams.get('league');

  if (!leagueId) {
    // If no leagueId, this route should do nothing or return an error.
    // Your global fetching is handled by the /api/fixtures route.
    return NextResponse.json({ error: 'League ID is required' }, { status: 400 });
  }

  const season = new Date().getFullYear().toString();
  const today = format(new Date(), 'yyyy-MM-dd');
  const nextSevenDays = format(addDays(new Date(), 7), 'yyyy-MM-dd');

  const options = (params: object) => ({
    method: 'GET',
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/fixtures`,
    params,
    headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    // --- 1. First, try to fetch UPCOMING matches ---
    const upcomingResponse = await axios.request(options({
      league: leagueId,
      season: season,
      from: today,
      to: nextSevenDays,
    }));
    
    let matches = upcomingResponse.data.response;

    // --- 2. If NO upcoming matches are found, fetch RECENT finished matches ---
    if (matches.length === 0) {
      console.log(`No upcoming matches for league ${leagueId}. Fetching recent results...`);
      const finishedResponse = await axios.request(options({
        league: leagueId,
        season: season,
        last: 5, // Get the last 5 finished fixtures
        status: 'FT', // Only get matches with a status of "Finished"
      }));
      matches = finishedResponse.data.response;
    }
    
    return NextResponse.json(matches);

  } catch (error) {
    console.error(`Error fetching matches for league ${leagueId}:`, error);
    return NextResponse.json({ error: 'Failed to fetch match data' }, { status: 500 });
  }
}

// ===== src/app/api/upload/route.ts =====

// ===== src/app/api/upload/route.ts (REVISED FOR GIFS AND NO CROPPING) =====
import { NextResponse } from "next/server";
import {
  S3Client,
  PutObjectCommand,
  ListObjectsV2Command,
  DeleteObjectCommand,
} from "@aws-sdk/client-s3";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import sharp from "sharp";
import path from "path";
import slugify from "slugify";

// --- R2/S3 Client Configuration ---
const s3Client = new S3Client({
  region: "auto",
  endpoint: process.env.NEXT_PUBLIC_R2_ENDPOINT as string,
  credentials: {
    accessKeyId: process.env.NEXT_PUBLIC_R2_ACCESS_KEY_ID as string,
    secretAccessKey: process.env.NEXT_PUBLIC_R2_SECRET_ACCESS_KEY as string,
  },
});

const R2_BUCKET_NAME = process.env.NEXT_PUBLIC_R2_BUCKET_NAME as string;
const R2_PUBLIC_URL = process.env.NEXT_PUBLIC_R2_PUBLIC_BUCKET_URL as string;

// --- GET handler to list uploaded files from R2 (unchanged) ---
export async function GET(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const listObjectsCommand = new ListObjectsV2Command({
      Bucket: R2_BUCKET_NAME,
      MaxKeys: 100,
    });

    const { Contents } = await s3Client.send(listObjectsCommand);

    const files =
      Contents?.map((item) => {
        const key = item.Key || "unknown";
        const fileExtension = path.extname(key).toLowerCase();
        let mimeType = "application/octet-stream";

        if (fileExtension === ".png") mimeType = "image/png";
        else if (fileExtension === ".jpg" || fileExtension === ".jpeg")
          mimeType = "image/jpeg";
        else if (fileExtension === ".gif") mimeType = "image/gif";
        else if (fileExtension === ".webp") mimeType = "image/webp";

        return {
          name: key,
          url: `${R2_PUBLIC_URL}/${key}`,
          size: item.Size || 0,
          lastModified: item.LastModified,
          type: mimeType,
        };
      }) || [];

    files.sort(
      (a, b) =>
        (b.lastModified?.getTime() || 0) - (a.lastModified?.getTime() || 0)
    );

    return NextResponse.json(files, { status: 200 });
  } catch (error) {
    console.error("Error listing files from R2:", error);
    return NextResponse.json(
      { error: "Failed to list files from Cloudflare R2." },
      { status: 500 }
    );
  }
}

// --- POST handler to upload files to R2 (UPDATED) ---
export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  try {
    const formData = await request.formData();
    const file = formData.get("file") as File;
    const uploadType = formData.get("uploadType") as string | null;

    if (!file) {
      return NextResponse.json({ error: "No file provided." }, { status: 400 });
    }

    let finalBuffer: Buffer;
    let finalContentType: string = file.type;
    let finalFileExtension: string;

    // ===== NEW GIF HANDLING LOGIC =====
    if (file.type === "image/gif") {
      finalBuffer = Buffer.from(await file.arrayBuffer());
      finalContentType = "image/gif";
      finalFileExtension = ".gif";
    } else {
      // Process other image types (PNG, JPEG, WebP, etc.)
      const inputBuffer = Buffer.from(await file.arrayBuffer());
      let sharpInstance = sharp(inputBuffer);

      if (uploadType === "banner") {
        // Banners should be resized to fit inside without cropping
        sharpInstance = sharpInstance.resize(1200, 1200, {
          fit: "inside", // This prevents cropping
          withoutEnlargement: true,
        });
      } else {
        // Other images (e.g., news featured images) should also be resized to fit without cropping
        // Change from 'cover' to 'inside' to prevent cropping
        sharpInstance = sharpInstance.resize(1200, 630, {
          fit: "inside", // Changed from "cover" to "inside"
          withoutEnlargement: true,
        });
      }

      finalBuffer = await sharpInstance.webp({ quality: 80 }).toBuffer();
      finalContentType = "image/webp";
      finalFileExtension = ".webp";
    }

    // Generate the new filename with "fanskor-" prefix, slug, and unique suffix
    const originalFilename = file.name;
    const extension = path.extname(originalFilename);
    const basename = path.basename(originalFilename, extension);
    const slug = slugify(basename, {
      lower: true,
      strict: true,
      remove: /[*+~.()'"!:@]/g,
    });
    const uniqueSuffix = Date.now().toString().slice(-6);

    const newFileName = `fanskor-${slug}-${uniqueSuffix}${finalFileExtension}`;

    const putObjectCommand = new PutObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: newFileName,
      Body: finalBuffer,
      ContentType: finalContentType,
    });

    await s3Client.send(putObjectCommand);

    const publicUrl = `${R2_PUBLIC_URL}/${newFileName}`;

    return NextResponse.json({
      message: "File uploaded successfully",
      url: publicUrl,
      name: newFileName,
      type: finalContentType,
      size: finalBuffer.length,
    });
  } catch (error) {
    console.error("Error uploading to R2:", error);
    return NextResponse.json(
      { error: "Failed to upload image to Cloudflare R2." },
      { status: 500 }
    );
  }
}

// --- DELETE handler to remove files from R2 (unchanged) ---
export async function DELETE(request: Request) {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "admin") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const { searchParams } = new URL(request.url);
  const fileKey = searchParams.get("key");

  if (!fileKey) {
    return NextResponse.json(
      { error: "File key is required for deletion." },
      { status: 400 }
    );
  }

  try {
    const deleteObjectCommand = new DeleteObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: fileKey,
    });

    await s3Client.send(deleteObjectCommand);
    console.log(`Successfully deleted R2 object: ${fileKey}`);

    return NextResponse.json(
      { message: "File deleted successfully." },
      { status: 200 }
    );
  } catch (error: any) {
    console.error(`Error deleting file ${fileKey} from R2:`, error);
    if (error.name === "NoSuchKey") {
      return NextResponse.json(
        { error: "File not found on Cloudflare R2." },
        { status: 404 }
      );
    }
    return NextResponse.json(
      { error: error.message || "Failed to delete file from Cloudflare R2." },
      { status: 500 }
    );
  }
}


// ===== src/app/api/votes/route.ts =====

import { NextResponse } from 'next/server';
import dbConnect from '@/lib/dbConnect';
import Vote from '@/models/Vote';

// --- GET Handler: Fetches vote counts for a fixture ---
export async function GET(request: Request) {
    console.log("requested here");
    
    const { searchParams } = new URL(request.url);
    const fixtureId = searchParams.get('fixture');

    if (!fixtureId) {
        return NextResponse.json({ error: 'Fixture ID is required' }, { status: 400 });
    }

    try {
        await dbConnect();
        const votes = await Vote.findOne({ fixtureId: Number(fixtureId) });
        console.log(votes);
        

        if (!votes) {
            // If no votes yet, return a default object
            return NextResponse.json({ homeVotes: 0, drawVotes: 0, awayVotes: 0 });
        }

        return NextResponse.json(votes);
    } catch (error) {
        console.log(error);
        
        return NextResponse.json({ error: 'Server error fetching votes' }, { status: 500 });
    }
}


// --- POST Handler: Submits a new vote ---
export async function POST(request: Request) {
    const { fixtureId, vote } = await request.json(); // vote should be 'home', 'draw', or 'away'

    if (!fixtureId || !['home', 'draw', 'away'].includes(vote)) {
        return NextResponse.json({ error: 'Valid fixtureId and vote type are required' }, { status: 400 });
    }
    
    try {
        await dbConnect();
        
        // Atomically find and update the document, or create it if it doesn't exist.
        // The $inc operator is crucial for preventing race conditions.
        const updatedVote = await Vote.findOneAndUpdate(
            { fixtureId: Number(fixtureId) },
            { $inc: { [`${vote}Votes`]: 1 } },
            { 
                upsert: true, // Create the document if it doesn't exist
                new: true     // Return the updated document
            }
        );

        return NextResponse.json(updatedVote);
    } catch (error) {
        return NextResponse.json({ error: 'Server error submitting vote' }, { status: 500 });
    }
}

// ===== src/app/contact-us/page.tsx =====

// src/app/contact-us/page.tsx
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import type { Metadata } from "next";
import { Mail, Phone, MapPin } from "lucide-react";
import axios from "axios"; // For server-side data fetching

import ContactFormClient from "@/components/ContactFormClient";
import NewsListItem from "@/components/NewsListItem"; // Reusing for news list (might need prop adjustments)
import AdSlotWidget from "@/components/AdSlotWidget";

const fetchSidebarNews = async (): Promise<any[]> => {
  const publicAppUrl = process.env.NEXT_PUBLIC_PUBLIC_APP_URL;
  if (!publicAppUrl) {
    console.error(
      "[Contact Us Page] NEXT_PUBLIC_PUBLIC_APP_URL is not defined! Cannot fetch news."
    );
    return [];
  }
  try {
    // Fetch latest 3 published posts for the sidebar
    const { data } = await axios.get(
      `${publicAppUrl}/api/posts?status=published&limit=3`,
      { timeout: 10000 }
    );
    console.log(
      `[Contact Us Page] Fetched ${data.length} news posts for sidebar.`
    );
    return data;
  } catch (error: any) {
    console.error(
      "[Contact Us Page] Failed to fetch news for sidebar:",
      error.message
    );
    return [];
  }
};

// --- Metadata for the Contact Us page (Server-side) ---
export const metadata: Metadata = {
  title: "Contact Us | Fan Skor Destek",
  description:
    "Get in touch with Fanskor support team. Send us your questions, feedback, or inquiries through our contact form or find our contact details here.",
  alternates: {
    canonical: `/contact-us`,
  },
  openGraph: {
    title: "Contact Us | Fan Skor Destek",
    description:
      "Get in touch with Fanskor support team. Send us your questions, feedback, or inquiries through our contact form or find our contact details here.",
    url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/contact-us`,
    siteName: "Fan Skor",
    type: "website",
  },
};

// --- Main Contact Us Page Component (Server-side) ---
export default async function ContactUsPage() {
  // Make async to await data fetching
  // --- SEO Description for the page content ---
  const contactPageSeoText =
    `Fanskor ekibine ulaşmak için doğru yerdesiniz! ` +
    `Sorularınız, geri bildirimleriniz, ortaklık talepleriniz veya herhangi bir konuda yardıma ihtiyacınız olduğunda bize ulaşmaktan çekinmeyin. ` +
    `Müşteri memnuniyeti bizim için önceliktir ve tüm mesajlarınıza en kısa sürede yanıt vermeyi taahhüt ediyoruz. ` +
    `Aşağıdaki formu kullanarak bize doğrudan mesaj gönderebilir veya iletişim bilgilerimiz aracılığıyla bize ulaşabilirsiniz.`;

  // --- Fetch data for right sidebar in parallel ---
  const [sidebarNews] = await Promise.all([fetchSidebarNews()]);

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr_288px] lg:gap-8 lg:items-start p-4 lg:p-0 lg:py-6">
        {" "}
        {/* Changed grid: 288px sidebar, 1fr main, 288px right sidebar */}
        <Sidebar /> {/* Left sidebar */}
        <main className="min-w-0">
          {" "}
          {/* Main content area */}
          {/* Page Heading and Description for SEO */}
          <div className="bg-brand-secondary p-6 rounded-lg shadow-xl mb-8">
            <h1 className="text-3xl font-bold text-white mb-3">
              İletişim Kurun
            </h1>
            <p className="text-brand-light text-base leading-relaxed">
              {contactPageSeoText}
            </p>
          </div>
          <div className="grid grid-cols-1 gap-8">
            {/* Contact Form (Client Component) */}
            <ContactFormClient />

            {/* Contact Details Section (Server-rendered) */}
            <div className="bg-brand-secondary p-8 rounded-lg shadow-xl">
              <h2 className="text-3xl font-bold text-white mb-6">
                İletişim Bilgileri
              </h2>
              <div className="space-y-6 text-brand-light">
                <div className="flex items-center gap-4">
                  <Mail size={24} className="text-brand-purple" />
                  <div>
                    <h3 className="font-semibold text-white">E-posta</h3>
                    <p className="text-brand-muted">support@fanskor.com</p>
                  </div>
                </div>
                <div className="flex items-center gap-4">
                  <Phone size={24} className="text-brand-purple" />
                  <div>
                    <h3 className="font-semibold text-white">Telefon</h3>
                    <p className="text-brand-muted">+90 (555) 123 45 67</p>
                  </div>
                </div>
                <div className="flex items-center gap-4">
                  <MapPin size={24} className="text-brand-purple" />
                  <div>
                    <h3 className="font-semibold text-white">Adres</h3>
                    <p className="text-brand-muted">
                      Futbol Caddesi No: 10, Skor Mahallesi <br />
                      Şampiyon Şehir, Türkiye
                    </p>
                  </div>
                </div>
                <div className="text-sm pt-4 border-t border-gray-700 text-brand-muted">
                  Mesajınıza 24 saat içinde yanıt vermeyi hedefliyoruz.
                </div>
              </div>
            </div>
          </div>
        </main>
        {/* --- NEW: Right Sidebar --- */}
        <aside className="lg:col-span-1 space-y-8 min-w-0">
          {/* News List Widget */}
          <section className="bg-brand-secondary rounded-lg shadow-lg p-6">
            <h2 className="text-2xl font-bold text-white mb-4">Son Haberler</h2>
            {sidebarNews && sidebarNews.length > 0 ? (
              <div className="space-y-4">
                {sidebarNews.map((post: any) => (
                  <NewsListItem key={post._id} post={post} />
                ))}
              </div>
            ) : (
              <p className="text-brand-muted text-center text-sm">
                Güncel haber bulunamadı.
              </p>
            )}
          </section>
          {/* Ad Slot (Right Sidebar) */}
          <AdSlotWidget location="homepage_right_sidebar" />
        </aside>
      </div>
    </div>
  );
}


// ===== src/app/football/league/[...slug]/page.tsx =====

// src/app/football/league/[...slug]/page.tsx
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import LeagueDetailView from "@/components/league-detail-view";
import axios from "axios";
import { notFound } from "next/navigation";

// Helper to extract the ID from the slug (e.g., "premier-league-39" -> "39")
const getLeagueIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

// The data fetching functions remain unchanged
async function getLeagueData(leagueId: string): Promise<any | null> {
  try {
    const { data } = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/leagues?id=${leagueId}`,
      {
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );

    if (!data.response || data.response.length === 0) {
      return null;
    }

    const leagueData = data.response[0];

    const standingsResponse = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/standings`,
      {
        params: { league: leagueId, season: new Date().getFullYear() },
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );

    leagueData.league.standings =
      standingsResponse.data.response[0]?.league?.standings || [];
    return leagueData;
  } catch (error) {
    console.error("Failed to fetch single league data:", error);
    return null;
  }
}

export async function generateMetadata({
  params,
}: {
  params: { slug: string[] };
}) {
  const slug = params.slug.join("/");
  const leagueId = getLeagueIdFromSlug(slug);
  if (!leagueId) return { title: "League Not Found" };

  const leagueData = await getLeagueData(leagueId);
  if (!leagueData) return { title: "League Not Found" };

  return {
    title: `${leagueData.league.name} - Info, Fixtures & Standings`,
    description: `All information about the ${leagueData.league.name}, including available seasons, fixtures, and full standings.`,
    alternates: {
      canonical: `/football/league/${slug}`,
    },
  };
}

// --- THE MAIN PAGE COMPONENT ---
export default async function LeaguePage({
  params,
}: {
  params: { slug: string[] };
}) {
  const slug = params.slug.join("/");
  const leagueId = getLeagueIdFromSlug(slug);

  if (!leagueId) {
    notFound();
  }

  const leagueData = await getLeagueData(leagueId);

  if (!leagueData) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <LeagueDetailView leagueData={leagueData} />
        </main>
      </div>
    </div>
  );
}


// ===== src/app/football/leagues/page.tsx =====

// src/app/football/leagues/page.tsx
// This is now a Server Component. Removed "use client";
import { headers } from "next/headers"; // Used for locale detection on server if needed, though not directly for SEO text
import axios from "axios";
import type { Metadata } from "next"; // Import Metadata type

import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import LeagueListClient from "@/components/LeagueListClient"; // <-- NEW IMPORT: Client Component
import { League } from "@/types/api-football"; // Assuming League type is accessible

// This ensures dynamic rendering for this page if it uses headers, cookies, etc.
// For metadata, it's often implicit, but explicit for page content.
export const dynamic = "force-dynamic";

// --- Server-side Data Fetching for Initial Leagues List ---
const fetchAllLeaguesServer = async (): Promise<League[]> => {
  const publicAppUrl = process.env.NEXT_PUBLIC_PUBLIC_APP_URL;
  if (!publicAppUrl) {
    console.error(
      "[Leagues Page Server] NEXT_PUBLIC_PUBLIC_APP_URL is not defined! Cannot fetch all leagues."
    );
    return [];
  }
  const apiUrl = `${publicAppUrl}/api/leagues?fetchAll=true`;
  console.log(
    `[Leagues Page Server] Attempting to fetch all leagues from internal API: ${apiUrl}`
  );
  try {
    const { data } = await axios.get(apiUrl, { timeout: 15000 }); // Increased timeout
    console.log(
      `[Leagues Page Server] Successfully fetched ${data.length} leagues.`
    );
    return data;
  } catch (error: any) {
    console.error(
      `[Leagues Page Server] Failed to fetch all leagues (${apiUrl}):`,
      error.message
    );
    if (axios.isAxiosError(error) && error.response) {
      console.error(
        "[Leagues Page Server] API Response Error (Status, Data):",
        error.response.status,
        error.response.data
      );
    }
    return [];
  }
};

// --- DYNAMIC METADATA GENERATION FOR LEAGUES PAGE ---
export async function generateMetadata(): Promise<Metadata> {
  const pageTitle =
    "All Football Leagues & Cups | Find Your Favorite Competition";
  const pageDescription =
    "Explore a comprehensive list of football leagues and cups from around the world. Find detailed information, standings, fixtures, and more for top divisions and international competitions.";

  // Construct Canonical URL
  const canonicalUrl = `/football/leagues`;

  console.log(
    `[Leagues Metadata] Generating metadata. Canonical: ${canonicalUrl}`
  );

  return {
    title: pageTitle,
    description: pageDescription,
    alternates: {
      canonical: canonicalUrl,
    },
    openGraph: {
      title: pageTitle,
      description: pageDescription,
      url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/football/leagues`,
      siteName: "Fan Skor",
      // images: [{ url: `${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/og-image.jpg` }],
      type: "website",
    },
    twitter: {
      card: "summary_large_image",
      title: pageTitle,
      description: pageDescription,
      // images: [`${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/twitter-image.jpg`],
    },
  };
}

export default async function LeaguesPage() {
  console.log(
    "[Leagues Page Server] Rendering LeaguesPage (Server Component)."
  );

  // Fetch all leagues server-side
  const allLeagues = await fetchAllLeaguesServer();

  // --- Generate SEO Text for the page ---
  const leaguesPageSeoText = `Futbol dünyasının kalbine hoş geldiniz! Bu sayfada, en heyecan verici yerel liglerden prestijli uluslararası kupalara kadar, dünya genelindeki tüm futbol liglerini ve kupalarını keşfedebilirsiniz. Takımların güncel sıralamalarını, yaklaşan fikstürlerini ve tarihi istatistiklerini kolayca bulun. En sevdiğiniz ligin detaylı analizlerine dalın ve futbolun nabzını tutun.`;

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <h1 className="text-4xl font-extrabold text-white mb-6">
            Leagues & Cups
          </h1>

          {/* Render the SEO text from the server */}
          <p className="italic text-[#a3a3a3] leading-relaxed mb-8">
            {leaguesPageSeoText}
          </p>

          {/* Render the Client Component, passing the initial server-fetched data */}
          <LeagueListClient initialAllLeagues={allLeagues} />
        </main>
      </div>
    </div>
  );
}


// ===== src/app/football/match/[...slug]/page.tsx =====

// src/app/football/match/[...slug]/page.tsx
// This is now a Server Component. No "use client" directive here.

import { notFound } from "next/navigation";
import axios from "axios";
import type { Metadata } from "next";

// Removed server-side i18n imports
// import { getDictionary } from '@/i18n.server';
// import { Locale } from '@/i18n.config';

// Import all the components used on this page
import Header from "@/components/Header";
import MatchHeader from "@/components/match/MatchHeader";
import MatchStatusBanner from "@/components/match/MatchStatusBanner";
import MatchH2HWidget from "@/components/match/MatchH2HWidget";
import MatchLineupsWidget from "@/components/match/MatchLineupsWidget";
import AdSlotWidget from "@/components/AdSlotWidget";
import MatchPredictionWidget from "@/components/match/MatchPredictionWidget";
import TeamFormWidget from "@/components/match/TeamFormWidget";
import LiveOddsWidget from "@/components/match/LiveOddsWidget";
import MatchActivityWidget from "@/components/match/MatchActivityWidget";
import TeamStandingsWidget from "@/components/match/TeamStandingsWidget";
import CasinoPartner from "@/models/CasinoPartner";
import CasinoPartnerWidget from "@/components/CasinoPartnerWidget";

// --- Helper Functions (callable by server components) ---
const getFixtureIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

// Server-side data fetching for initial page render and metadata
const fetchMatchDetailsServer = async (fixtureId: string) => {
  const publicAppUrl = process.env.NEXT_PUBLIC_PUBLIC_APP_URL;
  if (!publicAppUrl) {
    console.error(
      "[Match Page Server] NEXT_PUBLIC_PUBLIC_APP_URL is not defined! Cannot fetch data."
    );
    return null;
  }
  const apiUrl = `${publicAppUrl}/api/match-details?fixture=${fixtureId}`;
  console.log(
    `[Match Page Server] Attempting to fetch initial match data from internal API: ${apiUrl}`
  );

  try {
    const { data } = await axios.get(apiUrl, { timeout: 10000 });
    console.log(
      `[Match Page Server] Successfully fetched initial match data for fixture ID ${fixtureId}.`
    );
    return data;
  } catch (error: any) {
    console.error(
      `[Match Page Server] Failed to fetch initial match details (${apiUrl}):`,
      error.message
    );
    if (axios.isAxiosError(error) && error.response) {
      console.error(
        "[Match Page Server] API Response Error (Status, Data):",
        error.response.status,
        error.response.data
      );
    }
    return null;
  }
};

// Skeleton Component (remains unchanged)
const PageSkeleton = () => (
  <div className="animate-pulse container mx-auto p-4 md:p-8">
    <div className="h-48 w-full bg-brand-secondary rounded-lg mb-2"></div>
    <div className="h-10 w-full bg-brand-secondary rounded-b-lg mb-8"></div>
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mt-8">
      <div className="lg:col-span-2 space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div className="h-96 w-full bg-brand-secondary rounded-lg"></div>
          <div className="h-96 w-full bg-brand-secondary rounded-lg"></div>
        </div>
        <div className="h-96 w-full bg-brand-secondary rounded-lg"></div>
        <div className="h-64 w-full bg-brand-secondary rounded-lg"></div>
      </div>
      <div className="lg:col-span-1 space-y-6">
        <div className="h-48 w-full bg-brand-secondary rounded-lg"></div>
        <div className="h-28 w-full bg-brand-secondary rounded-lg"></div>
        <div className="h-80 w-full bg-brand-secondary rounded-lg"></div>
        <div className="h-64 w-full bg-brand-secondary rounded-lg"></div>
        <div className="h-40 w-full bg-brand-secondary rounded-lg"></div>
      </div>
    </div>
  </div>
);

// --- DYNAMIC METADATA GENERATION ---
export async function generateMetadata({
  params,
}: {
  params: { slug: string[] }; // Removed locale from params
}): Promise<Metadata> {
  console.log(
    `[generateMetadata] Function called for params: ${JSON.stringify(
      params.slug
    )}`
  );

  const slug = params.slug.join("/");
  const fixtureId = getFixtureIdFromSlug(slug);

  if (!fixtureId) {
    console.warn(
      "[generateMetadata] No valid fixtureId obtained from slug. Returning default metadata."
    );
    return {
      title: "Match Not Found",
      description: "Details for this football match are not available.",
    };
  }

  const matchData = await fetchMatchDetailsServer(fixtureId);

  if (!matchData || !matchData.fixture) {
    console.warn(
      `[generateMetadata] Data for fixture ID ${fixtureId} is missing or incomplete. Returning default metadata.`
    );
    return {
      title: "Match Not Found",
      description: "Details for this football match are not available.",
    };
  }

  const homeTeamName = matchData.fixture.teams.home.name;
  const awayTeamName = matchData.fixture.teams.away.name;
  const leagueName = matchData.fixture.league.name;

  // Removed getDictionary call
  // const dict = await getDictionary(params.locale);

  const pageTitle = `${homeTeamName} vs ${awayTeamName} - Live Score, Prediction & Match Stats | ${leagueName}`;

  // Reverted to static description, or you can add client-side translation if desired.
  // For metadata, static is safer if not using server-side i18n directly.
  const pageDescription = `Get ready for an electrifying clash between ${homeTeamName} and ${awayTeamName}, promising intense competition and thrilling moments for football fans! As these two teams step onto the pitch, all eyes will be on their tactical setups, player performances, and the strategies they bring to secure vital points.`;

  // Construct Canonical URL: metadataBase from root layout + relative path
  const canonicalUrl = `/football/match/${slug}`;
  console.log(
    `[generateMetadata] Constructed Canonical URL (relative): ${canonicalUrl}`
  );

  const metadataResult: Metadata = {
    title: pageTitle,
    description: pageDescription,
    alternates: {
      canonical: canonicalUrl,
    },
    openGraph: {
      title: pageTitle,
      description: pageDescription,
    },
    twitter: {
      card: "summary_large_image",
      title: pageTitle,
      description: pageDescription,
    },
  };

  console.log(
    "[generateMetadata] Successfully generated metadata. Returning result."
  );
  return metadataResult;
}

// --- Main Page Component (Server Component) ---
export default async function MatchDetailPage({
  params,
}: {
  params: { slug: string[] }; // Removed locale from params
}) {
  console.log(
    `[Match Page Server] Rendering MatchDetailPage for slug: ${JSON.stringify(
      params.slug
    )}`
  );

  const slug = params.slug.join("/");
  const fixtureId = getFixtureIdFromSlug(slug);

  if (!fixtureId) {
    console.error(
      "[Match Page Server] No fixtureId available, calling notFound()."
    );
    notFound();
  }

  // Fetch initial data on the server
  const data = await fetchMatchDetailsServer(fixtureId);

  // Handle cases where data fetching fails or fixture is not found
  if (!data || !data.fixture) {
    console.error(
      `[Match Page Server] Initial data fetch failed or fixture not found for ID ${fixtureId}, calling notFound().`
    );
    notFound();
  }

  // Removed getDictionary call
  // const dict = await getDictionary(params.locale);

  // Determine if match is live (server-side, for initial render)
  const isLive = ["1H", "HT", "2H", "ET", "BT", "P", "LIVE"].includes(
    data.fixture.status?.short
  );

  const { fixture, h2h, analytics } = data;
  const { home: homeTeam, away: awayTeam } = fixture.teams;

  // --- Generate SEO Optimization Text for display on page ---
  // Pass team names for client-side translation in MatchHeader
  const matchSeoDescription = `${homeTeam.name}, son haftalarda dikkat çekici galibiyetler ve sağlam savunma performanslarıyla bu maça güçlü bir formda geliyor. Saldırı hattı keskin, birçok fırsat yaratarak rakip hatalarından faydalanıyor. Bu arada, ${awayTeam.name}  de direncini gösterdi, erken aksaklıklardan geri döndü ve sıralamada istikrarlı bir şekilde yükselmeye başladı. Taraftarlar, her iki takımdan da yüksek enerji, agresif baskı ve yaratıcı oyunlar bekleyebilirler.`;

  const h2hSeoDescription = `Tarihsel olarak, ${homeTeam.name} ve ${awayTeam.name} arasındaki karşılaşmalar sıkı geçmiş, skor farkları dar ve son dakika dramalarıyla dolu olmuştur. Topa sahip olma yüzdeleri, kaleye atılan şutlar ve pas tamamlama oranları gibi detaylı istatistikler, her kritik anı takip edebilmeniz için gerçek zamanlı olarak güncellenecek.`;

  // --- Generate SEO Optimization Text for Standings widget ---
  const standingsSeoDescription =
    `${homeTeam.name}'nın güçlü orta saha motoruna ve yıldız forvetine dikkat edin, her ikisi de savunmaları aşmak için hayati öneme sahip. ` +
    `Ancak, ${awayTeam.name} esas olarak güçlü stoper kombinasyonuna ve maçın seyrini her an değiştirebilecek hızlı kanat oyuncularına bağımlıdır.`;

  const activitySeoDescription = `Fanskor, stadyumdan canlı güncellemeler, gerçek zamanlı skorlar ve detaylı maç istatistikleri sunar. Taktik analizlerden gerçek zamanlı gol bildirimlerine kadar, tek bir önemli anı bile kaçırmayacaksınız. Sohbete katılın, tahminlerinizi paylaşın ve ${homeTeam.name} ile ${awayTeam.name} arasında üstünlük mücadelesinde heyecana kapılın.`;

  return (
    <div className="bg-brand-dark min-h-screen">
      <Header />
      <div className="container mx-auto p-2 md:p-4 lg:p-6 text-brand-light">
        {/* Pass team names to MatchHeader for client-side translation */}
        <MatchHeader
          fixture={fixture}
          analytics={analytics}
          matchSeoDescription={matchSeoDescription} // Changed prop name
        />
        <MatchStatusBanner fixture={fixture} />

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mt-8">
          <main className="lg:col-span-2 space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <TeamFormWidget
                teamStats={analytics.homeTeamStats}
                team={homeTeam}
                location="Home"
              />
              <TeamFormWidget
                teamStats={analytics.awayTeamStats}
                team={awayTeam}
                location="Away"
              />
            </div>

            <MatchH2HWidget
              h2h={h2h}
              teams={fixture.teams}
              currentFixtureId={fixtureId!}
              h2hSeoDescription={h2hSeoDescription}
            />

            <MatchActivityWidget
              fixtureId={fixtureId!}
              homeTeamId={homeTeam.id}
              awayTeamId={awayTeam.id}
              homeTeamLogo={homeTeam.logo}
              awayTeamLogo={awayTeam.logo}
              isLive={isLive}
              activitySeoDescription={activitySeoDescription}
            />
          </main>

          <aside className="lg:col-span-1 space-y-6 sticky top-6">
            {isLive && <LiveOddsWidget fixtureId={fixtureId!} />}

            <CasinoPartnerWidget />

            <TeamStandingsWidget
              leagueId={fixture.league.id}
              season={fixture.league.season}
              homeTeamId={homeTeam.id}
              awayTeamId={awayTeam.id}
              standingsSeoDescription={standingsSeoDescription}
            />

            <MatchPredictionWidget
              apiPrediction={analytics.prediction}
              customPrediction={analytics.customPrediction}
              bookmakerOdds={analytics.bookmakerOdds}
              teams={fixture.teams}
            />

            <MatchLineupsWidget lineups={fixture.lineups} />

            <AdSlotWidget location="match_sidebar" />
          </aside>
        </div>
      </div>
    </div>
  );
}


// ===== src/app/football/news/page.tsx =====

// src/app/football/news/page.tsx
"use client";

import { useState, useMemo, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { IPost } from "@/models/Post"; // Ensure IPost is imported
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import Pagination from "@/components/Pagination";
import NewsListItem, { NewsListItemSkeleton } from "@/components/NewsListItem";
import { Info, Newspaper } from "lucide-react";
import Script from "next/script";
import PostCategories, { NewsCategory } from "@/components/PostCategories"; // Import the new component and type

export const dynamic = "force-dynamic";

const ITEMS_PER_PAGE = 8;

const fetchNews = async (): Promise<IPost[]> => {
  // No change needed here, it fetches all published posts
  const { data } = await axios.get("/api/posts?status=published");
  return data;
};

export default function NewsPage() {
  const [currentPage, setCurrentPage] = useState(1);
  // Set default active category to "trending" for display, which maps to "all" for filtering
  const [activeCategory, setActiveCategory] =
    useState<NewsCategory>("trending");

  const { data: allNews, isLoading } = useQuery<IPost[]>({
    queryKey: ["allNewsArticles"],
    queryFn: fetchNews,
    staleTime: 1000 * 60 * 5,
  });

  // --- ENHANCED: Filtering and Pagination Logic ---
  const { paginatedData, totalPages } = useMemo(() => {
    if (!allNews) return { paginatedData: [], totalPages: 0 };

    // Map "trending" to "all" for actual filtering against post.sport
    const filterCategory =
      activeCategory === "trending" ? "all" : activeCategory;

    // 1. Filter by the effective category
    const filteredNews =
      filterCategory === "all"
        ? allNews
        : allNews.filter((post) => post.sport === filterCategory); // Assuming post.sport matches NewsCategory values

    // 2. Paginate the filtered results
    const totalPages = Math.ceil(filteredNews.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    const paginatedData = filteredNews.slice(startIndex, endIndex);

    return { paginatedData, totalPages };
  }, [allNews, currentPage, activeCategory]);

  // Reset page to 1 when category changes
  useEffect(() => {
    setCurrentPage(1);
  }, [activeCategory]);

  // --- SEO: JSON-LD Structured Data (No change) ---
  const generateJsonLd = () => {
    if (!paginatedData || paginatedData.length === 0) return null;

    const items = paginatedData.map((post) => ({
      "@type": "NewsArticle",
      headline: post.title,
      image: [post.featuredImage || ""],
      datePublished: post.createdAt,
      dateModified: post.updatedAt,
      author: [
        {
          "@type": "Person",
          name: post.author,
        },
      ],
    }));

    return {
      "@context": "https://schema.org",
      "@type": "ItemList",
      itemListElement: items.map((item, index) => ({
        "@type": "ListItem",
        position: (currentPage - 1) * ITEMS_PER_PAGE + index + 1,
        item: item,
      })),
    };
  };

  return (
    <>
      {/* Add the JSON-LD Script to the head of the page */}
      <Script
        id="news-list-jsonld"
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(generateJsonLd()) }}
      />
      <div className="min-h-screen flex flex-col">
        <Header />
        <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
          <Sidebar />
          <main className="min-w-0 p-4 lg:p-0 lg:py-6">
            {/* --- ENHANCED UI: Page Header --- */}
            <div className="flex items-center gap-4 mb-8">
              <div className="p-3 bg-brand-purple/10 rounded-lg">
                <Newspaper className="w-8 h-8 text-brand-purple" />
              </div>
              <div>
                <h1 className="text-4xl font-extrabold text-white">
                  Latest News
                </h1>
                <p className="text-brand-muted">
                  Stay updated with the latest stories and analysis.
                </p>
              </div>
            </div>

            {/* --- ENHANCED UI: Category Filters (Now using the new component) --- */}
            <PostCategories
              activeCategory={activeCategory}
              onCategoryChange={setActiveCategory}
            />

            {isLoading ? (
              <div className="space-y-4">
                {Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
                  <NewsListItemSkeleton key={i} />
                ))}
              </div>
            ) : paginatedData.length > 0 ? (
              <div className="space-y-4">
                {paginatedData.map((post) => (
                  <NewsListItem key={post._id} post={post} />
                ))}
                {totalPages > 1 && (
                  <Pagination
                    currentPage={currentPage}
                    totalPages={totalPages}
                    onPageChange={setCurrentPage}
                  />
                )}
              </div>
            ) : (
              <div className="text-center py-20 bg-brand-secondary rounded-lg">
                <Info size={32} className="mx-auto text-brand-muted mb-3" />
                <p className="text-xl font-bold text-white">No News Found</p>
                <p className="text-brand-muted mt-2">
                  There are no articles available in the "
                  {activeCategory === "trending" ? "All" : activeCategory}"
                  category.
                </p>
              </div>
            )}
          </main>
        </div>
      </div>
    </>
  );
}


// ===== src/app/football/news/[slug]/page.tsx =====

import { notFound } from "next/navigation";
import dbConnect from "@/lib/dbConnect";
import Post from "@/models/Post";
import { format } from "date-fns";
import Header from "@/components/Header";
import Image from "next/image"; // <-- Import next/image
import SocialShareButtons from "@/components/SocialShareButtons"; // We will create this next
import NewsSidebar from "@/components/NewsSidebar";

// This function fetches the data on the server
async function getPost(slug: string) {
  await dbConnect();
  const post: any = await Post.findOne({
    slug: slug,
    status: "published",
  }).lean();
  if (!post) {
    return null;
  }
  return post;
}

// Update generateMetadata to use the new meta fields if they exist
export async function generateMetadata({
  params,
}: {
  params: { slug: string };
}) {
  const post = await getPost(params.slug);
  if (!post) {
    return { title: "Not Found" };
  }
  return {
    // Use specific meta title if available, otherwise fall back to post title
    title: post.metaTitle || `${post.title} | Fulltime News`,
    // Use specific meta description if available
    description:
      post.metaDescription ||
      post.content.replace(/<[^>]*>?/gm, "").substring(0, 160),
  };
}

// --- The Main Page Component ---
export default async function NewsArticlePage({
  params,
}: {
  params: { slug: string };
}) {
  const post = await getPost(params.slug);

  if (!post) {
    notFound();
  }

  // We need to construct the full URL for sharing
  const postUrl = `${process.env.NEXTAUTH_URL}/news/${post.slug}`;

  return (
    <div className="bg-brand-dark min-h-screen">
      <Header />
      {/* --- UPDATED LAYOUT --- */}
      <main className="container mx-auto p-4 md:p-8 grid grid-cols-1 lg:grid-cols-3 gap-12">
        {/* Main Content (Article) - Spans 2 columns on large screens */}
        <div className="lg:col-span-2">
          <article className="bg-brand-secondary rounded-lg overflow-hidden">
            {post.featuredImage && (
              <div className="relative w-full h-64 md:h-96">
                <Image
                  src={post.featuredImage}
                  alt={post.featuredImageAltText || post.title}
                  title={post.featuredImageTitle || post.title}
                  layout="fill"
                  objectFit="cover"
                  priority
                />
              </div>
            )}

            <div className="p-8">
              <div className="mb-8 text-center border-b border-gray-700/50 pb-8">
                <h1 className="text-4xl md:text-5xl font-extrabold text-white leading-tight mb-4">
                  {post.title}
                </h1>
                <p className="text-brand-muted">
                  Published by {post.author} on{" "}
                  {format(new Date(), "MMMM dd, yyyy")}
                </p>
              </div>

              <div
                className="prose prose-invert lg:prose-xl max-w-none"
                dangerouslySetInnerHTML={{ __html: post.content }}
              />

              <div className="mt-12 pt-8 border-t border-gray-700/50">
                <h3 className="text-lg font-bold text-center text-brand-muted mb-4">
                  Share this article
                </h3>
                <SocialShareButtons url={postUrl} title={post.title} />
              </div>
            </div>
          </article>
        </div>

        {/* Sidebar - Spans 1 column on large screens */}
        <div className="lg:col-span-1">
          <NewsSidebar />
        </div>
      </main>
    </div>
  );
}
// Optional: For better performance in production, generate static pages for each post at build time.
export async function generateStaticParams() {
  await dbConnect();
  const posts = await Post.find({ status: "published" }).select("slug").lean();
  return posts.map((post) => ({
    slug: post.slug,
  }));
}


// ===== src/app/football/team/[...slug]/page.tsx =====

// src/app/football/team/[...slug]/page.tsx
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import TeamDetailView from "@/components/TeamDetailView";
import { notFound } from "next/navigation";
import axios from "axios";
import type { Metadata } from "next"; // <-- NEW IMPORT for Metadata

// Helper to extract the ID from the slug (unchanged)
const getTeamIdFromSlug = (slug: string): string | null => {
  if (!slug) return null;
  const parts = slug.split("-");
  const lastPart = parts[parts.length - 1];
  return /^\d+$/.test(lastPart) ? lastPart : null;
};

// --- THIS IS THE CORRECTED DATA FETCHING FUNCTION ---
async function getTeamData(teamId: string) {
  const season = new Date().getFullYear();

  // Reusable options object for axios requests
  const options = (endpoint: string, params: object) => ({
    method: "GET",
    url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
    params,
    headers: { "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
  });

  try {
    const [teamInfoRes, squadRes, fixturesRes] = await Promise.all([
      axios.request(options("teams", { id: teamId })),
      axios.request(options("players/squads", { team: teamId })),
      axios.request(
        options("fixtures", { team: teamId, season: season, last: 50 })
      ),
    ]);

    if (!teamInfoRes.data.response[0]) {
      return null;
    }

    return {
      teamInfo: teamInfoRes.data.response[0],
      squad: squadRes.data.response[0]?.players || [],
      fixtures: fixturesRes.data.response || [],
    };
  } catch (error) {
    console.error(`Failed to fetch team details for teamId ${teamId}:`, error);
    return null;
  }
}

// --- generateMetadata function ---
export async function generateMetadata({
  params,
}: {
  params: { slug: string[] };
}): Promise<Metadata> {
  // Specify Metadata return type
  // --- THE FIX IS HERE: AWAIT params ---
  const awaitedParams = await params; // Await the params object
  const slug = awaitedParams.slug.join("/");
  const teamId = getTeamIdFromSlug(slug);

  if (!teamId) {
    return { title: "Team Not Found" };
  }

  try {
    const { data } = await axios.get(
      `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams?id=${teamId}`,
      {
        headers: {
          "x-apisports-key": process.env.NEXT_PUBLIC_API_FOOTBALL_KEY,
        },
      }
    );
    const teamInfo = data.response[0];
    if (!teamInfo) return { title: "Team Not Found" };

    const pageTitle = `${teamInfo.team.name} - Squad, Fixtures & Standings`;
    const pageDescription = `View the full squad, recent fixtures, and current standings for ${teamInfo.team.name}.`;
    const canonicalUrl = `/football/team/${slug}`;

    return {
      title: pageTitle,
      description: pageDescription,
      alternates: {
        canonical: canonicalUrl,
      },
      openGraph: {
        title: pageTitle,
        description: pageDescription,
        // images: [`${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/api/image-proxy?url=${encodeURIComponent(teamInfo.team.logo)}`],
      },
      twitter: {
        card: "summary_large_image",
        title: pageTitle,
        description: pageDescription,
        // images: [`${process.env.NEXT_PUBLIC_PUBLIC_APP_URL}/api/image-proxy?url=${encodeURIComponent(teamInfo.team.logo)}`],
      },
    };
  } catch {
    return { title: "Team Not Found" };
  }
}

// THE MAIN PAGE COMPONENT
export default async function TeamPage({
  params,
}: {
  params: { slug: string[] };
}) {
  // --- THE FIX IS HERE: AWAIT params ---
  const awaitedParams = await params; // Await the params object
  const slug = awaitedParams.slug.join("/");
  const teamId = getTeamIdFromSlug(slug);

  if (!teamId) {
    notFound();
  }

  const teamData = await getTeamData(teamId);

  if (!teamData) {
    notFound();
  }

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <TeamDetailView teamData={teamData} />
        </main>
      </div>
    </div>
  );
}


// ===== src/app/football/teams/page.tsx =====

// src/app/football/teams/page.tsx
"use client";

import { useState, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import StyledLink from "@/components/StyledLink";
import { ChevronRight, Globe, Search, Users } from "lucide-react";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";

export const dynamic = "force-dynamic";

// --- TYPE DEFINITION ---
interface EnrichedCountry {
  name: string;
  code: string | null;
  flagUrl: string;
  leagueCount: number;
}

// --- CARD AND SKELETON COMPONENTS (Unchanged) ---
const EnhancedCountryCard = ({ country }: { country: EnrichedCountry }) => (
  <StyledLink
    href={`/football/teams/${country.name}`}
    className="block group h-full"
  >
    <div className="bg-brand-secondary rounded-lg flex flex-col h-full transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20">
      <div className="p-4 flex items-center gap-4">
        <Image
          src={country.flagUrl}
          alt={country.name}
          width={40}
          height={40}
          className="rounded-full flex-shrink-0"
        />
        <div className="flex-1 min-w-0">
          <h3 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
            {country.name}
          </h3>
          <div className="flex items-center gap-1.5 text-xs text-brand-muted mt-1">
            <Globe size={12} />
            <span>View Teams</span>
          </div>
        </div>
        <ChevronRight className="text-brand-muted group-hover:text-brand-purple transition-colors flex-shrink-0" />
      </div>
      <div className="mt-auto border-t border-gray-700/50 p-3 text-xs text-brand-light flex items-center justify-center gap-2">
        <Users size={14} className="text-brand-muted" />
        <span className="font-semibold">{country.leagueCount}</span>
        <span>Professional Leagues</span>
      </div>
    </div>
  </StyledLink>
);

const CountryCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg flex flex-col h-full animate-pulse">
    <div className="p-4 flex items-center gap-4">
      <div className="w-10 h-10 rounded-full bg-gray-700"></div>
      <div className="space-y-2 flex-1">
        <div className="h-4 w-3/4 rounded bg-gray-600"></div>
        <div className="h-3 w-1/2 rounded bg-gray-600/50"></div>
      </div>
    </div>
    <div className="mt-auto border-t border-gray-700/50 p-3 flex items-center justify-center gap-2">
      <div className="h-4 w-2/3 bg-gray-700 rounded-md"></div>
    </div>
  </div>
);

export default function BrowseTeamsByCountryPage() {
  const [searchTerm, setSearchTerm] = useState("");

  // --- THIS IS THE FIX ---
  // Removed the external fetcher function and defined the query function directly and simply.
  // This is the most reliable pattern and avoids potential stale closure issues.
  const { data: countries, isLoading } = useQuery<EnrichedCountry[]>({
    queryKey: ["countryDirectory"],
    queryFn: async () => {
      const { data } = await axios.get("/api/directory/countries");
      return data;
    },
    staleTime: 1000 * 60 * 60 * 24, // Cache for a day
  });

  const filteredCountries = useMemo(() => {
    if (!countries) return [];
    return countries.filter((country) =>
      country.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [countries, searchTerm]);

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <h1 className="text-4xl font-extrabold text-white mb-2">
            Browse Teams by Country
          </h1>
          <p className="text-brand-muted mb-8">
            Select a country to view all associated professional teams.
          </p>

          <div className="relative mb-8 max-w-lg">
            <Search
              className="absolute left-3.5 top-1/2 -translate-y-1/2 text-brand-muted"
              size={20}
            />
            <input
              type="text"
              placeholder="Search for a country..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-3 pl-12 text-white focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
          </div>

          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-2 xl:grid-cols-3 gap-4">
            {isLoading ? (
              Array.from({ length: 18 }).map((_, i) => (
                <CountryCardSkeleton key={i} />
              ))
            ) : filteredCountries && filteredCountries.length > 0 ? (
              filteredCountries.map((country) => (
                <EnhancedCountryCard
                  key={country.code || country.name}
                  country={country}
                />
              ))
            ) : (
              <div className="text-center py-20 bg-brand-secondary rounded-lg col-span-full">
                <p className="text-xl font-bold text-white">
                  No Countries Found
                </p>
                <p className="text-brand-muted mt-2">
                  We couldn't find any countries with active leagues. Please
                  check back later.
                </p>
              </div>
            )}
          </div>
        </main>
      </div>
    </div>
  );
}


// ===== src/app/football/teams/[countryName]/page.tsx =====

// src/app/football/teams/[countryName]/page.tsx
"use client";

import { useState, useMemo, useEffect } from "react";
import { useParams } from "next/navigation";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import Pagination from "@/components/Pagination";
import StyledLink from "@/components/StyledLink";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import { Calendar, Info, MapPin, Search } from "lucide-react";

const ITEMS_PER_PAGE = 18;

// --- TYPE DEFINITION for the API response object ---
interface TeamsByCountryResponse {
  teams: any[];
  count: number;
}

// --- DATA FETCHER ---
const fetchTeamsByCountry = async (
  countryName: string
): Promise<TeamsByCountryResponse> => {
  const { data } = await axios.get(
    `/api/teams-by-country?country=${encodeURIComponent(countryName)}`
  );
  return data;
};

// EnhancedTeamCard and TeamCardSkeleton components remain the same
const EnhancedTeamCard = ({ team, venue }: { team: any; venue: any }) => (
  <StyledLink
    href={generateTeamSlug(team.name, team.id)}
    className="block group h-full"
  >
    <div className="bg-brand-secondary rounded-lg flex flex-col h-full transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20">
      <div className="p-4 flex items-center gap-4">
        <Image
          src={proxyImageUrl(team.logo)}
          alt={team.name}
          width={48}
          height={48}
          className="flex-shrink-0"
        />
        <div className="flex-1 min-w-0">
          <h3 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
            {team.name}
          </h3>
        </div>
      </div>
      <div className="px-4 pb-3 mt-auto border-t border-gray-700/50 pt-3 space-y-1.5 text-xs text-brand-muted">
        {team.founded && (
          <div className="flex items-center gap-2">
            <Calendar size={12} />
            <span>Founded: {team.founded}</span>
          </div>
        )}
        {venue?.name && (
          <div className="flex items-center gap-2 truncate">
            <MapPin size={12} />
            <span className="truncate" title={venue.name}>
              {venue.name}
            </span>
          </div>
        )}
      </div>
    </div>
  </StyledLink>
);

const TeamCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg p-4 h-36 animate-pulse">
    <div className="flex items-center gap-4">
      <div className="w-12 h-12 rounded-full bg-gray-700"></div>
      <div className="h-5 w-3/4 bg-gray-600 rounded"></div>
    </div>
    <div className="mt-6 space-y-2 border-t border-gray-700/50 pt-3">
      <div className="h-3 w-1/2 bg-gray-600/50 rounded"></div>
      <div className="h-3 w-full bg-gray-600/50 rounded"></div>
    </div>
  </div>
);

export default function TeamsByCountryPage() {
  const params = useParams();
  const countryName = decodeURIComponent(params.countryName as string);

  const [searchTerm, setSearchTerm] = useState("");
  const [currentPage, setCurrentPage] = useState(1);

  // --- FIX 1: Rename `data: teams` to `data: response` for clarity ---
  const { data: response, isLoading } = useQuery({
    queryKey: ["teamsByCountry", countryName],
    queryFn: () => fetchTeamsByCountry(countryName),
    staleTime: 1000 * 60 * 60,
  });

  const { paginatedData, totalPages } = useMemo(() => {
    // --- FIX 2: Access the `teams` array *from* the response object ---
    const teamsArray = response?.teams || []; // Use the actual array, or an empty one if data is not ready
    if (teamsArray.length === 0) return { paginatedData: [], totalPages: 0 };

    // --- FIX 3: Filter the `teamsArray`, not the response object ---
    const filtered = teamsArray.filter((teamData) =>
      teamData.team.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    const totalPages = Math.ceil(filtered.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    const paginatedData = filtered.slice(startIndex, endIndex);

    return { paginatedData, totalPages };
  }, [response, searchTerm, currentPage]);

  useEffect(() => {
    setCurrentPage(1);
  }, [searchTerm]);

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:gap-8 lg:items-start">
        <Sidebar />
        <main className="min-w-0 p-4 lg:p-0 lg:py-6">
          <h1 className="text-4xl font-extrabold text-white mb-6">
            Teams in {countryName}
          </h1>

          <div className="flex flex-col md:flex-row gap-4 mb-8">
            <div className="relative flex-grow">
              <Search
                className="absolute left-3.5 top-1/2 -translate-y-1/2 text-brand-muted"
                size={20}
              />
              <input
                type="text"
                placeholder="Search by team name..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-3 pl-12 text-white focus:outline-none focus:ring-2 focus:ring-brand-purple"
              />
            </div>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
            {isLoading ? (
              Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
                <TeamCardSkeleton key={i} />
              ))
            ) : paginatedData.length > 0 ? (
              paginatedData.map((teamData) => (
                <EnhancedTeamCard
                  key={teamData.team.id}
                  team={teamData.team}
                  venue={teamData.venue}
                />
              ))
            ) : (
              <div className="col-span-full text-center py-20 bg-brand-secondary rounded-lg">
                <Info size={32} className="mx-auto text-brand-muted mb-3" />
                <p className="text-xl font-bold text-white">No Results Found</p>
                <p className="text-brand-muted mt-2">
                  Try adjusting your search term or check back later.
                </p>
              </div>
            )}
          </div>

          {!isLoading && paginatedData.length > 0 && (
            <Pagination
              currentPage={currentPage}
              totalPages={totalPages}
              onPageChange={setCurrentPage}
            />
          )}
        </main>
      </div>
    </div>
  );
}


// ===== src/app/globals.css =====

@import "tailwindcss";

@tailwind base;
@tailwind components;
@tailwind utilities;
@import "nprogress/nprogress.css";
@import "slick-carousel/slick/slick.css";
@import "slick-carousel/slick/slick-theme.css";

.prose h2 {
  color: #e0e0e0; /* text-brand-light or white, matching your theme */
  font-size: 2.25rem; /* text-4xl equivalent */
  font-weight: 800; /* font-extrabold equivalent */
  margin-top: 2.5em; /* More space above */
  margin-bottom: 1em; /* More space below */
  border-bottom: 2px solid #ea591d; /* brand-purple color */
  padding-bottom: 0.5rem; /* Space under the line */
  line-height: 1.2;
}

/* Targeting H3 within a prose container */
.prose h3 {
  color: #e0e0e0; /* text-brand-light or white */
  font-size: 1.75rem; /* text-3xl equivalent */
  font-weight: 700; /* font-bold equivalent */
  margin-top: 2em;
  margin-bottom: 0.75em;
  line-height: 1.3;
}

/* Optional: If you're using prose-xl, you might want more aggressive styling */
/* For example, if .prose-xl h2 needs to be even bigger */
.prose-xl h2 {
  font-size: 2.5rem; /* Even larger for prose-xl on large screens */
  margin-top: 3em;
  margin-bottom: 1.2em;
}
.prose-xl h3 {
  font-size: 2rem; /* Even larger for prose-xl on large screens */
  margin-top: 2.5em;
  margin-bottom: 1em;
}

/* Ensure other prose elements like strong, em are not overridden by mistake if you added them */
.prose strong {
  color: #ffffff; /* Ensure bold is white */
}
.prose em {
  color: #e0e0e0; /* Ensure italic is brand-light */
}
.prose ul,
.prose ol {
  list-style-position: outside;
  padding-left: 1.5em;
}
.prose ul > li::before {
  background-color: #ea591d; /* Bullet color matching brand purple */
}
.prose a {
  color: #ea591d; /* Link color matching brand purple */
  text-decoration: none;
}
.prose a:hover {
  text-decoration: underline;
}

/* @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap'); */

/* --- NEW: High-Contrast Orange & Black Color System --- */
:root {
  /* Core Layout Colors */
  --color-background: #020202; /* Your deep black for the main background */
  --color-primary: #1a1a1a; /* A slightly lighter black for primary containers */
  --color-secondary: #2a2a2a; /* The lightest black for interactive cards */

  /* Text Colors */
  --text-primary: #fffffd; /* Your bright white for key info */
  --text-secondary: #e0e0e0; /* A slightly dimmer white for secondary text */
  --text-muted: #9e9e9e; /* A muted gray for non-critical details */

  /* Brand & Accent Colors */
  --brand-accent: #ed5c19; /* Your vibrant orange for primary actions */
  --brand-live: #ef4444; /* Red is still best for "live" indicators */
  --brand-yellow: #fbbf24; /* A complementary yellow for highlights like odds */
}

body {
  background-color: var(--color-background);
  color: var(--text-primary);
  font-family: var(--font-sans);
}

.custom-scrollbar {
  overflow-y: auto;
  scroll-behavior: smooth;

  /* For Firefox */
  scrollbar-width: thin;
  scrollbar-color: #393f47 transparent; /* thumb-color track-color */
}

/* For WebKit-based browsers (Chrome, Safari, Edge) 
*/
.custom-scrollbar::-webkit-scrollbar {
  width: 8px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background-color: #f3f4f6; /* Equivalent to track-gray-100 */
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background-color: #1f2937; /* Equivalent to thumb-gray-800 */
  border-radius: 10px;
}
.bg-brand-secondary {
  background-color: var(--tw-color-brand-secondary);
}

.slick-dots li.slick-active div {
  background-color: #8b5cf6 !important;
}

/* 1. Define the animation's steps using @keyframes */
@keyframes breathing-glow {
  0%,
  100% {
    /* A subtle green glow at the start and end */
    box-shadow: 0 0 10px 0px rgba(52, 211, 153, 0.4);
    transform: scale(1);
  }
  50% {
    /* A brighter, larger green glow in the middle of the animation */
    box-shadow: 0 0 25px 5px rgba(52, 211, 153, 0.7);
    transform: scale(1.05);
  }
}

/* 2. Create a reusable class that applies the animation */
.animate-breathing-glow {
  animation: breathing-glow 2.5s ease-in-out infinite;
}

/* Style the content generated by Tiptap */
.tiptap > * + * {
  margin-top: 0.75em;
}

.tiptap ul,
.tiptap ol {
  padding: 0 1rem;
}

.tiptap h1,
.tiptap h2,
.tiptap h3,
.tiptap h4,
.tiptap h5,
.tiptap h6 {
  line-height: 1.1;
}

.tiptap code {
  background-color: rgba(255, 255, 255, 0.1);
  color: #a1a1aa; /* zinc-400 */
  padding: 0.2rem 0.4rem;
  border-radius: 0.25rem;
  font-size: 0.9em;
}

.tiptap pre {
  background: #18181b; /* zinc-900 */
  color: #fff;
  font-family: "JetBrainsMono", "Courier New", Courier, monospace;
  padding: 0.75rem 1rem;
  border-radius: 0.5rem;
}

.tiptap pre code {
  color: inherit;
  padding: 0;
  background: none;
  font-size: 0.8rem;
}

.tiptap img {
  max-width: 100%;
  height: auto;
}

.tiptap blockquote {
  padding-left: 1rem;
  border-left: 2px solid rgba(255, 255, 255, 0.2);
}

.tiptap hr {
  border: none;
  border-top: 2px solid rgba(255, 255, 255, 0.2);
  margin: 2rem 0;
}

.slick-dots li.slick-active div {
  background-color: #8b5cf6; /* This is a Tailwind color for brand-purple */
}

/* 
  Custom NProgress styles to match your brand color.
  This targets the bar and the "peg" (the little circle at the end).
*/
#nprogress .bar {
  background: var(--brand-accent) !important;
  height: 3px !important;
}
#nprogress .peg {
  box-shadow: 0 0 10px var(--brand-accent), 0 0 5px var(--brand-accent) !important;
}

/* DEPRECATED: We will stop using these classes directly */
/* .bg-brand-dark { background-color: var(--color-background); } */
.bg-brand-secondary {
  background-color: var(--color-primary);
}
.text-brand-light {
  color: var(--text-primary);
}
.text-brand-muted {
  color: var(--text-muted);
}


// ===== src/app/layout.tsx =====

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import Providers from "./providers";
import { LeagueProvider } from "@/context/LeagueContext";
import "slick-carousel/slick/slick.css";
import "slick-carousel/slick/slick-theme.css";
import { LanguageProvider } from "@/context/LanguageContext";
import NextAuthProvider from "./NextAuthProvider";
import { Suspense } from "react";
import StickyFooterAd from "@/components/StickyFooterAd";
import Loading from "./loading";
import Footer from "@/components/Footer";

const inter = Inter({ subsets: ["latin"] });

const METADATA_BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";

export const metadata: Metadata = {
  metadataBase: new URL(METADATA_BASE_URL),
  alternates: {
    canonical: "/",
  },
  title: "Fan Skor | Canlı Skorlar, Tahminler ve En İyi Futbol Ligleri",
  description:
    "Fan Skor, canlı skorlar, haberler, tahminler, en iyi ligler, takım istatistikleri, uzman makaleleri ve güvenilir ortaklıkları tek bir platformda sunar.",
  icons: {
    icon: [{ url: "/favicon.ico", type: "image/png" }],
    apple: [{ url: "/favicon.ico" }],
  },
  robots: {
    index: true,
    follow: true,
    googleBot: {
      index: true,
      follow: true,
    },
  },
  // --- ADDED DEFAULT OPEN GRAPH TAGS ---
  openGraph: {
    title: "Fan Skor | Canlı Skorlar, Tahminler ve En İyi Futbol Ligleri",
    description:
      "Fan Skor, canlı skorlar, haberler, tahminler, en iyi ligler, takım istatistikleri, uzman makaleleri ve güvenilir ortaklıkları tek bir platformda sunar.",
    url: METADATA_BASE_URL, // Canonical URL for the site root
    siteName: "Fan Skor",
    images: [
      {
        url: `${METADATA_BASE_URL}/og-image.jpg`, // You should create this image in your public folder
        width: 1200,
        height: 630,
        alt: "Fan Skor - Türkiye Canlı Skor Sitesi",
      },
    ],
    locale: "en_US", // Default locale, can be changed dynamically by pages if i18n is used
    type: "website",
  },
  // --- ADDED DEFAULT TWITTER CARD TAGS ---
  twitter: {
    card: "summary_large_image",
    title: "Fan Skor | Canlı Skorlar, Tahminler ve En İyi Futbol Ligleri",
    description:
      "Fan Skor, canlı skorlar, haberler, tahminler, en iyi ligler, takım istatistikleri, uzman makaleleri ve güvenilir ortaklıkları tek bir platformda sunar.",
    creator: "@fanskor_official", // Your Twitter handle
    images: [`${METADATA_BASE_URL}/twitter-image.jpg`], // You should create this image in your public folder
  },
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body
        className={`${inter.className} bg-background text-text-primary`}
        suppressHydrationWarning={true}
      >
        <Suspense fallback={<Loading />}>
          <NextAuthProvider>
            <Providers>
              <LanguageProvider>
                <LeagueProvider>
                  <main>{children}</main>
                  <StickyFooterAd />
                  <Footer />
                </LeagueProvider>
              </LanguageProvider>
            </Providers>
          </NextAuthProvider>
        </Suspense>
      </body>
    </html>
  );
}


// ===== src/app/loading.tsx =====

// src/app/loading.tsx
// This file acts as the server-side container for our client-side preloader.

import LottiePreloader from "@/components/LottiePreloader"; // Import the new component

export default function Loading() {
  return (
    <div className="fixed inset-0 z-[100] flex items-center justify-center bg-[#1F1D2B]">
      {/* 
        We render the LottiePreloader component here. 
        Next.js will handle rendering the client component within this server component shell.
      */}
      <LottiePreloader />
    </div>
  );
}


// ===== src/app/login/page.tsx =====

"use client";

import { useState } from 'react';
import { signIn } from 'next-auth/react';
import { useRouter, useSearchParams } from 'next/navigation';
import { useTranslation } from '@/hooks/useTranslation';


export const dynamic = 'force-dynamic';

export default function LoginPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { t } = useTranslation();
  
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState(searchParams.get('error') || '');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    const result = await signIn('credentials', {
      redirect: false,
      email,
      password,
    });

    if (result?.error) {
      setError(t('invalid_credentials'));
    } else if (result?.ok) {
      router.push('/admin/dashboard');
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-brand-dark">
      <form onSubmit={handleSubmit} className="p-8 rounded-lg shadow-lg bg-brand-secondary w-full max-w-sm">
        <h1 className="text-2xl font-bold mb-6 text-center text-white">{t('admin_login')}</h1>
        {error && <p className="bg-red-500/20 text-red-400 p-3 rounded mb-4 text-sm">{error}</p>}
        <div className="space-y-4">
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder={t('email')}
            required
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder={t('password')}
            required
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
          />
        </div>
        <button type="submit" className="w-full mt-6 bg-brand-purple text-white font-bold py-3 rounded-lg hover:opacity-90 transition-opacity">
          {t('sign_in')}
        </button>
      </form>
    </div>
  );
}

// ===== src/app/NextAuthProvider.tsx =====

// src/app/NextAuthProvider.tsx
"use client";

import { SessionProvider } from "next-auth/react";

// This is a new wrapper component
export default function NextAuthProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  return <SessionProvider>{children}</SessionProvider>;
}

// ===== src/app/not-found.tsx =====

"use client";

import { Suspense } from 'react'; // <-- IMPORT Suspense
import Link from 'next/link';
import Header from '@/components/Header';
import { HeaderSkeleton } from '@/components/LayoutSkeletons'; // <-- IMPORT Skeleton
import { Frown } from 'lucide-react';

export default function NotFound() {
  return (
    <div className="min-h-screen flex flex-col">
      <Suspense fallback={<HeaderSkeleton />}>
        <Header />
      </Suspense>

      <main className="flex-1 flex flex-col items-center justify-center text-center p-4">
        <Frown className="w-16 h-16 text-text-muted mb-4" />
        <h1 className="text-4xl font-extrabold text-white">404 - Page Not Found</h1>
        <p className="text-lg text-text-secondary mt-2 mb-6">
          The page you are looking for does not exist or has been moved.
        </p>
        <Link 
            href="/"
            className="px-6 py-3 bg-brand-purple text-white font-bold rounded-lg hover:opacity-90 transition-opacity"
        >
          Go back to Homepage
        </Link>
      </main>
    </div>
  )
}

// ===== src/app/page.tsx =====

// src/app/page.tsx
import { Suspense } from "react";
import Header from "@/components/Header";
import Sidebar from "@/components/Sidebar";
import { MainContent } from "@/components/MainContent"; // This is a Client Component
import { SidebarSkeleton } from "@/components/LayoutSkeletons";

export default async function HomePage() {
  // --- Generate Homepage About SEO Text ---
  const homepageAboutSeoText = `Fanskor'da, size sadece gerçek zamanlı olarak düzenli olarak güncellenen Türk Süper Ligi'nin sonuçları ve puan durumlarından daha fazlasını sunuyoruz, ayrıca maç başlar başlamaz size en kapsamlı maç incelemesini ve canlı skorları veriyoruz, böylece Fanskor ile her zaman Türk Süper Ligi'nin nabzını tutuyorsunuz!
      Her bir golü veya diğer önemli anları kapsamak için derinlemesine analiz ve takım istatistiklerinin yanı sıra canlı güncellemeler vb. sunuyoruz. Önceden mi planlıyorsunuz? Hiçbir güçlük çekmeden gelecekteki maçları öğrenin ve bir daha asla önemli bir maçı kaçırmayın.
      İster favori takımınızı takip edin, ister ligin tüm maçlarını izleyin, Fanskor size gerçek taraftarın tercihi üzerine gerçek Türk futbolunun mükemmel, eksiksiz, güvenilir ve dinamik bir resmini sağlayabilir.
      Bir oyun takipçisi olmayın, Fanskor ile bir oyun takipçisi olun. Şimdi en yeni, itibarlı ve tek elden kapsamı alın!
      `;
  const sidebarAboutSeoText = `Fanskor, heyecan verici derbileri veya beklenmedik alt kadro hikayelerini takip ediyor olsanız da, size en son haberleri ve analizleri sunar. Fanskor, Türk Süper Ligi haberleri için başvurabileceğiniz kaynağınızdır. Maç programlarını kontrol edebilir, güncel puan durumunu görebilir, canlı sonuçları takip edebilir ve tüm takım istatistiklerine cebinizde ulaşabilirsiniz.`;

  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="container mx-auto flex-1 w-full lg:grid lg:grid-cols-[288px_1fr] lg:items-start lg:py-8">
        <Suspense fallback={<SidebarSkeleton />}>
          <Sidebar />
        </Suspense>

        <main className="min-w-0">
          {/* Pass the homepageAboutSeoText as a prop to MainContent */}
          <MainContent
            sidebarAboutSeoText={sidebarAboutSeoText}
            homepageAboutSeoText={homepageAboutSeoText}
          />
        </main>
      </div>
    </div>
  );
}


// ===== src/app/providers.tsx =====

"use client";

import ProgressBar from "@/components/ProgressBar";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { useState } from "react";
import { Toaster } from "react-hot-toast";

export default function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
          },
        },
      })
  );

 return (
    <QueryClientProvider client={queryClient}>
      {/* Add Toaster here. You can customize its position and style. */}
      <Toaster 
        position="top-right"
        toastOptions={{
          style: {
            background: '#333',
            color: '#fff',
          },
        }}
      />
      <ProgressBar />
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}

// ===== src/app/sitemap.ts =====

// src/app/sitemap.ts
// This is the full, dynamic sitemap.ts file.

import { MetadataRoute } from "next";
import axios from "axios";
import { format, subDays, addDays } from "date-fns";
import slugify from "slugify";

// --- IMPORTANT: This is the critical part for production deployment ---
// Ensure NEXT_PUBLIC_PUBLIC_APP_URL is set in your production environment variables.
const BASE_URL =
  process.env.NEXT_PUBLIC_PUBLIC_APP_URL || "http://localhost:3000";
console.log(`[Sitemap Generation] BASE_URL is: ${BASE_URL}`);

// --- Helper Functions to build slugs (ensure they match your frontend) ---
const generateLeagueSlug = (leagueName: string, leagueId: number): string => {
  const slug = slugify(leagueName, {
    lower: true,
    strict: true,
    remove: /[*+~.()'"!:@]/g,
  });
  return `/football/league/${slug}-${leagueId}`;
};

const generateTeamSlug = (teamName: string, teamId: number): string => {
  const slug = slugify(teamName, {
    lower: true,
    strict: true,
    remove: /[*+~.()'"!:@]/g,
  });
  return `/football/team/${slug}-${teamId}`;
};

const generateMatchSlug = (
  homeName: string,
  awayName: string,
  fixtureId: number
): string => {
  const slugifyPart = (str: string) =>
    slugify(str, { lower: true, strict: true, remove: /[*+~.()'"!:@]/g });
  return `/football/match/${slugifyPart(homeName)}-vs-${slugifyPart(
    awayName
  )}-${fixtureId}`;
};

// --- Fetchers for each content type ---

async function getNewsUrls(): Promise<MetadataRoute.Sitemap> {
  console.log(
    `[Sitemap] Fetching news from: ${BASE_URL}/api/posts?status=published`
  );
  try {
    const { data: posts } = await axios.get(
      `${BASE_URL}/api/posts?status=published`
    );
    console.log(`[Sitemap] Fetched ${posts.length} news posts.`);
    return posts.map((post: any) => ({
      url: `${BASE_URL}/football/news/${post.slug}`,
      lastModified: post.updatedAt
        ? new Date(post.updatedAt)
        : new Date(post.createdAt),
      changeFrequency: "weekly",
      priority: 0.8,
    }));
  } catch (error) {
    console.error("[Sitemap] Error generating news sitemap:", error);
    return [];
  }
}

async function getLeagueUrls(): Promise<MetadataRoute.Sitemap> {
  console.log(
    `[Sitemap] Fetching leagues from: ${BASE_URL}/api/leagues?fetchAll=true`
  );
  try {
    const { data: leagues } = await axios.get(
      `${BASE_URL}/api/leagues?fetchAll=true`
    );
    console.log(`[Sitemap] Fetched ${leagues.length} leagues.`);
    return leagues.map((league: any) => ({
      url: `${BASE_URL}${generateLeagueSlug(league.name, league.id)}`,
      lastModified: new Date(),
      changeFrequency: "monthly",
      priority: 0.7,
    }));
  } catch (error) {
    console.error("[Sitemap] Error generating league sitemap:", error);
    return [];
  }
}

async function getTeamUrls(): Promise<MetadataRoute.Sitemap> {
  console.log(`[Sitemap] Fetching teams from: ${BASE_URL}/api/directory/teams`);
  try {
    const { data: teamsData } = await axios.get(
      `${BASE_URL}/api/directory/teams`
    );
    console.log(`[Sitemap] Fetched ${teamsData.length} teams.`);
    return teamsData.map((teamData: any) => ({
      url: `${BASE_URL}${generateTeamSlug(
        teamData.team.name,
        teamData.team.id
      )}`,
      lastModified: new Date(),
      changeFrequency: "weekly",
      priority: 0.6,
    }));
  } catch (error) {
    console.error("[Sitemap] Error generating team sitemap:", error);
    return [];
  }
}

async function getMatchUrls(): Promise<MetadataRoute.Sitemap> {
  const today = new Date();
  const fromDate = format(subDays(today, 60), "yyyy-MM-dd");
  const toDate = format(addDays(today, 60), "yyyy-MM-dd");
  console.log(
    `[Sitemap] Fetching matches from: ${BASE_URL}/api/fixtures?from=${fromDate}&to=${toDate}`
  );
  try {
    const { data: matches } = await axios.get(
      `${BASE_URL}/api/fixtures?from=${fromDate}&to=${toDate}`
    );
    console.log(`[Sitemap] Fetched ${matches.length} matches.`);
    return matches.map((match: any) => ({
      url: `${BASE_URL}${generateMatchSlug(
        match.teams.home.name,
        match.teams.away.name,
        match.fixture.id
      )}`,
      lastModified: new Date(match.fixture.date),
      changeFrequency: "daily",
      priority: 0.9,
    }));
  } catch (error) {
    console.error("[Sitemap] Error generating match sitemap:", error);
    return [];
  }
}

export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  console.log("[Sitemap] Starting sitemap generation...");
  const [newsUrls, leagueUrls, teamUrls, matchUrls] = await Promise.all([
    getNewsUrls(),
    getLeagueUrls(),
    getTeamUrls(),
    getMatchUrls(),
  ]);

  const allUrls = [
    {
      url: `${BASE_URL}/`,
      lastModified: new Date(),
      changeFrequency: "daily",
      priority: 1,
    },
    {
      url: `${BASE_URL}/football/news`,
      lastModified: new Date(),
      changeFrequency: "daily",
      priority: 0.9,
    },
    {
      url: `${BASE_URL}/football/leagues`,
      lastModified: new Date(),
      changeFrequency: "daily",
      priority: 0.9,
    },
    {
      url: `${BASE_URL}/football/teams`,
      lastModified: new Date(),
      changeFrequency: "daily",
      priority: 0.9,
    },
    {
      url: `${BASE_URL}/contact-us`,
      lastModified: new Date(),
      changeFrequency: "weekly",
      priority: 0.9,
    },
    ...newsUrls,
    ...leagueUrls,
    ...teamUrls,
    ...matchUrls,
  ];

  console.log(
    `[Sitemap] Finished sitemap generation. Total URLs: ${allUrls.length}`
  );
  return allUrls;
}


// ===== src/components/Accordion.tsx =====

"use client";

import { useState, ReactNode } from 'react';
import { ChevronDown } from 'lucide-react';

interface AccordionProps {
  title: ReactNode; // Title can now be a component for more complex layouts
  statusNode?: ReactNode; // Optional node for the status badge
  children: ReactNode;
  defaultOpen?: boolean;
}

export default function Accordion({ title, statusNode, children, defaultOpen = false }: AccordionProps) {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <div className="border-b border-gray-700/50 last:border-b-0">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="w-full flex justify-between items-center p-4 transition-colors duration-200 bg-gray-800/50 hover:bg-gray-800/80"
      >
        {/* Left side containing title and status */}
        <div className="flex items-center gap-4">
            {/* The main title */}
            <div className="font-bold text-lg text-white text-left">{title}</div>
            {/* The optional status badge */}
            {statusNode}
        </div>
        
        {/* Right side with the chevron icon */}
        <ChevronDown
          size={24}
          className={`transform transition-transform duration-300 flex-shrink-0 ${isOpen ? 'rotate-180' : ''}`}
        />
      </button>
      
      {/* The collapsible content area */}
      <div
        className={`grid transition-all duration-300 ease-in-out ${
          isOpen ? 'grid-rows-[1fr] opacity-100' : 'grid-rows-[0fr] opacity-0'
        }`}
      >
        <div className="overflow-hidden">
          <div className="p-4 space-y-3 bg-brand-dark/30">{children}</div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/admin/AdminSidebar.tsx =====

// src/components/admin/AdminSidebar.tsx
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import {
  LayoutDashboard,
  Users,
  Calendar,
  Newspaper,
  Image,
  Sparkles,
  User,
  Crown,
  FileText, // <-- NEW ICON FOR FILE MANAGER
} from "lucide-react";
import { useSession, signOut } from "next-auth/react";
import { useTranslation } from "@/hooks/useTranslation";

export default function AdminSidebar() {
  const pathname = usePathname();
  const { data: session } = useSession();
  const { t } = useTranslation();

  const navItems = [
    {
      name: t("dashboard"),
      href: "/admin/dashboard",
      icon: LayoutDashboard,
    },
    {
      name: t("manage_news"),
      href: "/admin/news",
      icon: Newspaper,
    },
    {
      name: "Automated News",
      href: "/admin/auto-news",
      icon: Sparkles,
    },
    {
      name: "AI Journalists",
      href: "/admin/ai-journalists",
      icon: User,
    },
    {
      name: "Casino Partners",
      href: "/admin/casino-partners",
      icon: Crown,
    },
    {
      name: "File Manager", // <-- NEW ITEM
      href: "/admin/file-manager", // <-- NEW PATH
      icon: FileText, // <-- NEW ICON
    },
    {
      name: t("manage_banners"),
      href: "/admin/banners",
      icon: Image,
    },
    // { name: t('manage_users'), href: '/admin/users', icon: Users },
    // { name: t('manage_matches'), href: '/admin/matches', icon: Calendar },
  ];

  return (
    <aside className="w-72 bg-brand-secondary h-screen sticky top-0 p-6 flex flex-col justify-between">
      <div>
        <div className="text-2xl font-bold text-white mb-8">Admin Panel</div>
        <nav className="space-y-3">
          {navItems.map((item) => {
            const isActive = pathname.startsWith(item.href);
            const Icon = item.icon;
            return (
              <Link
                key={item.name}
                href={item.href}
                className={`flex items-center gap-3 p-3 rounded-lg transition-colors duration-200 ${
                  isActive
                    ? "bg-brand-purple text-white"
                    : "text-brand-muted hover:bg-gray-700 hover:text-white"
                }`}
              >
                <Icon size={20} />
                <span>{item.name}</span>
              </Link>
            );
          })}
        </nav>
      </div>

      <div className="border-t border-gray-700 pt-6">
        {session?.user && (
          <div className="mb-4 text-brand-muted text-sm">
            Logged in as{" "}
            <span className="font-semibold text-white">
              {session.user.name || session.user.email}
            </span>
          </div>
        )}
        <button
          onClick={() => signOut({ callbackUrl: "/login" })}
          className="w-full text-left flex items-center gap-3 p-3 rounded-lg text-red-400 hover:bg-gray-700 hover:text-red-300 transition-colors duration-200"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
            className="lucide lucide-log-out"
          >
            <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" />
            <polyline points="17 16 22 12 17 8" />
            <line x1="22" x2="10" y1="12" y2="12" />
          </svg>
          <span>{t("sign_out")}</span>
        </button>
      </div>
    </aside>
  );
}


// ===== src/components/admin/BannerFormModal.tsx =====

// src/components/admin/BannerFormModal.tsx
"use client";

import { useState, useEffect } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import Image from "next/image";
import { IBanner } from "@/models/Banner";
import { AD_SLOTS } from "@/config/adSlots";
import { X, UploadCloud, XCircle } from "lucide-react";

// ... interface and type definitions remain the same ...
interface BannerFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  banner: Partial<IBanner> | null;
}
type FormData = {
  title: string;
  imageUrl: string;
  linkUrl: string;
  isActive: boolean;
  location: string;
};

export default function BannerFormModal({
  isOpen,
  onClose,
  banner,
}: BannerFormModalProps) {
  // ... all existing state and useEffect hooks remain the same ...
  const queryClient = useQueryClient();
  const [formData, setFormData] = useState<FormData>({
    title: "",
    imageUrl: "",
    linkUrl: "",
    isActive: true,
    location: AD_SLOTS[0]?.id || "",
  });
  const [isUploading, setIsUploading] = useState(false);
  useEffect(() => {
    if (banner) {
      setFormData({
        title: banner.title || "",
        imageUrl: banner.imageUrl || "",
        linkUrl: banner.linkUrl || "",
        isActive: banner.isActive !== undefined ? banner.isActive : true,
        location: banner.location || AD_SLOTS[0]?.id || "",
      });
    } else {
      setFormData({
        title: "",
        imageUrl: "",
        linkUrl: "",
        isActive: true,
        location: AD_SLOTS[0]?.id || "",
      });
    }
    setIsUploading(false);
  }, [banner, isOpen]);

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setIsUploading(true);
    const uploadFormData = new FormData();
    uploadFormData.append("file", file);
    // --- THE FIX IS HERE ---
    // Add the uploadType to the form data to tell the server how to process this image.
    uploadFormData.append("uploadType", "banner");

    try {
      const { data } = await axios.post("/api/upload", uploadFormData);
      setFormData((prev) => ({ ...prev, imageUrl: data.url }));
      toast.success("Image uploaded successfully!");
    } catch (error) {
      toast.error("Image upload failed. Please try again.");
    } finally {
      setIsUploading(false);
    }
  };

  // ... the mutation and handleSubmit functions remain the same ...
  const mutation = useMutation({
    mutationFn: (newBanner: FormData) => {
      if (banner?._id) {
        return axios.put(`/api/banners/${banner._id}`, newBanner);
      }
      return axios.post("/api/banners", newBanner);
    },
    onSuccess: () => {
      toast.success(
        `Banner ${banner?._id ? "updated" : "created"} successfully!`
      );
      queryClient.invalidateQueries({ queryKey: ["adminBanners"] });
      onClose();
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.error || "An error occurred.");
    },
  });
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (
      !formData.title ||
      !formData.imageUrl ||
      !formData.linkUrl ||
      !formData.location
    ) {
      toast.error("All fields, including an uploaded image, are required.");
      return;
    }
    mutation.mutate(formData);
  };

  // ... the entire return JSX remains the same ...
  if (!isOpen) return null;
  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4">
      <div className="bg-brand-secondary rounded-lg p-6 md:p-8 w-full max-w-2xl relative max-h-[90vh] overflow-y-auto">
        <button
          onClick={onClose}
          className="absolute top-4 right-4 text-brand-muted hover:text-white"
        >
          <X size={24} />
        </button>
        <h2 className="text-2xl font-bold text-white mb-6">
          {banner?._id ? "Edit Banner" : "Create New Banner"}
        </h2>

        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label className="block text-sm font-medium text-brand-light mb-2">
              Banner Image
            </label>
            <div className="mt-2 flex justify-center rounded-lg border border-dashed border-gray-600 px-6 py-10">
              {formData.imageUrl ? (
                <div className="relative group w-full h-48">
                  <Image
                    src={formData.imageUrl}
                    alt="Banner preview"
                    layout="fill"
                    objectFit="contain"
                  />
                  <button
                    type="button"
                    onClick={() =>
                      setFormData((prev) => ({ ...prev, imageUrl: "" }))
                    }
                    className="absolute top-2 right-2 bg-red-600 rounded-full p-1 text-white opacity-0 group-hover:opacity-100 transition-opacity"
                    title="Remove image"
                  >
                    <XCircle size={20} />
                  </button>
                </div>
              ) : (
                <div className="text-center">
                  <UploadCloud className="mx-auto h-12 w-12 text-gray-500" />
                  <div className="mt-4 flex text-sm leading-6 text-gray-400">
                    <label
                      htmlFor="banner-image-upload"
                      className="relative cursor-pointer rounded-md font-semibold text-brand-purple focus-within:outline-none focus-within:ring-2 focus-within:ring-brand-purple focus-within:ring-offset-2 focus-within:ring-offset-brand-dark hover:text-brand-purple/80"
                    >
                      <span>
                        {isUploading ? "Uploading..." : "Upload an image"}
                      </span>
                      <input
                        id="banner-image-upload"
                        name="banner-image-upload"
                        type="file"
                        className="sr-only"
                        onChange={handleImageUpload}
                        disabled={isUploading}
                        accept="image/*"
                      />
                    </label>
                    <p className="pl-1">or drag and drop</p>
                  </div>
                  <p className="text-xs leading-5 text-gray-500">
                    PNG, JPG, GIF up to 10MB. Will be converted to WebP.
                  </p>
                </div>
              )}
            </div>
          </div>

          <div>
            <label
              htmlFor="title"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Title
            </label>
            <input
              id="title"
              type="text"
              value={formData.title}
              onChange={(e) =>
                setFormData({ ...formData, title: e.target.value })
              }
              required
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
          </div>
          <div>
            <label
              htmlFor="linkUrl"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Link URL (Destination)
            </label>
            <input
              id="linkUrl"
              type="url"
              value={formData.linkUrl}
              onChange={(e) =>
                setFormData({ ...formData, linkUrl: e.target.value })
              }
              required
              placeholder="https://destination.com"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            />
          </div>

          <div>
            <label
              htmlFor="location"
              className="block text-sm font-medium text-brand-light mb-1"
            >
              Location
            </label>
            <select
              id="location"
              value={formData.location}
              onChange={(e) =>
                setFormData({ ...formData, location: e.target.value })
              }
              className="w-full p-2.5 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            >
              {AD_SLOTS.map((slot) => (
                <option key={slot.id} value={slot.id}>
                  {slot.name}
                </option>
              ))}
            </select>
            <p className="text-xs text-brand-muted mt-1">
              {AD_SLOTS.find((s) => s.id === formData.location)?.description}
            </p>
          </div>

          <div className="flex items-center gap-3">
            <input
              id="isActive"
              type="checkbox"
              checked={formData.isActive}
              onChange={(e) =>
                setFormData({ ...formData, isActive: e.target.checked })
              }
              className="h-4 w-4 rounded border-gray-300 text-brand-purple focus:ring-brand-purple"
            />
            <label
              htmlFor="isActive"
              className="text-sm font-medium text-brand-light"
            >
              Active (Visible on site)
            </label>
          </div>

          <div className="flex justify-end gap-4 pt-4 border-t border-gray-700">
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={mutation.isPending || isUploading}
              className="bg-brand-purple text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isUploading
                ? "Uploading..."
                : mutation.isPending
                ? "Saving..."
                : "Save Banner"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}


// ===== src/components/admin/RichTextEditor.tsx =====

// src/components/admin/RichTextEditor.tsx
"use client";

import { useEditor, EditorContent } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import Link from "@tiptap/extension-link";
import Placeholder from "@tiptap/extension-placeholder";
import Underline from "@tiptap/extension-underline";
import Highlight from "@tiptap/extension-highlight";
import Typography from "@tiptap/extension-typography";
import CharacterCount from "@tiptap/extension-character-count";
import Image from "@tiptap/extension-image";

import {
  Bold,
  Italic,
  Strikethrough,
  Code,
  List,
  ListOrdered,
  Heading1,
  Heading2,
  Heading3,
  Quote,
  Minus,
  Undo,
  Redo,
  Link as LinkIcon,
  Image as ImageIcon,
} from "lucide-react";
import { useEffect } from "react";

interface RichTextEditorProps {
  value: string; // Now expects HTML string
  onChange: (value: string) => void; // Will output HTML string
}

const RichTextEditor: React.FC<RichTextEditorProps> = ({ value, onChange }) => {
  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        // Default StarterKit config is fine for HTML output
        // You might consider customizing headings, lists if needed
      }),
      Link.configure({
        openOnClick: false,
        autolink: true,
      }),
      Placeholder.configure({
        placeholder: "Write your news article content here...",
      }),
      Underline,
      Highlight.configure({
        multicolor: true,
      }),
      Typography,
      CharacterCount.configure({
        limit: 100000,
      }),
      Image.configure({
        inline: true,
        allowBase64: true,
      }),
    ],
    // Tiptap natively accepts HTML for 'content'
    content: value,
    onUpdate: ({ editor }) => {
      // When content updates, export it as HTML and pass to onChange
      onChange(editor.getHTML());
    },
    editorProps: {
      attributes: {
        class:
          "prose prose-invert lg:prose-xl focus:outline-none max-w-none min-h-[300px] border border-gray-600 rounded-b-md p-4 bg-gray-800",
      },
    },
  });

  // Effect to update editor content when 'value' prop changes externally
  useEffect(() => {
    // Only update if the new value is different from current editor HTML content
    // and editor is initialized.
    if (editor && value !== editor.getHTML()) {
      editor.commands.setContent(value, false); // Set content, 'false' means don't create a new history entry
    }
  }, [value, editor]);

  if (!editor) {
    return null;
  }

  return (
    <div className="border border-gray-600 rounded-md">
      <div className="flex flex-wrap items-center gap-1 p-2 border-b border-gray-600 bg-gray-700 rounded-t-md">
        {/* Formatting buttons remain the same, they operate on rich text */}
        <button
          onClick={() => editor.chain().focus().toggleBold().run()}
          disabled={!editor.can().chain().focus().toggleBold().run()}
          className={`p-2 rounded ${
            editor.isActive("bold")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Bold size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleItalic().run()}
          disabled={!editor.can().chain().focus().toggleItalic().run()}
          className={`p-2 rounded ${
            editor.isActive("italic")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Italic size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleStrike().run()}
          disabled={!editor.can().chain().focus().toggleStrike().run()}
          className={`p-2 rounded ${
            editor.isActive("strike")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Strikethrough size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleCode().run()}
          disabled={!editor.can().chain().focus().toggleCode().run()}
          className={`p-2 rounded ${
            editor.isActive("code")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Code size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleBulletList().run()}
          disabled={!editor.can().chain().focus().toggleBulletList().run()}
          className={`p-2 rounded ${
            editor.isActive("bulletList")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <List size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleOrderedList().run()}
          disabled={!editor.can().chain().focus().toggleOrderedList().run()}
          className={`p-2 rounded ${
            editor.isActive("orderedList")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <ListOrdered size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().setParagraph().run()}
          className={`p-2 rounded ${
            editor.isActive("paragraph")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          {/* <Paragraph size={18} /> */}
        </button>
        <button
          onClick={() =>
            editor.chain().focus().toggleHeading({ level: 1 }).run()
          }
          className={`p-2 rounded ${
            editor.isActive("heading", { level: 1 })
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Heading1 size={18} />
        </button>
        <button
          onClick={() =>
            editor.chain().focus().toggleHeading({ level: 2 }).run()
          }
          className={`p-2 rounded ${
            editor.isActive("heading", { level: 2 })
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Heading2 size={18} />
        </button>
        <button
          onClick={() =>
            editor.chain().focus().toggleHeading({ level: 3 }).run()
          }
          className={`p-2 rounded ${
            editor.isActive("heading", { level: 3 })
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Heading3 size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().toggleBlockquote().run()}
          className={`p-2 rounded ${
            editor.isActive("blockquote")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <Quote size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().setHorizontalRule().run()}
          className={`p-2 rounded text-brand-muted hover:bg-gray-600`}
        >
          <Minus size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().undo().run()}
          disabled={!editor.can().undo()}
          className={`p-2 rounded text-brand-muted hover:bg-gray-600`}
        >
          <Undo size={18} />
        </button>
        <button
          onClick={() => editor.chain().focus().redo().run()}
          disabled={!editor.can().redo()}
          className={`p-2 rounded text-brand-muted hover:bg-gray-600`}
        >
          <Redo size={18} />
        </button>
        <button
          onClick={() => {
            const url = window.prompt("URL");
            if (url) {
              editor.chain().focus().setLink({ href: url }).run();
            }
          }}
          className={`p-2 rounded ${
            editor.isActive("link")
              ? "bg-brand-purple text-white"
              : "text-brand-muted hover:bg-gray-600"
          }`}
        >
          <LinkIcon size={18} />
        </button>
        <button
          onClick={() => {
            const url = window.prompt("Image URL");
            if (url) {
              editor.chain().focus().setImage({ src: url }).run();
            }
          }}
          className={`p-2 rounded text-brand-muted hover:bg-gray-600`}
        >
          <ImageIcon size={18} />
        </button>
      </div>
      <EditorContent editor={editor} />
    </div>
  );
};

export default RichTextEditor;


// ===== src/components/AdSlotWidget.tsx =====

// ===== src/components/AdSlotWidget.tsx (CORRECTED) =====
"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import Link from "next/link";
import { IBanner } from "@/models/Banner";
import { proxyImageUrl } from "@/lib/image-proxy";

interface AdSlotWidgetProps {
  location: string;
}

// Fetch a single, active banner for a specific location
const fetchBannerForSlot = async (
  location: string
): Promise<IBanner | null> => {
  try {
    const { data } = await axios.get(
      `/api/banners?location=${location}&active=true`
    );
    // The API returns an array, we only want the first one for a single slot
    return data?.[0] || null;
  } catch (error) {
    console.error(`Failed to fetch banner for location: ${location}`, error);
    return null;
  }
};

const AdBannerSkeleton = () => (
  <div className="w-full h-[250px] bg-brand-secondary rounded-lg animate-pulse"></div>
);

export default function AdSlotWidget({ location }: AdSlotWidgetProps) {
  const {
    data: banner,
    isLoading,
    isError,
  } = useQuery<IBanner | null>({
    queryKey: ["banner", location],
    queryFn: () => fetchBannerForSlot(location),
    staleTime: 1000 * 60 * 5, // Cache for 5 minutes
    refetchOnWindowFocus: false, // Banners don't need to be refetched so often
  });

  if (isLoading) {
    return <AdBannerSkeleton />;
  }

  if (isError || !banner) {
    // Don't render anything if there's an error or no banner for this slot
    return null;
  }

  return (
    <div className="w-full">
      <Link
        href={banner.linkUrl}
        target="_blank"
        rel="noopener sponsored"
        className="relative block w-full overflow-hidden rounded-lg group"
        aria-label={`Advertisement: ${banner.title}`}
      >
        <Image
          src={proxyImageUrl(banner.imageUrl)}
          alt={banner.title}
          width={300}
          height={250}
          className="w-full h-auto object-cover transition-transform duration-300 group-hover:scale-105"
        />

        {/* The div that created the dark gradient overlay has been removed. */}

        <div className="absolute bottom-0 left-0 p-4 w-full">
          <h3 className="text-lg font-bold text-white drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)]">
            {banner.title}
          </h3>
          <span className="text-xs text-gray-300 drop-shadow-md">
            Advertisement
          </span>
        </div>
      </Link>
    </div>
  );
}


// ===== src/components/BettingPromotionWidget.tsx =====

"use client";

import { memo } from 'react';
import { ShieldCheck } from 'lucide-react';

// Using React.memo is a good practice for static components like this,
// as it prevents them from re-rendering if their props don't change.
const BettingPromotionWidget = memo(function BettingPromotionWidget() {
    
    // This handler can be updated later to redirect to a real partner link.
    const handleBetClick = () => {
        console.log("Redirecting to casino partner...");
        // Example of a real implementation:
        // window.open('https://your-partner-link.com/signup', '_blank');
    };

    return (
        <div className="bg-gradient-to-br from-green-500/20 to-brand-purple/20 p-4 rounded-xl border border-green-400/30 text-center space-y-3">
            
            <h3 className="text-lg font-bold text-white">
                Exclusive Welcome Offer!
            </h3>
            
            <p className="text-sm text-brand-light">
                Get a <span className="font-bold text-green-400">100% bonus</span> on your first deposit to bet on today's matches.
            </p>

            {/* The animated button container */}
            <div className="relative pt-2">
                {/* This span creates the pulsing glow effect behind the button */}
                <span className="absolute top-2 left-0 inline-flex h-full w-full rounded-lg bg-green-400 opacity-75 animate-ping"></span>
                
                <button
                    onClick={handleBetClick}
                    className="relative w-full bg-[#16A34A] text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2 hover:bg-green-700 transition-colors"
                >
                    <ShieldCheck size={18} />
                    <span>Claim Your Bonus Now</span>
                </button>
            </div>

            <p className="text-xs text-brand-muted/80">
                18+ | T&Cs apply. Please gamble responsibly.
            </p>
        </div>
    );
});

export default BettingPromotionWidget;

// ===== src/components/CasinoPartnerWidget.tsx =====

// src/components/CasinoPartnerWidget.tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { Crown } from "lucide-react";
import StyledLink from "./StyledLink";
import { proxyImageUrl } from "@/lib/image-proxy";

interface ICasinoPartner {
  _id: string;
  name: string;
  logoUrl: string;
  redirectUrl: string;
  description?: string;
  isFeatured: boolean;
  isActive: boolean;
  order: number;
}

interface CasinoPartnerWidgetProps {
  // Props are currently empty, keeping it for future expansion if needed
}

const fetchCasinoPartners = async (): Promise<ICasinoPartner[]> => {
  const { data } = await axios.get("/api/casino-partners");
  return data;
};

const CasinoPartnerWidget: React.FC<CasinoPartnerWidgetProps> = () => {
  const {
    data: partners,
    isLoading,
    isError,
  } = useQuery<ICasinoPartner[]>({
    queryKey: ["casinoPartnersPublic"],
    queryFn: fetchCasinoPartners,
    staleTime: 1000 * 60 * 15,
  });

  if (isLoading) {
    return (
      <div className="bg-brand-secondary rounded-lg shadow-lg p-4 animate-pulse space-y-4">
        <div className="h-6 w-3/4 bg-gray-700 rounded mb-4"></div>
        <div className="h-10 bg-gray-700 rounded"></div>
        <div className="h-10 bg-gray-700 rounded"></div>
        <div className="h-10 bg-gray-700 rounded"></div>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="bg-brand-secondary rounded-lg shadow-lg p-4 text-red-400">
        Failed to load partners.
      </div>
    );
  }

  if (!partners || partners.length === 0) {
    return (
      <div className="bg-brand-secondary rounded-lg shadow-lg p-4 text-brand-muted text-center">
        No active partners found.
      </div>
    );
  }

  return (
    <div className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden">
      <div className="p-4 border-b border-gray-700">
        <h2 className="text-xl font-bold text-white flex items-center gap-2">
          <Crown size={20} className="text-brand-purple" /> Ortak Casinolar
        </h2>
      </div>
      <div className="p-4 space-y-3">
        {partners.map((partner) => (
          <StyledLink
            key={partner._id}
            href={partner.redirectUrl}
            target="_blank"
            rel="noopener noreferrer nofollow"
            className={`
              block rounded-lg p-3 transition-all duration-300 transform 
              ${
                partner.isFeatured
                  ? "bg-gradient-to-br from-[#ea5a1e40] to-[#ea5a1e] border border-[#ea5a1e] hover:border-[#ea5a1e] shadow-xl shadow-brand-purple/30 transform scale-[1.02] -translate-y-0.5"
                  : "bg-brand-dark/50 border border-gray-700 hover:bg-brand-dark/70"
              }
              hover:shadow-2xl hover:shadow-brand-purple/50 
              flex items-center gap-3 relative overflow-hidden group
            `}
            title={partner.description || partner.name}
          >
            {partner.isFeatured && (
              // Subtle glow effect on hover for featured
              <div className="absolute inset-0 bg-[#ea5a1e32] opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none"></div>
            )}
            <div className="h-15 w-15 flex justify-center items-center">
              <Image
                src={partner.logoUrl}
                alt={`${partner.name} Logo`}
                width={60} // Slightly larger logo
                height={60} // Maintain aspect ratio
                objectFit="contain"
                className=" rounded-lg bg-gray-900 p-1 z-10" // Darker background for logo, larger padding
              />
            </div>
            <div className="flex flex-col flex-grow truncate z-10">
              {" "}
              {/* New container for name and description */}
              <span
                className={`font-semibold text-lg truncate 
                                  ${
                                    partner.isFeatured
                                      ? "text-white"
                                      : "text-brand-light"
                                  }`}
              >
                {partner.name}
              </span>
              {partner.description && (
                <span
                  className={`text-sm text-white mt-0.5 truncate 
                                      ${
                                        partner.isFeatured
                                          ? "text-white"
                                          : "text-brand-muted"
                                      }`}
                >
                  {partner.description}
                </span>
              )}
            </div>

            {partner.isFeatured && (
              <Crown size={20} className="text-yellow-400 flex-shrink-0 z-10" />
            )}
          </StyledLink>
        ))}
      </div>
    </div>
  );
};

export default CasinoPartnerWidget;


// ===== src/components/ContactFormClient.tsx =====

// src/components/ContactFormClient.tsx
"use client"; // This component MUST be a client component

import { useState } from "react";
import { useMutation } from "@tanstack/react-query";
import axios from "axios";
import toast from "react-hot-toast";
import { Loader2, CheckCircle } from "lucide-react"; // Icons for form submission feedback

const ContactFormClient: React.FC = () => {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [subject, setSubject] = useState("");
  const [message, setMessage] = useState("");

  const contactMutation = useMutation({
    mutationFn: (formData: {
      name: string;
      email: string;
      subject: string;
      message: string;
    }) => axios.post("/api/contact", formData),
    onSuccess: () => {
      toast.success("Your message has been sent successfully!");
      // Clear form
      setName("");
      setEmail("");
      setSubject("");
      setMessage("");
    },
    onError: (err: any) => {
      toast.error(
        err.response?.data?.error || "Failed to send message. Please try again."
      );
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    contactMutation.mutate({ name, email, subject, message });
  };

  return (
    <div className="bg-brand-secondary p-8 rounded-lg shadow-xl">
      <h2 className="text-3xl font-bold text-white mb-6">Bize Ulaşın</h2>
      <form onSubmit={handleSubmit} className="space-y-5">
        <div>
          <label
            htmlFor="name"
            className="block text-sm font-medium text-brand-light mb-1"
          >
            Adınız
          </label>
          <input
            type="text"
            id="name"
            value={name}
            onChange={(e) => setName(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            required
            disabled={contactMutation.isPending}
          />
        </div>
        <div>
          <label
            htmlFor="email"
            className="block text-sm font-medium text-brand-light mb-1"
          >
            E-posta Adresiniz
          </label>
          <input
            type="email"
            id="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            required
            disabled={contactMutation.isPending}
          />
        </div>
        <div>
          <label
            htmlFor="subject"
            className="block text-sm font-medium text-brand-light mb-1"
          >
            Konu
          </label>
          <input
            type="text"
            id="subject"
            value={subject}
            onChange={(e) => setSubject(e.target.value)}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple"
            required
            disabled={contactMutation.isPending}
          />
        </div>
        <div>
          <label
            htmlFor="message"
            className="block text-sm font-medium text-brand-light mb-1"
          >
            Mesajınız
          </label>
          <textarea
            id="message"
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            rows={5}
            className="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple resize-y"
            required
            disabled={contactMutation.isPending}
          ></textarea>
        </div>
        <button
          type="submit"
          className="w-full bg-[#ea5a1e] text-white font-bold py-3 rounded-lg hover:opacity-90 transition-opacity flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
          disabled={contactMutation.isPending}
        >
          {contactMutation.isPending ? (
            <Loader2 size={20} className="animate-spin" />
          ) : (
            <CheckCircle size={20} />
          )}
          {contactMutation.isPending ? "Gönderiliyor..." : "Mesaj Gönder"}
        </button>
      </form>
    </div>
  );
};

export default ContactFormClient;


// ===== src/components/CountryDropdown.tsx =====

"use client";

import { useState, useRef, useEffect } from 'react';
import Image from 'next/image';
import { ChevronDown, Globe } from 'lucide-react'; 
import { useQuery } from '@tanstack/react-query';
import axios from 'axios';
import { Country } from '@/types/api-football';
import { useLeagueContext } from '@/context/LeagueContext';
import { useTranslation } from '@/hooks/useTranslation';

const fetchCountries = async (): Promise<Country[]> => {
  const { data } = await axios.get('/api/countries');
  return data;
};

export default function CountryDropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const { t } = useTranslation();
  
  const { selectedCountry, setSelectedCountry } = useLeagueContext();

  const globalOption: Country = {
      name: t('global'),
      code: 'GLOBAL_VIEW',
      flagUrl: '',
  };

  const { data: countries, isLoading } = useQuery<Country[]>({
    queryKey: ['countries', globalOption.name], // Add translated name to key
    queryFn: fetchCountries,
    staleTime: 1000 * 60 * 60 * 24,
    refetchOnWindowFocus: false,
    select: (data) => {
      return [globalOption, ...data];
    },
  });
  
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleSelect = (country: Country) => {
    if (country.code === 'GLOBAL_VIEW') {
      setSelectedCountry(null);
    } else {
      setSelectedCountry(country);
    }
    setIsOpen(false);
  };

  return (
    <div className="relative" ref={dropdownRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        disabled={isLoading}
        className="flex items-center gap-2 bg-brand-secondary px-4 py-2 rounded-lg text-brand-light font-medium hover:bg-gray-700/50 transition-colors disabled:opacity-50 disabled:cursor-wait w-40 justify-between"
      >
        {isLoading ? (
          <span className="flex-grow text-left">{t('loading')}...</span>
        ) : selectedCountry ? (
          <>
            <Image 
              src={selectedCountry.flagUrl} 
              alt={selectedCountry.name} 
              width={20} 
              height={15} 
              className="flex-shrink-0"
            />
            <span className="truncate flex-grow text-left">{selectedCountry.name}</span>
          </>
        ) : (
          <>
            <Globe size={16} className="flex-shrink-0" />
            <span className="truncate flex-grow text-left">{t('global')}</span>
          </>
        )}
        <ChevronDown size={16} className={`transition-transform duration-200 flex-shrink-0 ${isOpen ? 'rotate-180' : ''}`} />
      </button>

      {isOpen && countries && (
        <div className="absolute top-full mt-2 w-56 max-h-80 overflow-y-auto bg-brand-secondary rounded-lg shadow-lg z-50 border border-gray-700/50 custom-scrollbar">
          <ul className="text-brand-light">
            {countries.map((country) => (
              <li key={country.code || country.name}>
                <button
                  onClick={() => handleSelect(country)}
                  className="flex w-full items-center gap-3 px-4 py-2.5 text-sm hover:bg-brand-purple transition-colors"
                >
                  {country.code === 'GLOBAL_VIEW' ? (
                    <Globe size={16} className="h-4 w-5 text-center" />
                  ) : (
                    <Image src={country.flagUrl} alt={country.name} width={20} height={15} />
                  )}
                  <span>{country.name}</span>
                </button>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}

// ===== src/components/DatePicker.tsx =====

// src/components/DatePicker.tsx
"use client";

import { useState, useRef, useEffect } from 'react';
import { format } from 'date-fns';
import { DayPicker } from 'react-day-picker';
import { Calendar as CalendarIcon } from 'lucide-react';
import 'react-day-picker/dist/style.css'; // Import the default styles

interface DatePickerProps {
  date: Date;
  setDate: (date: Date) => void;
}

export default function DatePicker({ date, setDate }: DatePickerProps) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  // Close the popover if the user clicks outside of it
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);
  
  const handleDaySelect = (selectedDate: Date | undefined) => {
    if (selectedDate) {
      setDate(selectedDate);
      setIsOpen(false);
    }
  };

  return (
    <div className="relative" ref={dropdownRef}>
      <button 
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center justify-center gap-2 w-full min-w-[280px] text-lg font-bold p-2 rounded-md hover:bg-brand-purple"
      >
        <CalendarIcon size={20} />
        <span>{format(date, 'eeee, dd MMMM yyyy')}</span>
      </button>

      {isOpen && (
        <div className="absolute top-full mt-2 bg-brand-secondary border border-gray-600 rounded-lg shadow-lg z-20 p-2">
          <DayPicker
            mode="single"
            selected={date}
            onSelect={handleDaySelect}
            initialFocus
            // Add custom styles for dark mode
            classNames={{
              caption: 'flex justify-center py-2 mb-4 relative items-center',
              caption_label: 'text-sm font-medium text-white',
              nav: 'flex items-center',
              nav_button: 'h-6 w-6 bg-transparent hover:bg-brand-purple p-1 rounded-md',
              nav_button_previous: 'absolute left-1.5',
              nav_button_next: 'absolute right-1.5',
              table: 'w-full border-collapse',
              head_row: 'flex font-medium text-brand-muted',
              head_cell: 'w-full p-2',
              row: 'flex w-full mt-2',
              cell: 'text-white',
              day: 'h-8 w-8 p-0 hover:bg-brand-purple rounded-md',
              day_selected: 'bg-brand-purple font-bold',
              day_today: 'bg-gray-700 rounded-md',
              day_outside: 'text-brand-muted opacity-50',
              day_disabled: 'text-brand-muted opacity-50 cursor-not-allowed',
            }}
          />
        </div>
      )}
    </div>
  );
}

// ===== src/components/DesktopLiveMatchCard .tsx =====

"use client";

import { useState, useMemo } from 'react';
import Image from 'next/image';
import { format } from 'date-fns';
import Link from '@/components/StyledLink'; 
import { History, ChevronDown, BarChart2 } from 'lucide-react';
import VotingPanel from './VotingPanel';
import { useTranslation } from '@/hooks/useTranslation';

interface MatchCardProps {
  match: any;
}

export default function LiveMatchCard({ match }: MatchCardProps) {
  const { fixture, teams, goals, league, events } = match;
  const [isExpanded, setIsExpanded] = useState(false);
  const { t } = useTranslation();

  const isLive = ['1H', 'HT', '2H', 'ET', 'P'].includes(fixture.status.short);
  const isFinished = ['FT', 'AET', 'PEN'].includes(fixture.status.short);
  const isUpcoming = !isLive && !isFinished;

  const momentumData = useMemo(() => {
    if (!isLive || !events || events.length === 0) return { teamId: null, type: null };
    const lastMajorEvent = [...events].reverse().find(e => e.type === 'Goal' || (e.type === 'Card' && e.detail === 'Red Card'));
    if (!lastMajorEvent) return { teamId: null, type: null };
    let momentumTeamId = lastMajorEvent.team.id;
    if (lastMajorEvent.type === 'Card') {
      momentumTeamId = momentumTeamId === teams.home.id ? teams.away.id : teams.home.id;
    }
    return { teamId: momentumTeamId, type: lastMajorEvent.type };
  }, [events, isLive, teams.home.id, teams.away.id]);

  return (
    <div className="bg-[#252837] rounded-xl overflow-hidden transition-all duration-300 ease-in-out">
      <div className="p-4">
        <div className="flex justify-between items-center text-sm text-brand-muted mb-4">
            <span className="font-semibold truncate pr-4">{league.name} - {league.round}</span>
            {isLive && <div className="flex items-center gap-2 flex-shrink-0"><span className="relative flex h-2 w-2"><span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span><span className="relative inline-flex rounded-full h-2 w-2 bg-brand-live"></span></span><span className="text-brand-live font-semibold">{fixture.status.elapsed}' {t('live')}</span></div>}
            {isFinished && <div className="flex items-center gap-1.5 bg-gray-700/50 text-gray-300 px-2 py-1 rounded-full"><History size={12} /><span className="font-semibold text-xs">{t('finished')}</span></div>}
            {isUpcoming && <div className="font-bold text-brand-light">{format(new Date(fixture.date), "HH:mm")}</div>}
        </div>

        <div className="flex items-center justify-between">
            {/* Home Team - Using flex-1 for robust sizing */}
            <div className="flex-1 flex flex-col items-center text-center gap-2 min-w-0">
                <div className="relative">
                    <Image src={teams.home.logo} alt={teams.home.name} width={64} height={64} className="object-contain h-16"/>
                    {momentumData.teamId === teams.home.id && (
                        <span className="absolute -top-1 -right-1 flex h-3 w-3">
                            <span className={`absolute inline-flex h-full w-full rounded-full ${momentumData.type === 'Goal' ? 'bg-green-400' : 'bg-red-400'} opacity-75 animate-ping`}></span>
                            <span className={`relative inline-flex rounded-full h-3 w-3 ${momentumData.type === 'Goal' ? 'bg-green-500' : 'bg-red-500'}`}></span>
                        </span>
                    )}
                </div>
                <h3 className="font-bold text-lg mt-2 text-brand-light w-full truncate">{teams.home.name}</h3>
            </div>
            
            {/* Score - Added padding for spacing */}
            <div className="text-4xl font-black text-white px-2 sm:px-4">
                {goals.home ?? 0} - {goals.away ?? 0}
            </div>
            
            {/* Away Team - Using flex-1 for robust sizing */}
            <div className="flex-1 flex flex-col items-center text-center gap-2 min-w-0">
                <div className="relative">
                    <Image src={teams.away.logo} alt={teams.away.name} width={64} height={64} className="object-contain h-16"/>
                    {momentumData.teamId === teams.away.id && (
                        <span className="absolute -top-1 -right-1 flex h-3 w-3">
                           <span className={`absolute inline-flex h-full w-full rounded-full ${momentumData.type === 'Goal' ? 'bg-green-400' : 'bg-red-400'} opacity-75 animate-ping`}></span>
                           <span className={`relative inline-flex rounded-full h-3 w-3 ${momentumData.type === 'Goal' ? 'bg-green-500' : 'bg-red-500'}`}></span>
                        </span>
                    )}
                </div>
                <h3 className="font-bold text-lg mt-2 text-brand-light w-full truncate">{teams.away.name}</h3>
            </div>
        </div>

        <div className="flex items-center justify-center gap-4 mt-4 border-t border-gray-700/50 pt-3">
            <Link href={`/football/match/${fixture.id}`} className="flex items-center gap-2 text-xs text-brand-muted hover:text-white transition-colors">
                <BarChart2 size={14} />
                <span>{t('match_details')}</span>
            </Link>
            {!isFinished && (
                <button
                    onClick={() => setIsExpanded(!isExpanded)}
                    className="flex items-center gap-2 text-xs text-green-400 hover:text-green-300 font-bold transition-all duration-300 rounded-lg px-3 py-1 bg-green-500/10"
                    aria-label={isExpanded ? t('hide_panel') : t('vote_and_see_poll')}
                >
                    <span>{isExpanded ? t('hide_panel') : t('vote_and_see_poll')}</span>
                    <ChevronDown size={16} className={`transition-transform duration-300 ${isExpanded ? 'rotate-180' : ''}`} />
                </button>
            )}
        </div>
      </div>

      <div className={`transition-all duration-300 ease-in-out grid ${isExpanded ? 'grid-rows-[1fr]' : 'grid-rows-[0fr]'}`}>
          <div className="overflow-hidden">
            {isExpanded && <div className="p-4 space-y-4">
                <VotingPanel fixtureId={fixture.id} teams={teams} />
              </div>}
          </div>
      </div>
    </div>
  );
}


// ===== src/components/DesktopMatchListItem.tsx =====

// src/components/DesktopMatchListItem.tsx
"use client";

import { useMemo } from "react";
import Image from "next/image";
import Link from "@/components/StyledLink";
import { format } from "date-fns";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { Star } from "lucide-react";
import { generateMatchSlug } from "@/lib/generate-match-slug";
import { proxyImageUrl } from "@/lib/image-proxy"; // Make sure proxyImageUrl is imported

// --- Type Definition for Odds ---
type Odds =
  | {
      home: string;
      draw: string;
      away: string;
    }
  | undefined
  | null;

// --- API Fetcher for Pre-Match Odds ---
const fetchPreMatchOdds = async (fixtureId: number): Promise<Odds> => {
  try {
    const { data } = await axios.get(`/api/odds?fixture=${fixtureId}`);
    return data;
  } catch {
    return null;
  }
};

// --- Main Component ---
interface DesktopMatchListItemProps {
  match: any;
  liveOdds?: Odds;
  isLive: boolean;
  customOdds?: Odds; // NEW: Custom calculated odds
}

export default function DesktopMatchListItem({
  match,
  liveOdds,
  isLive,
  customOdds, // NEW: Destructure customOdds
}: DesktopMatchListItemProps) {
  const { fixture, teams, goals } = match;
  const slug = generateMatchSlug(teams.home, teams.away, fixture.id);

  const isFinished = ["FT", "AET", "PEN"].includes(fixture.status.short);

  const { data: preMatchOdds, isLoading: isLoadingPreMatchOdds } = useQuery({
    queryKey: ["preMatchOdds", fixture.id],
    queryFn: () => fetchPreMatchOdds(fixture.id),
    enabled: !isFinished && !isLive,
    staleTime: 1000 * 60 * 60,
    refetchOnWindowFocus: false,
  });

  const displayOdds = isLive ? liveOdds : preMatchOdds;

  const lowestOdd = useMemo(() => {
    if (!displayOdds) return null;
    const oddValues = [
      parseFloat(displayOdds.home),
      parseFloat(displayOdds.draw),
      parseFloat(displayOdds.away),
    ];
    return Math.min(...oddValues);
  }, [displayOdds]);

  const OddBox = ({ value }: { value: string | undefined }) => {
    const isLowest = parseFloat(value || "999") === lowestOdd;
    return (
      <div
        className={`flex items-center justify-center p-2 rounded-md w-14 h-8 text-sm font-bold transition-colors duration-200 hover:bg-gray-600 ${
          isLowest
            ? "bg-yellow-500/20 text-brand-yellow"
            : "bg-transparent text-text-secondary"
        }`}
      >
        {value || "-"}
      </div>
    );
  };

  // --- NEW: CustomOddBox for Fanskor's odds ---
  const CustomOddBox = ({ value }: { value: string | undefined }) => {
    return (
      <div className="flex items-center justify-center p-2 rounded-md w-14 h-8 text-sm font-bold bg-brand-purple/20 text-white">
        {value || "-"}
      </div>
    );
  };

  return (
    <Link
      href={`/football/match/${slug}`}
      className="group flex items-center p-2 rounded-lg transition-all duration-300 ease-in-out border border-transparent hover:-translate-y-1 hover:shadow-xl hover:shadow-[#ed5c19]/10 hover:border-[#ed5c19]"
      style={{ backgroundColor: "var(--color-secondary)" }}
    >
      {/* Column 1: Status */}
      <div className="w-16 flex-shrink-0 text-center text-sm font-semibold">
        {isLive ? (
          <div className="flex items-center justify-center gap-1.5 text-green-400">
            <span className="h-1.5 w-1.5 rounded-full bg-green-500"></span>
            <span>{fixture.status.elapsed}'</span>
          </div>
        ) : isFinished ? (
          <div className="text-text-muted">FT</div>
        ) : (
          <div className="text-text-primary">
            {format(new Date(fixture.date), "HH:mm")}
          </div>
        )}
      </div>

      {/* Column 2: Teams */}
      <div className="flex-1 flex flex-col gap-1.5">
        <div className="flex items-center gap-3">
          <Image
            src={proxyImageUrl(teams.home.logo)}
            alt={teams.home.name}
            width={20}
            height={20}
          />
          <span className="font-semibold text-base text-text-primary">
            {teams.home.name}
          </span>
        </div>
        <div className="flex items-center gap-3">
          <Image
            src={proxyImageUrl(teams.away.logo)}
            alt={teams.away.name}
            width={20}
            height={20}
          />
          <span className="font-semibold text-base text-text-primary">
            {teams.away.name}
          </span>
        </div>
      </div>

      {/* Column 3: Odds Display (API/Live Odds) */}
      <div className="flex-1 flex items-center justify-center gap-1">
        {isFinished ? (
          <div className="h-8"></div>
        ) : isLoadingPreMatchOdds ? (
          <div className="flex items-center justify-center gap-1 w-full">
            <div
              className="w-14 h-8 rounded-md animate-pulse"
              style={{ backgroundColor: "var(--color-primary)" }}
            ></div>
            <div
              className="w-14 h-8 rounded-md animate-pulse"
              style={{ backgroundColor: "var(--color-primary)" }}
            ></div>
            <div
              className="w-14 h-8 rounded-md animate-pulse"
              style={{ backgroundColor: "var(--color-primary)" }}
            ></div>
          </div>
        ) : displayOdds ? (
          <>
            <OddBox value={displayOdds.home} />
            <OddBox value={displayOdds.draw} />
            <OddBox value={displayOdds.away} />
          </>
        ) : (
          <div className="flex items-center justify-center w-full h-8">
            <span className="text-xs font-semibold text-text-muted">
              No Odds Available
            </span>
          </div>
        )}
      </div>

      {/* --- NEW COLUMN: Fanskor Odds --- */}
      {/* This column is conditionally rendered based on `customOdds` */}
      {customOdds && !isFinished && (
        <div className="flex-1 flex flex-col items-center justify-center gap-1 text-center">
          <span className="text-xs text-brand-muted font-semibold">
            Fanskor Odds
          </span>
          <div className="flex items-center justify-center gap-1">
            <CustomOddBox value={customOdds.home} />
            <CustomOddBox value={customOdds.draw} />
            <CustomOddBox value={customOdds.away} />
          </div>
        </div>
      )}

      {/* Column 4: Scores */}
      <div
        className={`w-10 flex-shrink-0 flex flex-col items-center gap-1.5 text-base font-bold ${
          isLive ? "text-green-400" : "text-text-primary"
        }`}
      >
        <span>{goals.home ?? "-"}</span>
        <span>{goals.away ?? "-"}</span>
      </div>

      {/* Column 5: Favorite Action */}
      <div className="w-16 flex-shrink-0 flex items-center justify-end">
        <button className="p-2 text-text-muted transition-colors duration-300 group-hover:text-brand-yellow">
          <Star size={20} />
        </button>
      </div>
    </Link>
  );
}

// Skeleton code is unchanged.
export const MatchListItemSkeleton = () => (
  <div
    className="flex items-center p-3 rounded-lg animate-pulse"
    style={{ backgroundColor: "var(--color-secondary)" }}
  >
    <div className="w-20 flex-shrink-0">
      <div className="h-5 w-10 mx-auto rounded bg-gray-600/50"></div>
    </div>
    <div className="flex-1 flex flex-col gap-3">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3 w-3/5">
          <div className="w-6 h-6 rounded-full bg-gray-600/50"></div>
          <div className="h-5 w-full rounded bg-gray-600/50"></div>
        </div>
        <div className="h-5 w-6 rounded bg-gray-600/50"></div>
      </div>
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3 w-3/5">
          <div className="w-6 h-6 rounded-full bg-gray-600/50"></div>
          <div className="h-5 w-full rounded bg-gray-600/50"></div>
        </div>
        <div className="h-5 w-6 rounded bg-gray-600/50"></div>
      </div>
    </div>
    <div className="w-16 flex-shrink-0 flex items-center justify-end">
      <div className="h-6 w-6 rounded-full bg-gray-600/50"></div>
    </div>
  </div>
);


// ===== src/components/DirectoryCard.tsx =====

// src/components/DirectoryCard.tsx
import Image from "next/image";
import StyledLink from "./StyledLink";
import { League } from "@/types/api-football";
import { proxyImageUrl } from "@/lib/image-proxy";
import { Star } from "lucide-react"; // Import an icon for a badge

// The skeleton remains unchanged.
export const DirectoryCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg p-4 flex items-center gap-4 animate-pulse">
    <div className="w-10 h-10 rounded-full bg-gray-700"></div>
    <div className="space-y-2 flex-1">
      <div className="h-4 w-3/4 rounded bg-gray-600"></div>
      <div className="h-3 w-1/2 rounded bg-gray-600"></div>
    </div>
  </div>
);

// Add isPopular to the props interface
interface DirectoryCardProps extends League {
  isPopular?: boolean;
}

export default function DirectoryCard({
  id,
  name,
  logoUrl,
  countryName,
  href,
  isPopular,
}: DirectoryCardProps) {
  // Determine conditional classes based on the isPopular prop
  const containerClasses = isPopular
    ? "border-l-4 border-brand-purple"
    : "border-l-4 border-transparent";

  return (
    <StyledLink href={href} className="block group h-full">
      {/* Apply the conditional border class */}
      <div
        className={`bg-brand-secondary rounded-lg flex items-center gap-4 p-4 h-full transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20 ${containerClasses}`}
      >
        <Image
          src={proxyImageUrl(logoUrl)}
          alt={`${name} logo`}
          width={40}
          height={40}
          className="flex-shrink-0"
        />
        <div className="flex-1 min-w-0">
          <h3 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
            {name}
          </h3>
          <p className="text-sm text-brand-muted">{countryName}</p>
        </div>
        {/* Add a subtle star icon badge for popular leagues */}
        {isPopular && (
          <div className="flex-shrink-0" title="Popular Competition">
            <Star className="w-5 h-5 text-yellow-500/80" />
          </div>
        )}
      </div>
    </StyledLink>
  );
}


// ===== src/components/explore/BrowseByCountry.tsx =====

"use client";

import StyledLink from "../StyledLink";
import { Globe } from "lucide-react";

export default function BrowseByCountry() {
    return (
        <StyledLink href="/countries" className="block w-full bg-brand-secondary p-4 rounded-lg text-center hover:bg-gray-700/50 transition-colors">
            <Globe className="mx-auto mb-2 text-brand-muted" size={32} />
            <h3 className="font-bold text-lg text-white">Browse by Country</h3>
            <p className="text-sm text-brand-muted">Find leagues and cups from all over the world.</p>
        </StyledLink>
    );
}

// ===== src/components/explore/PopularLeaguesSlider.tsx =====

"use client";

import Slider from "react-slick";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { League } from "@/types/api-football";
import StyledLink from "../StyledLink";
import Image from "next/image";

// A dedicated card for the league slider
const LeagueSliderCard = ({ league }: { league: League }) => (
  <div className="px-2">
    <StyledLink href={league.href} className="block group">
      <div className="bg-brand-secondary rounded-lg p-3 flex flex-col items-center justify-center text-center h-32 transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20">
        <Image 
          src={league.logoUrl}
          alt={league.name}
          width={48}
          height={48}
          className="bg-white rounded-full p-1 mb-2"
        />
        <h4 className="font-bold text-white text-sm truncate w-full group-hover:text-brand-purple transition-colors">{league.name}</h4>
      </div>
    </StyledLink>
  </div>
);

const SkeletonCard = () => (
    <div className="px-2"><div className="bg-brand-secondary rounded-lg h-32 animate-pulse"></div></div>
);

const fetchPopularLeagues = async (): Promise<League[]> => {
    // This fetches only the curated popular leagues by not including the `fetchAll` param
    const { data } = await axios.get('/api/leagues?type=league');
    return data;
};

export default function PopularLeaguesSlider() {
    const { data: leagues, isLoading } = useQuery({
        queryKey: ['popularLeaguesExplore'],
        queryFn: fetchPopularLeagues,
        staleTime: 1000 * 60 * 60, // Cache for 1 hour
    });

    const sliderSettings = {
        dots: false,
        infinite: false,
        speed: 500,
        slidesToShow: 4,
        slidesToScroll: 2,
        arrows: false,
        responsive: [
            { breakpoint: 768, settings: { slidesToShow: 3.2 } },
            { breakpoint: 640, settings: { slidesToShow: 2.2 } },
        ]
    };

    if (isLoading) {
        return <Slider {...sliderSettings} className="-mx-2"><SkeletonCard /><SkeletonCard /><SkeletonCard /></Slider>;
    }
    
    if (!leagues) return null;

    return (
        <Slider {...sliderSettings} className="-mx-2">
            {leagues.map(league => (
                <LeagueSliderCard key={league.id} league={league} />
            ))}
        </Slider>
    );
}

// ===== src/components/explore/PopularTeamsGrid.tsx =====

"use client";

import { useQuery } from '@tanstack/react-query';
import axios, { AxiosResponse } from 'axios';
import StyledLink from '../StyledLink';
import Image from 'next/image';
import slugify from 'slugify';

interface TeamData { team: { id: number; name: string; logo: string; } }
interface ApiResponse { response: TeamData[] }

// A curated list of globally popular team IDs.
const POPULAR_TEAM_IDS = [
    33,  // Manchester United
    40,  // Liverpool
    42,  // Arsenal
    47,  // Tottenham
    50,  // Manchester City
    529, // Barcelona
    541, // Real Madrid
    157, // Bayern Munich
    496, // Inter Milan
    489, // AC Milan
];

const generateTeamSlug = (name: string, id: number) => {
    const slug = slugify(name, { lower: true, strict: true });
    return `/team/${slug}-${id}`;
};

// --- THIS IS THE CORRECTED FETCHER ---
const fetchPopularTeams = async (): Promise<TeamData[]> => {
    // 1. Create an array of Axios request promises, one for each ID.
    const teamPromises = POPULAR_TEAM_IDS.map(id =>
        axios.get<ApiResponse>(`${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/teams?id=${id}`, {
            headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY }
        })
    );

    // 2. Execute all promises in parallel and wait for them all to complete.
    // We use allSettled so that one failed request doesn't ruin the entire batch.
    const results = await Promise.allSettled(teamPromises);

    // 3. Filter out any failed requests and map the successful ones to get the team data.
    const successfulTeams = results
      .filter((result): result is PromiseFulfilledResult<AxiosResponse<ApiResponse>> => 
          result.status === 'fulfilled' && result.value.data.response.length > 0
      )
      .map(result => result.value.data.response[0]); // Extract the single team object from the response array

    return successfulTeams;
};


const SkeletonCard = () => (
    <div className="bg-brand-secondary rounded-lg h-24 animate-pulse"></div>
);

export default function PopularTeamsGrid() {
    const { data: teams, isLoading } = useQuery<TeamData[]>({
        queryKey: ['popularTeamsGrid'],
        queryFn: fetchPopularTeams,
        staleTime: 1000 * 60 * 60 * 24, // Team info is very static, cache for a day
        refetchOnWindowFocus: false,
    });

    return (
        <section>
            <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-bold text-white">Popular Teams</h2>
            </div>
            
            {isLoading ? (
                <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4">
                    {Array.from({ length: POPULAR_TEAM_IDS.length }).map((_, i) => <SkeletonCard key={i} />)}
                </div>
            ) : !teams || teams.length === 0 ? (
                 <div className="bg-brand-secondary rounded-lg p-6 text-center text-brand-muted">
                    <p>Could not load popular teams data.</p>
                 </div>
            ) : (
                <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4">
                    {teams.map(({ team }) => (
                        <StyledLink 
                            key={team.id} 
                            href={generateTeamSlug(team.name, team.id)}
                            className="bg-brand-secondary rounded-lg p-4 flex items-center justify-center h-24 transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20"
                            title={team.name}
                        >
                            <Image
                                src={team.logo}
                                alt={team.name}
                                width={64}
                                height={64}
                                className="object-contain max-h-16"
                            />
                        </StyledLink>
                    ))}
                </div>
            )}
        </section>
    );
}

// ===== src/components/ExploreTab.tsx =====

"use client";

import { Search } from 'lucide-react';
import PopularLeaguesSlider from './explore/PopularLeaguesSlider';
import PopularTeamsGrid from './explore/PopularTeamsGrid';
import BrowseByCountry from './explore/BrowseByCountry';

export default function ExploreTab() {
  return (
    <div className="p-4 space-y-8">
      {/* 1. Search Bar */}
      <div className="relative">
        <Search className="absolute left-3 top-1/2 -translate-y-1/2 text-brand-muted" size={20} />
        <input
          type="text"
          placeholder="Search for leagues, teams..."
          className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-3 pl-10 text-white focus:outline-none focus:ring-2 focus:ring-brand-purple"
        />
      </div>

       <section>
        <h2 className="text-xl font-bold text-white mb-4">Popular Leagues</h2>
        <PopularLeaguesSlider />
      </section>

      {/* This now renders our simplified, non-interactive grid */}
      <PopularTeamsGrid /> 
      
      <section>
        <BrowseByCountry />
      </section>
    </div>
  );
}

// ===== src/components/FinishedMatchSlide.tsx =====

// src/components/FinishedMatchSlide.tsx
"use client";

import Image from 'next/image';
import { format } from 'date-fns';
import { Calendar, History } from 'lucide-react';

interface MatchSlideProps {
  match: any; // Use a more specific type if you have one
}

export default function FinishedMatchSlide({ match }: MatchSlideProps) {
  const { teams, fixture, goals, league } = match;

  return (
    <div className="relative w-full h-64 overflow-hidden rounded-2xl bg-brand-secondary text-white">
      {/* Background Image & Overlay */}
      <Image
        src="https://images.unsplash.com/photo-1508098682722-e99c43a406b2?q=80&w=2070&auto=format&fit=crop"
        alt="Dark stadium background"
        layout="fill"
        objectFit="cover"
        className="z-0 opacity-80"
      />
      <div className="absolute inset-0 bg-black/70 z-10" />

      {/* Content */}
      <div className="relative z-20 flex h-full flex-col items-center justify-center p-4">
        <p className="font-semibold tracking-wider text-brand-muted flex items-center gap-2">
            <History size={14} />
            Recent Result
        </p>
        <p className="text-sm text-brand-muted mb-4">{league.round}</p>
        
        <div className="flex items-center justify-around w-full max-w-2xl my-2">
          {/* Home Team */}
          <div className="flex flex-col items-center gap-2 text-center w-1/3">
            <Image src={teams.home.logo} alt={teams.home.name} width={48} height={48}/>
            <h2 className="text-xl font-bold truncate">{teams.home.name}</h2>
          </div>
          
          {/* Score */}
          <span className="text-5xl font-black text-white mx-4">
            {goals.home} - {goals.away}
          </span>
          
          {/* Away Team */}
          <div className="flex flex-col items-center gap-2 text-center w-1/3">
            <Image src={teams.away.logo} alt={teams.away.name} width={48} height={48}/>
            <h2 className="text-xl font-bold truncate">{teams.away.name}</h2>
          </div>
        </div>

        <div className="mt-6 flex items-center gap-2 text-brand-muted">
            <Calendar size={16} />
            <span>{format(new Date(fixture.date), "dd MMMM yyyy")}</span>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/Footer.tsx =====

// src/components/Footer.tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Link from "next/link";
import Image from "next/image";
import { IPost } from "@/models/Post";
import { useTranslation } from "@/hooks/useTranslation";

// --- Reusable Sub-components for clean code ---
const FooterLink = ({
  href,
  children,
}: {
  href: string;
  children: React.ReactNode;
}) => (
  <Link
    href={href}
    className="text-sm text-brand-muted hover:text-white transition-colors"
  >
    {children}
  </Link>
);
const FooterColumn = ({
  title,
  children,
}: {
  title: string;
  children: React.ReactNode;
}) => (
  <div className="space-y-4">
    <h4 className="font-bold text-white uppercase tracking-wider">{title}</h4>
    <div className="flex flex-col space-y-3">{children}</div>
  </div>
);

// --- Fetchers for Dynamic Content ---
const fetchRecentPosts = async (): Promise<IPost[]> => {
  const { data } = await axios.get("/api/posts?status=published&limit=5");
  return data;
};

// Placeholder for fetching recent scores
const fetchRecentFootballScores = async () => {
  return [
    { id: 1, home: "RB Salzburg", away: "Real Madrid", href: "#" },
    { id: 2, home: "Juventus", away: "Man City", href: "#" },
    { id: 3, home: "Man City", away: "Al-Ain", href: "#" },
    { id: 4, home: "Benfica", away: "Chelsea", href: "#" },
    { id: 5, home: "Espérance", away: "Chelsea", href: "#" },
  ];
};

export default function Footer() {
  const { t } = useTranslation();

  const { data: recentPosts } = useQuery({
    queryKey: ["recentPostsFooter"],
    queryFn: fetchRecentPosts,
    staleTime: 1000 * 60 * 10,
  });

  const { data: footballScores } = useQuery({
    queryKey: ["recentScoresFooter"],
    queryFn: fetchRecentFootballScores,
    staleTime: 1000 * 60 * 5,
  });

  return (
    <footer className="bg-brand-secondary text-white py-12 hidden md:block">
      <div className="container mx-auto px-4">
        {/* --- TOP SECTION: 4-column grid --- */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8 mb-12">
          {/* Column 1: About & News */}
          <div className="space-y-8">
            <div>
              <h4 className="font-bold text-white uppercase tracking-wider mb-4">
                About
              </h4>
              <p className="text-sm text-brand-muted leading-relaxed">
                Fanskor ile her golün ve düdüğün bir adım önünde olun - canlı
                skor ve maç güncellemeleri için en iyi adresiniz.
              </p>
            </div>
            <div>
              <h4 className="font-bold text-white uppercase tracking-wider mb-4">
                News
              </h4>
              <div className="text-sm text-brand-muted space-y-2">
                {recentPosts?.map((post) => (
                  <Link
                    key={post._id}
                    href={`/football/news/${post.slug}`}
                    className="block truncate hover:text-white transition-colors"
                  >
                    {post.title}
                  </Link>
                ))}
              </div>
            </div>
          </div>

          {/* Column 2: Football Leagues */}
          <div className="space-y-8">
            <FooterColumn title="Football">
              <FooterLink href="https://fanskor.com/football/league/premier-league-39">
                Premier League
              </FooterLink>
              <FooterLink href="https://fanskor.com/football/league/la-liga-140">
                LaLiga
              </FooterLink>
              <FooterLink href="https://fanskor.com/football/league/serie-a-135">
                Serie A
              </FooterLink>
              <FooterLink href="https://fanskor.com/football/league/bundesliga-78">
                Bundesliga
              </FooterLink>
              <FooterLink href="https://fanskor.com/football/league/ligue-1-61">
                Ligue 1
              </FooterLink>
              <FooterLink href="https://fanskor.com/football/league/uefa-champions-league-2">
                UEFA Champions League
              </FooterLink>
            </FooterColumn>
          </div>

          {/* Column 3: Football Scores */}
          <div>
            <FooterColumn title="Football Scores">
              {footballScores?.map((score) => (
                <FooterLink key={score.id} href={score.href}>
                  {score.home} - {score.away}
                </FooterLink>
              ))}
            </FooterColumn>
          </div>

          {/* Column 4: Company & Legal Links */}
          <div>
            <FooterColumn title="Information">
              <FooterLink href="/contact-us">{t("contact_us")}</FooterLink>
              <FooterLink href="/faq">Frequently Ask Question</FooterLink>
              <FooterLink href="/author">Author</FooterLink>
              <FooterLink href="/report-abuse">Report Abuse</FooterLink>
              <FooterLink href="/privacy-policy">Privacy Policy</FooterLink>
              <FooterLink href="/terms-and-conditions">
                Terms & Conditions
              </FooterLink>
            </FooterColumn>
          </div>
        </div>

        {/* --- MODIFIED MIDDLE SECTION: Credibility and Responsible Gaming Logos --- */}
        <div className="flex flex-col md:flex-row justify-between items-center border-t border-gray-700/50 pt-8 mb-8">
          <div className="mb-6 md:mb-0">
            <Image
              src="/fanskor-transparent.webp"
              alt="Fanskor logo"
              width={280}
              height={40}
            />
          </div>
          <div className="flex items-center gap-6 md:gap-8">
            <Link href="/responsible-gaming" title="Responsible Gaming">
              <Image
                src="/images/logos/18plus.svg"
                alt="18+ Responsible Gaming"
                width={40}
                height={40}
              />
            </Link>
            <Link href="/about-us#credibility" title="Verified by GamCare">
              <Image
                src="/images/logos/gamcare.svg"
                alt="GamCare Verified"
                width={110}
                height={35}
              />
            </Link>
            <Link href="/responsible-gaming#gambleaware" title="BeGambleAware">
              <Image
                src="/images/logos/begambleaware.svg"
                alt="BeGambleAware"
                width={190}
                height={25}
              />
            </Link>
            <Link href="/about-us#security" title="Secure Connection">
              <Image
                src="/images/logos/dmca-protected.svg"
                alt="DMCA Protected"
                width={180}
                height={35}
              />
            </Link>
          </div>
        </div>

        {/* --- BOTTOM SECTION: Copyright and Legal Links --- */}
        <div className="flex flex-col md:flex-row justify-between items-center text-sm text-brand-muted">
          <p className="mb-4 md:mb-0">
            © {new Date().getFullYear()} Fanskor - All rights reserved.
          </p>
          <div className="flex flex-wrap justify-center gap-x-4 gap-y-2">
            <FooterLink href="/privacy-policy">Privacy Policy</FooterLink>
            <FooterLink href="/terms-and-conditions">
              Terms & Conditions
            </FooterLink>
            <FooterLink href="/gdpr">GDPR & Journalism</FooterLink>
          </div>
        </div>
      </div>
    </footer>
  );
}


// ===== src/components/Header.tsx =====

"use client";

import { useState } from "react";
import { usePathname } from "next/navigation";
import Image from "next/image";
import { Bell, Menu, X, Aperture, ArrowRight } from "lucide-react";
import CountryDropdown from "./CountryDropdown";
import LanguageDropdown from "./LanguageDropdown";
import { useTranslation } from "@/hooks/useTranslation";
import StyledLink from "./StyledLink";
import NavDropdown from "./NavDropdown";

export default function Header() {
  const { t } = useTranslation();
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const pathname = usePathname();

  // --- NEW, STRUCTURED NAVIGATION ARRAY ---
  // This makes the navigation much easier to manage and extend
  const navItems = [
    {
      title: t("football"),
      isDropdown: true,
      subLinks: [
        {
          name: t("leagues"),
          href: "/football/leagues",
          description: "Browse all competitions",
        },
        {
          name: t("teams"),
          href: "/football/teams",
          description: "Find your favorite club",
        },
        {
          name: t("news"),
          href: "/football/news",
          description: "The latest headlines",
        },
      ],
      href: "/",
    },
    // When you're ready, just add the new sport here!
    { title: t("basketball"), href: "/basketball" },
    { title: t("tennis"), href: "/tennis" },
  ];

  const handleMobileLinkClick = () => {
    setIsMobileMenuOpen(false);
  };

  return (
    <header className="bg-grey-700/50 top-0 z-50 border-b border-gray-700/50">
      <div className="container mx-auto flex h-20 items-center justify-between px-4 lg:px-6">
        <StyledLink href="/" className="flex items-center gap-3 group">
          <Image
            src={"/fanskor.webp"}
            alt="fanskor-logo"
            width={250}
            height={100}
          />
        </StyledLink>

        {/* --- DESKTOP NAVIGATION --- */}
        <nav className="hidden lg:flex items-center gap-8">
          {navItems.map((item) => (
            <li key={item.title} className="list-none">
              {item.isDropdown && item.subLinks ? (
                <NavDropdown title={item.title} subLinks={item.subLinks} />
              ) : (
                <StyledLink
                  href={item.href!}
                  className={`relative py-2 text-base font-medium transition-colors ${
                    pathname.startsWith(item.href!)
                      ? "text-white"
                      : "text-brand-muted hover:text-white"
                  }`}
                >
                  {item.title}
                </StyledLink>
              )}
            </li>
          ))}
        </nav>

        <div className="flex items-center gap-4">
          <div className="hidden lg:flex items-center gap-4">
            <LanguageDropdown />
            {/* <CountryDropdown /> */}
          </div>
          <button
            className="lg:hidden text-brand-muted"
            onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}
          >
            {isMobileMenuOpen ? <X size={28} /> : <Menu size={28} />}
          </button>
        </div>
      </div>

      {/* --- UPDATED MOBILE MENU --- */}
      {isMobileMenuOpen && (
        <div className="lg:hidden bg-brand-dark border-t border-gray-700/50 p-4 space-y-4">
          <nav>
            <ul className="space-y-2">
              {navItems.map((item) => (
                <li key={item.title}>
                  {item.isDropdown ? (
                    <div className="space-y-2">
                      <p className="p-3 text-sm font-bold uppercase text-brand-muted tracking-wider">
                        {item.title}
                      </p>
                      <ul className="space-y-1 pl-4 border-l-2 border-gray-700/50">
                        {item.subLinks!.map((subLink) => (
                          <li key={subLink.name}>
                            <StyledLink
                              href={subLink.href}
                              onClick={handleMobileLinkClick}
                              className="flex justify-between items-center w-full rounded-lg p-3 text-base font-medium text-brand-light hover:bg-gray-700/50"
                            >
                              <span>{subLink.name}</span>
                              <ArrowRight size={16} />
                            </StyledLink>
                          </li>
                        ))}
                      </ul>
                    </div>
                  ) : (
                    <StyledLink
                      href={item.href!}
                      onClick={handleMobileLinkClick}
                      className="block w-full rounded-lg p-3 text-base font-medium text-brand-light hover:bg-gray-700/50"
                    >
                      {item.title}
                    </StyledLink>
                  )}
                </li>
              ))}
            </ul>
          </nav>
          <hr className="border-gray-700/50" />
          <div className="flex items-center justify-between gap-4">
            <CountryDropdown />
            <LanguageDropdown />
          </div>
        </div>
      )}
    </header>
  );
}


// ===== src/components/LanguageDropdown.tsx =====

"use client";

import { useState } from 'react';
import { useLanguage } from '@/context/LanguageContext';
import { ChevronDown } from 'lucide-react';
import Image from 'next/image';

const languages = {
    en: { name: 'English', flag: '/flags/gb.png' },
    tr: { name: 'Türkçe', flag: '/flags/tr.png' }
};

export default function LanguageDropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const { locale, setLocale } = useLanguage();

  const selectedLanguage = languages[locale];

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 bg-brand-secondary px-3 py-2 rounded-lg text-brand-light font-medium hover:bg-gray-700/50 transition-colors"
      >
        <Image src={selectedLanguage.flag} alt={selectedLanguage.name} width={20} height={15} />
        <span className="text-sm hidden md:block">{selectedLanguage.name}</span>
        <ChevronDown size={16} className={`transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`} />
      </button>

      {isOpen && (
        <div className="absolute top-full mt-2 w-40 bg-brand-secondary rounded-lg shadow-lg z-50 border border-gray-700/50">
          <ul className="text-brand-light">
            {(Object.keys(languages) as Array<keyof typeof languages>).map((key) => (
              <li key={key}>
                <button
                  onClick={() => { setLocale(key); setIsOpen(false); }}
                  className="flex w-full items-center gap-3 px-4 py-2.5 text-sm hover:bg-brand-purple transition-colors"
                >
                  <Image src={languages[key].flag} alt={languages[key].name} width={20} height={15} />
                  <span>{languages[key].name}</span>
                </button>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}

// ===== src/components/LayoutSkeletons.tsx =====

export const HeaderSkeleton = () => (
    // Mimics the h-20 class on your Header
    <div className="h-20 w-full" style={{ backgroundColor: 'var(--color-primary)' }}></div>
);

export const SidebarSkeleton = () => (
    // Mimics the general shape of the sidebar
    <div className="hidden lg:block w-72 rounded-xl" style={{ backgroundColor: 'var(--color-primary)' }}></div>
);

// ===== src/components/league-detail-view/index.tsx =====

"use client";

import Image from "next/image";
import { Shield, Users, Trophy, Flag } from "lucide-react";

// Import our NEW, redesigned widget components
import LeagueStatCard from "./LeagueStatCard";
import LeagueFixturesWidget from "./LeagueFixturesWidget";
import LeagueStandingsWidget from "./LeagueStandingsWidget";
import LeagueTopScorersWidget from "./LeagueTopScorersWidget";
import LeagueTeamsList from "./LeagueTeamsList"; // Renamed from LeagueTeamsTab

export default function LeagueDetailView({ leagueData }: { leagueData: any }) {
  const { league, country, seasons } = leagueData;
  const currentSeason =
    seasons.find((s: any) => s.current === true)?.year ||
    new Date().getFullYear();

  return (
    <div className="flex flex-col gap-8">
      {/* 1. HERO HEADER */}
      <div className="flex flex-col items-center text-center gap-4 p-4 bg-brand-secondary rounded-xl">
        <Image
          src={league.logo}
          alt={league.name}
          width={80}
          height={80}
          className="bg-white rounded-full p-2"
        />
        <h1 className="text-4xl font-extrabold text-white">{league.name}</h1>
        <div className="flex items-center gap-2 text-brand-muted">
          <Image src={country.flag} alt={country.name} width={20} height={20} />
          <span>{country.name}</span>
        </div>
      </div>

      {/* 2. "AT A GLANCE" STAT CARDS */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <LeagueStatCard icon={<Shield />} label="Type" value={league.type} />
        <LeagueStatCard icon={<Flag />} label="Country" value={country.name} />
        <LeagueStatCard
          icon={<Trophy />}
          label="Current Season"
          value={currentSeason}
        />
        <LeagueStatCard
          icon={<Users />}
          label="Teams"
          value={seasons[0]?.coverage?.fixtures?.events ? "20" : "N/A"}
        />
      </div>

      {/* 3. DYNAMIC MAIN CONTENT GRID */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
        {/* Main Content Column */}
        <div className="lg:col-span-2 space-y-8">
          <LeagueFixturesWidget leagueId={league.id} season={currentSeason} />
        </div>

        {/* Sidebar Widgets Column */}
        <div className="lg:col-span-1 space-y-8">
          {league.type === "League" && (
            <LeagueStandingsWidget
              leagueId={league.id}
              season={currentSeason}
            />
          )}
          <LeagueTopScorersWidget leagueId={league.id} season={currentSeason} />
        </div>
      </div>

      {/* 4. FULL TEAMS LIST */}
      <LeagueTeamsList
        leagueId={league.id}
        season={currentSeason}
        countryName={country.name}
        countryFlag={country.flag}
      />
    </div>
  );
}


// ===== src/components/league-detail-view/LeagueFixturesWidget.tsx =====

// src/components/league/LeagueFixturesWidget.tsx
"use client";

import { useState, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { DayPicker } from "react-day-picker";
import { format } from "date-fns";
import { Calendar, Info } from "lucide-react";
import MatchListItem, { MatchListItemSkeleton } from "../MatchListItem";
import "react-day-picker/dist/style.css";
import { useTranslation } from "@/hooks/useTranslation";

type FixtureView = "upcoming" | "today" | "date";

// --- A SIMPLER, MORE ROBUST FETCHER ---
// This function now takes a clean parameters object.
const fetchFixtures = async (params: {
  leagueId: number;
  upcoming?: boolean;
  date?: string;
}) => {
  // URLSearchParams automatically handles building the query string correctly.
  const queryParams = new URLSearchParams({
    league: params.leagueId.toString(),
  });

  if (params.upcoming) {
    queryParams.set("upcoming", "true");
  }
  if (params.date) {
    queryParams.set("date", params.date);
  }

  const { data } = await axios.get(`/api/fixtures?${queryParams.toString()}`);
  return data;
};

export default function LeagueFixturesWidget({
  leagueId,
}: {
  leagueId: number;
}) {
  const [view, setView] = useState<FixtureView>("upcoming");
  const [selectedDate, setSelectedDate] = useState<Date>(new Date());
  const [isCalendarOpen, setIsCalendarOpen] = useState(false);

  const { t } = useTranslation();

  // --- THE CORE FIX: AVOIDING COMPLEX STATE DEPENDENCIES ---
  // We use useMemo to create a stable parameters object based on the current view.
  // This object will be the "single source of truth" for our query.
  const queryParams = useMemo(() => {
    const baseParams = { leagueId };
    switch (view) {
      case "upcoming":
        return { ...baseParams, upcoming: true };
      case "today":
        return { ...baseParams, date: format(new Date(), "yyyy-MM-dd") };
      case "date":
        return { ...baseParams, date: format(selectedDate, "yyyy-MM-dd") };
      default:
        return { ...baseParams, upcoming: true };
    }
  }, [view, leagueId, selectedDate]);

  const {
    data: fixtures,
    isLoading,
    isError,
  } = useQuery({
    // The queryKey is now simpler and directly reflects the parameters being used.
    // When `queryParams` changes, TanStack Query knows it's a new query.
    queryKey: ["leagueFixtures", queryParams],
    queryFn: () => fetchFixtures(queryParams), // Pass the params object directly.
    enabled: !!leagueId,
    staleTime: 1000 * 60 * 5,
  });

  const handleDateSelect = (date: Date) => {
    setSelectedDate(date);
    setView("date");
    setIsCalendarOpen(false);
  };

  const renderDateButtonText = () => {
    if (view === "date") return format(selectedDate, "do MMM");
    return "Select Date";
  };

  return (
    <div className="bg-brand-secondary rounded-xl p-4">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-xl font-bold text-white">{t("fixtures")}</h3>
        <div className="flex items-center gap-1 bg-gray-700/50 p-1 rounded-lg">
          <button
            onClick={() => setView("upcoming")}
            className={`px-3 py-1 text-sm rounded-md font-semibold transition-colors ${
              view === "upcoming"
                ? "bg-brand-purple text-white"
                : "text-brand-muted hover:bg-gray-700"
            }`}
          >
            {t("upcoming")}
          </button>
          <button
            onClick={() => setView("today")}
            className={`px-3 py-1 text-sm rounded-md font-semibold transition-colors ${
              view === "today"
                ? "bg-brand-purple text-white"
                : "text-brand-muted hover:bg-gray-700"
            }`}
          >
            {t("today")}
          </button>
          <div className="relative">
            <button
              onClick={() => setIsCalendarOpen(!isCalendarOpen)}
              className={`flex items-center gap-1 px-3 py-1 text-sm rounded-md font-semibold transition-colors ${
                view === "date"
                  ? "bg-brand-purple text-white"
                  : "text-brand-muted hover:bg-gray-700"
              }`}
            >
              <Calendar size={14} />
              {renderDateButtonText()}
            </button>
            {isCalendarOpen && (
              <div className="absolute top-full right-0 mt-2 z-20 bg-brand-dark border border-gray-700 rounded-lg shadow-lg">
                <DayPicker
                  mode="single"
                  selected={selectedDate}
                  onSelect={(date) => date && handleDateSelect(date)}
                  className="text-white"
                  initialFocus
                />
              </div>
            )}
          </div>
        </div>
      </div>
      <div className="space-y-3 max-h-[600px] overflow-y-auto scrollbar-thin scrollbar-track-transparent scrollbar-thumb-gray-600 pr-2">
        {isLoading &&
          Array.from({ length: 5 }).map((_, i) => (
            <MatchListItemSkeleton key={i} />
          ))}
        {isError && (
          <div className="text-center py-10 text-red-400">
            <p>{t("error_loading_fixtures")}</p>
          </div>
        )}
        {!isLoading &&
          !isError &&
          fixtures &&
          fixtures.length > 0 &&
          fixtures.map((match: any) => (
            <MatchListItem key={match.fixture.id} match={match} />
          ))}
        {!isLoading && !isError && (!fixtures || fixtures.length === 0) && (
          <div className="text-center py-10 text-brand-muted">
            <Info size={32} className="mx-auto mb-3" />
            <p>{t("no_fixtures_found")}</p>
          </div>
        )}
      </div>
    </div>
  );
}


// ===== src/components/league-detail-view/LeagueStandingsWidget.tsx =====

// src/components/league/LeagueStandingsWidget.tsx
"use client";

import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import StyledLink from "@/components/StyledLink";
import { Info } from "lucide-react";

// --- SELF-CONTAINED TYPE DEFINITIONS ---
interface Team {
  id: number;
  name: string;
  logo: string;
}
interface TeamStats {
  played: number;
  win: number;
  draw: number;
  lose: number;
}
interface TeamStanding {
  rank: number;
  team: Team;
  points: number;
  goalsDiff: number;
  group: string;
  description: string | null;
  all: TeamStats;
}
interface League {
  id: number;
  name: string;
  logo: string;
  href: string;
}

interface LeagueStandingsWidgetProps {
  standings: TeamStanding[][]; // The nested array of standings groups
  league: League;
}

// --- UI COLORING HELPER ---
const getRankIndicatorClass = (description: string | null): string => {
  if (!description) return "bg-gray-700 text-brand-light";
  const desc = description.toLowerCase();
  if (desc.includes("champions league") || desc.includes("promotion"))
    return "bg-green-500/20 text-green-400";
  if (desc.includes("europa league") || desc.includes("qualification"))
    return "bg-orange-500/20 text-orange-400";
  if (desc.includes("conference league") || desc.includes("play-off"))
    return "bg-sky-400/20 text-sky-300";
  if (desc.includes("relegation")) return "bg-red-600/20 text-red-500";
  return "bg-gray-700 text-brand-light";
};

export default function LeagueStandingsWidget({
  standings,
  league,
}: LeagueStandingsWidgetProps) {
  // --- START OF THE FIX ---

  // 1. Sanitize the data at the top level to remove any entirely empty groups `[]`.
  const sanitizedGroups = standings?.filter(
    (group) => group && group.length > 0
  );

  // 2. If after sanitization there are no valid groups, show a message.
  if (!sanitizedGroups || sanitizedGroups.length === 0) {
    return (
      <div className="bg-brand-secondary p-8 rounded-lg text-center">
        <Info size={32} className="mx-auto text-brand-muted mb-3" />
        <p className="text-brand-light font-semibold">
          Standings are not available for this competition.
        </p>
      </div>
    );
  }

  // --- END OF THE FIX ---

  return (
    <div className="space-y-8">
      {/* Map over the SANITIZED groups */}
      {sanitizedGroups.map((group, index) => {
        // --- SECONDARY FIX ---
        // Also filter *within* each group to remove malformed rows (the cause of the crash).
        const validGroup = group.filter((item) => item && item.team);

        // If a group becomes empty after filtering bad rows, skip rendering it.
        if (validGroup.length === 0) return null;

        return (
          <div
            key={index}
            className="bg-brand-secondary rounded-lg overflow-hidden"
          >
            {/* Show group name only if there are multiple groups */}
            {sanitizedGroups.length > 1 && (
              <h3 className="text-xl font-bold text-white p-4 bg-gray-800/50">
                {validGroup[0].group}
              </h3>
            )}

            <div className="overflow-x-auto">
              <table className="w-full text-sm">
                <thead className="text-left text-brand-muted">
                  <tr className="text-xs uppercase">
                    <th className="p-3 w-8 text-center">#</th>
                    <th className="p-3">Team</th>
                    <th className="p-3 text-center">Played</th>
                    <th className="p-3 text-center">W</th>
                    <th className="p-3 text-center">D</th>
                    <th className="p-3 text-center">L</th>
                    <th className="p-3 text-center">GD</th>
                    <th className="p-3 text-center font-bold">Points</th>
                  </tr>
                </thead>
                <tbody className="text-brand-light">
                  {/* Map over the inner valid group */}
                  {validGroup.map((item) => (
                    <tr
                      key={item.team.id}
                      className="border-t border-gray-700/50"
                    >
                      <td className="p-3 text-center">
                        <span
                          className={`w-6 h-6 flex items-center justify-center text-xs font-bold rounded-md ${getRankIndicatorClass(
                            item.description
                          )}`}
                        >
                          {item.rank}
                        </span>
                      </td>
                      <td className="p-3">
                        <StyledLink
                          href={generateTeamSlug(item.team.name, item.team.id)}
                          className="flex items-center gap-3 group"
                        >
                          <Image
                            src={proxyImageUrl(item.team?.logo)}
                            alt={item.team.name}
                            width={24}
                            height={24}
                          />
                          <span className="font-semibold group-hover:text-brand-purple transition-colors">
                            {item.team.name}
                          </span>
                        </StyledLink>
                      </td>
                      <td className="p-3 text-center">{item.all.played}</td>
                      <td className="p-3 text-center">{item.all.win}</td>
                      <td className="p-3 text-center">{item.all.draw}</td>
                      <td className="p-3 text-center">{item.all.lose}</td>
                      <td className="p-3 text-center">{item.goalsDiff}</td>
                      <td className="p-3 text-center font-bold text-white">
                        {item.points}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        );
      })}
    </div>
  );
}


// ===== src/components/league-detail-view/LeagueStatCard.tsx =====

import { ReactNode } from 'react';

interface LeagueStatCardProps {
    icon: ReactNode;
    label: string;
    value: string | number;
}

export default function LeagueStatCard({ icon, label, value }: LeagueStatCardProps) {
    return (
        <div className="bg-brand-secondary p-4 rounded-lg flex items-center gap-4">
            <div className="flex-shrink-0 bg-brand-purple/20 text-brand-purple p-3 rounded-lg">
                {icon}
            </div>
            <div>
                <p className="text-sm text-brand-muted">{label}</p>
                <p className="font-bold text-white text-lg">{value}</p>
            </div>
        </div>
    );
}

// ===== src/components/league-detail-view/LeagueTeamsList.tsx =====

// src/components/LeagueTeamsList.tsx
"use client";

import { useState, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import TeamCard, { TeamCardSkeleton } from "./TeamCard";
import { Info, Search } from "lucide-react";

interface LeagueTeamsListProps {
  leagueId: number;
  season: number;
  countryName: string; // Pass these down for fallback
  countryFlag: string;
}

// Define the shape of our combined data
interface CombinedTeamData {
  team: any;
  venue: any;
  rank?: number;
  description?: string;
  squadSize?: number; // Placeholder for now
}

const fetchLeagueData = async (leagueId: number, season: number) => {
  const [teamsResponse, standingsResponse] = await Promise.all([
    axios.get(`/api/teams?league=${leagueId}&season=${season}`),
    axios.get(`/api/standings?league=${leagueId}&season=${season}`),
  ]);

  const teamsData = teamsResponse.data;
  const standingsData = standingsResponse.data.standings?.[0] || [];
  const standingsMap = new Map(standingsData.map((s: any) => [s.team.id, s]));

  const combinedData: CombinedTeamData[] = teamsData.map((teamData: any) => {
    const standing = standingsMap.get(teamData.team.id);
    return {
      ...teamData,
      rank: standing?.rank,
      description: standing?.description, // <-- Get the description
    };
  });

  // --- NEW: SORTING LOGIC ---
  // Sort by rank. Teams without a rank (rank is null/undefined) are pushed to the end.
  combinedData.sort((a, b) => {
    if (a.rank == null) return 1;
    if (b.rank == null) return -1;
    return a.rank - b.rank;
  });

  return combinedData;
};

export default function LeagueTeamsList({
  leagueId,
  season,
  countryName,
  countryFlag,
}: LeagueTeamsListProps) {
  const [searchTerm, setSearchTerm] = useState("");

  const {
    data: combinedData,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["leagueCombinedData", leagueId, season],
    queryFn: () => fetchLeagueData(leagueId, season),
    staleTime: 1000 * 60 * 60,
  });

  const filteredTeams = useMemo(() => {
    if (!combinedData) return [];
    // Search filter is now applied to the *already sorted* list
    return combinedData.filter((teamData: CombinedTeamData) =>
      teamData.team.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [combinedData, searchTerm]);

  const responsiveGridClasses =
    "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4";

  if (isError) {
    return (
      <div className="bg-brand-secondary p-8 rounded-lg text-center">
        <Info size={32} className="mx-auto text-brand-muted mb-3" />
        <p className="text-brand-light font-semibold">
          Could not load team data.
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="relative">
        <Search
          className="absolute left-3.5 top-1/2 -translate-y-1/2 text-brand-muted"
          size={20}
        />
        <input
          type="text"
          placeholder="Search for a team..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="w-full bg-brand-secondary border border-gray-700/50 rounded-lg p-3 pl-12 text-white focus:outline-none focus:ring-2 focus:ring-brand-purple"
        />
      </div>

      {isLoading ? (
        <div className={responsiveGridClasses}>
          {Array.from({ length: 12 }).map((_, i) => (
            <TeamCardSkeleton key={i} />
          ))}
        </div>
      ) : filteredTeams.length > 0 ? (
        <div className={responsiveGridClasses}>
          {filteredTeams.map((data: CombinedTeamData) => (
            <TeamCard
              key={data.team.id}
              team={data.team}
              venue={data.venue}
              rank={data.rank}
              countryName={countryName}
              countryFlag={countryFlag}
              rankDescription={data.description} // <-- PASS THE DESCRIPTION
            />
          ))}
        </div>
      ) : (
        <div className="bg-brand-secondary p-8 rounded-lg text-center">
          <Info size={32} className="mx-auto text-brand-muted mb-3" />
          <p className="text-brand-light font-semibold">
            No teams found matching "{searchTerm}"
          </p>
        </div>
      )}
    </div>
  );
}


// ===== src/components/league-detail-view/LeagueTopScorersWidget.tsx =====

"use client";
import { useQuery } from '@tanstack/react-query';
import axios from 'axios';
import Image from 'next/image';
import { Trophy } from 'lucide-react';

const fetchTopScorers = async (leagueId: number, season: number) => {
    const { data } = await axios.get(`/api/top-scorers?league=${leagueId}&season=${season}`);
    return data;
};

const SkeletonRow = () => (
    <div className="flex items-center gap-4 p-2 animate-pulse">
        <div className="w-10 h-10 rounded-full bg-gray-600/50"></div>
        <div className="flex-1 space-y-2">
            <div className="h-4 w-3/4 bg-gray-600/50 rounded"></div>
            <div className="h-3 w-1/2 bg-gray-600/50 rounded"></div>
        </div>
        <div className="w-8 h-8 rounded-full bg-gray-600/50"></div>
    </div>
);

export default function LeagueTopScorersWidget({ leagueId, season }: { leagueId: number, season: number }) {
    const { data: topScorers, isLoading } = useQuery({
        queryKey: ['topScorers', leagueId, season],
        queryFn: () => fetchTopScorers(leagueId, season),
    });

     if (isLoading) return (
        <div className="bg-brand-secondary rounded-xl p-4">
            <h3 className="text-xl font-bold text-white mb-4">Golden Boot Race</h3>
            <div className="space-y-3">{Array.from({length: 3}).map((_, i) => <SkeletonRow key={i} />)}</div>
        </div>
    );
    
    if (!topScorers || topScorers.length === 0) {
        return null;
    }

    return (
        <div className="bg-brand-secondary rounded-xl p-4">
            <h3 className="text-xl font-bold text-white mb-4">Golden Boot Race</h3>
            <div className="space-y-3">
                {topScorers.slice(0, 5).map((scorer: any, index: number) => (
                    <div key={scorer.player.id} className="flex items-center gap-4">
                        <Image src={scorer.player.photo} alt={scorer.player.name} width={40} height={40} className="rounded-full bg-gray-800" />
                        <div className="flex-1">
                            <p className="font-bold text-white">{scorer.player.name}</p>
                            <p className="text-xs text-brand-muted">{scorer.statistics[0].team.name}</p>
                        </div>
                        <div className={`flex items-center justify-center gap-2 font-bold text-lg p-2 rounded-lg ${index === 0 ? 'text-yellow-300 bg-yellow-500/10' : 'text-white'}`}>
                            <Trophy size={16} />
                            <span>{scorer.statistics[0].goals.total}</span>
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
}

// ===== src/components/league-detail-view/TeamCard.tsx =====

// src/components/league-detail-view/TeamCard.tsx
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import StyledLink from "@/components/StyledLink";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import { Users, MapPin } from "lucide-react";

interface TeamCardProps {
  team: any;
  venue: any;
  rank?: number;
  countryName?: string;
  countryFlag?: string;
  squadSize?: number;
  rankDescription?: string; // NEW: Pass the rank description for coloring
}

// --- NEW: COLORING HELPER ---
// This function now returns a set of Tailwind classes for border and text color.
const getRankClasses = (
  description: string | null
): { border: string; text: string } => {
  if (!description)
    return { border: "border-gray-700/50", text: "text-brand-muted" };
  const desc = description.toLowerCase();
  if (desc.includes("champions league") || desc.includes("promotion"))
    return { border: "border-green-500", text: "text-green-400" };
  if (desc.includes("europa league") || desc.includes("qualification"))
    return { border: "border-orange-500", text: "text-orange-400" };
  if (desc.includes("conference league") || desc.includes("play-off"))
    return { border: "border-sky-400", text: "text-sky-300" };
  if (desc.includes("relegation"))
    return { border: "border-red-600", text: "text-red-500" };
  return { border: "border-gray-700/50", text: "text-brand-muted" };
};

export function TeamCardSkeleton() {
  // Skeleton remains the same, simple and effective.
  return (
    <div className="bg-brand-secondary rounded-lg flex flex-col h-full animate-pulse">
      <div className="p-4 flex items-start gap-4">
        <div className="w-10 h-10 rounded-full bg-gray-700"></div>
        <div className="flex-1 space-y-2">
          <div className="h-4 w-3/4 bg-gray-600 rounded"></div>
          <div className="h-3 w-1/2 bg-gray-600/50 rounded"></div>
        </div>
      </div>
      <div className="px-4 pb-4 mt-auto space-y-2">
        <div className="h-3 w-full bg-gray-600/50 rounded"></div>
        <div className="h-3 w-2/3 bg-gray-600/50 rounded"></div>
      </div>
    </div>
  );
}

export default function TeamCard({
  team,
  venue,
  rank,
  countryName,
  countryFlag,
  squadSize,
  rankDescription,
}: TeamCardProps) {
  const rankClasses = getRankClasses(rankDescription || null);

  return (
    <StyledLink
      href={generateTeamSlug(team.name, team.id)}
      className="block group h-full"
    >
      {/* The card now has a dynamic left border color */}
      <div
        className={`bg-brand-secondary rounded-lg flex flex-col h-full border-l-4 ${rankClasses.border} transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20`}
      >
        {/* --- TOP SECTION --- */}
        <div className="p-4 flex items-start gap-4">
          <Image
            src={proxyImageUrl(team.logo)}
            alt={team.name}
            width={40}
            height={40}
            className="flex-shrink-0 mt-1"
          />
          <div className="flex-1 min-w-0">
            <h4 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
              {team.name}
            </h4>
            {countryName && countryFlag && (
              <div className="flex items-center gap-1.5 text-xs text-brand-muted mt-1">
                <Image
                  src={countryFlag}
                  alt={countryName}
                  width={16}
                  height={16}
                  className="rounded-full"
                />
                <span>{countryName}</span>
              </div>
            )}
          </div>
          {/* Prominent Rank Display */}
          {rank && (
            <div className={`text-2xl font-black ${rankClasses.text}`}>
              {rank}
            </div>
          )}
        </div>

        {/* --- DETAILS SECTION (at the bottom) --- */}
        <div className="px-4 pb-4 mt-auto space-y-1.5 border-t border-gray-700/50 pt-3">
          {squadSize && (
            <div className="flex items-center gap-2 text-xs text-brand-muted">
              <Users className="w-3 h-3" />
              <span>Squad Size: {squadSize}</span>
            </div>
          )}
          {venue?.name && (
            <div className="flex items-center gap-2 text-xs text-brand-muted truncate">
              <MapPin className="w-3 h-3" />
              <span>{venue.name}</span>
            </div>
          )}
        </div>
      </div>
    </StyledLink>
  );
}


// ===== src/components/LeagueListClient.tsx =====

// src/components/LeagueListClient.tsx
"use client";

import { useState, useMemo, useEffect } from "react";
import { useQueries } from "@tanstack/react-query"; // Keep useQueries for live/active status polling
import axios from "axios";
import { League } from "@/types/api-football";
import DirectoryCard, {
  DirectoryCardSkeleton,
} from "@/components/DirectoryCard";
import Pagination from "@/components/Pagination";
import { Search } from "lucide-react"; // Import Search icon

const ITEMS_PER_PAGE = 15;

// Fetcher function for the IDs of currently active leagues (can still be client-side fetched)
const fetchActiveLeagueIds = async (): Promise<number[]> => {
  const { data } = await axios.get("/api/active-leagues");
  return data;
};

interface LeagueListClientProps {
  initialAllLeagues: League[]; // Server-fetched leagues passed as prop
}

export default function LeagueListClient({
  initialAllLeagues,
}: LeagueListClientProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const [filter, setFilter] = useState<"all" | "league" | "cup">("all");
  const [currentPage, setCurrentPage] = useState(1);

  // useQueries to fetch active league IDs.
  // We don't fetch all leagues here again, we use `initialAllLeagues`.
  const { data: activeLeagueIds, isLoading: isLoadingActive } = useQueries({
    queries: [
      {
        queryKey: ["activeLeagueIds"],
        queryFn: fetchActiveLeagueIds,
        staleTime: 1000 * 60 * 10, // Re-check for active leagues every 10 minutes
      },
    ],
  })[0]; // Get the first (and only) query result

  const isLoading = isLoadingActive; // Only active status loading is client-side dynamic now

  // The main logic for filtering and sorting the leagues
  const { paginatedData, totalPages } = useMemo(() => {
    // Use the initialAllLeagues provided by the server
    const allLeagues = initialAllLeagues;
    const activeIdsSet = new Set(activeLeagueIds || []); // Ensure activeIdsSet is always a Set

    // First, apply the user's search and type filters
    const filtered = allLeagues.filter((league) => {
      const matchesSearch = league.name
        .toLowerCase()
        .includes(searchTerm.toLowerCase());
      const matchesFilter =
        filter === "all" || league.type.toLowerCase() === filter;
      return matchesSearch && matchesFilter;
    });

    // Separate the filtered list into active and inactive leagues
    const activeLeagues = filtered.filter((l) => activeIdsSet.has(l.id));
    const inactiveLeagues = filtered.filter((l) => !activeIdsSet.has(l.id));

    // Sort each sub-list alphabetically for consistent ordering
    activeLeagues.sort((a, b) => a.name.localeCompare(b.name));
    inactiveLeagues.sort((a, b) => a.name.localeCompare(b.name));

    // Combine the lists, with active leagues appearing first
    const sortedAndFiltered = [...activeLeagues, ...inactiveLeagues];

    // Apply pagination to the final, sorted list
    const totalPages = Math.ceil(sortedAndFiltered.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    const paginatedData = sortedAndFiltered.slice(startIndex, endIndex);

    return { paginatedData, totalPages };
  }, [initialAllLeagues, activeLeagueIds, searchTerm, filter, currentPage]);

  // Reset to the first page whenever the filters change
  useEffect(() => {
    setCurrentPage(1);
  }, [searchTerm, filter]);

  return (
    <>
      <div className="flex flex-col md:flex-row gap-4 mb-8">
        <div className="relative flex-grow">
          <Search
            className="absolute left-3.5 top-1/2 -translate-y-1/2 text-brand-muted"
            size={20}
          />
          <input
            type="text"
            placeholder="Search by name..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-full md:w-1/3 p-3 rounded bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-purple pl-12"
          />
        </div>
        <div className="flex items-center gap-2 p-1 rounded-lg bg-brand-secondary">
          <button
            onClick={() => setFilter("all")}
            className={`px-4 py-1.5 rounded-md text-sm font-semibold transition-colors ${
              filter === "all"
                ? "bg-brand-purple text-white"
                : "text-brand-muted hover:bg-gray-700/50"
            }`}
          >
            All
          </button>
          <button
            onClick={() => setFilter("league")}
            className={`px-4 py-1.5 rounded-md text-sm font-semibold transition-colors ${
              filter === "league"
                ? "bg-brand-purple text-white"
                : "text-brand-muted hover:bg-gray-700/50"
            }`}
          >
            Leagues
          </button>
          <button
            onClick={() => setFilter("cup")}
            className={`px-3 py-1.5 rounded-md text-sm font-semibold transition-colors ${
              filter === "cup"
                ? "bg-brand-purple text-white"
                : "text-brand-muted hover:bg-gray-700/50"
            }`}
          >
            Cups
          </button>
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
        {isLoadingActive // Show skeleton only for active status loading
          ? Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => (
              <DirectoryCardSkeleton key={i} />
            ))
          : paginatedData.map((league) => (
              <DirectoryCard
                key={league.id}
                {...league}
                isPopular={activeLeagueIds?.includes(league.id)}
              />
            ))}
      </div>

      {!isLoadingActive && paginatedData.length > 0 && (
        <Pagination
          currentPage={currentPage}
          totalPages={totalPages}
          onPageChange={setCurrentPage}
        />
      )}

      {!isLoadingActive && paginatedData.length === 0 && (
        <div className="text-center py-20 bg-brand-secondary rounded-lg">
          <p className="text-xl font-bold text-white">No Results Found</p>
          <p className="text-brand-muted mt-2">
            Try adjusting your search or filter.
          </p>
        </div>
      )}
    </>
  );
}


// ===== src/components/LeagueStandingsSlide.tsx =====

// src/components/LeagueStandingsSlide.tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { League } from "@/types/api-football";

// Type definitions...
type StandingsData = {
  league: { id: number; name: string; logo: string; };
  standings: TeamStanding[];
};
type TeamStanding = {
  rank: number;
  team: { id: number; name: string; logo: string };
  points: number;
  all: { played: number };
};

const fetchStandingsForLeague = async (leagueId: number): Promise<StandingsData | null> => {
  try {
    const { data } = await axios.get(`/api/standings?league=${leagueId}`);
    // If the API returns a valid response but no standings, treat it as null
    if (!data || !data.standings || data.standings.length === 0) {
        return null;
    }
    return data;
  } catch (error) {
    console.error(`Failed to fetch standings for league ${leagueId}:`, error);
    return null; // Return null on API error as well
  }
};

// Skeleton loader...
const SlideSkeleton = () => (
    <div className="bg-brand-secondary rounded-xl p-4 lg:p-6 animate-pulse">
        <div className="h-7 w-3/4 rounded bg-gray-600/50 mb-4"></div>
        <div className="space-y-3 mt-4">
            {Array.from({ length: 5 }).map((_, i) => <div key={i} className="h-5 w-full rounded bg-gray-600/50"></div>)}
        </div>
    </div>
);

export default function LeagueStandingsSlide({ league }: { league: League }) {
  const { data, isLoading } = useQuery<StandingsData | null>({
    queryKey: ['standings', league.id],
    queryFn: () => fetchStandingsForLeague(league.id),
    staleTime: 1000 * 60 * 10, // Cache for 10 minutes
  });

  if (isLoading) return <SlideSkeleton />;
  
  // --- THIS IS THE FIX ---
  // If data is null (either from an API error or because there are no standings),
  // render nothing. This prevents a blank slide from being created.
  if (!data) {
    return null;
  }

  const topStandings = data.standings.slice(0, 5);

  return (
    <div className="bg-brand-secondary rounded-xl p-4 lg:p-6 h-full">
      <div className="flex items-center gap-3 mb-4">
        <Image src={data.league.logo} alt={data.league.name} width={32} height={32}/>
        <h3 className="text-xl font-bold text-brand-light truncate">{data.league.name}</h3>
      </div>
      {/* The standings table */}
      <table className="w-full text-sm">
        <thead className="text-brand-muted text-xs">
          <tr className="border-b border-gray-700/50">
            <th className="p-2 font-semibold text-left w-8">#</th>
            <th className="p-2 font-semibold text-left">Team</th>
            <th className="p-2 font-semibold text-center">P</th>
            <th className="p-2 font-semibold text-center">Pts</th>
          </tr>
        </thead>
        <tbody>
          {topStandings.map((team: TeamStanding) => (
            <tr key={team.team.id} className="border-t border-gray-700/50">
              <td className="p-2 text-center">{team.rank}</td>
              <td className="p-2 flex items-center gap-2 font-medium truncate">
                <Image src={team.team.logo} alt={team.team.name} width={16} height={16} />
                {team.team.name}
              </td>
              <td className="p-2 text-center text-brand-muted">{team.all.played}</td>
              <td className="p-2 text-center font-bold text-brand-light">{team.points}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

// ===== src/components/LiveMatchCard.tsx =====

"use client";

import { useState, useMemo } from 'react';
import Image from 'next/image';
import { format } from 'date-fns';
import Link from '@/components/StyledLink'; 
import { History, BarChart2, Star } from 'lucide-react'; // Import the Star icon
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'axios';
import { useVoteStorage } from '@/hooks/useVoteStorage';
import { useTranslation } from '@/hooks/useTranslation';

// --- Type Definitions for Vote Data ---
interface VoteData {
    homeVotes: number;
    drawVotes: number;
    awayVotes: number;
}

// --- API Helper Functions (integrated from VotingPanel) ---
const getVotes = async (fixtureId: number): Promise<VoteData> => {
    const { data } = await axios.get(`/api/votes?fixture=${fixtureId}`);
    return data;
};

const submitVote = async ({ fixtureId, vote }: { fixtureId: number; vote: string }): Promise<VoteData> => {
    const { data } = await axios.post('/api/votes', { fixtureId, vote });
    return data;
};

// --- A sub-component for a single team row for cleanliness ---
const TeamRow = ({ team, score, hasMomentum, momentumType, onVote, isVotedFor, isDisabled }: any) => (
    <div className="flex justify-between items-center">
        <div className="flex items-center gap-3 min-w-0">
            <div className="relative flex-shrink-0">
                <Image src={team.logo} alt={team.name} width={32} height={32} className="object-contain h-8 w-8"/>
                {hasMomentum && (
                    <span className="absolute -top-1 -right-1 flex h-3 w-3">
                        <span className={`absolute inline-flex h-full w-full rounded-full ${momentumType === 'Goal' ? 'bg-green-400' : 'bg-red-400'} opacity-75 animate-ping`}></span>
                        <span className={`relative inline-flex rounded-full h-3 w-3 ${momentumType === 'Goal' ? 'bg-green-500' : 'bg-red-500'}`}></span>
                    </span>
                )}
            </div>
            <span className="font-bold text-white truncate">{team.name}</span>
        </div>
        <div className="flex items-center gap-3">
            <span className="text-xl font-black text-white">{score ?? 0}</span>
            <button onClick={onVote} disabled={isDisabled} className="disabled:cursor-not-allowed disabled:opacity-50">
                <Star size={20} className={`transition-all duration-200 ${isVotedFor ? 'text-yellow-400 fill-yellow-400' : 'text-gray-500 hover:text-yellow-400'}`} />
            </button>
        </div>
    </div>
);


export default function MobileLiveMatchCard({ match }: { match: any }) {
  const { fixture, teams, goals, league, events } = match;
  const { t } = useTranslation();
  const queryClient = useQueryClient();
  const { setVote, getVoteForFixture } = useVoteStorage();

  const isFinished = ['FT', 'AET', 'PEN'].includes(fixture.status.short);
  
  // State to track the user's vote for this specific match
  const [votedFor, setVotedFor] = useState<'home' | 'away' | null>(() => getVoteForFixture(fixture.id) as 'home' | 'away' | null);

  // Fetch community vote data
  const { data: voteData } = useQuery({
      queryKey: ['votes', fixture.id],
      queryFn: () => getVotes(fixture.id),
      staleTime: 1000 * 60,
      enabled: !isFinished, // Only fetch for non-finished matches
  });

  // Mutation to submit a vote
  const voteMutation = useMutation({
      mutationFn: submitVote,
      onSuccess: () => {
          queryClient.invalidateQueries({ queryKey: ['votes', fixture.id] });
      },
  });

  const handleVote = (choice: 'home' | 'away') => {
      if (votedFor) return; // Prevent re-voting
      setVotedFor(choice);
      setVote(fixture.id, choice);
      voteMutation.mutate({ fixtureId: fixture.id, vote: choice });
  };
  
  const momentumData = useMemo(() => {
    // ... (momentum logic remains unchanged)
    if (!['1H', 'HT', '2H', 'ET', 'P'].includes(fixture.status.short) || !events || events.length === 0) return { teamId: null, type: null };
    const lastMajorEvent = [...events].reverse().find(e => e.type === 'Goal' || (e.type === 'Card' && e.detail === 'Red Card'));
    if (!lastMajorEvent) return { teamId: null, type: null };
    let momentumTeamId = lastMajorEvent.team.id;
    if (lastMajorEvent.type === 'Card') {
        momentumTeamId = momentumTeamId === teams.home.id ? teams.away.id : teams.home.id;
    }
    return { teamId: momentumTeamId, type: lastMajorEvent.type };
  }, [events, fixture.status.short, teams.home.id, teams.away.id]);

  // Calculate vote percentages for the progress bar
  const totalVotes = (voteData?.homeVotes || 0) + (voteData?.awayVotes || 0);
  const homePercent = totalVotes > 0 ? Math.round(((voteData?.homeVotes || 0) / totalVotes) * 100) : 50;

  return (
    <div className="bg-[#252837] rounded-xl overflow-hidden flex flex-col">
      {/* HEADER: League & Status */}
      <div className="flex justify-between items-center p-3 border-b border-gray-700/50">
          <div className="flex items-center gap-2 min-w-0">
            <Image src={league.logo} alt={league.name} width={20} height={20} className="flex-shrink-0" />
            <span className="text-sm font-semibold truncate text-brand-muted">{league.name}</span>
          </div>
          <div className="flex-shrink-0">
            {['1H', 'HT', '2H', 'ET', 'P'].includes(fixture.status.short) && <div className="flex items-center gap-1.5 text-brand-live font-semibold text-xs"><span className="relative flex h-2 w-2"><span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span><span className="relative inline-flex rounded-full h-2 w-2 bg-brand-live"></span></span><span>{fixture.status.elapsed}'</span></div>}
            {isFinished && <div className="flex items-center gap-1.5 bg-gray-700/50 text-gray-300 px-2 py-0.5 rounded-full text-xs font-semibold"><History size={12} /><span>{t('finished')}</span></div>}
            {!isFinished && !['1H', 'HT', '2H', 'ET', 'P'].includes(fixture.status.short) && <div className="font-bold text-brand-light text-sm">{format(new Date(fixture.date), "HH:mm")}</div>}
          </div>
      </div>

      {/* BODY: Vertically Stacked Teams with Star Voting */}
      <div className="p-3 space-y-2">
          <TeamRow 
            team={teams.home} 
            score={goals.home} 
            hasMomentum={momentumData.teamId === teams.home.id}
            momentumType={momentumData.type}
            onVote={() => handleVote('home')}
            isVotedFor={votedFor === 'home'}
            isDisabled={!!votedFor || isFinished}
          />
          <TeamRow 
            team={teams.away} 
            score={goals.away} 
            hasMomentum={momentumData.teamId === teams.away.id}
            momentumType={momentumData.type}
            onVote={() => handleVote('away')}
            isVotedFor={votedFor === 'away'}
            isDisabled={!!votedFor || isFinished}
          />
      </div>

      {/* NEW: Community Rating Progress Bar (shows after voting) */}
      {votedFor && voteData && (
          <div className="px-3 pb-3 space-y-2">
              <div className="flex justify-between items-center">
                  <span className="text-xs font-bold text-white">{homePercent}%</span>
                  <span className="text-xs font-semibold text-brand-muted">Community Rating</span>
                  <span className="text-xs font-bold text-white">{100 - homePercent}%</span>
              </div>
              <div className="flex w-full h-1.5 rounded-full overflow-hidden bg-gray-700">
                  <div className="bg-brand-purple" style={{ width: `${homePercent}%` }}></div>
                  <div className="bg-blue-600" style={{ width: `${100 - homePercent}%` }}></div>
              </div>
          </div>
      )}
      
      {/* FOOTER: Match Details Link */}
      <div className="p-2 bg-gray-900/30 flex justify-end items-center">
        <Link href={`/football/match/${fixture.id}`} className="flex items-center gap-2 text-xs text-brand-muted hover:text-white transition-colors py-1 px-2">
            <BarChart2 size={14} />
            <span>{t('match_details')}</span>
        </Link>
      </div>
    </div>
  );
}

export const MatchCardSkeleton = () => (
    <div className="bg-[#252837] rounded-xl p-4 flex flex-col gap-4 animate-pulse">
        <div className="flex justify-between items-center">
            <div className="h-4 w-1/3 rounded bg-gray-600/50"></div>
            <div className="h-4 w-1/4 rounded bg-gray-600/50"></div>
        </div>
        <div className="flex items-center justify-between py-4">
            <div className="flex flex-col items-center gap-2 w-1/3"><div className="h-12 w-12 rounded-full bg-gray-600/50"></div><div className="h-4 w-2/3 rounded bg-gray-600/50"></div></div>
            <div className="h-8 w-1/4 rounded bg-gray-600/50"></div>
            <div className="flex flex-col items-center gap-2 w-1/3"><div className="h-12 w-12 rounded-full bg-gray-600/50"></div><div className="h-4 w-2/3 rounded bg-gray-600/50"></div></div>
        </div>
        <div className="h-10 w-full rounded-lg bg-gray-600/50 mt-auto"></div>
    </div>
);

// ===== src/components/LiveMatchUpdater.tsx =====

// src/components/LiveMatchUpdater.tsx
"use client";

import { useQuery } from '@tanstack/react-query';
import axios from 'axios';
// --- IMPORT THE NEW COMPONENTS ---
import SidebarMatchItem, { SidebarMatchItemSkeleton } from './SidebarMatchItem';

interface MatchData {
  fixture: { id: number; status: { elapsed: number; }; };
  teams: { home: any; away: any; };
  goals: { home: any; away: any; };
}

const fetchGlobalLiveMatches = async (): Promise<MatchData[]> => {
    const { data } = await axios.get('/api/global-live');
    return data;
};

export default function LiveMatchUpdater({ initialLiveMatches }: { initialLiveMatches: MatchData[] }) {
  
  const { data: liveMatches, isLoading } = useQuery<MatchData[]>({
    queryKey: ['globalLiveMatches'],
    queryFn: fetchGlobalLiveMatches,
    initialData: initialLiveMatches,
    refetchInterval: 30000,
  });

  // This check handles the initial server-side render where `isLoading` is false
  // but we might not have data yet. `liveMatches` from `useQuery` will be defined
  // because we provide `initialData`.
  if (!liveMatches || liveMatches.length === 0) {
      return <p className="text-sm text-brand-muted text-center py-4">No matches are currently live.</p>;
  }

  return (
    <div className="space-y-1">
      {/* Show top 5 live matches using the new component */}
      {liveMatches.slice(0, 5).map(match => (
        <SidebarMatchItem key={match.fixture.id} match={match} />
      ))}
    </div>
  );
}

// ===== src/components/LottiePreloader.tsx =====

// src/components/LottiePreloader.tsx
"use client";

import Lottie from "lottie-react";
// Import the animation data directly from the public folder
import animationData from "../../public/fanskor-preloader.json";

export default function LottiePreloader() {
  const style = {
    height: 250, // Adjust size as needed
    width: 250,
  };

  return (
    <div className="flex flex-col items-center gap-2">
      <Lottie animationData={animationData} style={style} loop={true} />
    </div>
  );
}


// ===== src/components/MainContent.tsx =====

"use client";

import { useState, Dispatch, SetStateAction } from "react";
import { useLeagueContext } from "@/context/LeagueContext";
import { League } from "@/types/api-football";

// Import all the components for the layout
import MatchList from "./MatchList";
import StandingsDisplay from "./StandingsDisplay";
import NewsSection from "./NewsSection";
import MobileHomeTabs from "./MobileHomeTabs";
import LeagueDetailView from "./league-detail-view";
import AdSlotWidget from "./AdSlotWidget";

interface MainContentProps {
  sidebarAboutSeoText: string;
  homepageAboutSeoText: any;
}

export const MainContent: React.FC<MainContentProps> = ({
  sidebarAboutSeoText,
  homepageAboutSeoText,
}) => {
  const { selectedLeague } = useLeagueContext();
  const [liveLeagues, setLiveLeagues] = useState<League[]>([]);

  // Logic for showing the league detail view (unchanged)
  if (selectedLeague) {
    return (
      <div className="flex-1 p-4 lg:p-8">
        <LeagueDetailView leagueData={selectedLeague} />
      </div>
    );
  }

  // Main dashboard layout
  return (
    <>
      {/* --- Desktop Layout (3-column grid) --- */}
      <div className="hidden lg:grid lg:grid-cols-3 lg:gap-8 flex-1 pl-8">
        {/* Main Content Area (MatchList) */}
        <div className="lg:col-span-2 flex flex-col">
          <MatchList setLiveLeagues={setLiveLeagues} />

          <div className="container mx-auto px-4 mt-8 pb-8">
            <div className="bg-brand-secondary rounded-lg shadow-lg p-6">
              <h2 className="text-2xl font-bold text-white mb-4">
                Fanskor Hakkında
              </h2>
              <p className="text-brand-light text-base leading-relaxed">
                {homepageAboutSeoText}
              </p>
            </div>
          </div>
        </div>

        {/* Right Sidebar Column */}
        <div className="lg:col-span-1 flex flex-col gap-6">
          {/* --- AD SLOT PLACED HERE --- */}
          <AdSlotWidget location="homepage_right_sidebar" />

          <StandingsDisplay />

          {/* The sticky container for ads and news */}
          <div className="space-y-8 gap-8">
            <section className="bg-brand-secondary rounded-lg shadow-lg p-6">
              <h2 className="text-2xl font-bold text-white mb-4">
                Fanskor Hakkında
              </h2>
              <p className="text-brand-light text-base leading-relaxed">
                {sidebarAboutSeoText}
              </p>
            </section>
            <NewsSection />
          </div>
        </div>
      </div>

      {/* --- Mobile Layout (Tab-based) --- */}
      <div className="block lg:hidden w-full">
        <MobileHomeTabs
          liveLeagues={liveLeagues}
          setLiveLeagues={setLiveLeagues}
        />
      </div>
    </>
  );
};


// ===== src/components/match/BettingPromotionWidget.tsx =====

"use client";

import { memo } from 'react';
import Image from 'next/image';
import { ShieldCheck } from 'lucide-react';

// This is a static promotional component.
const BettingPromotionWidget = memo(function BettingPromotionWidget() {
    
    const handleBetClick = () => {
        console.log("Redirecting to casino partner from sidebar widget...");
        // In a real app: window.open('https://chinchincasino.com/signup', '_blank');
    };

    return (
        <div className="bg-gradient-to-br from-green-500/20 to-brand-purple/20 p-4 rounded-xl border border-green-400/30 text-center space-y-3">
            
            {/* You can add a logo of your betting partner here */}
            {/* <Image src="/path/to/partner-logo.svg" alt="Partner Logo" width={100} height={40} className="mx-auto" /> */}
            
            <h3 className="text-lg font-bold text-white">
                Exclusive Welcome Offer!
            </h3>
            <p className="text-sm text-brand-light">
                Get a <span className="font-bold text-green-400">100% bonus</span> on your first deposit to bet on this match.
            </p>

            {/* The animated button */}
            <div className="relative pt-2">
                <span className="absolute top-2 left-0 inline-flex h-full w-full rounded-lg bg-green-400 opacity-75 animate-ping"></span>
                <button
                    onClick={handleBetClick}
                    className="relative w-full bg-[#16A34A] text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2 hover:bg-green-700 transition-colors"
                >
                    <ShieldCheck size={18} />
                    <span>Claim Your Bonus</span>
                </button>
            </div>

            <p className="text-xs text-brand-muted/80">
                18+ | T&Cs apply. Gamble responsibly.
            </p>
        </div>
    );
});

export default BettingPromotionWidget;

// ===== src/components/match/FormGuide.tsx =====

"use client";
import { memo } from 'react';

// Displays W-D-L streak
const FormGuide = memo(function FormGuide({ form, teamId }: { form: any[], teamId: number }) {
    if (!form || form.length === 0) return null;

    return (
        <div className="flex items-center gap-1.5">
            {form.map((match: any) => {
                const goals = match.goals;
                const home = match.teams.home;
                
                let result = 'D';
                if (goals.home !== goals.away) {
                    const winnerId = goals.home > goals.away ? home.id : match.teams.away.id;
                    result = winnerId === teamId ? 'W' : 'L';
                }
                
                const classes = {
                    W: 'bg-green-500 text-green-900',
                    D: 'bg-gray-500 text-gray-900',
                    L: 'bg-red-500 text-red-900',
                };
                
                return (
                    <span key={match.fixture.id} className={`flex items-center justify-center w-6 h-6 rounded-full text-xs font-bold ${classes[result as keyof typeof classes]}`}>
                        {result}
                    </span>
                );
            })}
        </div>
    );
});
export default FormGuide;

// ===== src/components/match/HeaderOdds.tsx =====

// src/components/match/HeaderOdds.tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";

interface HeaderOddsProps {
  fixtureId: number;
}

const fetchOdds = async (fixtureId: number) => {
  // We use our existing /api/odds route which is optimized for one bookmaker
  const { data } = await axios.get(`/api/odds?fixture=${fixtureId}`);
  return data;
};

export default function HeaderOdds({ fixtureId }: HeaderOddsProps) {
  const { data: odds, isLoading } = useQuery({
    queryKey: ["headerOdds", fixtureId],
    queryFn: () => fetchOdds(fixtureId),
    staleTime: 1000 * 60 * 60, // 1 hour
    enabled: !!fixtureId,
  });

  const OddBox = ({ label, value }: { label: string; value?: string }) => (
    <div className="flex flex-col items-center justify-center p-2 rounded-md bg-gray-800/50 w-16 h-14">
      <span className="text-xs text-brand-muted">{label}</span>
      <span className="text-sm font-bold text-white">{value || "-"}</span>
    </div>
  );

  if (isLoading) {
    return (
      <div className="flex items-center justify-center gap-2 mt-4 animate-pulse">
        <div className="w-16 h-14 bg-gray-700/50 rounded-md"></div>
        <div className="w-16 h-14 bg-gray-700/50 rounded-md"></div>
        <div className="w-16 h-14 bg-gray-700/50 rounded-md"></div>
      </div>
    );
  }

  if (!odds) return null;

  return (
    <div className="flex items-center justify-center gap-2 mt-4">
      <OddBox label="Home" value={odds.home} />
      <OddBox label="Draw" value={odds.draw} />
      <OddBox label="Away" value={odds.away} />
    </div>
  );
}


// ===== src/components/match/LiveOddsWidget.tsx =====

// src/components/match/LiveOddsWidget.tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { TrendingUp, Goal, CornerUpRight, Users } from "lucide-react";

interface LiveOddsWidgetProps {
  fixtureId: string;
}

// --- Data Fetcher ---
const fetchLiveOdds = async (fixtureId: string) => {
  const { data } = await axios.get(
    `/api/live-odds-by-fixture?fixture=${fixtureId}`
  );
  return data;
};

// --- Reusable Sub-components for clean code ---
const OddsMarketRow = ({
  title,
  icon: Icon,
  oddsData,
  labels,
}: {
  title: string;
  icon: React.ElementType;
  oddsData: any | null;
  labels: { [key: string]: string };
}) => {
  if (!oddsData) return null;

  return (
    <div>
      <h4 className="flex items-center gap-2 text-sm font-semibold text-brand-light mb-2">
        <Icon size={16} className="text-brand-purple" />
        {title} {oddsData.handicap && `(${oddsData.handicap})`}
      </h4>
      <div className="grid grid-cols-2 gap-2">
        {Object.keys(labels).map(
          (key) =>
            oddsData[key] && (
              <div
                key={key}
                className="bg-gray-800/50 p-2 rounded-md flex justify-between items-center text-xs"
              >
                <span className="text-brand-muted">{labels[key]}</span>
                <span className="font-bold text-white">{oddsData[key]}</span>
              </div>
            )
        )}
      </div>
    </div>
  );
};

const LiveOddsSkeleton = () => (
  <div className="bg-brand-secondary p-4 rounded-lg animate-pulse">
    <div className="h-5 w-3/4 mb-4 bg-gray-700 rounded"></div>
    <div className="space-y-4">
      <div className="space-y-2">
        <div className="h-4 w-1/2 bg-gray-600 rounded"></div>
        <div className="grid grid-cols-2 gap-2">
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
        </div>
      </div>
      <div className="space-y-2">
        <div className="h-4 w-1/2 bg-gray-600 rounded"></div>
        <div className="grid grid-cols-2 gap-2">
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
          <div className="h-9 bg-gray-700/50 rounded-md"></div>
        </div>
      </div>
    </div>
  </div>
);

export default function LiveOddsWidget({ fixtureId }: LiveOddsWidgetProps) {
  const {
    data: liveOdds,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["liveOdds", fixtureId],
    queryFn: () => fetchLiveOdds(fixtureId),
    staleTime: 10 * 1000, // 10 seconds
    refetchInterval: 20 * 1000, // Refetch every 20 seconds
    enabled: !!fixtureId,
  });

  // Don't render if there's an error or no data after loading
  if (!isLoading && (isError || !liveOdds)) {
    return null;
  }

  if (isLoading) {
    return <LiveOddsSkeleton />;
  }

  return (
    <div className="bg-brand-secondary p-4 rounded-lg">
      <div className="flex items-center gap-2 mb-4">
        <TrendingUp size={20} className="text-green-400" />
        <h3 className="text-lg font-bold text-white">Live Odds</h3>
        <span className="relative flex h-3 w-3 ml-auto">
          <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
          <span className="relative inline-flex rounded-full h-3 w-3 bg-green-500"></span>
        </span>
      </div>

      <div className="space-y-4">
        <OddsMarketRow
          title="Over / Under"
          icon={Goal}
          oddsData={liveOdds.overUnder}
          labels={{ over: "Over", under: "Under" }}
        />
        <OddsMarketRow
          title="Asian Handicap"
          icon={Users}
          oddsData={liveOdds.asianHandicap}
          labels={{ home: "Home", away: "Away" }}
        />
        <OddsMarketRow
          title="Match Corners"
          icon={CornerUpRight}
          oddsData={liveOdds.matchCorners}
          labels={{ over: "Over", under: "Under" }}
        />
        {/* You could add more markets like 'Next Goal' here if desired */}
      </div>
    </div>
  );
}


// ===== src/components/match/MatchActivityWidget.tsx =====

// src/components/match/MatchActivityWidget.tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { useMemo } from "react";
import Image from "next/image";
import {
  Clock,
  CheckCircle,
  XCircle,
  Goal,
  ArrowLeftRight,
  Slash,
} from "lucide-react";
import { format } from "date-fns";
import Link from "next/link"; // Assuming match activity events might link to players/teams

// Type definitions for events (align with API-Football's fixture events)
interface MatchEvent {
  time: {
    elapsed: number;
    extra: number | null;
  };
  team: {
    id: number;
    name: string;
    logo: string;
  };
  player: {
    id: number;
    name: string;
  };
  assist: {
    id: number | null;
    name: string | null;
  };
  type: "Goal" | "Card" | "subst" | "Var";
  detail: string; // e.g., "Yellow Card", "Red Card", "Penalty"
  comments: string | null;
}

interface MatchActivityWidgetProps {
  fixtureId: string;
  homeTeamId: number;
  awayTeamId: number;
  homeTeamLogo: string;
  awayTeamLogo: string;
  isLive: boolean; // Indicates if the match is currently live (for polling)
  activitySeoDescription: string; // <-- NEW PROP
}

const fetchFixtureEvents = async (fixtureId: string): Promise<MatchEvent[]> => {
  const { data } = await axios.get(`/api/match-details?fixture=${fixtureId}`);
  // Extract events from the full match details response
  return data?.events || [];
};

export default function MatchActivityWidget({
  fixtureId,
  homeTeamId,
  awayTeamId,
  homeTeamLogo,
  awayTeamLogo,
  isLive,
  activitySeoDescription, // <-- NEW PROP
}: MatchActivityWidgetProps) {
  const {
    data: events,
    isLoading,
    isError,
  } = useQuery<MatchEvent[]>({
    queryKey: ["fixtureEvents", fixtureId],
    queryFn: () => fetchFixtureEvents(fixtureId),
    enabled: !!fixtureId,
    // Poll for updates if match is live
    refetchInterval: isLive ? 10000 : false, // Poll every 10 seconds if live
    staleTime: isLive ? 5000 : 1000 * 60 * 5, // Data is stale after 5s if live, 5m if not
  });

  const sortedEvents = useMemo(() => {
    if (!events) return [];
    // Sort events by elapsed time ascending for chronological display
    return [...events].sort((a, b) => a.time.elapsed - b.time.elapsed);
  }, [events]);

  const EventIcon = ({ type, detail }: { type: string; detail: string }) => {
    switch (type) {
      case "Goal":
        return <Goal size={16} className="text-green-500" />;
      case "Card":
        return detail === "Yellow Card" ? (
          <Slash size={16} className="text-yellow-500 rotate-45" />
        ) : (
          <Slash size={16} className="text-red-500 rotate-45" />
        );
      case "subst":
        return <ArrowLeftRight size={16} className="text-blue-400" />;
      default:
        return <Clock size={16} className="text-brand-muted" />;
    }
  };

  if (isLoading)
    return (
      <div className="bg-brand-dark rounded-lg p-6 shadow-lg animate-pulse">
        <div className="h-6 w-3/4 bg-gray-700 rounded mb-4"></div>
        <div className="h-4 w-1/2 bg-gray-600 rounded mb-4"></div>
        <div className="space-y-2">
          <div className="h-8 bg-gray-700 rounded"></div>
          <div className="h-8 bg-gray-700 rounded"></div>
          <div className="h-8 bg-gray-700 rounded"></div>
        </div>
      </div>
    );
  if (isError)
    return (
      <div className="bg-brand-dark rounded-lg p-6 text-red-400">
        Failed to load match activity.
      </div>
    );

  return (
    <div className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden">
      <div className="p-6">
        <h2 className="text-2xl font-bold text-white mb-4">Match Activity</h2>

        {/* --- Activity SEO Optimization Text --- */}
        <p className="italic text-[#a3a3a3] leading-relaxed mb-6">
          {activitySeoDescription}
        </p>

        {sortedEvents.length === 0 ? (
          <p className="text-brand-muted text-center p-4">
            No significant match activity yet.
          </p>
        ) : (
          <div className="relative">
            {/* Vertical timeline line */}
            <div className="absolute left-1/2 transform -translate-x-1/2 w-0.5 bg-gray-700 h-full"></div>

            <div className="space-y-6">
              {sortedEvents.map((event, index) => (
                <div
                  key={index}
                  className={`flex items-center w-full ${
                    event.team.id === homeTeamId
                      ? "flex-row-reverse"
                      : "flex-row"
                  }`}
                >
                  {/* Event Time & Icon */}
                  <div
                    className={`flex items-center flex-shrink-0 w-1/2 ${
                      event.team.id === homeTeamId
                        ? "justify-end pr-6"
                        : "justify-start pl-6"
                    }`}
                  >
                    <span className="text-brand-muted text-sm flex items-center gap-1">
                      <Clock size={16} /> {event.time.elapsed}'
                    </span>
                    <div className="relative mx-3">
                      <div className="w-4 h-4 rounded-full bg-brand-purple border-2 border-gray-700 absolute top-1/2 -left-2 -translate-y-1/2"></div>
                      <EventIcon type={event.type} detail={event.detail} />
                    </div>
                  </div>

                  {/* Event Details */}
                  <div
                    className={`flex-grow w-1/2 ${
                      event.team.id === homeTeamId
                        ? "text-right pl-3"
                        : "text-left pr-3"
                    }`}
                  >
                    <div className="flex items-center gap-2 justify-end">
                      {event.team.id === homeTeamId && (
                        <Image
                          src={homeTeamLogo}
                          alt={event.team.name}
                          width={20}
                          height={20}
                          className="object-contain"
                        />
                      )}
                      <span className="font-semibold text-white">
                        {event.player.name}
                      </span>
                      {event.team.id === awayTeamId && (
                        <Image
                          src={awayTeamLogo}
                          alt={event.team.name}
                          width={20}
                          height={20}
                          className="object-contain"
                        />
                      )}
                    </div>
                    <p className="text-brand-muted text-sm">{event.detail}</p>
                    {event.comments && (
                      <p className="text-xs text-gray-500">{event.comments}</p>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}


// ===== src/components/match/MatchAnalyticsWidget.tsx =====

import { memo } from 'react';
import Image from 'next/image';
import { CheckCircle, XCircle, ShieldQuestion, TrendingUp, TrendingDown } from 'lucide-react';

// A small, reusable component to display the W-D-L form streak.
const FormGuide = memo(function FormGuide({ formString }: { formString: string }) {
    if (!formString) return <span className="text-xs text-text-muted">N/A</span>;
    
    return (
        <div className="flex items-center gap-1.5">
            {formString.split('').slice(0, 5).map((result, index) => {
                const classes = {
                    W: 'bg-green-500 text-green-900',
                    D: 'bg-gray-500 text-gray-900',
                    L: 'bg-red-500 text-red-900',
                };
                return (
                    <span 
                        key={index} 
                        className={`flex items-center justify-center w-6 h-6 rounded-full text-xs font-bold ${classes[result as keyof typeof classes]}`}
                    >
                        {result}
                    </span>
                );
            })}
        </div>
    );
});


// The main widget component.
const MatchAnalyticsWidget = memo(function MatchAnalyticsWidget({ analytics }: { analytics: any }) {

    // If there's no prediction data, don't render the widget.
    if (!analytics?.prediction || !analytics.homeTeamStats || !analytics.awayTeamStats) {
        return (
             <div className="bg-brand-secondary rounded-xl">
                <h3 className="text-lg font-bold p-4 border-b border-gray-700/50">Prediction & Form</h3>
                <p className="text-text-muted text-center py-8">Analytics are not available for this match.</p>
            </div>
        );
    }

    const { prediction, homeTeamStats, awayTeamStats } = analytics;
    const { percent } = prediction.predictions;
    const btts = prediction.comparison.btts === 'Yes';
    const overUnder = prediction.comparison.under_over === 'Over 2.5';

    // Parse percentages, removing '%' and converting to numbers.
    const homePercent = parseFloat(percent.home.replace('%', ''));
    const drawPercent = parseFloat(percent.draw.replace('%', ''));
    const awayPercent = parseFloat(percent.away.replace('%', ''));
    
    return (
        <div className="bg-brand-secondary rounded-xl">
            <h3 className="text-lg font-bold p-4 border-b border-gray-700/50">Prediction & Form</h3>
            <div className="p-4 space-y-5">

                {/* --- 1. Win Probability Section --- */}
                <div>
                    <div className="flex justify-between items-center mb-1.5">
                        <div className="flex flex-col items-center gap-1 text-center">
                            <Image src={homeTeamStats.team.logo} alt={homeTeamStats.team.name} width={32} height={32} />
                            <span className="font-bold text-lg text-white">{homePercent}%</span>
                        </div>
                        <div className="flex flex-col items-center gap-1 text-center">
                            <span className="text-text-muted text-sm font-semibold">Draw</span>
                            <span className="font-bold text-lg text-white">{drawPercent}%</span>
                        </div>
                        <div className="flex flex-col items-center gap-1 text-center">
                            <Image src={awayTeamStats.team.logo} alt={awayTeamStats.team.name} width={32} height={32} />
                            <span className="font-bold text-lg text-white">{awayPercent}%</span>
                        </div>
                    </div>
                    {/* The visual win-distribution bar */}
                    <div className="flex w-full h-2 rounded-full overflow-hidden" style={{ backgroundColor: 'var(--color-secondary)' }}>
                        <div className="bg-brand-purple" style={{ width: `${homePercent}%` }}></div>
                        <div className="bg-gray-500" style={{ width: `${drawPercent}%` }}></div>
                        <div className="bg-brand-highlight" style={{ width: `${awayPercent}%` }}></div>
                    </div>
                </div>

                {/* --- 2. Key Insights Section --- */}
                <div className="grid grid-cols-2 gap-3 text-sm">
                    <div className="flex items-center gap-2 p-3 rounded-lg" style={{backgroundColor: 'var(--color-primary)'}}>
                        {btts ? <CheckCircle size={20} className="text-green-400" /> : <XCircle size={20} className="text-red-400" />}
                        <span className="font-semibold">Both Teams to Score</span>
                    </div>
                     <div className="flex items-center gap-2 p-3 rounded-lg" style={{backgroundColor: 'var(--color-primary)'}}>
                        {overUnder ? <TrendingUp size={20} className="text-green-400" /> : <TrendingDown size={20} className="text-red-400" />}
                        <span className="font-semibold">Over 2.5 Goals</span>
                    </div>
                </div>

                {/* --- 3. Team Form Guide Section --- */}
                <div className="space-y-3">
                    <div className="flex items-center justify-between">
                        <span className="font-semibold text-text-secondary">{homeTeamStats.team.name}</span>
                        <FormGuide formString={homeTeamStats.form} />
                    </div>
                    <div className="flex items-center justify-between">
                        <span className="font-semibold text-text-secondary">{awayTeamStats.team.name}</span>
                        <FormGuide formString={awayTeamStats.form} />
                    </div>
                </div>
                
                {/* --- 4. Final Advice Section --- */}
                {prediction.predictions.advice && (
                    <div className="flex items-center gap-2 p-3 text-center rounded-lg border-2 border-dashed border-gray-700">
                        <ShieldQuestion size={20} className="text-brand-purple flex-shrink-0" />
                        <p className="text-sm font-semibold text-text-secondary">{prediction.predictions.advice}</p>
                    </div>
                )}
            </div>
        </div>
    );
});

export default MatchAnalyticsWidget;

// ===== src/components/match/MatchH2HWidget.tsx =====

// src/components/match/MatchH2HWidget.tsx
"use client";

import { useMemo, useState } from "react";
import Image from "next/image";
import { format } from "date-fns";
import Link from "next/link";
import { ChevronRight, CalendarDays } from "lucide-react";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateMatchSlug } from "@/lib/generate-match-slug";
// No useTranslation import here for h2hSeoDescription
// import { useTranslation } from '@/hooks/useTranslation';

interface MatchH2HWidgetProps {
  h2h: any[]; // Array of past match fixtures
  teams: {
    home: { id: number; name: string; logo: string };
    away: { id: number; name: string; logo: string };
  };
  currentFixtureId: string;
  h2hSeoDescription: string; // This prop receives the static Turkish string
}

export default function MatchH2HWidget({
  h2h,
  teams,
  currentFixtureId,
  h2hSeoDescription,
}: MatchH2HWidgetProps) {
  const [showAll, setShowAll] = useState(false);
  const filteredH2H = useMemo(
    () =>
      h2h.filter((match) => match.fixture.id !== parseInt(currentFixtureId)),
    [h2h, currentFixtureId]
  );
  const displayedH2H = showAll ? filteredH2H : filteredH2H.slice(0, 5);

  const headToHeadRecords = useMemo(() => {
    if (!filteredH2H || filteredH2H.length === 0) {
      return { homeWins: 0, awayWins: 0, draws: 0 };
    }

    let homeWins = 0;
    let awayWins = 0;
    let draws = 0;

    filteredH2H.forEach((match: any) => {
      if (match.fixture.status.short === "FT") {
        if (match.teams.home.winner) {
          if (match.teams.home.id === teams.home.id) {
            homeWins++;
          } else {
            awayWins++;
          }
        } else if (match.teams.away.winner) {
          if (match.teams.away.id === teams.away.id) {
            homeWins++;
          } else {
            awayWins++;
          }
        } else {
          draws++;
        }
      }
    });

    return { homeWins, awayWins, draws };
  }, [filteredH2H, teams]);

  return (
    <div className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden">
      <div className="p-6">
        <h2 className="text-2xl font-bold text-white mb-4">Head-to-Head</h2>

        {/* --- H2H SEO Optimization Text --- */}
        {/* This text is now passed as an already formed string from the Server Component */}
        <p className="italic text-[#a3a3a3] leading-relaxed mb-6">
          {h2hSeoDescription}
        </p>

        {filteredH2H.length === 0 ? (
          <p className="text-brand-muted text-center p-4">
            No head-to-head matches found.
          </p>
        ) : (
          <>
            <div className="grid grid-cols-3 text-center gap-4 mb-6">
              <div className="flex flex-col items-center">
                <Image
                  src={teams.home.logo}
                  alt={teams.home.name}
                  width={50}
                  height={50}
                  className="w-12 h-12 object-contain mb-2"
                />
                <span className="text-white font-semibold text-lg">
                  {headToHeadRecords.homeWins}
                </span>
                <span className="text-brand-muted text-sm">Wins</span>
              </div>
              <div className="flex flex-col items-center">
                <span className="text-white font-semibold text-lg">
                  {headToHeadRecords.draws}
                </span>
                <span className="text-brand-muted text-sm">Draws</span>
              </div>
              <div className="flex flex-col items-center">
                <Image
                  src={teams.away.logo}
                  alt={teams.away.name}
                  width={50}
                  height={50}
                  className="w-12 h-12 object-contain mb-2"
                />
                <span className="text-white font-semibold text-lg">
                  {headToHeadRecords.awayWins}
                </span>
                <span className="text-brand-muted text-sm">Wins</span>
              </div>
            </div>

            <div className="space-y-3">
              {displayedH2H.map((match) => (
                <Link
                  key={match.fixture.id}
                  href={generateMatchSlug(
                    match.teams.home.name,
                    match.teams.away.name,
                    match.fixture.id
                  )}
                  className="block bg-gray-800/50 p-3 rounded-md hover:bg-gray-700/50 transition-colors duration-200"
                >
                  <div className="flex items-center justify-between text-sm">
                    <div className="flex items-center gap-2">
                      <CalendarDays size={16} className="text-brand-muted" />
                      <span className="text-brand-muted">
                        {format(new Date(match.fixture.date), "dd MMM yyyy")}
                      </span>
                    </div>
                    <div className="flex items-center gap-3">
                      <div className="flex items-center gap-2">
                        <Image
                          src={match.teams.home.logo}
                          alt={match.teams.home.name}
                          width={24}
                          height={24}
                          className="w-6 h-6 object-contain"
                        />
                        <span className="text-white font-medium">
                          {match.teams.home.name}
                        </span>
                        <span className="font-bold text-white text-lg">
                          {match.goals.home}
                        </span>
                      </div>
                      <span className="text-brand-muted"> - </span>
                      <div className="flex items-center gap-2">
                        <span className="font-bold text-white text-lg">
                          {match.goals.away}
                        </span>
                        <span className="text-white font-medium">
                          {match.teams.away.name}
                        </span>
                        <Image
                          src={match.teams.away.logo}
                          alt={match.teams.away.name}
                          width={24}
                          height={24}
                          className="w-6 h-6 object-contain"
                        />
                      </div>
                    </div>
                  </div>
                </Link>
              ))}
            </div>

            {filteredH2H.length > 5 && (
              <div className="text-center mt-6">
                <button
                  onClick={() => setShowAll(!showAll)}
                  className="bg-brand-purple text-white px-4 py-2 rounded-lg text-sm font-semibold hover:opacity-90 transition-opacity"
                >
                  {showAll ? "Show Less" : `Show All (${filteredH2H.length})`}
                </button>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
}


// ===== src/components/match/MatchHeader.tsx =====

// src/components/match/MatchHeader.tsx
"use client"; // This component remains a Client Component

import Image from "next/image";
import { format } from "date-fns";
import { useMemo } from "react";
import { ChevronRight, Clock, CalendarDays, BarChart2 } from "lucide-react";
import Link from "next/link";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateLeagueSlug } from "@/lib/generate-league-slug";
import { generateTeamSlug } from "@/lib/generate-team-slug";
// Removed useTranslation import
// import { useTranslation } from '@/hooks/useTranslation';

// Assuming these types are defined elsewhere or simplified for this example
interface Team {
  id: number;
  name: string;
  logo: string;
}

interface Fixture {
  fixture: any;
  id: number;
  date: string;
  timestamp: number;
  timezone: string;
  status: {
    long: string;
    short: any;
    elapsed: number | null;
  };
  venue: {
    id: number;
    name: string;
    city: string;
  };
  teams: {
    home: Team;
    away: Team;
  };
  league: {
    id: number;
    name: string;
    country: string;
    logo: string;
    flag: string;
    season: number;
    round: string;
  };
  goals: {
    home: number | null;
    away: number | null;
  };
  score: {
    halftime: {
      home: number | null;
      away: number | null;
    };
    fulltime: {
      home: number | null;
      away: number | null;
    };
    extratime: {
      home: number | null;
      away: number | null;
    };
    penalty: {
      home: number | null;
      away: number | null;
    };
  };
}

interface MatchHeaderProps {
  fixture: Fixture;
  analytics: {
    prediction?: any;
    homeTeamStats?: any;
    awayTeamStats?: any;
    customPrediction?: any;
    customOdds?: any;
    bookmakerOdds?: any;
  };
  // Now directly receives the untranslated string
  matchSeoDescription: string;
}

const MatchHeader: React.FC<MatchHeaderProps> = ({
  fixture,
  analytics,
  matchSeoDescription,
}) => {
  // Removed useTranslation hook call
  // const { t } = useTranslation();

  const homeTeam = fixture?.teams?.home;
  const awayTeam = fixture?.teams?.away;
  const league = fixture?.league;
  const status = fixture?.fixture.status;
  const venue = fixture?.fixture.venue;
  const goals = fixture?.goals;
  const score = fixture?.score;
  const fixtureDate = fixture?.fixture;

  if (
    !homeTeam ||
    !awayTeam ||
    !league ||
    !status ||
    !venue ||
    !score ||
    !goals ||
    !fixtureDate
  ) {
    console.error("[MatchHeader] Essential fixture data missing:", {
      fixture,
      homeTeam,
      awayTeam,
      league,
      status,
      venue,
      score,
      goals,
      fixtureDate,
    });
    return (
      <div className="text-red-400 p-4">Error: Match data incomplete.</div>
    );
  }

  const validFixtureDate = useMemo(() => {
    if (
      fixtureDate &&
      typeof fixtureDate === "string" &&
      !isNaN(new Date(fixtureDate).getTime())
    ) {
      return new Date(fixtureDate);
    }
    console.warn(
      `[MatchHeader] Invalid or missing fixture.date received: "${fixtureDate}". Using current date as fallback.`
    );
    return new Date();
  }, [fixtureDate]);

  const formattedDate = useMemo(
    () => format(validFixtureDate, "dd MMMM yyyy"),
    [validFixtureDate]
  );
  const formattedTime = useMemo(
    () => format(validFixtureDate, "HH:mm"),
    [validFixtureDate]
  );

  const prediction = useMemo(() => {
    if (analytics?.customPrediction) {
      return analytics.customPrediction;
    }
    if (analytics?.prediction && analytics.prediction?.percent) {
      return {
        home: analytics.prediction.percent.home,
        draw: analytics.prediction.percent.draw,
        away: analytics.prediction.percent.away,
      };
    }
    return null;
  }, [analytics?.customPrediction, analytics?.prediction]);

  const winningPrediction = useMemo(() => {
    if (!prediction) return null;
    const max = Math.max(prediction.home, prediction.draw, prediction.away);
    if (max === prediction.home)
      return { team: homeTeam, percent: prediction.home };
    if (max === prediction.away)
      return { team: awayTeam, percent: prediction.away };
    return { team: null, percent: prediction.draw };
  }, [prediction, homeTeam, awayTeam]);

  const isLive = useMemo(() => {
    const liveStatuses = ["1H", "HT", "2H", "ET", "BT", "P", "LIVE"];
    return liveStatuses.includes(status?.short || "");
  }, [status?.short]);

  const finalScoreHome =
    score?.fulltime?.home !== null ? score.fulltime.home : goals?.home;
  const finalScoreAway =
    score?.fulltime?.away !== null ? score.fulltime.away : goals?.away;

  // This text is now passed as an already translated prop
  // const translatedMatchSeoDescription = t('match_seo_description', {
  //   home_team_name: matchSeoDescriptionData.homeTeamName,
  //   away_team_name: matchSeoDescriptionData.awayTeamName
  // });

  return (
    <div className="bg-brand-secondary rounded-lg overflow-hidden shadow-lg mb-4">
      {/* League Info & Breadcrumbs */}
      <div className="p-4 bg-gray-800/50 flex items-center justify-between text-brand-muted text-sm">
        <div className="flex items-center gap-2">
          <Link
            href={`/football/leagues`}
            className="hover:text-white transition-colors"
          >
            Leagues
          </Link>
          <ChevronRight size={14} />
          <Link
            href={generateLeagueSlug(league.name, league.id)}
            className="hover:text-white transition-colors"
          >
            {league.name}
          </Link>
        </div>
        <div className="text-xs">{league.round}</div>
      </div>

      {/* Match Overview - Teams, Score, Status */}
      <div className="p-6 flex flex-col items-center justify-center text-center">
        <div className="flex items-center w-full justify-around mb-6 gap-4">
          {/* Home Team */}
          <Link
            href={generateTeamSlug(homeTeam.name, homeTeam.id)}
            className="flex flex-col items-center gap-3 flex-1 min-w-0"
          >
            <Image
              src={proxyImageUrl(homeTeam.logo)}
              alt={homeTeam.name}
              width={80}
              height={80}
              className="w-20 h-20 object-contain"
            />
            <span className="font-bold text-white text-xl truncate">
              {homeTeam.name}
            </span>
          </Link>

          {/* Score / VS */}
          <div className="flex flex-col items-center justify-center flex-shrink-0 mx-4">
            {status?.short === "NS" ? (
              <span className="text-4xl font-extrabold text-white">VS</span>
            ) : (
              <span className="text-4xl font-extrabold text-white">
                {finalScoreHome !== null ? finalScoreHome : "?"} -{" "}
                {finalScoreAway !== null ? finalScoreAway : "?"}
              </span>
            )}
            <span
              className={`text-sm font-semibold mt-2 px-3 py-1 rounded-full ${
                isLive
                  ? "bg-green-500/20 text-green-400"
                  : "bg-gray-700/50 text-brand-muted"
              }`}
            >
              {status?.long || "N/A"}{" "}
              {status?.elapsed !== null && isLive && `(${status.elapsed}')`}
            </span>
          </div>

          {/* Away Team */}
          <Link
            href={generateTeamSlug(awayTeam.name, awayTeam.id)}
            className="flex flex-col items-center gap-3 flex-1 min-w-0"
          >
            <Image
              src={proxyImageUrl(awayTeam.logo)}
              alt={awayTeam.name}
              width={80}
              height={80}
              className="w-20 h-20 object-contain"
            />
            <span className="font-bold text-white text-xl truncate">
              {awayTeam.name}
            </span>
          </Link>
        </div>

        {/* Match Details: Date, Time, Venue */}
        <div className="grid grid-cols-1 sm:grid-cols-3 gap-y-3 gap-x-6 text-brand-muted text-sm border-t border-b border-gray-700/50 py-4 w-full justify-center">
          <div className="flex items-center justify-center gap-2">
            <CalendarDays size={18} />
            <span>{formattedDate}</span>
          </div>
          <div className="flex items-center justify-center gap-2">
            <Clock size={18} />
            <span>{formattedTime}</span>
          </div>
          <div className="flex items-center justify-center gap-2">
            <BarChart2 size={18} />
            <span>
              {venue?.name || "N/A"} ({venue?.city || "N/A"})
            </span>
          </div>
        </div>

        {/* Prediction Display */}
        {winningPrediction && (
          <div className="mt-4 text-white font-semibold text-lg flex items-center justify-center gap-2">
            <span className="text-brand-muted">Prediction:</span>
            {winningPrediction.team ? (
              <span className="flex items-center gap-1">
                <Image
                  src={proxyImageUrl(winningPrediction.team.logo)}
                  alt={winningPrediction.team.name}
                  width={24}
                  height={24}
                />
                {winningPrediction.team.name}
              </span>
            ) : (
              <span>Draw</span>
            )}
            <span className="text-brand-purple">
              ({winningPrediction.percent}%)
            </span>
          </div>
        )}
      </div>

      {/* --- SEO OPTIMIZATION TEXT --- */}
      {/* This text is now passed as an already translated prop */}
      <div className="p-6 border-t border-gray-700/50">
        <p className=" leading-relaxed italic text-[#a3a3a3]">
          {matchSeoDescription}
        </p>
      </div>
    </div>
  );
};

export default MatchHeader;


// ===== src/components/match/MatchLineupsWidget.tsx =====

"use client";

import { memo } from 'react';
import Image from 'next/image';
import Accordion from '@/components/Accordion'; // Reusing our custom Accordion component

// A clean, reusable sub-component to display a list of players (Starting XI or Subs).
const PlayerList = memo(function PlayerList({ title, players }: { title: string, players: any[] }) {
    if (!players || players.length === 0) return null;

    return (
        <div>
            <h4 className="font-bold text-base mb-3 mt-4 text-text-muted border-b border-gray-700/50 pb-2">
                {title}
            </h4>
            <ul className="space-y-3 pt-2">
                {players.map((p: any) => (
                    <li key={p.player.id} className="flex items-center gap-3 text-sm">
                        <span className="text-text-muted font-mono w-8 text-center flex-shrink-0">
                            {p.player.number}
                        </span>
                        <span className="font-medium text-text-secondary">
                            {p.player.name}
                        </span>
                    </li>
                ))}
            </ul>
        </div>
    );
});


// The main widget component that orchestrates the display.
const MatchLineupsWidget = memo(function MatchLineupsWidget({ lineups }: { lineups: any[] }) {
    // If there are no lineups (or not enough data), don't render the widget.
    if (!lineups || lineups.length < 2) {
        return null; 
    }

    const homeLineup = lineups[0];
    const awayLineup = lineups[1];

    // This is the title for the Home Team's accordion, including its logo and name.
    const homeAccordionTitle = (
        <div className="flex items-center gap-3">
            <Image src={homeLineup.team.logo} alt={homeLineup.team.name} width={28} height={28}/>
            <h3 className="font-bold text-lg text-white">
                {homeLineup.team.name} Lineup
            </h3>
        </div>
    );

    // This is the title for the Away Team's accordion.
    const awayAccordionTitle = (
        <div className="flex items-center gap-3">
            <Image src={awayLineup.team.logo} alt={awayLineup.team.name} width={28} height={28}/>
            <h3 className="font-bold text-lg text-white">
                {awayLineup.team.name} Lineup
            </h3>
        </div>
    );

    return (
        // The main container. overflow-hidden is important for the accordion's rounded corners.
        <div className="bg-brand-secondary rounded-xl overflow-hidden">
            
            {/* Accordion for the Home Team */}
            <Accordion 
                title={homeAccordionTitle}
                statusNode={<span className="text-sm font-mono text-text-muted">{homeLineup.formation}</span>}
                defaultOpen={true} // The home team's lineup is open by default.
            >
                <PlayerList title="Starting XI" players={homeLineup.startXI} />
                <PlayerList title="Substitutes" players={homeLineup.substitutes} />
            </Accordion>
            
            {/* Accordion for the Away Team */}
            <Accordion 
                title={awayAccordionTitle}
                statusNode={<span className="text-sm font-mono text-text-muted">{awayLineup.formation}</span>}
                // The away team's lineup is closed by default to save space.
            >
                <PlayerList title="Starting XI" players={awayLineup.startXI} />
                <PlayerList title="Substitutes" players={awayLineup.substitutes} />
            </Accordion>
        </div>
    );
});

export default MatchLineupsWidget;

// ===== src/components/match/MatchPredictionWidget.tsx =====

// src/components/match/MatchPredictionWidget.tsx
"use client";

import { useMemo } from "react";
import { BrainCircuit } from "lucide-react";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";

// --- Type Definitions ---
interface PredictionData {
  home: number;
  draw: number;
  away: number;
}

interface MatchPredictionWidgetProps {
  apiPrediction: any;
  customPrediction: PredictionData | null;
  bookmakerOdds: any[];
  teams: { home: any; away: any };
}

// --- CONFIGURATION: Whitelist of Major Bookmaker IDs ---
const MAJOR_BOOKMAKER_IDS = new Set([1, 2, 6, 8, 9, 24, 31]);

// --- NEW: Sub-component for a single outcome comparison (e.g., Home Win) ---
const OutcomeComparison = ({
  icon,
  label,
  apiValue,
  customValue,
  colorClass,
}: {
  icon: React.ReactNode;
  label: string;
  apiValue?: number;
  customValue?: number;
  colorClass: string;
}) => (
  <div className="space-y-2">
    <div className="flex items-center gap-3">
      {icon}
      <h5 className="font-bold text-white">{label}</h5>
    </div>
    <div className="space-y-1.5 text-xs">
      {/* API Bar */}
      <div className="flex items-center gap-2">
        <span className="w-12 text-brand-muted font-semibold">Others</span>
        <div className="flex-1 bg-gray-700 h-5 rounded-sm overflow-hidden">
          <div
            className={`h-full ${colorClass} opacity-70 transition-all duration-500`}
            style={{ width: `${apiValue || 0}%` }}
          ></div>
        </div>
        <span className="w-8 font-mono text-right text-brand-muted">
          {apiValue ?? "-"}%
        </span>
      </div>
      {/* Fanskor Bar */}
      <div className="flex items-center gap-2">
        <span className="w-12 text-white font-bold">Fanskor</span>
        <div className="flex-1 bg-gray-700 h-5 rounded-sm overflow-hidden">
          <div
            className={`h-full ${colorClass} transition-all duration-500`}
            style={{ width: `${customValue || 0}%` }}
          ></div>
        </div>
        <span className="w-8 font-mono font-bold text-right text-white">
          {customValue ?? "-"}%
        </span>
      </div>
    </div>
  </div>
);

// --- BookmakerOddsRow sub-component (unchanged) ---
const BookmakerOddsRow = ({
  bookmaker,
  bestOdds,
}: {
  bookmaker: any;
  bestOdds: any;
}) => {
  const matchWinnerBet = bookmaker.bets.find((bet: any) => bet.id === 1);
  if (!matchWinnerBet) return null;

  const odds = {
    home:
      matchWinnerBet.values.find((v: any) => v.value === "Home")?.odd || "-",
    draw:
      matchWinnerBet.values.find((v: any) => v.value === "Draw")?.odd || "-",
    away:
      matchWinnerBet.values.find((v: any) => v.value === "Away")?.odd || "-",
  };

  const highlightClass =
    "bg-yellow-500/20 text-brand-yellow ring-1 ring-yellow-500/50";
  const defaultClass = "bg-gray-700/50";

  return (
    <div className="grid grid-cols-4 gap-2 items-center text-sm py-2 border-b border-gray-700/50 last:border-b-0">
      <span className="col-span-1 font-semibold text-brand-light truncate pr-2">
        {bookmaker.name}
      </span>
      <span
        className={`col-span-1 text-center font-mono rounded p-1.5 transition-colors ${
          odds.home === bestOdds.home ? highlightClass : defaultClass
        }`}
      >
        {odds.home}
      </span>
      <span
        className={`col-span-1 text-center font-mono rounded p-1.5 transition-colors ${
          odds.draw === bestOdds.draw ? highlightClass : defaultClass
        }`}
      >
        {odds.draw}
      </span>
      <span
        className={`col-span-1 text-center font-mono rounded p-1.5 transition-colors ${
          odds.away === bestOdds.away ? highlightClass : defaultClass
        }`}
      >
        {odds.away}
      </span>
    </div>
  );
};

export default function MatchPredictionWidget({
  apiPrediction,
  customPrediction,
  bookmakerOdds,
  teams,
}: MatchPredictionWidgetProps) {
  const majorBookmakers = useMemo(() => {
    if (!bookmakerOdds) return [];
    return bookmakerOdds.filter((bookie) => MAJOR_BOOKMAKER_IDS.has(bookie.id));
  }, [bookmakerOdds]);

  const { averageOdds, bestOdds } = useMemo(() => {
    if (!majorBookmakers || majorBookmakers.length === 0) {
      return { averageOdds: null, bestOdds: null };
    }

    let totalHome = 0,
      totalDraw = 0,
      totalAway = 0;
    let maxHome = 0,
      maxDraw = 0,
      maxAway = 0;
    let count = 0;

    majorBookmakers.forEach((bookie) => {
      const bet = bookie.bets.find((b: any) => b.id === 1);
      if (bet) {
        const homeOdd = parseFloat(
          bet.values.find((v: any) => v.value === "Home")?.odd || "0"
        );
        const drawOdd = parseFloat(
          bet.values.find((v: any) => v.value === "Draw")?.odd || "0"
        );
        const awayOdd = parseFloat(
          bet.values.find((v: any) => v.value === "Away")?.odd || "0"
        );

        if (homeOdd > 0 && drawOdd > 0 && awayOdd > 0) {
          totalHome += homeOdd;
          totalDraw += drawOdd;
          totalAway += awayOdd;
          if (homeOdd > maxHome) maxHome = homeOdd;
          if (drawOdd > maxDraw) maxDraw = drawOdd;
          if (awayOdd > maxAway) maxAway = awayOdd;
          count++;
        }
      }
    });

    if (count === 0) return { averageOdds: null, bestOdds: null };

    return {
      averageOdds: {
        home: (totalHome / count).toFixed(2),
        draw: (totalDraw / count).toFixed(2),
        away: (totalAway / count).toFixed(2),
      },
      bestOdds: {
        home: maxHome.toFixed(2),
        draw: maxDraw.toFixed(2),
        away: maxAway.toFixed(2),
      },
    };
  }, [majorBookmakers]);

  const parsedApiPrediction: PredictionData | null = apiPrediction?.predictions
    ?.percent
    ? {
        home: parseInt(apiPrediction.predictions.percent.home.replace("%", "")),
        draw: parseInt(apiPrediction.predictions.percent.draw.replace("%", "")),
        away: parseInt(apiPrediction.predictions.percent.away.replace("%", "")),
      }
    : null;

  return (
    <div className="bg-brand-secondary p-4 rounded-lg">
      <div className="flex items-center gap-2 mb-4">
        <BrainCircuit size={20} className="text-brand-purple" />
        <h3 className="text-lg font-bold text-white">Prediction Comparison</h3>
      </div>

      {/* --- NEW, CLEARER PREDICTION UI --- */}
      <div className="space-y-4">
        <OutcomeComparison
          icon={
            <Image
              src={proxyImageUrl(teams.home.logo)}
              alt={teams.home.name}
              width={24}
              height={24}
            />
          }
          label={`${teams.home.name} Win`}
          apiValue={parsedApiPrediction?.home}
          customValue={customPrediction?.home}
          colorClass="bg-green-500"
        />
        <OutcomeComparison
          icon={
            <div className="w-6 h-6 flex items-center justify-center font-bold text-2xl text-brand-muted">
              =
            </div>
          }
          label="Draw"
          apiValue={parsedApiPrediction?.draw}
          customValue={customPrediction?.draw}
          colorClass="bg-yellow-500"
        />
        <OutcomeComparison
          icon={
            <Image
              src={proxyImageUrl(teams.away.logo)}
              alt={teams.away.name}
              width={24}
              height={24}
            />
          }
          label={`${teams.away.name} Win`}
          apiValue={parsedApiPrediction?.away}
          customValue={customPrediction?.away}
          colorClass="bg-red-500"
        />
      </div>

      {/* Average Market Odds & Bookmaker Comparison Sections */}
      {averageOdds && (
        <div className="mt-4 pt-4 border-t border-gray-700/50">
          <h4 className="font-semibold text-brand-light text-sm mb-2">
            Average Market Odds
          </h4>
          <div className="grid grid-cols-3 gap-2 text-center text-white font-bold">
            <div className="bg-green-500/20 p-2 rounded-md">
              1: {averageOdds.home}
            </div>
            <div className="bg-yellow-500/20 p-2 rounded-md">
              X: {averageOdds.draw}
            </div>
            <div className="bg-red-500/20 p-2 rounded-md">
              2: {averageOdds.away}
            </div>
          </div>
        </div>
      )}

      {majorBookmakers && majorBookmakers.length > 0 && (
        <div className="mt-4 pt-4 border-t border-gray-700/50">
          <h4 className="font-semibold text-brand-light mb-2">
            Compare Major Bookmakers ({majorBookmakers.length})
          </h4>

          <div className="grid grid-cols-4 gap-2 text-xs text-brand-muted font-bold mb-1">
            <span className="col-span-1">Bookmaker</span>
            <span className="col-span-1 text-center">Home (1)</span>
            <span className="col-span-1 text-center">Draw (X)</span>
            <span className="col-span-1 text-center">Away (2)</span>
          </div>

          <div className="space-y-1">
            {majorBookmakers.map((bookie) => (
              <BookmakerOddsRow
                key={bookie.id}
                bookmaker={bookie}
                bestOdds={bestOdds}
              />
            ))}
          </div>
        </div>
      )}
    </div>
  );
}


// ===== src/components/match/MatchStatsWidget.tsx =====

import { memo } from 'react';

// This is the core display logic, kept as a memoized sub-component for cleanliness.
const StatsContent = memo(function StatsContent({ statistics, teams }: { statistics: any[], teams: any }) {
    // Find the statistics for each team. Default to an empty array if not found.
    const homeStats = statistics.find(s => s.team.id === teams.home.id)?.statistics || [];
    const awayStats = statistics.find(s => s.team.id === teams.away.id)?.statistics || [];

    // Create a unique set of all available stat types from both teams.
    // This ensures all stats are displayed even if one team has a stat the other doesn't.
    const allStatTypes = Array.from(new Set([...homeStats.map((s: any) => s.type), ...awayStats.map((s: any) => s.type)]));

    return (
        // The main container for the stats grid. It's a single column on mobile and two columns on desktop.
        <div className="p-4 md:p-6 grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-5">
            {allStatTypes.map(type => {
                // Find the specific stat value for each team, defaulting to '0'.
                const homeStatValue = homeStats.find((s: any) => s.type === type)?.value ?? '0';
                const awayStatValue = awayStats.find((s: any) => s.type === type)?.value ?? '0';
                
                // Convert values to numbers, removing '%' if present, for calculating the progress bar width.
                const homeValueNum = parseFloat(String(homeStatValue).replace('%', ''));
                const awayValueNum = parseFloat(String(awayStatValue).replace('%', ''));
                const total = homeValueNum + awayValueNum;
                
                // Calculate the percentage width for the home team's bar.
                const homePercent = total > 0 ? (homeValueNum / total) * 100 : 50;

                return (
                    <div key={type}>
                        {/* Header for each stat (e.g., "5  Ball Possession  95") */}
                        <div className="flex justify-between items-center mb-1.5 text-sm font-semibold">
                            <span className="text-white w-1/4 text-left">{homeStatValue}</span>
                            <span className="text-text-muted w-1/2 text-center">{type}</span>
                            <span className="text-white w-1/4 text-right">{awayStatValue}</span>
                        </div>
                        {/* The visual progress bar */}
                        <div className="flex w-full h-2 rounded-full" style={{ backgroundColor: 'var(--color-secondary)' }}>
                            <div className="bg-brand-purple rounded-l-full" style={{ width: `${homePercent}%` }}></div>
                            <div className="bg-brand-highlight rounded-r-full" style={{ width: `${100 - homePercent}%` }}></div>
                        </div>
                    </div>
                );
            })}
        </div>
    );
});


// This is the main exported widget component.
const MatchStatsWidget = memo(function MatchStatsWidget({ statistics, teams }: { statistics: any[], teams: any }) {
    // If there are no stats for one of the teams, don't render the widget at all.
    if (!statistics || statistics.length < 2) {
        return null;
    }
    
    return (
        <div className="bg-brand-secondary rounded-xl">
            <h3 className="text-lg font-bold p-4 border-b border-gray-700/50">
                Team Statistics
            </h3>
            <StatsContent statistics={statistics} teams={teams} />
        </div>
    );
});

export default MatchStatsWidget;

// ===== src/components/match/MatchStatusBanner.tsx =====

"use client";

import { memo } from 'react';
import { format } from 'date-fns';

interface MatchStatusBannerProps {
  fixture: any;
}

// This component displays a colored banner with the match's current status.
const MatchStatusBanner = memo(function MatchStatusBanner({ fixture }: MatchStatusBannerProps) {
    const status = fixture.fixture.status;
    
    // Determine the text and background color based on the status code
    let content = <p>{status.long}</p>;
    let bgClass = 'bg-gray-600'; // Default for statuses like 'Postponed'

    switch (status.short) {
        case 'TBD':
        case 'NS':
            content = <p>Upcoming - {format(new Date(fixture.fixture.date), 'HH:mm')}</p>;
            bgClass = 'bg-blue-600';
            break;
        case '1H':
        case 'HT':
        case '2H':
        case 'ET':
        case 'P':
            content = <p className="animate-pulse">{status.elapsed}' - {status.long}</p>;
            bgClass = 'bg-red-600';
            break;
        case 'FT':
        case 'AET':
        case 'PEN':
            content = <p>Full Time</p>;
            bgClass = 'bg-gray-800';
            break;
    }

    return (
        <div className={`text-center font-bold text-white py-2 rounded-b-xl text-sm tracking-wider mb-8 ${bgClass}`}>
            {content}
        </div>
    );
});

export default MatchStatusBanner;

// ===== src/components/match/TeamFormWidget.tsx =====

// src/components/match/TeamFormWidget.tsx
"use client";

import { TrendingUp, Shield, BarChart2 } from "lucide-react";
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";

interface TeamFormWidgetProps {
  teamStats: any; // e.g., homeTeamStats or awayTeamStats from the API
  team: any; // The basic team object { id, name, logo }
  location: "Home" | "Away";
}

// --- Reusable Sub-component for a single stat row ---
const StatRow = ({
  label,
  value,
  highlight = false,
}: {
  label: string;
  value: string | number;
  highlight?: boolean;
}) => (
  <div className="flex justify-between items-center text-sm py-1.5">
    <span className="text-brand-muted">{label}</span>
    <span
      className={`font-bold ${highlight ? "text-brand-purple" : "text-white"}`}
    >
      {value}
    </span>
  </div>
);

// --- Reusable Sub-component for the W/D/L form display ---
const FormPill = ({ result }: { result: "W" | "D" | "L" }) => {
  const styles = {
    W: "bg-green-500/80 text-white",
    D: "bg-yellow-500/80 text-white",
    L: "bg-red-500/80 text-white",
  };
  return (
    <div
      className={`w-6 h-6 flex items-center justify-center rounded-full font-bold text-xs ${styles[result]}`}
    >
      {result}
    </div>
  );
};

export default function TeamFormWidget({
  teamStats,
  team,
  location,
}: TeamFormWidgetProps) {
  // Don't render if we don't have the necessary stats
  if (!teamStats || !teamStats.form) {
    return (
      <div className="bg-brand-secondary p-4 rounded-lg">
        <h3 className="text-lg font-bold text-white mb-2">
          Form & Stats ({location})
        </h3>
        <p className="text-sm text-brand-muted text-center py-4">
          Detailed stats not available for this team.
        </p>
      </div>
    );
  }

  const formArray = teamStats.form.slice(-10).split(""); // Get last 10 results
  const goalsFor = teamStats.goals.for.total.total;
  const goalsAgainst = teamStats.goals.against.total.total;

  return (
    <div className="bg-brand-secondary p-4 rounded-lg space-y-4">
      {/* Header */}
      <div className="flex items-center gap-3">
        <Image
          src={proxyImageUrl(team.logo)}
          alt={team.name}
          width={40}
          height={40}
        />
        <div>
          <p className="text-xs text-brand-muted">{location} Team</p>
          <h3 className="text-lg font-bold text-white">{team.name}</h3>
        </div>
      </div>

      {/* Form Section */}
      <div>
        <h4 className="font-semibold text-brand-light mb-2 flex items-center gap-2">
          <TrendingUp size={16} /> Recent Form (Last {formArray.length})
        </h4>
        <div className="flex items-center gap-1.5">
          {formArray.map((result: "W" | "D" | "L", index: number) => (
            <FormPill key={index} result={result} />
          ))}
        </div>
      </div>

      {/* Stats Section */}
      <div>
        <h4 className="font-semibold text-brand-light mb-1 flex items-center gap-2">
          <BarChart2 size={16} /> Performance
        </h4>
        <div className="bg-gray-800/50 p-2 rounded-md">
          <StatRow
            label="Matches Played"
            value={`${teamStats.fixtures.played.home} (H) / ${teamStats.fixtures.played.away} (A)`}
          />
          <StatRow
            label="Wins"
            value={`${teamStats.fixtures.wins.home} (H) / ${teamStats.fixtures.wins.away} (A)`}
          />
          <StatRow
            label="Draws"
            value={`${teamStats.fixtures.draws.home} (H) / ${teamStats.fixtures.draws.away} (A)`}
          />
          <StatRow
            label="Losses"
            value={`${teamStats.fixtures.loses.home} (H) / ${teamStats.fixtures.loses.away} (A)`}
          />
        </div>
      </div>

      {/* Goals Section */}
      <div>
        <h4 className="font-semibold text-brand-light mb-1 flex items-center gap-2">
          <Shield size={16} /> Goal Analysis
        </h4>
        <div className="bg-gray-800/50 p-2 rounded-md">
          <StatRow label="Goals For" value={goalsFor} highlight />
          <StatRow label="Goals Against" value={goalsAgainst} />
          <StatRow
            label="Avg. Scored"
            value={teamStats.goals.for.average.total}
          />
          <StatRow
            label="Avg. Conceded"
            value={teamStats.goals.against.average.total}
          />
        </div>
      </div>
    </div>
  );
}


// ===== src/components/match/TeamStandingsWidget.tsx =====

// src/components/match/TeamStandingsWidget.tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { useMemo } from "react";
import Image from "next/image";
import { ChevronRight, Trophy } from "lucide-react";
import Link from "next/link";
import { generateLeagueSlug } from "@/lib/generate-league-slug"; // Assuming this is used
import { generateTeamSlug } from "@/lib/generate-team-slug";

// Type definitions (ensure they are comprehensive or align with your API response)
interface TeamStanding {
  rank: number;
  team: { id: number; name: string; logo: string };
  points: number;
  goalsDiff: number;
  all: { played: number; win: number; draw: number; lose: number };
  description: string | null;
  group: string; // Group name for group stage standings
}

interface LeagueInfo {
  id: number;
  name: string;
  logo: string;
  type: string;
  href: string; // The generated slug
}

interface StandingsResponse {
  league: LeagueInfo | null;
  standings: TeamStanding[][]; // Array of arrays for multiple groups/stages
}

interface TeamStandingsWidgetProps {
  leagueId: number;
  season: number;
  homeTeamId: number;
  awayTeamId: number;
  standingsSeoDescription: string; // <-- NEW PROP
}

const fetchStandings = async (
  leagueId: number,
  season: number
): Promise<StandingsResponse> => {
  const { data } = await axios.get(
    `/api/standings?league=${leagueId}&season=${season}`
  );
  return data;
};

export default function TeamStandingsWidget({
  leagueId,
  season,
  homeTeamId,
  awayTeamId,
  standingsSeoDescription, // <-- NEW PROP
}: TeamStandingsWidgetProps) {
  const {
    data: standingsData,
    isLoading,
    isError,
  } = useQuery<StandingsResponse>({
    queryKey: ["standings", leagueId, season],
    queryFn: () => fetchStandings(leagueId, season),
    enabled: !!leagueId && !!season,
    staleTime: 1000 * 60 * 5, // Cache for 5 minutes
  });

  const allStandings = useMemo(() => {
    // Flatten the array of arrays into a single list of standings,
    // assuming there's only one relevant group or we want to show all.
    // In many cases, it's just standings[0] for a league.
    return standingsData?.standings ? standingsData.standings.flat() : [];
  }, [standingsData]);

  // Find the ranks of the home and away teams in the flattened standings
  const homeTeamRank = useMemo(() => {
    return allStandings.find((s) => s.team.id === homeTeamId);
  }, [allStandings, homeTeamId]);

  const awayTeamRank = useMemo(() => {
    return allStandings.find((s) => s.team.id === awayTeamId);
  }, [allStandings, awayTeamId]);

  // Display only the teams involved in the match and a few surrounding teams for context
  const relevantStandings = useMemo(() => {
    if (!homeTeamRank || !awayTeamRank) return [];

    const ranksToShow = new Set<number>();
    ranksToShow.add(homeTeamRank.rank);
    ranksToShow.add(awayTeamRank.rank);

    // Also include teams directly above/below for context, up to 5 total
    const sortedRanks = Array.from(ranksToShow).sort((a, b) => a - b);
    const minRank = Math.max(1, sortedRanks[0] - 2); // At least rank 1
    const maxRank = sortedRanks[sortedRanks.length - 1] + 2;

    const filteredAndSorted = allStandings
      .filter((s) => s.rank >= minRank && s.rank <= maxRank)
      .sort((a, b) => a.rank - b.rank)
      .slice(0, 5); // Limit to max 5 entries

    // Ensure both home and away teams are definitely in the list, even if outside the narrow range
    if (!filteredAndSorted.some((s) => s.team.id === homeTeamId)) {
      filteredAndSorted.push(homeTeamRank);
    }
    if (!filteredAndSorted.some((s) => s.team.id === awayTeamId)) {
      filteredAndSorted.push(awayTeamRank);
    }
    // Re-sort and de-duplicate after potentially adding
    return Array.from(new Set(filteredAndSorted)).sort(
      (a, b) => a.rank - b.rank
    );
  }, [homeTeamRank, awayTeamRank, allStandings, homeTeamId, awayTeamId]);

  if (isLoading)
    return (
      <div className="bg-brand-dark rounded-lg p-6 shadow-lg animate-pulse">
        <div className="h-6 w-3/4 bg-gray-700 rounded mb-4"></div>
        <div className="h-4 w-1/2 bg-gray-600 rounded mb-4"></div>
        <div className="space-y-2">
          <div className="h-8 bg-gray-700 rounded"></div>
          <div className="h-8 bg-gray-700 rounded"></div>
          <div className="h-8 bg-gray-700 rounded"></div>
        </div>
      </div>
    );
  if (isError)
    return (
      <div className="bg-brand-dark rounded-lg p-6 text-red-400">
        Failed to load standings.
      </div>
    );
  if (!standingsData?.league)
    return (
      <div className="bg-brand-secondary rounded-lg p-6 text-brand-muted">
        No standings available for this league.
      </div>
    );

  const league = standingsData.league;

  return (
    <div className="bg-brand-secondary rounded-lg shadow-lg overflow-hidden">
      <div className="p-6">
        <h2 className="text-2xl font-bold text-white mb-4">League Standings</h2>
        <Link
          href={league.href}
          className="flex items-center gap-3 mb-6 hover:text-white transition-colors"
        >
          <Image src={league.logo} alt={league.name} width={30} height={30} />
          <span className="text-xl font-semibold">{league.name}</span>
          <ChevronRight size={20} className="text-brand-muted" />
        </Link>

        {/* --- Standings SEO Optimization Text --- */}
        <p className="italic text-[#a3a3a3] leading-relaxed mb-6 ">
          {standingsSeoDescription}
        </p>

        <div className="overflow-x-auto">
          <table className="w-full text-left text-brand-light text-sm">
            <thead className="bg-gray-800/50 text-xs text-brand-muted uppercase">
              <tr>
                <th className="p-3">#</th>
                <th className="p-3">Takım</th>
                <th className="p-3">O</th>
                <th className="p-3">G</th>
                <th className="p-3">B</th>
                <th className="p-3">M</th>
                <th className="p-3">Av.</th>
                <th className="p-3">P</th>
              </tr>
            </thead>
            <tbody>
              {relevantStandings.map((teamStanding) => (
                <tr
                  key={teamStanding.team.id}
                  className={`border-t border-gray-700/50 ${
                    teamStanding.team.id === homeTeamId ||
                    teamStanding.team.id === awayTeamId
                      ? "bg-brand-dark font-bold" // Highlight current match teams
                      : ""
                  }`}
                >
                  <td className="p-3">{teamStanding.rank}</td>
                  <td className="p-3 flex items-center gap-2">
                    <Image
                      src={teamStanding.team.logo}
                      alt={teamStanding.team.name}
                      width={20}
                      height={20}
                      className="w-5 h-5 object-contain"
                    />
                    <Link
                      href={generateTeamSlug(
                        teamStanding.team.name,
                        teamStanding.team.id
                      )}
                      className="hover:text-white"
                    >
                      {teamStanding.team.name}
                    </Link>
                  </td>
                  <td className="p-3">{teamStanding.all.played}</td>
                  <td className="p-3">{teamStanding.all.win}</td>
                  <td className="p-3">{teamStanding.all.draw}</td>
                  <td className="p-3">{teamStanding.all.lose}</td>
                  <td className="p-3">{teamStanding.goalsDiff}</td>
                  <td className="p-3">{teamStanding.points}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
}


// ===== src/components/match/WinProbability.tsx =====

"use client";
import { memo } from 'react';
import { CircularProgressbar, buildStyles } from 'react-circular-progressbar';
import 'react-circular-progressbar/dist/styles.css';

const WinProbability = memo(function WinProbability({ home, draw, away }: { home: number, draw: number, away: number }) {
    const homeColor = '#8B5CF6'; // purple-500
    const awayColor = '#3B82F6'; // blue-500
    
    return (
        <div className="w-32 h-32 relative">
            <div className="absolute inset-0 transform scale-75">
                <CircularProgressbar
                    value={away}
                    styles={buildStyles({
                        pathColor: awayColor,
                        trailColor: 'transparent',
                        pathTransitionDuration: 0.5,
                    })}
                />
            </div>
            <CircularProgressbar
                value={home + draw}
                counterClockwise
                styles={buildStyles({
                    pathColor: homeColor,
                    trailColor: 'transparent',
                    pathTransitionDuration: 0.5,
                })}
            />
            <div className="absolute inset-0 flex flex-col items-center justify-center">
                <p className="text-xs text-brand-muted">DRAW</p>
                <p className="font-black text-2xl text-white">{draw}%</p>
            </div>
        </div>
    );
});
export default WinProbability;

// ===== src/components/MatchDateNavigator.tsx =====

// src/components/MatchDateNavigator.tsx
"use client";

import { useState, useRef, useEffect } from "react";
import { format, addDays, subDays, isToday } from "date-fns";
import { DayPicker } from "react-day-picker";
import "react-day-picker/dist/style.css";
import {
  Calendar as CalendarIcon,
  ChevronLeft,
  ChevronRight,
} from "lucide-react";
import { useTranslation } from "@/hooks/useTranslation";

interface DateNavigatorProps {
  selectedDate: Date;
  onDateChange: (date: Date) => void;
}

export default function MatchDateNavigator({
  selectedDate,
  onDateChange,
}: DateNavigatorProps) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const { t } = useTranslation();

  // --- ENHANCEMENT: Still handles closing the popover on outside clicks ---
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const handleDaySelect = (date: Date | undefined) => {
    if (date) {
      onDateChange(date);
      setIsOpen(false);
    }
  };

  const handleTodayClick = () => {
    onDateChange(new Date());
    setIsOpen(false);
  };

  return (
    // --- The outer container now includes the dropdownRef ---
    <div className="relative w-full" ref={dropdownRef}>
      {/* --- ENHANCEMENT: Redesigned navigator bar for better UX --- */}
      <div className="flex items-center justify-between rounded-lg p-2 bg-brand-secondary">
        {/* --- NEW: "Today" button for quick navigation --- */}
        <button
          onClick={handleTodayClick}
          disabled={isToday(selectedDate)}
          className="px-4 py-2 text-sm font-semibold text-white rounded-md hover:bg-brand-purple/80 transition-colors disabled:opacity-50 disabled:hover:bg-transparent"
          aria-label="Go to today's date"
        >
          {t("today")}
        </button>

        {/* --- ENHANCEMENT: Centered date controls --- */}
        <div className="flex items-center gap-2">
          <button
            onClick={() => onDateChange(subDays(selectedDate, 1))}
            className="p-2 transition-colors hover:bg-gray-700/50 rounded-full"
            aria-label="Previous day"
          >
            <ChevronLeft size={20} />
          </button>

          <button
            onClick={() => setIsOpen(!isOpen)}
            className="flex items-center gap-2 px-4 py-2 rounded-md hover:bg-gray-700/50 transition-colors"
            aria-expanded={isOpen}
          >
            <CalendarIcon size={18} className="text-text-muted" />
            <span className="font-bold text-lg text-white">
              {format(selectedDate, "d MMMM")}
            </span>
          </button>

          <button
            onClick={() => onDateChange(addDays(selectedDate, 1))}
            className="p-2 transition-colors hover:bg-gray-700/50 rounded-full"
            aria-label="Next day"
          >
            <ChevronRight size={20} />
          </button>
        </div>
        {/* Placeholder to balance the flex layout */}
        <div className="w-[84px]"></div>
      </div>

      {/* 
        --- THE FIX & ENHANCEMENT: The Calendar Popup ---
        - Now has a solid background, border, and shadow.
        - Uses transition classes for a smooth fade-in/slide-in effect.
      */}
      <div
        className={`absolute top-full right-0 mt-2 bg-brand-secondary border border-gray-700/50 rounded-lg shadow-2xl z-20 
                   transition-all duration-200 ease-out
                   ${
                     isOpen
                       ? "opacity-100 translate-y-0"
                       : "opacity-0 -translate-y-2 pointer-events-none"
                   }`}
      >
        <DayPicker
          mode="single"
          selected={selectedDate}
          onSelect={handleDaySelect}
          initialFocus
          // --- ENHANCEMENT: Refined classNames for better visual style ---
          classNames={{
            root: "p-3",
            caption: "flex justify-between items-center mb-4",
            caption_label: "text-base font-bold text-white",
            nav_button:
              "h-8 w-8 flex items-center justify-center rounded-full hover:bg-gray-700 transition-colors",
            head_row: "flex",
            head_cell:
              "w-10 h-10 flex items-center justify-center font-semibold text-brand-muted text-sm",
            row: "flex w-full mt-2",
            cell: "flex items-center justify-center",
            day: "h-10 w-10 text-white rounded-full hover:bg-brand-purple/60 transition-colors cursor-pointer",
            day_selected:
              "bg-brand-purple text-white font-bold hover:bg-brand-purple",
            day_today:
              "ring-2 ring-brand-purple ring-offset-2 ring-offset-brand-secondary", // Today gets a distinct ring
            day_outside: "text-brand-muted/40 cursor-default",
            day_disabled: "text-brand-muted/40 cursor-not-allowed",
          }}
        />
      </div>
    </div>
  );
}


// ===== src/components/MatchList.tsx =====

"use client";

import { useEffect, useMemo, useState, Dispatch, SetStateAction } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { useLeagueContext } from "@/context/LeagueContext";
import { useTranslation } from "@/hooks/useTranslation";
import { League } from "@/types/api-football";
import MatchListItem, { MatchListItemSkeleton } from "./MatchListItem";
import MatchDateNavigator from "./MatchDateNavigator";
import { Globe, ChevronsDown } from "lucide-react";
import { format } from "date-fns";

type StatusFilter = "all" | "live" | "finished" | "scheduled";
const STATUS_MAP: Record<StatusFilter, string[]> = {
  all: [],
  live: ["1H", "HT", "2H", "ET", "P", "LIVE"],
  finished: ["FT", "AET", "PEN"],
  scheduled: ["NS", "TBD", "PST"],
};
const INITIAL_MATCHES_TO_SHOW = 3;
const MATCHES_PER_PAGE = 5;

const fetchAllMatches = async (
  leagueId: number | null,
  date: Date
): Promise<any[]> => {
  const dateString = format(date, "yyyy-MM-dd");
  const url = leagueId
    ? `/api/fixtures?league=${leagueId}&date=${dateString}`
    : `/api/fixtures?date=${dateString}`;
  const { data } = await axios.get(url);
  return data;
};

const fetchGlobalLiveMatches = async (): Promise<any[]> => {
  const { data } = await axios.get("/api/global-live");
  return data;
};

const LeagueGroupHeader = ({
  league,
}: {
  league: { name: string; logo: string; country: string; flag: string | null };
}) => (
  <div
    className="flex items-center gap-3 p-3 sticky top-0 z-10"
    style={{ backgroundColor: "var(--color-primary)" }}
  >
    <div className="w-[28px] h-[28px] flex items-center justify-center">
      {league.country === "World" ? (
        <Globe size={24} className="text-text-muted" />
      ) : (
        <Image
          src={league.flag || "/default-flag.png"}
          alt={league.country}
          width={28}
          height={28}
          className="rounded-full object-cover"
        />
      )}
    </div>
    <div>
      <h3 className="font-bold text-base text-white">{league.country}</h3>
      <p className="text-sm text-text-muted">{league.name}</p>
    </div>
  </div>
);

const TabButton = ({
  label,
  isActive,
  liveCount,
  onClick,
  hasLiveIndicator,
}: {
  label: string;
  isActive: boolean;
  liveCount?: number;
  onClick: () => void;
  hasLiveIndicator?: boolean;
}) => (
  <button
    onClick={onClick}
    className={`relative flex-1 md:flex-none flex items-center justify-center gap-2 px-3 md:px-4 py-2.5 rounded-lg text-xs md:text-sm font-bold transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-brand-purple/50 ${
      isActive
        ? "bg-brand-purple text-white shadow-lg"
        : "bg-transparent text-text-muted hover:text-white"
    }`}
  >
    {hasLiveIndicator && (
      <span className="relative flex h-3 w-3">
        <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span>
        <span className="relative inline-flex rounded-full h-3 w-3 bg-brand-live"></span>
      </span>
    )}
    {label}
    {liveCount && liveCount > 0 && (
      <span className="ml-1 flex items-center justify-center text-[10px] font-bold text-white bg-brand-live rounded-full h-4 w-4">
        {liveCount}
      </span>
    )}
  </button>
);

export default function MatchList({
  setLiveLeagues,
}: {
  setLiveLeagues: Dispatch<SetStateAction<League[]>>;
}) {
  const { selectedLeague } = useLeagueContext();
  const { t } = useTranslation();
  const [activeStatusFilter, setActiveStatusFilter] =
    useState<StatusFilter>("all");
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [visibleMatchCounts, setVisibleMatchCounts] = useState<
    Record<string, number>
  >({});

  // Query for matches based on selected date (for 'all', 'finished', 'scheduled' tabs)
  const {
    data: allMatches,
    isLoading,
    error,
  } = useQuery({
    queryKey: [
      "allMatches",
      selectedLeague?.id || "global",
      format(selectedDate, "yyyy-MM-dd"),
    ],
    queryFn: () => fetchAllMatches(selectedLeague?.id || null, selectedDate),
    // This query should NOT run when the 'live' tab is active
    enabled: activeStatusFilter !== "live",
    refetchInterval: 30000,
  });

  // +++ START: ADDED NEW DEDICATED QUERY FOR THE LIVE MATCH LIST
  // Query for live matches (only runs when 'live' tab is active)
  const { data: liveMatchesData, isLoading: isLoadingLive } = useQuery({
    queryKey: ["globalLiveMatchesList"],
    queryFn: fetchGlobalLiveMatches,
    // This is the key: only enable this query when the user wants to see live matches.
    enabled: activeStatusFilter === "live",
    refetchInterval: 30000,
  });
  // +++ END: ADDED NEW DEDICATED QUERY FOR THE LIVE MATCH LIST

  // Query for the global live match count (for the badge on the tab)
  const { data: globalLiveCount } = useQuery({
    queryKey: ["globalLiveCount"],
    queryFn: fetchGlobalLiveMatches,
    select: (data) => data.length,
    refetchInterval: 30000,
    staleTime: 25000,
  });

  useEffect(() => {
    setVisibleMatchCounts({});
  }, [selectedDate, activeStatusFilter]);

  const groupedMatches = useMemo(() => {
    // Determine the source of matches based on the active tab
    const matchesToProcess =
      activeStatusFilter === "live" ? liveMatchesData : allMatches;

    if (!matchesToProcess) return [];

    const statusFilter = STATUS_MAP[activeStatusFilter];
    const matchesToGroup =
      statusFilter.length > 0
        ? matchesToProcess.filter((m) =>
            statusFilter.includes(m.fixture.status.short)
          )
        : matchesToProcess;

    matchesToGroup.sort((a, b) => {
      const aIsLive = STATUS_MAP.live.includes(a.fixture.status.short);
      const bIsLive = STATUS_MAP.live.includes(b.fixture.status.short);

      if (aIsLive && !bIsLive) return -1;

      if (!aIsLive && bIsLive) return 1;

      // For live matches, sort by country and league name
      if (activeStatusFilter === "live") {
        const countryComparison = a.league.country.localeCompare(
          b.league.country
        );
        if (countryComparison !== 0) return countryComparison;
        return a.league.name.localeCompare(b.league.name);
      }

      return (
        new Date(a.fixture.date).getTime() - new Date(b.fixture.date).getTime()
      );
    });

    return matchesToGroup.reduce((acc, match) => {
      const leagueId = match.league.id;
      if (!acc[leagueId])
        acc[leagueId] = { leagueInfo: match.league, matches: [] };
      acc[leagueId].matches.push(match);
      return acc;
    }, {} as Record<string, { leagueInfo: any; matches: any[] }>);
  }, [allMatches, liveMatchesData, activeStatusFilter]); // ++ UPDATED dependencies

  useEffect(() => {
    if (allMatches) {
      const live = allMatches.filter((m) =>
        STATUS_MAP.live.includes(m.fixture.status.short)
      );
      const uniqueLeagues = Array.from(
        new Map(live.map((m) => [m.league.id, m.league])).values()
      ).map((l) => ({
        id: l.id,
        name: l.name,
        logoUrl: l.logo,
        countryName: l.country,
        countryFlagUrl: l.flag,
        type: l.type,
        href: "",
      }));
      setLiveLeagues(uniqueLeagues);
    }
  }, [allMatches, setLiveLeagues]);

  const handleLoadMore = (leagueId: number) => {
    setVisibleMatchCounts((prevCounts) => ({
      ...prevCounts,
      [leagueId]:
        (prevCounts[leagueId] || INITIAL_MATCHES_TO_SHOW) + MATCHES_PER_PAGE,
    }));
  };

  if (error)
    return (
      <div className="text-center py-10 bg-primary rounded-xl">
        Could not load match data.
      </div>
    );

  const tabButtons: { key: StatusFilter; label: string }[] = [
    { key: "all", label: "All" },
    { key: "live", label: "Live" },
    { key: "finished", label: "Finished" },
    { key: "scheduled", label: "Scheduled" },
  ];

  // ++ UPDATED loading state check
  const isCurrentlyLoading =
    (isLoading && activeStatusFilter !== "live") ||
    (isLoadingLive && activeStatusFilter === "live");

  return (
    <div className="space-y-4">
      {}
      <div
        className="flex flex-col gap-3 p-2 rounded-xl"
        style={{ backgroundColor: "var(--color-primary)" }}
      >
        {}
        <div className="flex justify-center">
          <MatchDateNavigator
            selectedDate={selectedDate}
            onDateChange={setSelectedDate}
          />
        </div>

        {}
        <div
          className="flex items-center gap-1 p-1 rounded-xl w-full"
          style={{ backgroundColor: "var(--color-secondary)" }}
        >
          {tabButtons.map((tab) => (
            <TabButton
              key={tab.key}
              label={tab.label}
              isActive={activeStatusFilter === tab.key}
              liveCount={tab.key === "live" ? globalLiveCount : undefined}
              hasLiveIndicator={
                tab.key === "live" && (globalLiveCount ?? 0) > 0
              }
              onClick={() => setActiveStatusFilter(tab.key)}
            />
          ))}
        </div>
      </div>

      {}
      <div className="space-y-4">
        {isCurrentlyLoading ? ( // ++ UPDATED loading state check
          <div
            style={{ backgroundColor: "var(--color-primary)" }}
            className="rounded-lg p-2 space-y-2"
          >
            {Array.from({ length: 10 }).map((_, i) => (
              <MatchListItemSkeleton key={i} />
            ))}
          </div>
        ) : Object.keys(groupedMatches).length > 0 ? (
          Object.values(groupedMatches).map(({ leagueInfo, matches }: any) => {
            const visibleCount =
              visibleMatchCounts[leagueInfo.id] || INITIAL_MATCHES_TO_SHOW;
            const remainingMatches = matches.length - visibleCount;
            const hasMore = remainingMatches > 0;

            return (
              <div
                key={leagueInfo.id}
                style={{ backgroundColor: "var(--color-primary)" }}
                className="rounded-lg overflow-hidden"
              >
                <LeagueGroupHeader league={leagueInfo} />
                <div className="p-2 space-y-2">
                  {matches.slice(0, visibleCount).map((match: any) => (
                    <MatchListItem key={match.fixture.id} match={match} />
                  ))}
                  {hasMore && (
                    <button
                      onClick={() => handleLoadMore(leagueInfo.id)}
                      className="w-full flex items-center justify-center gap-2 text-sm font-semibold text-text-muted p-3 rounded-lg transition-colors hover:text-white"
                      style={{ backgroundColor: "var(--color-secondary)" }}
                    >
                      <ChevronsDown size={16} />
                      Show {Math.min(MATCHES_PER_PAGE, remainingMatches)} more
                      matches
                    </button>
                  )}
                </div>
              </div>
            );
          })
        ) : (
          <div
            className="text-center py-20 rounded-lg"
            style={{ backgroundColor: "var(--color-primary)" }}
          >
            <p className="text-white font-semibold capitalize">
              No Matches Found
            </p>
            {/* ++ UPDATED "No matches" message */}
            <p className="text-sm text-text-muted mt-1">
              {activeStatusFilter === "live"
                ? "There are no matches currently live."
                : `There are no ${
                    activeStatusFilter !== "all" ? activeStatusFilter : ""
                  } matches for the selected date.`}
            </p>
          </div>
        )}
      </div>
    </div>
  );
}


// ===== src/components/MatchListItem.tsx =====

// src/components/MatchListItem.tsx
import DesktopMatchListItem, {
  MatchListItemSkeleton as DesktopSkeleton,
} from "./DesktopMatchListItem";
import MobileMatchListItem, {
  MobileMatchListItemSkeleton as MobileSkeleton,
} from "./MobileMatchListItem";

// Define a type for the odds object for better type safety
type Odds =
  | {
      home: string;
      draw: string;
      away: string;
    }
  | undefined;

// Define the props for the component, including the new optional liveOdds
interface MatchListItemProps {
  match: any;
  liveOdds?: Odds;
  customOdds?: Odds;
}

// This component acts as a router, displaying the correct list item
// based on the screen size and passing all necessary props down.
export default function MatchListItem({
  match,
  liveOdds,
  customOdds,
}: MatchListItemProps) {
  // --- THIS IS THE FIX ---
  // 1. Centralize the "isLive" logic here.
  const status = match.fixture.status.short;
  const isLive = ["1H", "HT", "2H", "ET", "BT", "P", "LIVE"].includes(status);

  return (
    <>
      {/* Desktop version (now receives customOdds) */}
      <div className="hidden lg:block">
        <DesktopMatchListItem
          match={match}
          liveOdds={liveOdds}
          isLive={isLive}
          customOdds={customOdds}
        />
      </div>

      {/* Mobile version (now receives customOdds) */}
      <div className="block lg:hidden">
        <MobileMatchListItem
          match={match}
          liveOdds={liveOdds}
          isLive={isLive}
          customOdds={customOdds}
        />
      </div>
    </>
  );
}

// This component routes to the correct skeleton. No changes are needed here.
export const MatchListItemSkeleton = () => {
  return (
    <>
      <div className="hidden lg:block">
        <DesktopSkeleton />
      </div>
      <div className="block lg:hidden">
        <MobileSkeleton />
      </div>
    </>
  );
};


// ===== src/components/MatchSlide.tsx =====

import Image from 'next/image';
import { format } from 'date-fns';
import { Calendar, MapPin } from 'lucide-react';

interface MatchSlideProps {
  match: any; // Use a more specific type if you have one
}

export default function MatchSlide({ match }: MatchSlideProps) {
  const { teams, fixture, league } = match;

  return (
    <div className="relative w-full h-64 overflow-hidden rounded-2xl bg-brand-secondary text-white">
      {/* Background Image & Overlay */}
      <Image
        // Use a generic, high-quality background image
        src="https://images.unsplash.com/photo-1579952363873-27f3bade9f55?q=80&w=1935&auto=format&fit=crop"
        alt="Stadium background"
        layout="fill"
        objectFit="cover"
        className="z-0"
      />
      <div className="absolute inset-0 bg-black/70 z-10" />

      {/* Content */}
      <div className="relative z-20 flex h-full flex-col items-center justify-center p-4">
        <p className="font-semibold tracking-wider text-brand-muted">Upcoming Match</p>
        <p className="text-sm text-brand-muted mb-4">{league.round}</p>
        
        <div className="flex items-center justify-around w-full max-w-lg my-2">
          {/* Home Team */}
          <div className="flex items-center gap-3">
            <Image src={teams.home.logo} alt={teams.home.name} width={40} height={40}/>
            <h2 className="text-3xl sm:text-4xl font-black">{teams.home.name}</h2>
          </div>
          
          <span className="text-xl font-light text-brand-muted mx-4">VS</span>
          
          {/* Away Team */}
          <div className="flex items-center gap-3">
            <h2 className="text-3xl sm:text-4xl font-black">{teams.away.name}</h2>
            <Image src={teams.away.logo} alt={teams.away.name} width={40} height={40}/>
          </div>
        </div>

        <div className="mt-6 flex flex-col sm:flex-row items-center gap-x-6 gap-y-2 text-brand-muted">
          <div className="flex items-center gap-2">
            <Calendar size={16} />
            <span>{format(new Date(fixture.date), "dd MMMM yyyy ⋅ h:mma")}</span>
          </div>
          <div className="flex items-center gap-2">
            <MapPin size={16} />
            <span>{fixture.venue.name}</span>
          </div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/MobileHomeTabs.tsx =====

"use client";

import { useState, Dispatch, SetStateAction } from "react";
// Import BrainCircuit for Analytics icon
import { List, Newspaper, BrainCircuit, Compass } from "lucide-react";
import { League } from "@/types/api-football";

// Import the content components
import MatchList from "./MatchList";
import NewsSection from "./NewsSection";
import ExploreTab from "./ExploreTab";

// Define the NEW tabs we want to show
const TABS = [
  { id: "matches", label: "Matches", icon: List },
  { id: "explore", label: "Explore", icon: Compass },
  { id: "news", label: "News", icon: Newspaper },
];

interface MobileHomeTabsProps {
  liveLeagues: League[];
  setLiveLeagues: Dispatch<SetStateAction<League[]>>;
}

export default function MobileHomeTabs({
  liveLeagues,
  setLiveLeagues,
}: MobileHomeTabsProps) {
  const [activeTab, setActiveTab] = useState("matches");

  return (
    <div className="flex flex-col h-full">
      <div className="flex-grow p-2 sm:p-4 space-y-8 overflow-y-auto">
        {activeTab === "matches" && (
          <MatchList setLiveLeagues={setLiveLeagues} />
        )}
        {activeTab === "explore" && <ExploreTab />}
        {activeTab === "news" && <NewsSection />}
      </div>

      <div className="sticky bottom-0 left-0 right-0 bg-brand-secondary border-t border-gray-700/50 shadow-lg z-999999">
        <div className="flex justify-around items-center h-16">
          {TABS.map((tab) => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id)}
              className={`flex flex-col items-center justify-center gap-1 w-full h-full transition-colors duration-200 ${
                activeTab === tab.id
                  ? "text-brand-purple"
                  : "text-brand-muted hover:text-white"
              }`}
            >
              <tab.icon size={22} />
              <span className="text-xs font-semibold">{tab.label}</span>
            </button>
          ))}
        </div>
      </div>
    </div>
  );
}


// ===== src/components/MobileLiveMatchCard.tsx =====

"use client";

import { useState, useMemo } from 'react';
import Image from 'next/image';
import { format } from 'date-fns';
import Link from '@/components/StyledLink'; 
import { History, ChevronDown, BarChart2 } from 'lucide-react';
import VotingPanel from './VotingPanel';
import { useTranslation } from '@/hooks/useTranslation';

interface MatchCardProps {
  match: any;
}

// --- A sub-component for a single team row for cleanliness ---
const TeamRow = ({ team, score, hasMomentum, momentumType }: any) => (
    <div className="flex justify-between items-center">
        <div className="flex items-center gap-3 min-w-0">
            <div className="relative flex-shrink-0">
                <Image src={team.logo} alt={team.name} width={32} height={32} className="object-contain h-8 w-8"/>
                {hasMomentum && (
                    <span className="absolute -top-1 -right-1 flex h-3 w-3">
                        <span className={`absolute inline-flex h-full w-full rounded-full ${momentumType === 'Goal' ? 'bg-green-400' : 'bg-red-400'} opacity-75 animate-ping`}></span>
                        <span className={`relative inline-flex rounded-full h-3 w-3 ${momentumType === 'Goal' ? 'bg-green-500' : 'bg-red-500'}`}></span>
                    </span>
                )}
            </div>
            <span className="font-bold text-white truncate">{team.name}</span>
        </div>
        <span className="text-xl font-black text-white">{score ?? 0}</span>
    </div>
);


export default function MobileLiveMatchCard({ match }: MatchCardProps) {
  const { fixture, teams, goals, league, events } = match;
  const [isExpanded, setIsExpanded] = useState(false);
  const { t } = useTranslation();

  const isLive = ['1H', 'HT', '2H', 'ET', 'P'].includes(fixture.status.short);
  const isFinished = ['FT', 'AET', 'PEN'].includes(fixture.status.short);
  const isUpcoming = !isLive && !isFinished;

  const momentumData = useMemo(() => {
    if (!isLive || !events || events.length === 0) return { teamId: null, type: null };
    const lastMajorEvent = [...events].reverse().find(e => e.type === 'Goal' || (e.type === 'Card' && e.detail === 'Red Card'));
    if (!lastMajorEvent) return { teamId: null, type: null };
    let momentumTeamId = lastMajorEvent.team.id;
    if (lastMajorEvent.type === 'Card') {
        momentumTeamId = momentumTeamId === teams.home.id ? teams.away.id : teams.home.id;
    }
    return { teamId: momentumTeamId, type: lastMajorEvent.type };
  }, [events, isLive, teams.home.id, teams.away.id]);

  return (
    <div className="bg-[#252837] rounded-xl overflow-hidden flex flex-col">
      {/* HEADER: League & Status */}
      <div className="flex justify-between items-center p-3 border-b border-gray-700/50">
          <div className="flex items-center gap-2 min-w-0">
            <Image src={league.logo} alt={league.name} width={20} height={20} className="flex-shrink-0" />
            <span className="text-sm font-semibold truncate text-brand-muted">{league.name}</span>
          </div>
          <div className="flex-shrink-0">
            {isLive && <div className="flex items-center gap-1.5 text-brand-live font-semibold text-xs"><span className="relative flex h-2 w-2"><span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span><span className="relative inline-flex rounded-full h-2 w-2 bg-brand-live"></span></span><span>{fixture.status.elapsed}'</span></div>}
            {isFinished && <div className="flex items-center gap-1.5 bg-gray-700/50 text-gray-300 px-2 py-0.5 rounded-full text-xs font-semibold"><History size={12} /><span>{t('finished')}</span></div>}
            {isUpcoming && <div className="font-bold text-brand-light text-sm">{format(new Date(fixture.date), "HH:mm")}</div>}
          </div>
      </div>

      {/* BODY: Vertically Stacked Teams */}
      <div className="p-3 space-y-2">
          <TeamRow 
            team={teams.home} 
            score={goals.home} 
            hasMomentum={momentumData.teamId === teams.home.id}
            momentumType={momentumData.type}
          />
          <TeamRow 
            team={teams.away} 
            score={goals.away} 
            hasMomentum={momentumData.teamId === teams.away.id}
            momentumType={momentumData.type}
          />
      </div>

      {/* FOOTER: Actions */}
      <div className="p-2 bg-gray-900/30 flex justify-between items-center">
        <Link href={`/football/match/${fixture.id}`} className="flex items-center gap-2 text-xs text-brand-muted hover:text-white transition-colors py-1 px-2">
            <BarChart2 size={14} />
            <span>{t('match_details')}</span>
        </Link>
        {!isFinished && (
            <button
                onClick={() => setIsExpanded(!isExpanded)}
                className="flex items-center gap-1.5 text-xs text-green-400 hover:text-green-300 font-bold transition-all duration-300 rounded-lg px-2 py-1.5 bg-green-500/10"
                aria-label={isExpanded ? t('hide_panel') : t('vote_and_see_poll')}
            >
                <span>{t('vote_and_see_poll')}</span>
                <ChevronDown size={14} className={`transition-transform duration-300 ${isExpanded ? 'rotate-180' : ''}`} />
            </button>
        )}
      </div>

      {/* EXPANDABLE: Voting Panel */}
      <div className={`transition-all duration-300 ease-in-out grid ${isExpanded ? 'grid-rows-[1fr]' : 'grid-rows-[0fr]'}`}>
          <div className="overflow-hidden">
            {isExpanded && <VotingPanel fixtureId={fixture.id} teams={teams} />}
          </div>
      </div>
    </div>
  );
}

// ===== src/components/MobileMatchListItem.tsx =====

// src/components/MobileMatchListItem.tsx
"use client";

import { useState } from "react";
import Image from "next/image";
import Link from "@/components/StyledLink";
import { format } from "date-fns";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import { useVoteStorage } from "@/hooks/useVoteStorage";
import { Star, ChevronDown } from "lucide-react";
import { generateMatchSlug } from "@/lib/generate-match-slug";
import OddsDisplay from "./OddsDisplay"; // This is likely for API/general odds
import { proxyImageUrl } from "@/lib/image-proxy"; // Assuming proxyImageUrl is needed for TeamRow

// --- Type Definitions & API Helpers (Unchanged) ---
type Odds = { home: string; draw: string; away: string } | undefined | null;
interface VoteData {
  homeVotes: number;
  drawVotes: number;
  awayVotes: number;
}
const getVotes = async (fixtureId: number): Promise<VoteData | null> => {
  try {
    const { data } = await axios.get(`/api/votes?fixture=${fixtureId}`);
    return data;
  } catch {
    return null;
  }
};
const submitVote = async ({
  fixtureId,
  vote,
}: {
  fixtureId: number;
  vote: string;
}): Promise<VoteData> => {
  const { data } = await axios.post("/api/votes", { fixtureId, vote });
  return data;
};

// --- Reusable TeamRow sub-component ---
const TeamRow = ({
  team,
  score,
  onVote,
  isVotedFor,
  isDisabled,
  isLive,
}: {
  team: { name: string; logo: string; winner: boolean };
  score: number | null;
  onVote: (e: React.MouseEvent) => void;
  isVotedFor: boolean;
  isDisabled: boolean;
  isLive: boolean;
}) => (
  <div className="flex items-center justify-between">
    <div className="flex items-center gap-3 min-w-0">
      <Image
        src={proxyImageUrl(team.logo)}
        alt={team.name}
        width={24}
        height={24}
      />{" "}
      {/* Ensure proxyImageUrl is used */}
      <span
        className={`font-semibold text-sm truncate ${
          team.winner ? "text-text-primary" : "text-text-secondary"
        }`}
      >
        {team.name}
      </span>
    </div>
    <div className="flex items-center gap-3">
      <span
        className={`font-bold text-sm ${
          isLive
            ? "text-green-400"
            : team.winner
            ? "text-text-primary"
            : "text-text-secondary"
        }`}
      >
        {score ?? "-"}
      </span>
      {/* <button
        onClick={onVote}
        disabled={isDisabled}
        className="p-1 disabled:cursor-not-allowed disabled:opacity-50"
      >
        <Star
          size={20}
          className={`transition-all duration-200 ${
            isVotedFor
              ? "text-brand-yellow fill-brand-yellow"
              : "text-gray-500 hover:text-brand-yellow"
          }`}
        />
      </button> */}
    </div>
  </div>
);

export default function MobileMatchListItem({
  match,
  liveOdds,
  customOdds,
}: {
  match: any;
  liveOdds?: Odds;
  customOdds?: Odds;
}) {
  const { fixture, teams, goals } = match;
  const slug = generateMatchSlug(teams.home, teams.away, fixture.id);
  const queryClient = useQueryClient();
  const { setVote, getVoteForFixture } = useVoteStorage();

  const [votedFor, setVotedFor] = useState<"home" | "away" | null>(
    () => getVoteForFixture(fixture.id) as "home" | "away" | null
  );
  const [isExpanded, setIsExpanded] = useState(false);

  const isLive = ["1H", "HT", "2H", "ET", "P", "LIVE"].includes(
    fixture.status.short
  );
  const isFinished = ["FT", "AET", "PEN"].includes(fixture.status.short);

  const { data: voteData } = useQuery({
    queryKey: ["votes", fixture.id],
    queryFn: () => getVotes(fixture.id),
    enabled: !isFinished && !!votedFor,
  });

  const voteMutation = useMutation({
    mutationFn: submitVote,
    onSuccess: () =>
      queryClient.invalidateQueries({ queryKey: ["votes", fixture.id] }),
  });

  const handleVote = (e: React.MouseEvent, choice: "home" | "away") => {
    e.preventDefault();
    e.stopPropagation();
    if (votedFor || isFinished) return;
    setVotedFor(choice);
    setVote(fixture.id, choice);
    voteMutation.mutate({ fixtureId: fixture.id, vote: choice });
    if (!isExpanded) setIsExpanded(true); // Automatically expand on vote
  };

  const totalVotes = (voteData?.homeVotes || 0) + (voteData?.awayVotes || 0);
  const homePercent =
    totalVotes > 0
      ? Math.round(((voteData?.homeVotes || 0) / totalVotes) * 100)
      : 50;

  return (
    <div
      className="rounded-lg p-2"
      style={{ backgroundColor: "var(--color-secondary)" }}
    >
      <div className="flex items-start gap-2">
        <Link
          href={`/football/match/${slug}`}
          className="flex-1 flex items-center gap-3"
        >
          <div className="w-12 flex-shrink-0 text-center text-xs font-bold">
            {isLive ? (
              <div className="flex items-center justify-center gap-1.5 text-green-400">
                <span className="h-1.5 w-1.5 rounded-full bg-green-500"></span>
                <span>{fixture.status.elapsed}'</span>
              </div>
            ) : isFinished ? (
              <div className="text-text-muted">FT</div>
            ) : (
              <div>{format(new Date(fixture.date), "HH:mm")}</div>
            )}
          </div>
          <div className="flex-1 flex flex-col gap-2">
            <TeamRow
              team={teams.home}
              score={goals.home}
              onVote={(e) => handleVote(e, "home")}
              isVotedFor={votedFor === "home"}
              isDisabled={!!votedFor || isFinished}
              isLive={isLive}
            />
            <TeamRow
              team={teams.away}
              score={goals.away}
              onVote={(e) => handleVote(e, "away")}
              isVotedFor={votedFor === "away"}
              isDisabled={!!votedFor || isFinished}
              isLive={isLive}
            />
          </div>
        </Link>
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className="p-2 text-text-muted"
        >
          <ChevronDown
            size={20}
            className={`transition-transform duration-200 ${
              isExpanded ? "rotate-180" : ""
            }`}
          />
        </button>
      </div>

      {isExpanded && (
        <div className="mt-2 pt-2 ml-14 border-t border-gray-700/50 space-y-3">
          {votedFor && (
            <div className="flex w-full h-1.5 rounded-full overflow-hidden bg-gray-700">
              <div
                className="bg-brand-purple"
                style={{ width: `${homePercent}%` }}
              ></div>
              <div
                className="bg-blue-600"
                style={{ width: `${100 - homePercent}%` }}
              ></div>
            </div>
          )}

          {/* Existing OddsDisplay (likely for API/general odds) */}
          {/* Only show if not finished and if OddsDisplay has content */}
          {!isFinished && (
            <OddsDisplay fixtureId={fixture.id} initialOdds={liveOdds} />
          )}

          {/* --- NEW: Fanskor Odds Display --- */}
          {customOdds && !isFinished && (
            <div className="space-y-1">
              <h4 className="text-xs font-semibold text-brand-light">
                Fanskor Odds
              </h4>
              <div className="grid grid-cols-3 gap-2 text-center text-white font-bold text-sm">
                <div className="bg-brand-purple/20 p-2 rounded-md">
                  1: {customOdds.home}
                </div>
                <div className="bg-brand-purple/20 p-2 rounded-md">
                  X: {customOdds.draw}
                </div>
                <div className="bg-brand-purple/20 p-2 rounded-md">
                  2: {customOdds.away}
                </div>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

// Skeleton remains unchanged.
export const MobileMatchListItemSkeleton = () => (
  <div
    className="flex items-center p-3 rounded-lg animate-pulse"
    style={{ backgroundColor: "var(--color-secondary)" }}
  >
    <div className="w-12 h-8 rounded bg-gray-600/50"></div>
    <div className="flex-1 ml-3 space-y-2">
      <div className="h-4 w-4/5 rounded bg-gray-600/50"></div>
      <div className="h-4 w-3/5 rounded bg-gray-600/50"></div>
    </div>
    <div className="w-10 h-6 rounded bg-gray-600/50"></div>
  </div>
);


// ===== src/components/NavDropdown.tsx =====

"use client";

import { useState, ReactNode } from 'react';
import { ChevronDown } from 'lucide-react';
import StyledLink from './StyledLink';

interface SubLink {
    name: string;
    href: string;
    description: string;
}

interface NavDropdownProps {
    title: string;
    subLinks: SubLink[];
}

export default function NavDropdown({ title, subLinks }: NavDropdownProps) {
    const [isOpen, setIsOpen] = useState(false);

    return (
        <div 
            className="relative"
            onMouseEnter={() => setIsOpen(true)}
            onMouseLeave={() => setIsOpen(false)}
        >
            {/* The main navigation item */}
            <button className="flex items-center gap-1 py-2 text-base font-medium text-brand-light transition-colors hover:text-white">
                <span>{title}</span>
                <ChevronDown 
                    size={16} 
                    className={`transition-transform duration-300 ${isOpen ? 'rotate-180' : ''}`} 
                />
            </button>
            
            {/* The dropdown menu */}
            <div
                className={`absolute top-full pt-3 transition-all duration-300 ease-in-out ${
                    isOpen ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-2 pointer-events-none'
                }`}
            >
                <div className="bg-brand-secondary rounded-lg shadow-2xl border border-gray-700/50 w-64 overflow-hidden">
                    <ul className="space-y-1 p-2">
                        {subLinks.map(link => (
                            <li key={link.name}>
                                <StyledLink
                                    href={link.href}
                                    className="block p-3 rounded-md hover:bg-brand-purple"
                                >
                                    <p className="font-bold text-white">{link.name}</p>
                                    <p className="text-sm text-brand-muted">{link.description}</p>
                                </StyledLink>
                            </li>
                        ))}
                    </ul>
                </div>
            </div>
        </div>
    );
}

// ===== src/components/NewsItemCard.tsx =====

import Image from 'next/image';
import Link from '@/components/StyledLink'; 

// --- 1. Define the TypeScript interface for a single news article ---
export interface NewsArticleType {
  id: string;
  title: string;
  excerpt: string;
  imageUrl: string;
  articleUrl: string; // The URL the card will link to
}

interface NewsItemCardProps {
  article: NewsArticleType;
}

// --- 2. The NewsItemCard Component ---
export default function NewsItemCard({ article }: NewsItemCardProps) {
  return (
    // The entire card is a clickable link for better UX
    <Link href={article.articleUrl} target="_blank" rel="noopener noreferrer" className="block">
      <div className="bg-brand-secondary rounded-xl overflow-hidden group transition-all duration-300 hover:shadow-lg hover:shadow-purple-900/20">
        
        {/* Image Container with hover effect */}
        <div className="relative w-full h-40">
          <Image
            src={article.imageUrl}
            alt={article.title}
            layout="fill"
            objectFit="cover"
            className="transition-transform duration-300 group-hover:scale-110"
          />
        </div>

        {/* Text Content */}
        <div className="p-4">
          <h4 className="font-bold text-lg text-brand-light mb-2 leading-tight group-hover:text-brand-purple transition-colors">
            {article.title}
          </h4>
          <p className="text-sm text-brand-muted line-clamp-3">
            {article.excerpt}
          </p>
        </div>
      </div>
    </Link>
  );
}

// --- 3. Skeleton Component (can be in this file or its own) ---
export const NewsItemCardSkeleton = () => {
    return (
        <div className="bg-brand-secondary rounded-xl overflow-hidden animate-pulse">
            <div className="w-full h-40 bg-gray-600/50"></div>
            <div className="p-4 space-y-3">
                <div className="h-5 w-full rounded bg-gray-600/50"></div>
                <div className="h-5 w-4/5 rounded bg-gray-600/50"></div>
                <div className="h-3 w-full rounded bg-gray-600/50 mt-2"></div>
                <div className="h-3 w-1/2 rounded bg-gray-600/50"></div>
            </div>
        </div>
    )
}

// ===== src/components/NewsLeagueStandingsSlide.tsx =====

// src/components/LeagueStandingsSlide.tsx
"use client";

import Image from 'next/image';
import Link from '@/components/StyledLink'; 

interface TeamStanding {
  rank: number;
  team: { id: number; name: string; logo: string; };
  points: number;
}
interface StandingsData {
  league: { id: number; name: string; logo: string; };
  standings: TeamStanding[];
}

export default function NewsLeagueStandingsSlide({ standingsData }: { standingsData: StandingsData }) {
  const { league, standings } = standingsData;

  return (
    // The px-1 is important to prevent slides from touching edge-to-edge
    <div className="px-1"> 
      <div className="bg-brand-secondary rounded-xl p-4 h-full">
        {/* Slide Header with League Info and Link */}
            <Image src={league.logo} alt={league.name} width={32} height={32} />
            <h4 className="font-bold text-xl text-brand-light truncate group-hover:text-brand-purple transition-colors">
              {league.name}
            </h4>
        {/* Standings Table */}
        <div className="overflow-x-auto">
            <table className="w-full text-sm">
                <thead className="text-brand-muted text-xs">
                    <tr className="border-b border-gray-700/50">
                        <th className="p-2 font-semibold text-center w-8">#</th>
                        <th className="p-2 font-semibold text-left">Team</th>
                        <th className="p-2 font-semibold text-center">Pts</th>
                    </tr>
                </thead>
                <tbody>
                    {/* Show top 5 teams */}
                    {standings.slice(0, 5).map((team) => (
                    <tr key={team.team.id} className="border-t border-gray-700/50">
                        <td className="p-2 text-center text-brand-muted">{team.rank}</td>
                        <td className="p-2 flex items-center gap-2 font-medium">
                        <Image src={team.team.logo} alt={team.team.name} width={18} height={18} />
                        <span className="truncate">{team.team.name}</span>
                        </td>
                        <td className="p-2 text-center font-bold">{team.points}</td>
                    </tr>
                    ))}
                </tbody>
            </table>
        </div>
      </div>
    </div>
  );
}

// Skeleton for a single slide
export const LeagueStandingsSlideSkeleton = () => (
    <div className="px-1">
        <div className="bg-brand-secondary rounded-xl p-4 animate-pulse">
            <div className="flex items-center gap-3 mb-4">
                <div className="w-8 h-8 rounded-full bg-gray-600/50"></div>
                <div className="h-6 w-3/4 rounded bg-gray-600/50"></div>
            </div>
            <div className="space-y-3 mt-4">
                {Array.from({ length: 5 }).map((_, i) => (
                    <div key={i} className="h-5 w-full rounded bg-gray-600/50"></div>
                ))}
            </div>
        </div>
    </div>
);

// ===== src/components/NewsListItem.tsx =====

// src/components/NewsListItem.tsx
"use client";

import Image from "next/image";
import StyledLink from "./StyledLink";
import { IPost } from "@/models/Post";
import { format } from "date-fns";
import { ArrowUpRight } from "lucide-react";

export function NewsListItemSkeleton() {
  return (
    <div className="bg-brand-secondary rounded-lg flex flex-col sm:flex-row gap-0 animate-pulse">
      <div className="w-full sm:w-48 md:w-56 h-40 sm:h-auto bg-gray-700 rounded-t-lg sm:rounded-l-lg sm:rounded-tr-none flex-shrink-0"></div>
      <div className="w-full p-6 space-y-3">
        <div className="h-4 w-1/4 bg-gray-600 rounded"></div>
        <div className="h-6 w-full bg-gray-600 rounded"></div>
        <div className="h-4 w-3/4 bg-gray-600 rounded"></div>
      </div>
    </div>
  );
}

interface NewsListItemProps {
  post: IPost;
}

export default function NewsListItem({ post }: NewsListItemProps) {
  const postUrl = `/football/news/${post.slug}`;

  return (
    // --- FIX 1: The flex parent ---
    // The main container is a flexbox. We set items-center to vertically align content.
    <div className="bg-brand-secondary rounded-lg group flex flex-col sm:flex-row items-center transition-colors hover:bg-gray-800/50">
      {/* --- Image Container --- */}
      {/* It has a fixed width and shrinks to 0 height on small screens, letting aspect-video take over. */}
      <StyledLink
        href={postUrl}
        className="block w-full sm:w-48 md:w-56 flex-shrink-0 h-40 sm:h-auto sm:self-stretch"
      >
        <div className="relative w-full h-full">
          {post.featuredImage ? (
            <Image
              src={post.featuredImage}
              alt={post.featuredImageAltText || post.title}
              layout="fill"
              objectFit="cover"
              className="rounded-t-lg sm:rounded-l-lg sm:rounded-tr-none"
            />
          ) : (
            <div className="w-full h-full bg-gray-800 flex items-center justify-center rounded-t-lg sm:rounded-l-lg sm:rounded-tr-none">
              <span className="text-brand-muted">No Image</span>
            </div>
          )}
        </div>
      </StyledLink>

      {/* --- FIX 2: The Text Content Container --- */}
      {/* `min-w-0` is the key fix. It allows this flex item to shrink and its text content to wrap properly. */}
      {/* `flex-1` ensures it takes up the remaining available space. */}
      <div className="p-6 flex flex-col flex-1 min-w-0">
        <p className="text-sm text-brand-muted mb-2">
          {format(new Date(post.createdAt), "MMMM dd, yyyy")}
        </p>
        <h3 className="font-bold text-white leading-tight mb-3 text-lg">
          <StyledLink
            href={postUrl}
            className="hover:text-brand-purple transition-colors"
          >
            {post.title}
          </StyledLink>
        </h3>
        {post.metaDescription && (
          <p className="text-brand-light text-sm flex-grow mb-4 line-clamp-2">
            {post.metaDescription}
          </p>
        )}
        <div className="mt-auto">
          <StyledLink
            href={postUrl}
            className="text-brand-purple font-semibold text-sm flex items-center gap-1"
          >
            Read More <ArrowUpRight size={16} />
          </StyledLink>
        </div>
      </div>
    </div>
  );
}


// ===== src/components/NewsSection.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import NewsItemCard, {
  NewsArticleType,
  NewsItemCardSkeleton,
} from "./NewsItemCard";
import axios from "axios";
import { IPost } from "@/models/Post";
import StyledLink from "./StyledLink"; // Import the StyledLink component
import { ArrowRight } from "lucide-react"; // Import an icon for the button
import { useTranslation } from "@/hooks/useTranslation";

// The fetcher function remains the same, it fetches all published posts.
const fetchNews = async (): Promise<NewsArticleType[]> => {
  const { data } = await axios.get("/api/posts?status=published");
  // Transform the API response into the format the card component expects.
  const transformedNews: NewsArticleType[] = data.map((post: IPost) => ({
    id: post._id,
    title: post.title,
    excerpt: post.content.replace(/<[^>]*>?/gm, "").substring(0, 150) + "...",
    imageUrl:
      post.featuredImage ||
      "https://images.unsplash.com/photo-1599508704512-2f19efd1e35f?q=80&w=1935&auto=format&fit=crop",
    articleUrl: `/football/news/${post.slug}`,
  }));

  return transformedNews;
};

export default function NewsSection() {
  const {
    data: news,
    isLoading,
    error,
  } = useQuery<NewsArticleType[]>({
    queryKey: ["newsArticles"],
    queryFn: fetchNews,
    staleTime: 1000 * 60 * 10, // Cache for 10 minutes
  });

  const { t } = useTranslation();

  return (
    <section>
      {/* --- NEW: Section Header with Title and "See All" Button --- */}
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-xl font-bold text-white">{t("latest_news")}</h3>
        {/* The button only shows if there are more than 2 articles */}
        {news && news.length > 2 && (
          <StyledLink
            href="/football/news"
            className="flex items-center gap-1 text-sm font-semibold text-text-muted transition-colors hover:text-white"
          >
            See all
            <ArrowRight size={16} />
          </StyledLink>
        )}
      </div>

      <div className="space-y-4">
        {isLoading ? (
          // Show two skeletons while loading
          <>
            <NewsItemCardSkeleton />
            <NewsItemCardSkeleton />
          </>
        ) : error ? (
          <div
            className="rounded-xl p-6 text-center text-text-muted"
            style={{ backgroundColor: "var(--color-primary)" }}
          >
            <p>Could not load news articles.</p>
          </div>
        ) : news && news.length > 0 ? (
          // --- ENHANCEMENT: Use .slice(0, 2) to only show the first two articles ---
          news
            .slice(0, 2)
            .map((article) => (
              <NewsItemCard key={article.id} article={article} />
            ))
        ) : (
          <div
            className="rounded-xl p-6 text-center text-text-muted"
            style={{ backgroundColor: "var(--color-primary)" }}
          >
            <p>No news articles available yet.</p>
          </div>
        )}
      </div>
    </section>
  );
}


// ===== src/components/NewsSidebar.tsx =====

// src/components/NewsSidebar.tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Slider from "react-slick";

// Import the child components and their skeletons
import LeagueStandingsSlide, {
  LeagueStandingsSlideSkeleton,
} from "./NewsLeagueStandingsSlide";
import SidebarMatchItem, { SidebarMatchItemSkeleton } from "./SidebarMatchItem";
import AdSlotWidget from "./AdSlotWidget";

// --- Type Definitions for data structures ---
interface TeamStanding {
  rank: number;
  team: { id: number; name: string; logo: string };
  points: number;
}
interface StandingsData {
  league: { id: number; name: string; logo: string };
  standings: TeamStanding[];
}
interface MatchData {
  fixture: { id: number; status: { elapsed: number } };
  teams: { home: any; away: any };
  goals: { home: any; away: any };
}

// --- API Fetcher Functions ---
const fetchGlobalLiveMatches = async (): Promise<MatchData[]> => {
  try {
    const { data } = await axios.get("/api/global-live");
    return data;
  } catch (error) {
    console.error("Error fetching global live matches for sidebar:", error);
    return [];
  }
};

// A curated list of popular league IDs to display in the slider
const POPULAR_LEAGUE_IDS = [39, 88, 140, 78, 61]; // Premier League, La Liga, Serie A, Bundesliga, Ligue 1

const fetchStandingsForLeagues = async (
  leagueIds: number[]
): Promise<StandingsData[]> => {
  try {
    const standingsPromises = leagueIds.map((id) =>
      axios.get(`/api/standings?league=${id}`).then((res) => res.data)
    );
    const results = await Promise.allSettled(standingsPromises);

    // Filter out any failed requests and leagues with no standings data
    return results
      .filter(
        (result) =>
          result.status === "fulfilled" && result.value?.standings?.length > 0
      )
      .map((result) => (result as PromiseFulfilledResult<StandingsData>).value);
  } catch (error) {
    console.error(
      "Error fetching popular league standings for sidebar:",
      error
    );
    return [];
  }
};

// --- Main Sidebar Component ---
export default function NewsSidebar() {
  const { data: liveMatches, isLoading: isLoadingMatches } = useQuery({
    queryKey: ["globalLiveMatchesSidebar"],
    queryFn: fetchGlobalLiveMatches,
    refetchInterval: 30000,
  });

  const { data: popularStandings, isLoading: isLoadingStandings } = useQuery({
    queryKey: ["popularStandingsSidebar"],
    queryFn: () => fetchStandingsForLeagues(POPULAR_LEAGUE_IDS),
    staleTime: 1000 * 60 * 60,
  });

  const sliderSettings = {
    dots: true,
    infinite: false,
    speed: 500,
    slidesToShow: 1,
    slidesToScroll: 1,
    autoplay: true,
    autoplaySpeed: 8000,
    arrows: false,
    appendDots: (dots: any) => (
      <div style={{ position: "absolute", bottom: "-25px" }}>
        <ul style={{ margin: "0px" }}> {dots} </ul>
      </div>
    ),
    customPaging: (i: any) => (
      <div className="w-2 h-2 rounded-full bg-gray-600 transition-colors duration-300 hover:bg-brand-purple active:bg-brand-purple"></div>
    ),
  };

  return (
    <aside className="space-y-8">
      {/* Live Matches Widget (no changes needed here) */}
      <section className="bg-brand-secondary rounded-xl p-4">
        <h3 className="text-lg font-bold text-brand-light mb-4">
          Live Matches
        </h3>
        <div className="space-y-1">
          {isLoadingMatches ? (
            <>
              <SidebarMatchItemSkeleton />
              <SidebarMatchItemSkeleton />
            </>
          ) : liveMatches && liveMatches.length > 0 ? (
            liveMatches
              .slice(0, 5)
              .map((match) => (
                <SidebarMatchItem
                  key={match.fixture.id}
                  match={match as MatchData}
                />
              ))
          ) : (
            <p className="text-sm text-brand-muted text-center py-4">
              No matches are currently live.
            </p>
          )}
        </div>
      </section>

      <AdSlotWidget location="news_sidebar" />

      {/* Popular League Standings Widget */}
      <section></section>
    </aside>
  );
}


// ===== src/components/OddsDisplay.tsx =====

"use client";

import { useQuery } from '@tanstack/react-query';
import axios from 'axios';

type Odds = { home: string; draw: string; away: string; } | undefined | null;

const fetchOdds = async (fixtureId: number): Promise<Odds> => {
    try {
        const { data } = await axios.get(`/api/odds?fixture=${fixtureId}`);
        return data;
    } catch (error) {
        console.error(error);
        return null;
    }
};

const OddBox = ({ label, value }: { label: string, value: string }) => (
    <div className="flex-1 flex items-center justify-between p-2 rounded-md" style={{ backgroundColor: 'var(--color-primary)' }}>
        <span className="font-bold text-sm text-text-muted">{label}</span>
        <span className="font-bold text-sm text-brand-highlight">{value}</span>
    </div>
);

export default function OddsDisplay({ fixtureId, initialOdds }: { fixtureId: number, initialOdds?: Odds }) {
    const { data: odds, isLoading, isError } = useQuery({
        queryKey: ['odds', fixtureId],
        queryFn: () => fetchOdds(fixtureId),
        // CRITICAL: Only enable the query if initialOdds are NOT provided
        enabled: !initialOdds,
        // Pass the live odds as initial data to prevent fetching if they already exist
        initialData: initialOdds,
        staleTime: 1000 * 60 * 5,
        refetchOnWindowFocus: false,
    });

    const displayData = initialOdds || odds;

    if (isLoading && !initialOdds) {
        return <div className="text-xs text-center text-text-muted p-2 animate-pulse">Loading Odds...</div>;
    }

    if (isError || !displayData) {
        return <div className="text-xs text-center text-text-muted p-2">Odds not available.</div>;
    }

    return (
        <div className="flex items-center justify-center gap-2">
            <OddBox label="1" value={displayData.home} />
            <OddBox label="X" value={displayData.draw} />
            <OddBox label="2" value={displayData.away} />
        </div>
    );
}

// ===== src/components/Pagination.tsx =====

"use client";

import { ChevronLeft, ChevronRight } from 'lucide-react';

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
}

export default function Pagination({ currentPage, totalPages, onPageChange }: PaginationProps) {
  // Don't render pagination if there's only one page or no pages
  if (totalPages <= 1) {
    return null;
  }

  const handlePrevious = () => {
    if (currentPage > 1) {
      onPageChange(currentPage - 1);
    }
  };

  const handleNext = () => {
    if (currentPage < totalPages) {
      onPageChange(currentPage + 1);
    }
  };

  return (
    <div className="flex items-center justify-center gap-4 mt-8">
      <button
        onClick={handlePrevious}
        disabled={currentPage === 1}
        className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-brand-secondary rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50 transition-colors"
      >
        <ChevronLeft size={16} />
        <span>Previous</span>
      </button>

      <span className="text-sm font-semibold text-brand-muted">
        Page {currentPage} of {totalPages}
      </span>

      <button
        onClick={handleNext}
        disabled={currentPage === totalPages}
        className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-brand-secondary rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50 transition-colors"
      >
        <span>Next</span>
        <ChevronRight size={16} />
      </button>
    </div>
  );
}

// ===== src/components/PopularTeamsList.tsx =====

"use client";

import { useState, useMemo } from 'react';
import { useQuery } from '@tanstack/react-query';
import axios from 'axios';
import Link from '@/components/StyledLink'; 
import { usePathname } from 'next/navigation';
import Image from 'next/image';
import slugify from 'slugify';
import { ChevronLeft, ChevronRight } from 'lucide-react';

// --- Type Definitions ---
interface TeamData {
  team: { id: number; name: string; logo: string; };
  venue: any;
}

// --- Helper Functions ---
const generateTeamSlug = (name: string, id: number) => {
    const slug = slugify(name, { lower: true, strict: true });
    return `/football/team/${slug}-${id}`;
};

const fetchPopularTeams = async (): Promise<TeamData[]> => {
    const POPULAR_LEAGUE_ID = 39; // Premier League
    const season = new Date().getFullYear();
    const { data } = await axios.get(`/api/teams?league=${POPULAR_LEAGUE_ID}&season=${season}`);
    return data;
};

// --- Skeleton Component for Loading State ---
const TeamItemSkeleton = () => (
    <div className="flex items-center p-2.5 rounded-lg animate-pulse">
        <div className="flex items-center gap-3 w-full">
            <div className="h-6 w-6 rounded-full bg-gray-600/50"></div>
            <div className="h-4 w-4/5 rounded bg-gray-600/50"></div>
        </div>
    </div>
);


// --- Main Component ---
export default function PopularTeamsList() {
    const pathname = usePathname();
    const [currentPage, setCurrentPage] = useState(1);
    const ITEMS_PER_PAGE = 6; // Number of teams to show per page

    const { data: allTeams, isLoading, isError } = useQuery<TeamData[]>({
        queryKey: ['popularTeams'],
        queryFn: fetchPopularTeams,
        staleTime: 1000 * 60 * 60 * 24, // Team lists are static for a season, cache for a day
        refetchOnWindowFocus: false,
    });

    const totalPages = allTeams ? Math.ceil(allTeams.length / ITEMS_PER_PAGE) : 0;

    const paginatedTeams = useMemo(() => {
        if (!allTeams) return [];
        const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
        const endIndex = startIndex + ITEMS_PER_PAGE;
        return allTeams.slice(startIndex, endIndex);
    }, [allTeams, currentPage]);

    if (isLoading) {
        return <div className="space-y-1">{Array.from({ length: ITEMS_PER_PAGE }).map((_, i) => <TeamItemSkeleton key={i} />)}</div>;
    }

    if (isError || !paginatedTeams || paginatedTeams.length === 0) {
        return <p className="text-brand-muted text-xs p-2.5">Could not load popular teams.</p>;
    }

    return (
        <div>
            {/* List of Teams */}
            <ul className="space-y-1">
                {paginatedTeams.map(({ team }) => {
                    const href = generateTeamSlug(team.name, team.id);
                    const isActive = pathname.startsWith(href);
                    return (
                        <li key={team.id}>
                            <Link
                                href={href}
                                className={`w-full flex items-center p-2.5 rounded-lg transition-all duration-200 ${
                                    isActive ? 'bg-brand-purple shadow-md text-white' : 'hover:bg-gray-700/50 text-brand-light'
                                }`}
                            >
                                <div className="flex items-center gap-3 overflow-hidden">
                                    <Image src={team.logo} alt={`${team.name} logo`} width={24} height={24} className="flex-shrink-0" />
                                    <span className={`font-bold text-sm truncate ${isActive ? 'text-white' : 'text-brand-light'}`}>
                                        {team.name}
                                    </span>
                                </div>
                            </Link>
                        </li>
                    );
                })}
            </ul>

            {/* Pagination Controls */}
            {totalPages > 1 && (
                <div className="flex items-center justify-between mt-4 px-2">
                    <button
                        onClick={() => setCurrentPage(p => p - 1)}
                        disabled={currentPage === 1}
                        className="p-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50"
                    >
                        <ChevronLeft size={18} />
                    </button>
                    <span className="text-xs font-semibold text-brand-muted">
                        Page {currentPage} / {totalPages}
                    </span>
                    <button
                        onClick={() => setCurrentPage(p => p + 1)}
                        disabled={currentPage === totalPages}
                        className="p-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-700/50"
                    >
                        <ChevronRight size={18} />
                    </button>
                </div>
            )}
        </div>
    );
}

// ===== src/components/PostCategories.tsx =====

// src/components/PostCategories.tsx
"use client";

import React from "react";

// Define the categories for news articles
export type NewsCategory =
  | "all"
  | "trending" // Functional alias for "all" for display purposes
  | "football"
  | "basketball"
  | "tennis"
  | "general"
  | "prediction"
  | "match_reports";

interface PostCategoriesProps {
  activeCategory: NewsCategory;
  onCategoryChange: (category: NewsCategory) => void;
}

const categories: { value: NewsCategory; label: string }[] = [
  { value: "all", label: "All News" },
  { value: "trending", label: "Trending News" }, // Displayed as a tab
  { value: "prediction", label: "Prediction" },
  { value: "match_reports", label: "Match Reports" },
];

const PostCategories: React.FC<PostCategoriesProps> = ({
  activeCategory,
  onCategoryChange,
}) => {
  // Map "trending" to "all" internally for logic, but keep "trending" for display
  const effectiveActiveCategory =
    activeCategory === "trending" ? "all" : activeCategory;

  const handleClick = (category: NewsCategory) => {
    onCategoryChange(category);
  };

  return (
    <div className="flex flex-wrap gap-3 mb-8">
      {categories.map((category) => {
        // Determine if this tab should be active.
        // If the category is "trending", it's active if activeCategory is "trending".
        // Otherwise, it's active if effectiveActiveCategory matches the category's value.
        const isActive =
          (category.value === "trending" && activeCategory === "trending") ||
          (category.value !== "trending" &&
            effectiveActiveCategory === category.value);

        return (
          <button
            key={category.value}
            onClick={() => handleClick(category.value)}
            className={`
              px-4 py-2 rounded-full font-semibold text-sm transition-all duration-200 ease-in-out
              ${
                isActive
                  ? "bg-brand-purple text-white border border-brand-purple" // Active state
                  : "bg-transparent text-white border border-white hover:bg-white/10" // Inactive state with white border and text
              }
            `}
          >
            {category.label}
          </button>
        );
      })}
    </div>
  );
};

export default PostCategories;


// ===== src/components/PredictionDisplay.tsx =====

"use client";

import { useQuery } from '@tanstack/react-query';
import axios from 'axios';
import Image from 'next/image';

// The data fetched now includes the teams object
interface PredictionData {
    teams: {
        home: { id: number; name: string; logo: string; };
        away: { id: number; name: string; logo: string; };
    };
    percent: { home: number; draw: number; away: number };
}

// Fetcher function (no change)
const fetchPrediction = async (fixtureId: number): Promise<PredictionData> => {
    const { data } = await axios.get(`/api/predictions?fixture=${fixtureId}`);
    return data;
};

// Skeleton loader for the new prediction UI
const PredictionSkeleton = () => (
    <div className="pt-4 mt-4 border-t border-gray-700/50 animate-pulse">
        <div className="h-4 w-1/2 mx-auto rounded bg-gray-600/50 mb-4"></div>
        <div className="flex justify-between items-center">
            <div className="flex flex-col items-center gap-2 w-1/4">
                <div className="w-8 h-8 rounded-full bg-gray-600/50"></div>
                <div className="h-5 w-10 rounded bg-gray-600/50"></div>
            </div>
            <div className="h-5 w-10 rounded bg-gray-600/50"></div>
            <div className="flex flex-col items-center gap-2 w-1/4">
                <div className="w-8 h-8 rounded-full bg-gray-600/50"></div>
                <div className="h-5 w-10 rounded bg-gray-600/50"></div>
            </div>
        </div>
        <div className="h-2 w-full rounded-full bg-gray-600/50 mt-3"></div>
    </div>
);

export default function PredictionDisplay({ fixtureId }: { fixtureId: number }) {
    const { data, isLoading, error } = useQuery({
        queryKey: ['prediction', fixtureId],
        queryFn: () => fetchPrediction(fixtureId),
        staleTime: 1000 * 60 * 60,
        retry: 1,
    });

    if (isLoading) return <PredictionSkeleton />;
    if (error || !data) return null;

    // Destructure everything from the single `data` object
    const { teams, percent } = data;
    const { home, draw, away } = percent;

    return (
        <div className="pt-4 mt-4 border-t border-gray-700/50 space-y-3">
            <h4 className="text-sm font-semibold text-center text-brand-muted tracking-wider">PREDICTION</h4>
            <div className="flex justify-between items-center text-white">
                <div className="flex flex-col items-center gap-2 w-1/4">
                    {/* Use the logo from the fetched prediction data */}
                    <Image src={teams.home.logo} alt={teams.home.name} width={32} height={32} className="object-contain"/>
                    <span className="font-bold text-lg">{home}%</span>
                </div>
                <div className="flex flex-col items-center gap-2 opacity-80">
                    <span className="text-xs text-brand-muted">DRAW</span>
                    <span className="font-bold text-lg">{draw}%</span>
                </div>
                <div className="flex flex-col items-center gap-2 w-1/4">
                    {/* Use the logo from the fetched prediction data */}
                    <Image src={teams.away.logo} alt={teams.away.name} width={32} height={32} className="object-contain"/>
                    <span className="font-bold text-lg">{away}%</span>
                </div>
            </div>
            <div className="flex w-full h-2 rounded-full overflow-hidden bg-gray-800">
                <div className="bg-[#6D28D9] transition-all duration-500" style={{ width: `${home}%` }}></div>
                <div className="bg-gray-500 transition-all duration-500" style={{ width: `${draw}%` }}></div>
                <div className="bg-blue-600 transition-all duration-500" style={{ width: `${away}%` }}></div>
            </div>
        </div>
    );
}

// ===== src/components/ProgressBar.tsx =====

"use client";

import { useEffect } from 'react';
import { usePathname, useSearchParams } from 'next/navigation';
import NProgress from 'nprogress';

export default function ProgressBar() {
  const pathname = usePathname();
  const searchParams = useSearchParams();

  useEffect(() => {
    // Configure NProgress. This is optional.
    NProgress.configure({ showSpinner: false });

    // This effect will run when the pathname or search parameters change,
    // which signifies that a navigation has completed.
    NProgress.done();
    
    // Cleanup function
    return () => {
      NProgress.remove();
    };
  }, [pathname, searchParams]);
  
  // This component doesn't render anything itself. It just controls the NProgress bar.
  return null; 
}

// ===== src/components/Sidebar.tsx =====

"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import Link from "@/components/StyledLink";
import { usePathname } from "next/navigation";
import { useLeagueContext } from "@/context/LeagueContext";
import { League } from "@/types/api-football";
import { useTranslation } from "@/hooks/useTranslation";
import slugify from "slugify";
import PopularTeamsList from "./PopularTeamsList";
import AdSlotWidget from "./AdSlotWidget";
import CasinoPartnerWidget from "./CasinoPartnerWidget";

// --- (All helper functions and sub-components like LeagueList, LeagueItemSkeleton remain the same) ---
const generateLeagueSlug = (name: string, id: number) => {
  const slug = slugify(name, { lower: true, strict: true });
  return `/football/league/${slug}-${id}`;
};

const fetchLeagues = async (countryName: string | null): Promise<League[]> => {
  const endpoint = countryName
    ? `/api/leagues?type=league&country=${encodeURIComponent(countryName)}`
    : `/api/leagues?type=league`;
  const { data } = await axios.get(endpoint);
  return data.map((item: any) => ({
    ...item,
    href: generateLeagueSlug(item.name, item.id),
  }));
};

const LeagueList = ({ leagues }: { leagues: League[] }) => {
  const pathname = usePathname();
  if (!leagues || leagues.length === 0) {
    return (
      <p className="text-text-muted text-xs p-2.5">No competitions found.</p>
    );
  }
  return (
    <ul className="space-y-1">
      {leagues.map((league) => {
        const isActive = pathname.startsWith(league.href);
        return (
          <li key={league.id}>
            <Link
              href={league.href}
              className={`w-full flex items-center justify-between p-2.5 rounded-lg transition-all duration-200 ${
                isActive
                  ? "bg-brand-purple shadow-md text-white"
                  : "hover:bg-gray-700/50 text-text-primary"
              }`}
            >
              <div className="flex items-center gap-3 overflow-hidden">
                <Image
                  src={league.logoUrl}
                  alt={`${league.name} logo`}
                  width={24}
                  height={24}
                  className="flex-shrink-0"
                />
                <span
                  className={`font-bold text-sm truncate ${
                    isActive ? "text-white" : "text-text-primary"
                  }`}
                >
                  {league.name}
                </span>
              </div>
            </Link>
          </li>
        );
      })}
    </ul>
  );
};

const LeagueItemSkeleton = () => (
  <div className="flex items-center justify-between p-2.5 rounded-lg animate-pulse">
    <div className="flex items-center gap-3 w-3/4">
      <div className="h-6 w-6 rounded-full bg-gray-600/50"></div>
      <div className="h-4 w-full rounded bg-gray-600/50"></div>
    </div>
  </div>
);

// --- Main Sidebar Component ---
export default function Sidebar() {
  const { t } = useTranslation();
  const { selectedCountry } = useLeagueContext();

  const { data: leagues, isLoading: isLoadingLeagues } = useQuery<League[]>({
    queryKey: ["leagues", selectedCountry?.name || "global"],
    queryFn: () => fetchLeagues(selectedCountry?.name || null),
  });

  return (
    // --- The outer <aside> is NO LONGER sticky. It's just a simple container. ---
    <aside className="hidden lg:block">
      {/* --- NEW STICKY CONTAINER --- */}
      {/* We use another div inside to manage the gap between sticky items. */}
      <div className="flex flex-col gap-4 h-auto">
        <CasinoPartnerWidget />

        {/* --- WIDGET 1: Popular Leagues (This part will scroll normally) --- */}
        <section
          className="flex flex-col gap-2 p-3 rounded-xl"
          style={{ backgroundColor: "var(--color-primary)" }}
        >
          <h2 className="text-sm font-bold uppercase tracking-wider text-text-muted px-2">
            {selectedCountry
              ? `Leagues in ${selectedCountry.name}`
              : t("popular_leagues")}
          </h2>
          {isLoadingLeagues ? (
            <div className="space-y-1">
              {Array.from({ length: 5 }).map((_, i) => (
                <LeagueItemSkeleton key={i} />
              ))}
            </div>
          ) : (
            <LeagueList leagues={leagues!} />
          )}
        </section>

        {/* --- AD SLOT WIDGET (Now Sticky) --- */}
        <AdSlotWidget location="homepage_left_sidebar" />

        {/* --- WIDGET 2: Popular Teams (Now Sticky) --- */}
        <section
          className="flex flex-col gap-2 p-3 rounded-xl sticky top-8"
          style={{ backgroundColor: "var(--color-primary)" }}
        >
          <h2 className="text-sm font-bold uppercase tracking-wider text-text-muted px-2">
            {t("popular_teams")}
          </h2>
          <PopularTeamsList />
        </section>
      </div>
    </aside>
  );
}


// ===== src/components/SidebarMatchItem.tsx =====

// src/components/SidebarMatchItem.tsx
"use client"; // This component is static but used in a client component, so it's good practice.

import Image from 'next/image';
import Link from '@/components/StyledLink'; 

interface SidebarMatchItemProps {
  match: {
    fixture: {
      id: number;
      status: {
        elapsed: number;
      };
    };
    teams: {
      home: { name: string; logo: string; };
      away: { name: string; logo: string; };
    };
    goals: {
      home: number;
      away: number;
    };
  };
}

// --- Main Minimal List Item Component for Sidebar ---
export default function SidebarMatchItem({ match }: SidebarMatchItemProps) {
  const { fixture, teams, goals } = match;

  return (
    <Link 
      href={`/football/match/${fixture.id}`} 
      className="block p-2.5 rounded-lg transition-colors duration-200 hover:bg-gray-700/50"
    >
      <div className="flex items-center gap-3 w-full">
        {/* Live Status */}
        <div className="flex flex-col items-center w-10 text-center text-brand-live font-semibold text-sm">
          <span>{fixture.status.elapsed}'</span>
          <div className="relative flex h-2 w-2 mt-1">
            <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span>
            <span className="relative inline-flex rounded-full h-2 w-2 bg-brand-live"></span>
          </div>
        </div>
        
        {/* Teams and Score */}
        <div className="flex-1 space-y-1.5 text-sm">
          {/* Home Team */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2 truncate">
              <Image src={teams.home.logo} alt={teams.home.name} width={18} height={18} />
              <span className="font-medium truncate">{teams.home.name}</span>
            </div>
            <span className="font-bold">{goals.home}</span>
          </div>
          {/* Away Team */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2 truncate">
              <Image src={teams.away.logo} alt={teams.away.name} width={18} height={18} />
              <span className="font-medium truncate">{teams.away.name}</span>
            </div>
            <span className="font-bold">{goals.away}</span>
          </div>
        </div>
      </div>
    </Link>
  );
}

// --- Skeleton for the Sidebar Match Item ---
export const SidebarMatchItemSkeleton = () => (
    <div className="flex items-center gap-3 w-full p-2.5 animate-pulse">
        <div className="flex flex-col items-center w-10">
            <div className="h-4 w-6 rounded bg-gray-600/50"></div>
            <div className="h-2 w-2 rounded-full bg-gray-600/50 mt-1.5"></div>
        </div>
        <div className="flex-1 space-y-2">
            <div className="flex items-center justify-between">
                <div className="h-4 w-3/5 rounded bg-gray-600/50"></div>
                <div className="h-4 w-4 rounded bg-gray-600/50"></div>
            </div>
            <div className="flex items-center justify-between">
                <div className="h-4 w-3/5 rounded bg-gray-600/50"></div>
                <div className="h-4 w-4 rounded bg-gray-600/50"></div>
            </div>
        </div>
    </div>
);

// ===== src/components/SocialShareButtons.tsx =====

// src/components/SocialShareButtons.tsx
"use client";

import {
  FacebookShareButton,
  FacebookIcon,
  TwitterShareButton,
  XIcon, // The new icon for Twitter
  WhatsappShareButton,
  WhatsappIcon,
  LinkedinShareButton,
  LinkedinIcon,
  TelegramShareButton,
  TelegramIcon,
  RedditShareButton,
  RedditIcon,
} from 'react-share';

interface SocialShareButtonsProps {
  url: string;
  title: string;
}

export default function SocialShareButtons({ url, title }: SocialShareButtonsProps) {
  const iconSize = 48;
  const iconBgStyle = { background: 'none' };
  const iconClassName = "rounded-full transition-transform duration-200 hover:scale-110";

  return (
    <div className="flex items-center justify-center gap-4 flex-wrap">
      <FacebookShareButton url={url} quote={title} className={iconClassName}>
        <FacebookIcon size={iconSize} round bgStyle={iconBgStyle} />
      </FacebookShareButton>

      <TwitterShareButton url={url} title={title} className={iconClassName}>
        <XIcon size={iconSize} round bgStyle={iconBgStyle} />
      </TwitterShareButton>

      <WhatsappShareButton url={url} title={title} separator=":: " className={iconClassName}>
        <WhatsappIcon size={iconSize} round bgStyle={iconBgStyle} />
      </WhatsappShareButton>

      <LinkedinShareButton url={url} title={title} className={iconClassName}>
        <LinkedinIcon size={iconSize} round bgStyle={iconBgStyle} />
      </LinkedinShareButton>

      <TelegramShareButton url={url} title={title} className={iconClassName}>
        <TelegramIcon size={iconSize} round bgStyle={iconBgStyle} />
      </TelegramShareButton>
      
      <RedditShareButton url={url} title={title} className={iconClassName}>
        <RedditIcon size={iconSize} round bgStyle={iconBgStyle} />
      </RedditShareButton>
    </div>
  );
}

// ===== src/components/StandingsDisplay.tsx =====

// src/components/StandingsDisplay.tsx
"use client";

import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Slider from "react-slick";
import Image from "next/image";
import { ChevronRight, Info } from "lucide-react";

import { useLeagueContext } from "@/context/LeagueContext";
import { proxyImageUrl } from "@/lib/image-proxy";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import StyledLink from "./StyledLink";
import { useTranslation } from "@/hooks/useTranslation";

// --- SELF-CONTAINED TYPE DEFINITIONS ---
interface Team {
  id: number;
  name: string;
  logo: string;
}
interface TeamStats {
  played: number;
  win: number;
  draw: number;
  lose: number;
}
interface TeamStanding {
  rank: number;
  team: Team;
  points: number;
  goalsDiff: number;
  group: string;
  description: string | null;
  all: TeamStats;
}
interface League {
  id: number;
  name: string;
  logo: string;
  href: string;
}
interface StandingsResponse {
  league: League | null;
  standings: TeamStanding[][];
}

// --- CONFIGURATION ---
const POPULAR_LEAGUES = [
  {
    id: 39,
    name: "Premier League",
    logo: "https://media.api-sports.io/football/leagues/39.png",
  },
  {
    id: 140,
    name: "La Liga",
    logo: "https://media.api-sports.io/football/leagues/140.png",
  },
  {
    id: 135,
    name: "Serie A",
    logo: "https://media.api-sports.io/football/leagues/135.png",
  },
  {
    id: 78,
    name: "Bundesliga",
    logo: "https://media.api-sports.io/football/leagues/78.png",
  },
  {
    id: 61,
    name: "Ligue 1",
    logo: "https://media.api-sports.io/football/leagues/61.png",
  },
];

// --- FETCHER ---
const fetchStandings = async (
  leagueId: number,
  season: number
): Promise<StandingsResponse> => {
  const { data } = await axios.get(
    `/api/standings?league=${leagueId}&season=${season}`
  );
  return data;
};

// --- UI HELPERS ---
const getRankIndicatorClass = (description: string | null): string => {
  if (!description) return "bg-gray-700 text-brand-light";
  const desc = description.toLowerCase();
  if (desc.includes("champions league") || desc.includes("promotion"))
    return "bg-green-500/20 text-green-400";
  if (desc.includes("europa league") || desc.includes("qualification"))
    return "bg-orange-500/20 text-orange-400";
  if (desc.includes("conference league") || desc.includes("play-off"))
    return "bg-sky-400/20 text-sky-300";
  if (desc.includes("relegation")) return "bg-red-600/20 text-red-500";
  return "bg-gray-700 text-brand-light";
};

// --- INTERNAL TABLE COMPONENT ---
const InternalStandingTable = ({
  group,
  league,
}: {
  group: TeamStanding[];
  league: League;
}) => {
  const { t } = useTranslation();
  const validGroup = group.filter((item) => item && item.team);
  if (validGroup.length === 0) return null;

  return (
    <div className="px-1 overflow-y-auto max-h-96 custom-scrollbar">
      <table className="w-full text-sm">
        <thead className="text-left text-brand-muted sticky top-0 bg-brand-secondary z-10">
          <tr className="text-xs">
            <th className="p-2 w-8 text-center">#</th>
            <th className="p-2">{t("table_header_team")}</th>
            <th className="p-2 text-center">P</th>
            <th className="p-2 text-center">GD</th>
            <th className="p-2 text-center font-bold">Pts</th>
          </tr>
        </thead>
        <tbody className="text-brand-light">
          {validGroup.map((item) => (
            <tr key={item.team.id} className="border-t border-gray-700/50">
              <td className="p-2 text-center">
                <span
                  className={`w-6 h-6 flex items-center justify-center text-xs font-bold rounded-md ${getRankIndicatorClass(
                    item.description
                  )}`}
                >
                  {item.rank}
                </span>
              </td>
              <td className="p-2">
                <StyledLink
                  href={generateTeamSlug(item.team.name, item.team.id)}
                  className="flex items-center gap-2 group"
                >
                  <Image
                    src={proxyImageUrl(item.team.logo)}
                    alt={item.team.name}
                    width={20}
                    height={20}
                  />
                  <span className="font-semibold group-hover:text-brand-purple transition-colors whitespace-nowrap">
                    {item.team.name}
                  </span>
                </StyledLink>
              </td>
              <td className="p-2 text-center">{item.all.played}</td>
              <td className="p-2 text-center">{item.goalsDiff}</td>
              <td className="p-2 text-center font-bold text-white">
                {item.points}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

// --- LOADING SKELETON ---
const StandingsDisplaySkeleton = () => (
  <div className="bg-brand-secondary rounded-lg h-[480px] animate-pulse">
    <div className="p-2 border-b border-gray-700/50 flex space-x-1">
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
      <div className="flex-1 h-10 bg-gray-700 rounded-md"></div>
    </div>
    <div className="p-4">
      <div className="flex justify-between items-center mb-4">
        <div className="h-5 w-2/5 bg-gray-700 rounded"></div>
        <div className="h-4 w-1/4 bg-gray-700 rounded"></div>
      </div>
      <div className="space-y-2">
        {[...Array(8)].map((_, i) => (
          <div key={i} className="flex items-center gap-3 h-8">
            <div className="w-6 h-6 bg-gray-600 rounded"></div>
            <div className="w-5 h-5 bg-gray-600 rounded-full"></div>
            <div className="flex-1 h-4 bg-gray-600 rounded"></div>
            <div className="w-6 h-4 bg-gray-600 rounded"></div>
          </div>
        ))}
      </div>
    </div>
  </div>
);

// --- MAIN WIDGET COMPONENT ---
export default function StandingsDisplay() {
  const { t } = useTranslation();
  const { selectedLeague } = useLeagueContext();
  const [activePopularLeagueId, setActivePopularLeagueId] = useState(
    POPULAR_LEAGUES[0].id
  );
  const season = new Date().getFullYear();
  const leagueIdToFetch = selectedLeague?.id || activePopularLeagueId;

  const { data, isLoading, isError } = useQuery<StandingsResponse>({
    queryKey: ["standings", leagueIdToFetch, season],
    queryFn: () => fetchStandings(leagueIdToFetch, season),
    staleTime: 1000 * 60 * 15,
  });

  const sliderSettings = {
    dots: true,
    infinite: false,
    speed: 500,
    slidesToShow: 1,
    slidesToScroll: 1,
    arrows: false,
    appendDots: (dots: any) => (
      <div>
        <ul className="m-0 pt-3"> {dots} </ul>
      </div>
    ),
  };

  const sanitizedStandingsGroups = data?.standings?.filter(
    (group) => group && group.length > 0
  );
  const hasStandings =
    sanitizedStandingsGroups && sanitizedStandingsGroups.length > 0;
  const showTabs = !selectedLeague || (selectedLeague && !hasStandings);

  if (isLoading) return <StandingsDisplaySkeleton />;

  return (
    <div className="bg-brand-secondary rounded-lg">
      {showTabs && (
        <div className="flex items-center p-2 space-x-1 border-b border-gray-700/50">
          {POPULAR_LEAGUES.map((popLeague) => (
            <button
              key={popLeague.id}
              onClick={() => setActivePopularLeagueId(popLeague.id)}
              className={`group flex-1 p-2 rounded-md transition-colors ${
                activePopularLeagueId === popLeague.id
                  ? "bg-brand-purple/20"
                  : "hover:bg-white/5"
              }`}
              title={popLeague.name}
            >
              <Image
                src={proxyImageUrl(popLeague.logo)}
                alt={popLeague.name}
                width={24}
                height={24}
                className="mx-auto transition-transform duration-300 ease-in-out group-hover:scale-110"
              />
            </button>
          ))}
        </div>
      )}

      <div className="p-4">
        {hasStandings && data?.league ? (
          <>
            <div className="flex justify-between items-center mb-3">
              <h3 className="text-white font-bold">{data.league.name}</h3>
              <StyledLink
                href={data.league.href}
                className="text-xs text-brand-muted hover:text-white flex items-center gap-1"
              >
                View Full Table <ChevronRight size={14} />
              </StyledLink>
            </div>
            {sanitizedStandingsGroups.length === 1 ? (
              <InternalStandingTable
                group={sanitizedStandingsGroups[0]}
                league={data.league}
              />
            ) : (
              <Slider {...sliderSettings}>
                {sanitizedStandingsGroups.map((group) => (
                  <div key={group[0].group}>
                    <h4 className="text-center text-brand-light font-bold text-sm mb-2">
                      {group[0].group}
                    </h4>
                    <InternalStandingTable
                      group={group}
                      league={data.league!}
                    />
                  </div>
                ))}
              </Slider>
            )}
          </>
        ) : (
          <div className="text-center py-6">
            <Info size={32} className="mx-auto text-brand-muted mb-3" />
            <h4 className="font-bold text-white mb-1">
              {data?.league?.name ||
                selectedLeague?.name ||
                t("no_standings_title")}
            </h4>
            <p className="text-sm text-brand-muted">
              {t("standings_not_available")}
              {showTabs && t("select_another_league_prompt")}
            </p>
          </div>
        )}
      </div>
    </div>
  );
}


// ===== src/components/StickyFooterAd.tsx =====

// src/components/StickyFooterAd.tsx
"use client";

import { useState, useEffect, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import Image from "next/image";
import { X } from "lucide-react";

// Self-contained type definition
interface IBanner {
  _id: string;
  title: string;
  imageUrl: string;
  linkUrl: string;
  isActive: boolean;
}

export default function StickyFooterAd() {
  const [isDismissed, setIsDismissed] = useState(true);
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (sessionStorage.getItem("footerAdDismissed") === "true") {
      setIsDismissed(true);
    } else {
      setIsDismissed(false);
    }
  }, []);

  // --- MODIFIED: The API call is now parameterized directly ---
  // This uses the existing data fetching pattern without introducing new functions.
  const { data: banners, isLoading } = useQuery<IBanner[]>({
    // A more specific query key to avoid cache collisions with other banner slots.
    queryKey: ["sticky_footer"],
    queryFn: () =>
      axios
        .get("/api/banners?active=true&location=sticky_footer")
        .then((res) => res.data),
    staleTime: 5 * 60 * 1000,
    refetchOnWindowFocus: false,
  });

  const randomAd = useMemo(() => {
    if (!banners || banners.length === 0) return null;
    const randomIndex = Math.floor(Math.random() * banners.length);
    return banners[randomIndex];
  }, [banners]);

  // Effect to trigger the slide-up animation
  useEffect(() => {
    if (!isLoading && randomAd && !isDismissed) {
      const timer = setTimeout(() => setIsVisible(true), 100);
      return () => clearTimeout(timer);
    }
  }, [isLoading, randomAd, isDismissed]);

  const handleDismiss = () => {
    setIsVisible(false);
    setTimeout(() => {
      setIsDismissed(true);
      sessionStorage.setItem("footerAdDismissed", "true");
    }, 500);
  };

  if (!randomAd || isDismissed) {
    return null;
  }

  return (
    <div className="fixed inset-0 top-auto z-50 flex justify-center p-2 pointer-events-none">
      <div
        className={`
          pointer-events-auto flex items-center gap-4 w-full max-w-lg 
          bg-brand-secondary/80 backdrop-blur-sm 
          border border-gray-600/50 shadow-2xl shadow-black/50 rounded-lg
          transition-all duration-500 ease-in-out
          ${
            isVisible
              ? "translate-y-0 opacity-100"
              : "translate-y-full opacity-0"
          }
        `}
      >
        <a
          href={randomAd.linkUrl}
          target="_blank"
          rel="noopener sponsored"
          className="flex-grow flex items-center gap-4 p-3 group"
        >
          <div className="flex-shrink-0 w-20 h-16 relative">
            <Image
              src={randomAd.imageUrl}
              alt={randomAd.title}
              layout="fill"
              objectFit="cover"
              className="rounded-md"
            />
          </div>
          <div className="flex-grow min-w-0">
            <p className="text-xs text-brand-muted">Sponsored</p>
            <h4 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
              {randomAd.title}
            </h4>
          </div>
        </a>

        <button
          onClick={handleDismiss}
          className="flex-shrink-0 self-start p-2 text-brand-muted hover:text-white"
          aria-label="Close ad"
        >
          <X size={18} />
        </button>
      </div>
    </div>
  );
}


// ===== src/components/StyledLink.tsx =====

"use client";

import { default as NextLink, LinkProps } from "next/link";
import NProgress from "nprogress";
import React from "react"; // Import React to use React.CSSProperties

// This is a client-side component that wraps the standard Next.js Link.
// It starts the NProgress bar on click.
export default function StyledLink({
  href,
  children,
  className,
  style, // Add style prop here
  ...props
}: LinkProps & {
  children: React.ReactNode;
  className?: string;
  style?: React.CSSProperties; // Define type for style prop
} & any) {
  const handleLinkClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
    // Check if it's a link to a different page before starting the progress bar.
    // This prevents the bar from showing for on-page anchor links.
    const currentPath = window.location.pathname;
    if (href.toString() !== currentPath) {
      NProgress.start();
    }

    // If there's an existing onClick handler, make sure to call it.
    if (props.onClick) {
      props.onClick(e);
    }
  };

  return (
    <NextLink
      href={href}
      className={className}
      style={style} // Apply style prop here
      {...props}
      onClick={handleLinkClick}
    >
      {children}
    </NextLink>
  );
}


// ===== src/components/tabs/LineupsTab.tsx =====

import Image from 'next/image';

const PlayerList = ({ title, players }: { title: string, players: any[] }) => (
  <div>
    <h4 className="font-bold text-lg mb-2 text-brand-muted">{title}</h4>
    <ul className="space-y-3">
      {players.map((p: any) => (
        <li key={p.player.id} className="flex items-center gap-3">
          <span className="text-brand-muted font-mono w-6 text-center">{p.player.number}</span>
          <span>{p.player.name}</span>
        </li>
      ))}
    </ul>
  </div>
);

// This component displays the starting XI and substitutes for both teams
export default function LineupsTab({ lineups }: { lineups: any[] }) {
  if (!lineups || lineups.length < 2) {
    return <p className="text-brand-muted text-center py-8">Lineups are not yet available.</p>;
  }

  const homeLineup = lineups[0];
  const awayLineup = lineups[1];

  return (
    <div className="p-4 grid grid-cols-1 md:grid-cols-2 gap-8">
      {/* Home Team */}
      <div>
        <div className="flex items-center gap-3 mb-4">
          <Image src={homeLineup.team.logo} alt={homeLineup.team.name} width={32} height={32}/>
          <h3 className="font-bold text-xl">{homeLineup.team.name}</h3>
        </div>
        <p className="mb-4 text-brand-muted">Formation: {homeLineup.formation}</p>
        <PlayerList title="Starting XI" players={homeLineup.startXI} />
        <PlayerList title="Substitutes" players={homeLineup.substitutes} />
      </div>
      {/* Away Team */}
      <div>
        <div className="flex items-center gap-3 mb-4">
          <Image src={awayLineup.team.logo} alt={awayLineup.team.name} width={32} height={32}/>
          <h3 className="font-bold text-xl">{awayLineup.team.name}</h3>
        </div>
        <p className="mb-4 text-brand-muted">Formation: {awayLineup.formation}</p>
        <PlayerList title="Starting XI" players={awayLineup.startXI} />
        <PlayerList title="Substitutes" players={awayLineup.substitutes} />
      </div>
    </div>
  );
}

// ===== src/components/tabs/StatsTab.tsx =====

import { BarChart2 } from 'lucide-react';

// This component displays a side-by-side comparison of team stats
export default function StatsTab({ statistics, teams }: { statistics: any[], teams: any }) {
  if (!statistics || statistics.length < 2) {
    return <p className="text-brand-muted text-center py-8">Statistics are not available for this match.</p>;
  }

  const homeStats = statistics.find((s: any) => s.team.id === teams.home.id)?.statistics || [];
  const awayStats = statistics.find((s: any) => s.team.id === teams.away.id)?.statistics || [];
  
  // Combine stats to ensure we display all available types
  const allStatTypes = Array.from(new Set([...homeStats.map((s: any) => s.type), ...awayStats.map((s: any) => s.type)]));

  return (
    <div className="space-y-4 p-4">
      {allStatTypes.map((type) => {
        const homeStat = homeStats.find((s: any) => s.type === type)?.value ?? 0;
        const awayStat = awayStats.find((s: any) => s.type === type)?.value ?? 0;
        const total = (Number(homeStat) || 0) + (Number(awayStat) || 0);
        const homePercent = total > 0 ? ((Number(homeStat) || 0) / total) * 100 : 50;

        return (
          <div key={type}>
            <div className="flex justify-between items-center mb-1 text-sm font-semibold">
              <span>{homeStat ?? 0}</span>
              <span className="text-brand-muted">{type}</span>
              <span>{awayStat ?? 0}</span>
            </div>
            <div className="flex w-full h-2 rounded-full overflow-hidden bg-gray-700">
              <div className="bg-brand-purple" style={{ width: `${homePercent}%` }}></div>
              <div className="bg-blue-600" style={{ width: `${100 - homePercent}%` }}></div>
            </div>
          </div>
        );
      })}
    </div>
  );
}

// ===== src/components/team/index.tsx =====

// src/components/TeamDetailView.tsx
"use client";

import { useState } from "react";
import AdSlotWidget from "@/components/AdSlotWidget";

// New Components
import TeamHeader from "./TeamHeader";
import TeamInfoWidget from "./TeamInfoWidget";
import TeamTrophiesWidget from "./TeamTrophiesWidget";
import TeamSquadTab from "./TeamSquadTab";
// We can reuse the fixtures widget from the league page
import LeagueFixturesWidget from "@/components/league-detail-view/LeagueFixturesWidget";

const TABS = ["Squad", "Fixtures", "Standings"];

export default function TeamDetailView({ teamData }: { teamData: any }) {
  const [activeTab, setActiveTab] = useState(TABS[0]);

  const { teamInfo, squad, fixtures } = teamData;
  const { team, venue } = teamInfo;

  return (
    <div>
      <TeamHeader team={team} countryFlag={fixtures?.[0]?.league?.flag || ""} />

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 items-start">
        <div className="lg:col-span-2 space-y-6">
          <div className="bg-brand-secondary rounded-lg p-2 flex items-center space-x-2">
            {TABS.map((tab) => (
              <button
                key={tab}
                onClick={() => setActiveTab(tab)}
                className={`flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-colors ${
                  activeTab === tab
                    ? "bg-brand-purple text-white"
                    : "text-brand-muted hover:bg-gray-700/50"
                }`}
              >
                {tab}
              </button>
            ))}
          </div>

          <div>
            {activeTab === "Squad" && <TeamSquadTab squad={squad} />}
            {activeTab === "Fixtures" && (
              // The fixtures widget needs a leagueId. We get it from the team's first fixture.
              <LeagueFixturesWidget leagueId={fixtures?.[0]?.league?.id} />
            )}
            {activeTab === "Standings" && (
              <div className="bg-brand-secondary p-8 rounded-lg text-center">
                <p>Team Standings Tab - Coming Soon!</p>
              </div>
            )}
          </div>
        </div>

        <aside className="lg:col-span-1 space-y-6">
          <TeamInfoWidget venue={venue} />
          <TeamTrophiesWidget teamId={team.id} />
          <AdSlotWidget />
        </aside>
      </div>
    </div>
  );
}


// ===== src/components/team/TeamFixturesWidget.tsx =====

// src/components/team/TeamFixturesWidget.tsx
"use client";

import { useState, useMemo } from "react";
import { Info } from "lucide-react";
// We can reuse the same list item component for a consistent look
import MatchListItem from "../MatchListItem";

interface TeamFixturesWidgetProps {
  fixtures: any[]; // The array of fixtures fetched on the server
}

export default function TeamFixturesWidget({
  fixtures,
}: TeamFixturesWidgetProps) {
  const [activeTab, setActiveTab] = useState<"upcoming" | "results">(
    "upcoming"
  );

  const filteredMatches = useMemo(() => {
    if (!fixtures) return [];

    // Sort all fixtures by date first to ensure correct order
    const sortedFixtures = [...fixtures].sort(
      (a, b) =>
        new Date(a.fixture.date).getTime() - new Date(b.fixture.date).getTime()
    );

    if (activeTab === "upcoming") {
      // Filter for matches that are not finished
      return sortedFixtures.filter(
        (m: any) => !["FT", "AET", "PEN"].includes(m.fixture.status.short)
      );
    } else {
      // Filter for finished matches and reverse to show most recent first
      return sortedFixtures
        .filter((m: any) =>
          ["FT", "AET", "PEN"].includes(m.fixture.status.short)
        )
        .reverse();
    }
  }, [fixtures, activeTab]);

  return (
    <div className="bg-brand-secondary rounded-xl p-4">
      <div className="flex justify-end items-center mb-4">
        {/* The control tabs for switching between views */}
        <div className="flex items-center gap-1 bg-gray-700/50 p-1 rounded-lg">
          <button
            onClick={() => setActiveTab("upcoming")}
            className={`px-3 py-1 text-sm rounded-md font-semibold transition-colors ${
              activeTab === "upcoming"
                ? "bg-brand-purple text-white"
                : "text-brand-muted hover:bg-gray-700"
            }`}
          >
            Upcoming
          </button>
          <button
            onClick={() => setActiveTab("results")}
            className={`px-3 py-1 text-sm rounded-md font-semibold transition-colors ${
              activeTab === "results"
                ? "bg-brand-purple text-white"
                : "text-brand-muted hover:bg-gray-700"
            }`}
          >
            Results
          </button>
        </div>
      </div>

      <div className="space-y-3 max-h-[800px] overflow-y-auto scrollbar-thin scrollbar-track-transparent scrollbar-thumb-gray-600 pr-2">
        {filteredMatches && filteredMatches.length > 0 ? (
          filteredMatches.map((match: any) => (
            <MatchListItem key={match.fixture.id} match={match} />
          ))
        ) : (
          <div className="text-center py-10 text-brand-muted">
            <Info size={32} className="mx-auto mb-3" />
            <p>No {activeTab} matches found.</p>
          </div>
        )}
      </div>
    </div>
  );
}


// ===== src/components/team/TeamHeader.tsx =====

// src/components/team/TeamHeader.tsx
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";
import { Calendar } from "lucide-react";

export default function TeamHeader({
  team,
  countryFlag,
}: {
  team: any;
  countryFlag: string;
}) {
  return (
    <div className="bg-brand-secondary p-6 rounded-lg mb-8 flex flex-col md:flex-row items-center gap-6">
      <div className="relative">
        <Image
          src={proxyImageUrl(team.logo)}
          alt={`${team.name} logo`}
          width={96}
          height={96}
        />
        <Image
          src={countryFlag}
          alt={team.country}
          width={32}
          height={32}
          className="rounded-full absolute -bottom-2 -right-2 border-2 border-brand-secondary"
        />
      </div>
      <div>
        <h1 className="text-4xl md:text-5xl font-extrabold text-white text-center md:text-left">
          {team.name}
        </h1>
        {team.founded && (
          <div className="flex items-center gap-2 text-brand-muted justify-center md:justify-start mt-2">
            <Calendar size={14} />
            <span>Founded in {team.founded}</span>
          </div>
        )}
      </div>
    </div>
  );
}


// ===== src/components/team/TeamInfoWidget.tsx =====

// src/components/team/TeamInfoWidget.tsx
import { MapPin, Users } from "lucide-react";

const InfoRow = ({
  icon: Icon,
  label,
  value,
}: {
  icon: React.ElementType;
  label: string;
  value: string | number;
}) => (
  <div className="flex justify-between items-center text-sm py-2 border-b border-gray-700/50">
    <div className="flex items-center gap-2 text-brand-muted">
      <Icon size={14} />
      <span>{label}</span>
    </div>
    <span className="font-semibold text-white text-right">{value}</span>
  </div>
);

export default function TeamInfoWidget({ venue }: { venue: any }) {
  return (
    <div className="bg-brand-secondary p-4 rounded-lg">
      <h3 className="text-lg font-bold text-white mb-2">Venue Information</h3>
      <div className="space-y-1">
        <InfoRow icon={MapPin} label="Stadium" value={venue.name} />
        <InfoRow icon={MapPin} label="City" value={venue.city} />
        <InfoRow
          icon={Users}
          label="Capacity"
          value={venue.capacity?.toLocaleString()}
        />
      </div>
    </div>
  );
}


// ===== src/components/team/TeamSquadTab.tsx =====

// src/components/team/TeamSquadTab.tsx
import Image from "next/image";
import { proxyImageUrl } from "@/lib/image-proxy";

const PlayerCard = ({ player }: { player: any }) => (
  <div className="bg-brand-secondary rounded-lg p-3 flex items-center gap-3">
    <Image
      src={proxyImageUrl(player.photo)}
      alt={player.name}
      width={48}
      height={48}
      className="rounded-full"
    />
    <div className="flex-1">
      <p className="font-bold text-white">{player.name}</p>
      <p className="text-sm text-brand-muted">{player.position}</p>
    </div>
    <div className="text-2xl font-black text-brand-muted w-12 text-center">
      {player.number || "-"}
    </div>
  </div>
);

export default function TeamSquadTab({ squad }: { squad: any[] }) {
  const goalkeepers = squad.filter((p) => p.position === "Goalkeeper");
  const defenders = squad.filter((p) => p.position === "Defender");
  const midfielders = squad.filter((p) => p.position === "Midfielder");
  const attackers = squad.filter((p) => p.position === "Attacker");

  const renderPositionGroup = (title: string, players: any[]) => {
    if (players.length === 0) return null;
    return (
      <div>
        <h4 className="text-lg font-bold text-brand-light mb-3 mt-4 border-b border-gray-700 pb-2">
          {title}
        </h4>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
          {players.map((player) => (
            <PlayerCard
              key={player.id + Date.now().toString()}
              player={player}
            />
          ))}
        </div>
      </div>
    );
  };

  return (
    <div className="space-y-6">
      {renderPositionGroup("Goalkeepers", goalkeepers)}
      {renderPositionGroup("Defenders", defenders)}
      {renderPositionGroup("Midfielders", midfielders)}
      {renderPositionGroup("Attackers", attackers)}
    </div>
  );
}


// ===== src/components/team/TeamTrophiesWidget.tsx =====

// src/components/team/TeamTrophiesWidget.tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { Trophy } from "lucide-react";

const fetchTrophies = async (teamId: number) => {
  const { data } = await axios.get(`/api/team-trophies?team=${teamId}`);
  return data;
};

const Skeleton = () => (
  <div className="bg-brand-secondary p-4 rounded-lg animate-pulse">
    <div className="h-5 w-3/4 mb-4 bg-gray-700 rounded"></div>
    <div className="space-y-3">
      <div className="h-8 w-full bg-gray-600 rounded"></div>
      <div className="h-8 w-full bg-gray-600 rounded"></div>
      <div className="h-8 w-full bg-gray-600 rounded"></div>
    </div>
  </div>
);

export default function TeamTrophiesWidget({ teamId }: { teamId: number }) {
  const {
    data: trophies,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["teamTrophies", teamId],
    queryFn: () => fetchTrophies(teamId),
    staleTime: 1000 * 60 * 60 * 24, // Trophies don't change often
  });

  if (isLoading) return <Skeleton />;
  if (isError || !trophies || trophies.length === 0) return null;

  return (
    <div className="bg-brand-secondary p-4 rounded-lg">
      <h3 className="text-lg font-bold text-white mb-4">Honours</h3>
      <div className="space-y-2 max-h-80 overflow-y-auto scrollbar-thin scrollbar-track-transparent scrollbar-thumb-gray-600">
        {trophies.map((trophy: any, index: number) => (
          <div
            key={`${trophy.league}-${trophy.season}-${index}`}
            className="flex items-center gap-3 bg-gray-800/50 p-2 rounded-md"
          >
            <Trophy className="w-5 h-5 text-yellow-500 flex-shrink-0" />
            <div className="flex-1">
              <p className="text-sm font-semibold text-white">
                {trophy.league}
              </p>
              <p className="text-xs text-brand-muted">{trophy.season}</p>
            </div>
            <p className="text-sm font-bold text-brand-light">{trophy.place}</p>
          </div>
        ))}
      </div>
    </div>
  );
}


// ===== src/components/TeamDetailView.tsx =====

// src/components/TeamDetailView.tsx
"use client";

import { useState } from "react";
import AdSlotWidget from "./AdSlotWidget";

// Component Imports
import TeamHeader from "./team/TeamHeader";
import TeamInfoWidget from "./team/TeamInfoWidget";
import TeamTrophiesWidget from "./team/TeamTrophiesWidget";
import TeamSquadTab from "./team/TeamSquadTab";
// --- IMPORT THE NEW, CORRECT WIDGET ---
import TeamFixturesWidget from "./team/TeamFixturesWidget";

const TABS = ["Squad", "Fixtures", "Standings"];

export default function TeamDetailView({ teamData }: { teamData: any }) {
  const [activeTab, setActiveTab] = useState(TABS[1]); // Default to Fixtures tab

  // Destructure the data passed from the server-side page
  const { teamInfo, squad, fixtures } = teamData;
  const { team, venue } = teamInfo;

  return (
    <div>
      <TeamHeader team={team} countryFlag={fixtures?.[0]?.league?.flag || ""} />

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 items-start">
        <div className="lg:col-span-2 space-y-6">
          <div className="bg-brand-secondary rounded-lg p-2 flex items-center space-x-2">
            {TABS.map((tab) => (
              <button
                key={tab}
                onClick={() => setActiveTab(tab)}
                className={`flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-colors ${
                  activeTab === tab
                    ? "bg-brand-purple text-white"
                    : "text-brand-muted hover:bg-gray-700/50"
                }`}
              >
                {tab}
              </button>
            ))}
          </div>

          <div>
            {activeTab === "Squad" && <TeamSquadTab squad={squad} />}

            {/* --- THIS IS THE FIX --- */}
            {/* Replace the old widget with the new one, passing the pre-fetched fixtures data */}
            {activeTab === "Fixtures" && (
              <TeamFixturesWidget fixtures={fixtures} />
            )}

            {activeTab === "Standings" && (
              <div className="bg-brand-secondary p-8 rounded-lg text-center">
                <p>Team Standings Tab - Coming Soon!</p>
              </div>
            )}
          </div>
        </div>

        <aside className="lg:col-span-1 space-y-6">
          <TeamInfoWidget venue={venue} />
          <TeamTrophiesWidget teamId={team.id} />
        </aside>
      </div>
    </div>
  );
}


// ===== src/components/TeamDirectoryCard.tsx =====

// src/components/TeamDirectoryCard.tsx
import Image from "next/image";
import StyledLink from "./StyledLink";
import { generateTeamSlug } from "@/lib/generate-team-slug";
import { proxyImageUrl } from "@/lib/image-proxy"; // <-- IMPORT

interface TeamDirectoryCardProps {
  team: { id: number; name: string; logo: string };
  venue: { name: string; city: string };
}

export const TeamDirectoryCardSkeleton = () => (
  <div className="bg-brand-secondary rounded-lg p-4 flex items-center gap-4 animate-pulse">
    <div className="w-10 h-10 rounded-full bg-gray-700"></div>
    <div className="space-y-2 flex-1">
      <div className="h-4 w-3/4 rounded bg-gray-600"></div>
      <div className="h-3 w-1/2 rounded bg-gray-600"></div>
    </div>
  </div>
);

export default function TeamDirectoryCard({
  team,
  venue,
}: TeamDirectoryCardProps) {
  const href = generateTeamSlug(team.name, team.id);

  return (
    <StyledLink href={href} className="block group">
      <div className="bg-brand-secondary rounded-lg p-4 flex items-center gap-4 transition-all duration-300 transform hover:-translate-y-1 hover:shadow-lg hover:shadow-purple-900/20">
        <Image
          // --- APPLY PROXY ---
          src={proxyImageUrl(team.logo)}
          alt={`${team.name} logo`}
          width={40}
          height={40}
          className="flex-shrink-0"
        />
        <div className="min-w-0">
          <h3 className="font-bold text-white truncate group-hover:text-brand-purple transition-colors">
            {team.name}
          </h3>
          <p className="text-sm text-brand-muted">{venue?.city || "Unknown"}</p>
        </div>
      </div>
    </StyledLink>
  );
}


// ===== src/components/UpcomingMatchesSlider.tsx =====

// src/components/UpcomingMatchesSlider.tsx
"use client";

import Slider from "react-slick";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { useLeagueContext } from "@/context/LeagueContext";

// Import both slide types
import MatchSlide from "./MatchSlide";
import FinishedMatchSlide from "./FinishedMatchSlide";

// Fetcher function - no changes needed, it still calls the same endpoint
const fetchLeagueMatches = async (leagueId: number) => {
  const { data } = await axios.get(`/api/upcoming-matches?league=${leagueId}`);
  return data;
};

// --- A new Skeleton component for the slider ---
const SliderSkeleton = () => (
    <div className="relative w-full h-64 overflow-hidden rounded-2xl bg-brand-secondary p-8 animate-pulse">
        <div className="flex h-full items-center justify-center">
            <div className="h-12 w-80 rounded bg-gray-600/50"></div>
        </div>
    </div>
);

export default function UpcomingMatchesSlider() {
  const { selectedLeague } = useLeagueContext();

  // The query now fetches either upcoming or finished matches
  const { data: matches, isLoading } = useQuery({
    queryKey: ['leagueMatches', selectedLeague?.id],
    queryFn: () => fetchLeagueMatches(selectedLeague!.id),
    enabled: !!selectedLeague, // Only run if a league is selected
    staleTime: 1000 * 60 * 5, // Cache for 5 minutes
  });

  const sliderSettings = {
    dots: true,
    infinite: true,
    speed: 500,
    slidesToShow: 1,
    slidesToScroll: 1,
    autoplay: true,
    autoplaySpeed: 7000,
    pauseOnHover: true,
    arrows: false,
    appendDots: (dots: any) => (
      <div><ul className="-bottom-5 relative">{dots}</ul></div>
    ),
  };
  
  if (isLoading) {
    return <SliderSkeleton />;
  }

  // Handle case with no upcoming or finished matches found
  if (!matches || matches.length === 0) {
    return (
        <div className="flex h-64 items-center justify-center rounded-xl bg-brand-secondary text-brand-muted">
            No recent or upcoming matches found for this league.
        </div>
    );
  }

  return (
    <div className="w-full">
      <Slider {...sliderSettings}>
        {matches.map((match: any) => {
          // --- HERE IS THE LOGIC TO CHOOSE THE SLIDE ---
          // Check the match status to decide which component to render
          const isFinished = match.fixture.status.short === 'FT';

          return (
            <div key={match.fixture.id} className="px-1">
              {isFinished ? (
                <FinishedMatchSlide match={match} />
              ) : (
                <MatchSlide match={match} />
              )}
            </div>
          );
        })}
      </Slider>
    </div>
  );
}

// ===== src/components/VotingPanel.tsx =====

"use client";

import { useState, memo } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'axios';
import Image from 'next/image';
import { useVoteStorage } from '@/hooks/useVoteStorage'; // Assumes this hook exists

// --- Type Definitions ---
interface VoteData {
    homeVotes: number;
    drawVotes: number;
    awayVotes: number;
}
interface VotingPanelProps {
    fixtureId: number;
    teams: { home: any; away: any; };
}

// --- API Helper Functions ---
const getVotes = async (fixtureId: number): Promise<VoteData> => {
    const { data } = await axios.get(`/api/votes?fixture=${fixtureId}`);
    return data;
};

const submitVote = async ({ fixtureId, vote }: { fixtureId: number; vote: string }): Promise<VoteData> => {
    const { data } = await axios.post('/api/votes', { fixtureId, vote });
    return data;
};

// --- Skeleton Component for Loading State ---
const PanelSkeleton = () => (
    <div className="animate-pulse p-4">
        <div className="h-4 w-1/2 mx-auto rounded bg-gray-600/50 mb-4"></div>
        <div className="grid grid-cols-3 gap-3">
            <div className="h-24 rounded-lg bg-gray-700/50"></div>
            <div className="h-24 rounded-lg bg-gray-700/50"></div>
            <div className="h-24 rounded-lg bg-gray-700/50"></div>
        </div>
    </div>
);

// --- Main VotingPanel Component ---
const VotingPanel = memo(function VotingPanel({ fixtureId, teams }: VotingPanelProps) {
    const queryClient = useQueryClient();
    const { setVote, getVoteForFixture } = useVoteStorage();
    
    // Initialize state by checking if a vote exists in local storage.
    const [hasVoted, setHasVoted] = useState(() => !!getVoteForFixture(fixtureId));

    // Query to fetch live community vote data
    const { data: voteData, isLoading } = useQuery({
        queryKey: ['votes', fixtureId],
        queryFn: () => getVotes(fixtureId),
        staleTime: 1000 * 60, // Refetch data every minute to show new votes
    });

    // Mutation to submit a new vote
    const voteMutation = useMutation({
        mutationFn: submitVote,
        onSuccess: () => {
            // After a successful vote, immediately refetch the vote counts to get the latest data.
            queryClient.invalidateQueries({ queryKey: ['votes', fixtureId] });
        },
    });

    const handleVote = (choice: 'home' | 'draw' | 'away') => {
        if (hasVoted) return; // Prevent re-voting
        
        setVote(fixtureId, choice); // Save to local storage
        setHasVoted(true);          // Update state to show results immediately
        voteMutation.mutate({ fixtureId, vote: choice }); // Send the vote to the backend
    };

    const handleBetClick = (e: React.MouseEvent) => {
        e.stopPropagation();
        console.log(`User clicked Bet Now for fixture ${fixtureId}`);
        // Example: window.open('https://chinchincasino.com', '_blank');
    };

    if (isLoading) {
        return <PanelSkeleton />;
    }

    if (!voteData) {
        return <p className="text-center text-sm text-brand-muted py-4">Could not load voting data.</p>;
    }

    // Calculate percentages from community votes for the results view
    const totalVotes = voteData.homeVotes + voteData.drawVotes + voteData.awayVotes;
    const homePercent = totalVotes > 0 ? Math.round((voteData.homeVotes / totalVotes) * 100) : 34;
    const awayPercent = totalVotes > 0 ? Math.round((voteData.awayVotes / totalVotes) * 100) : 33;
    const drawPercent = 100 - homePercent - awayPercent;

    return (
        <div className="bg-[#1F1D2B] p-4 border-t-2 border-gray-900/50">
            {!hasVoted ? (
                // --- VOTING VIEW ---
                <>
                    <h4 className="text-center text-sm font-bold text-brand-muted mb-3 tracking-wider">WHO WILL WIN?</h4>
                    <div className="flex justify-center items-stretch gap-3">
                        <button onClick={() => handleVote('home')} className="flex-1 flex flex-col items-center gap-2 p-3 rounded-lg bg-gray-800/60 hover:bg-brand-purple transition-all duration-200 transform hover:-translate-y-1">
                            <Image src={teams.home.logo} alt={teams.home.name} width={48} height={48} className="object-contain h-12"/>
                            <span className="text-xs font-semibold text-white truncate">{teams.home.name}</span>
                        </button>
                        <button onClick={() => handleVote('draw')} className="flex-1 flex flex-col items-center justify-center gap-2 p-3 rounded-lg bg-gray-800/60 hover:bg-brand-purple transition-all duration-200 transform hover:-translate-y-1">
                            <span className="font-bold text-3xl text-white">=</span>
                            <span className="text-xs font-semibold text-white">DRAW</span>
                        </button>
                        <button onClick={() => handleVote('away')} className="flex-1 flex flex-col items-center gap-2 p-3 rounded-lg bg-gray-800/60 hover:bg-brand-purple transition-all duration-200 transform hover:-translate-y-1">
                            <Image src={teams.away.logo} alt={teams.away.name} width={48} height={48} className="object-contain h-12"/>
                            <span className="text-xs font-semibold text-white truncate">{teams.away.name}</span>
                        </button>
                    </div>
                </>
            ) : (
                // --- RESULTS VIEW (After Voting) ---
                <>
                    <h4 className="text-xs font-bold text-center text-brand-muted mb-2 tracking-widest">COMMUNITY VOTE</h4>
                    <div className="flex justify-between items-center mb-1">
                        <span className="text-sm font-bold text-white">{homePercent}%</span>
                        <span className="text-xs text-brand-muted">Draw {drawPercent}%</span>
                        <span className="text-sm font-bold text-white">{awayPercent}%</span>
                    </div>
                    <div className="flex w-full h-2 rounded-full overflow-hidden bg-gray-800 mb-4">
                        <div className="bg-brand-purple" style={{ width: `${homePercent}%` }}></div>
                        <div className="bg-gray-500" style={{ width: `${drawPercent}%` }}></div>
                        <div className="bg-blue-600" style={{ width: `${awayPercent}%` }}></div>
                    </div>
                    <div className="relative">
                        <span className="absolute top-0 left-0 inline-flex h-full w-full rounded-lg bg-orange-400 opacity-75 animate-ping"></span>
                        <button onClick={handleBetClick} className="relative w-full bg-orange-500 text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2 hover:bg-orange-600 transition-colors">
                            Bet 10€ and Win 1000 €
                        </button>
                    </div>
                    <p className="text-xs text-brand-muted mt-1.5 text-center">18+. Gamble responsibly. Verified Partner chinchincasino.com.</p>
                </>
            )}
        </div>
    );
});

export default VotingPanel;

// ===== src/config/adSlots.ts =====

// src/config/adSlots.ts

export interface AdSlot {
  id: string; // The unique identifier used in the code and database
  name: string; // A user-friendly name for the admin panel
  description: string; // A hint for the admin
}

// Define all available ad locations in the application
export const AD_SLOTS: AdSlot[] = [
  {
    id: "match_sidebar",
    name: "Match Page Sidebar",
    description:
      "Appears in the right sidebar on the individual match detail page.",
  },
  {
    id: "news_sidebar",
    name: "News Article Sidebar",
    description:
      "Appears in the right sidebar on individual news article pages.",
  },
  {
    id: "homepage_left_sidebar",
    name: "Homepage Left Sidebar",
    description:
      "Appears on the left side of the main content on the homepage. Ideal for vertical ads.",
  },
  {
    id: "homepage_right_sidebar",
    name: "Homepage Right Sidebar",
    description:
      "Appears on the right side of the main content on the homepage. Ideal for vertical ads.",
  },
  {
    id: "homepage_header",
    name: "Homepage Header Banner",
    description:
      "A prominent banner at the top of the homepage (under the header).",
  },
  {
    id: "sticky_footer",
    name: "Sticky Footer Banner",
    description:
      "A banner that sticks to the bottom of the screen on all pages. Ideal for landscape ads (e.g., 728x90).",
  },
];


// ===== src/context/CountryContext.tsx =====

"use client";

import { createContext, useState, useContext, ReactNode, Dispatch, SetStateAction } from 'react';
import { Country } from '@/types/api-football';

// 1. Define the shape of the context data
interface CountryContextType {
  selectedCountry: Country | null;
  setSelectedCountry: Dispatch<SetStateAction<Country | null>>;
}

// 2. Create the context with a default value
const CountryContext = createContext<CountryContextType | undefined>(undefined);

// 3. Create the Provider component
export function CountryProvider({ children }: { children: ReactNode }) {
  const [selectedCountry, setSelectedCountry] = useState<Country | null>(null);

  return (
    <CountryContext.Provider value={{ selectedCountry, setSelectedCountry }}>
      {children}
    </CountryContext.Provider>
  );
}

// 4. Create a custom hook for easy consumption
export function useCountry() {
  const context = useContext(CountryContext);
  if (context === undefined) {
    throw new Error('useCountry must be used within a CountryProvider');
  }
  return context;
}

// ===== src/context/LanguageContext.tsx =====

"use client";

import { createContext, useState, useContext, ReactNode, Dispatch, SetStateAction } from 'react';

// Define the shape of the context data
interface LanguageContextType {
  locale: 'en' | 'tr';
  setLocale: Dispatch<SetStateAction<'en' | 'tr'>>;
}

// Create the context with a default value
const LanguageContext = createContext<LanguageContextType | undefined>(undefined);

// Create the Provider component
export function LanguageProvider({ children }: { children: ReactNode }) {
  // Default language is English
  const [locale, setLocale] = useState<'en' | 'tr'>('tr');

  return (
    <LanguageContext.Provider value={{ locale, setLocale }}>
      {children}
    </LanguageContext.Provider>
  );
}

// Create a custom hook for easy consumption
export function useLanguage() {
  const context = useContext(LanguageContext);
  if (context === undefined) {
    throw new Error('useLanguage must be used within a LanguageProvider');
  }
  return context;
}

// ===== src/context/LeagueContext.tsx =====

"use client";

import { createContext, useContext, useState, ReactNode } from "react";
import { Country, League } from "@/types/api-football";

interface LeagueContextType {
  selectedCountry: Country | null;
  setSelectedCountry: (country: Country | null) => void;
  selectedLeague: League | null;
  setSelectedLeague: (league: League | null) => void;
}

const LeagueContext = createContext<LeagueContextType | undefined>(undefined);

export const LeagueProvider = ({ children }: { children: ReactNode }) => {
  // --- CHANGE: Start with null state by default ---
  const [selectedCountry, setSelectedCountry] = useState<Country | null>(null);
  const [selectedLeague, setSelectedLeague] = useState<League | null>(null);

  // --- REMOVE: The entire useQuery and useEffect for finding a live match ---
  // The logic to pre-select a country and league is no longer needed.

  const value = { selectedCountry, setSelectedCountry, selectedLeague, setSelectedLeague };

  return (
    <LeagueContext.Provider value={value}>{children}</LeagueContext.Provider>
  );
};

export const useLeagueContext = (): LeagueContextType => {
  const context = useContext(LeagueContext);
  if (!context) throw new Error("useLeagueContext must be used within a LeagueProvider");
  return context;
};

// ===== src/hooks/useTranslation.ts =====

"use client";

import { useLanguage } from "@/context/LanguageContext";
import en from "@/locales/en.json";
import tr from "@/locales/tr.json";

// The `translations` object now needs a type hint so TypeScript
// understands its structure without relying on the `en.json` import for types.
const translations: Record<"en" | "tr", Record<string, string>> = { en, tr };

export function useTranslation() {
  const { locale } = useLanguage();

  // The function signature now uses our reliable `TranslationKey` type.
  const t = (
    key: string,
    params?: { [key: string]: string | number }
  ): string => {
    // We look up the translation using the key.
    // The `|| key` ensures it falls back gracefully if a key is somehow missing from a language file.
    let translation = translations[locale][key] || key;

    if (params) {
      Object.keys(params).forEach((paramKey) => {
        const regex = new RegExp(`{${paramKey}}`, "g");
        translation = translation.replace(regex, String(params[paramKey]));
      });
    }

    return translation;
  };

  return { t, locale };
}


// ===== src/hooks/useVoteStorage.ts =====

"use client";

import { useState, useCallback } from 'react';

const VOTE_STORAGE_KEY = 'matchVotes';

// This custom hook manages getting and setting votes in localStorage.
export function useVoteStorage() {
    // Helper function to safely get votes from localStorage
    const getVotes = useCallback((): { [key: number]: string } => {
        // localStorage is a browser-only API, so we must check if window is defined.
        if (typeof window === 'undefined') {
            return {};
        }
        try {
            const votes = window.localStorage.getItem(VOTE_STORAGE_KEY);
            return votes ? JSON.parse(votes) : {};
        } catch (error) {
            console.error("Error parsing votes from localStorage", error);
            return {};
        }
    }, []);

    // Helper function to save a vote
    const setVote = useCallback((fixtureId: number, choice: 'home' | 'draw' | 'away') => {
        if (typeof window === 'undefined') {
            return;
        }
        try {
            const allVotes = getVotes();
            allVotes[fixtureId] = choice;
            window.localStorage.setItem(VOTE_STORAGE_KEY, JSON.stringify(allVotes));
        } catch (error) {
            console.error("Error saving vote to localStorage", error);
        }
    }, [getVotes]);
    
    // Function to check if a vote exists for a specific fixture
    const getVoteForFixture = useCallback((fixtureId: number): string | null => {
        return getVotes()[fixtureId] || null;
    }, [getVotes]);

    return { setVote, getVoteForFixture };
}

// ===== src/lib/data/team.ts =====

// src/lib/data/team.ts
import axios from 'axios';

// This function contains the core logic that was previously inside your API route.
// It can be called from ANY server-side code (Server Components, API Routes, etc.).
export async function fetchTeamDetails(teamId: string) {
    const season = new Date().getFullYear().toString();

    const options = (endpoint: string, params: object) => ({
        method: 'GET',
        url: `${process.env.NEXT_PUBLIC_API_FOOTBALL_HOST}/${endpoint}`,
        params,
        headers: { 'x-apisports-key': process.env.NEXT_PUBLIC_API_FOOTBALL_KEY },
    });

    try {
        // Fetch all data in parallel for maximum efficiency
        const [
            teamInfoResponse,
            squadResponse,
            recentFixturesResponse,
            standingsResponse
        ] = await Promise.all([
            axios.request(options('teams', { id: teamId })),
            axios.request(options('players/squads', { team: teamId })),
            axios.request(options('fixtures', { team: teamId, last: 10 })),
            axios.request(options('standings', { team: teamId, season: season })),
        ]);

        // Check if the primary team info fetch failed
        if (!teamInfoResponse.data.response || teamInfoResponse.data.response.length === 0) {
            // Returning null is better than throwing an error here,
            // as the calling page can handle it gracefully with notFound().
            return null; 
        }

        const responseData = {
            teamInfo: teamInfoResponse.data.response[0],
            squad: squadResponse.data.response[0]?.players ?? [],
            fixtures: recentFixturesResponse.data.response,
            standings: standingsResponse.data.response,
        };

        return responseData;

    } catch (error) {
        console.error(`[ServerLib] Error fetching details for team ${teamId}:`, error);
        // It's crucial to return null so the page can handle the error.
        return null; 
    }
}

// ===== src/lib/dbConnect.ts =====

import mongoose from 'mongoose';

const NEXT_PUBLIC_MONGODB_URI = process.env.NEXT_PUBLIC_MONGODB_URI;

if (!NEXT_PUBLIC_MONGODB_URI) {
  throw new Error(
    'Please define the NEXT_PUBLIC_MONGODB_URI environment variable inside .env.local'
  );
}

let cached = (global as any).mongoose;

if (!cached) {
  cached = (global as any).mongoose = { conn: null, promise: null };
}

async function dbConnect() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
      serverSelectionTimeoutMS: 30000, // Increase timeout to 30s
      socketTimeoutMS: 45000, // Close sockets after 45s of inactivity
    };

    cached.promise = mongoose.connect(NEXT_PUBLIC_MONGODB_URI!, opts).then((mongoose) => {
      console.log("New Mongoose connection established.");
      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

export default dbConnect;

// ===== src/lib/generate-league-slug.ts =====

import slugify from 'slugify';

/**
 * Generates a URL-friendly slug for a league.
 * e.g., "Premier League", 39 -> "/league/premier-league-39"
 * @param name - The name of the league.
 * @param id - The unique ID of the league.
 * @returns A string representing the path.
 */
export function generateLeagueSlug(name: string, id: number): string {
  const nameSlug = slugify(name, {
    lower: true,    // convert to lower case
    strict: true,   // remove special characters
    trim: true,     // trim leading/trailing spaces
  });
  
  return `/football/league/${nameSlug}-${id}`;
}

// ===== src/lib/generate-match-slug.ts =====

// src/lib/generate-match-slug.ts
import slugify from 'slugify';

interface Team {
  name: string;
}

// The function now requires the fixture ID
export function generateMatchSlug(homeTeam: Team, awayTeam: Team, fixtureId: number): string {
  const homeName = homeTeam?.name || 'team';
  const awayName = awayTeam?.name || 'team';
  
  const homeSlug = slugify(homeName, { lower: true, strict: true });
  const awaySlug = slugify(awayName, { lower: true, strict: true });

  // Append the unique ID to the end of the slug
  return `${homeSlug}-vs-${awaySlug}-${fixtureId}`;
}

// ===== src/lib/generate-team-slug.ts =====

// src/lib/generate-team-slug.ts
import slugify from "slugify";

export const generateTeamSlug = (teamName: string, teamId: number): string => {
  const slug = slugify(teamName, {
    lower: true,
    strict: true,
    remove: /[*+~.()'"!:@]/g,
  });
  return `/football/team/${slug}-${teamId}`;
};


// ===== src/lib/image-proxy.ts =====

// src/lib/image-proxy.ts

// A placeholder image for when a logo is missing.
// You can create a simple SVG and place it in your /public directory.
const PLACEHOLDER_IMAGE = "/images/placeholder-logo.svg";

/**
 * Wraps an external image URL with our caching proxy.
 * Returns a placeholder if the URL is invalid or missing.
 * @param url The original external image URL.
 * @returns The proxied URL or a placeholder.
 */
export function proxyImageUrl(url: string | null | undefined): string {
  if (!url || !url.startsWith("http")) {
    return PLACEHOLDER_IMAGE;
  }

  return `/api/image-proxy?url=${encodeURIComponent(url)}`;
}


// ===== src/lib/mongoClient.ts =====

/**
 * This utility file manages the connection to MongoDB using the native MongoDB driver.
 * It is used exclusively by the Auth.js MongoDBAdapter.
 *
 * It establishes a single, shared connection promise that can be reused across
 * serverless function invocations, which is a critical performance optimization.
 *
 * All other application logic that uses Mongoose should use `dbConnect.ts` instead.
 */

import { MongoClient } from "mongodb";

if (!process.env.NEXT_PUBLIC_MONGODB_URI) {
  throw new Error('Invalid/Missing environment variable: "NEXT_PUBLIC_MONGODB_URI"');
}

const uri = process.env.NEXT_PUBLIC_MONGODB_URI;
const options = {};

let client: MongoClient;
let clientPromise: Promise<MongoClient>;

if (process.env.NODE_ENV === "development") {
  // In development mode, use a global variable so that the value
  // is preserved across module reloads caused by HMR (Hot Module Replacement).
  // This prevents creating new connections on every code change.
  let globalWithMongo = global as typeof globalThis & {
    _mongoClientPromise?: Promise<MongoClient>;
  };

  if (!globalWithMongo._mongoClientPromise) {
    client = new MongoClient(uri, options);
    globalWithMongo._mongoClientPromise = client.connect();
    console.log("New native MongoDB connection established for Auth.js.");
  }
  clientPromise = globalWithMongo._mongoClientPromise;
} else {
  // In production mode, it's best to not use a global variable.
  // A new connection is created once per instance.
  client = new MongoClient(uri, options);
  clientPromise = client.connect();
}

// Export a module-scoped MongoClient promise. By doing this in a
// separate module, the client can be shared across functions.
export default clientPromise;

// ===== src/lib/odds-converter.ts =====

// src/lib/odds-converter.ts

/**
 * Converts a win percentage into a decimal odd format.
 * @param percent The prediction confidence percentage (e.g., 45 for 45%).
 * @returns The decimal odd as a string (e.g., "2.22"), or "N/A" if invalid.
 */
export const convertPercentageToOdds = (
  percent: number | undefined | null
): string => {
  if (percent === null || percent === undefined || percent <= 0) {
    return "N/A";
  }
  // Ensure we don't divide by zero and handle unrealistically high confidences
  const safePercent = Math.max(1, Math.min(percent, 99));
  return (100 / safePercent).toFixed(2);
};


// ===== src/lib/prediction-engine.ts =====

// src/lib/prediction-engine.ts
// This file contains the core logic for the simple prediction engine.

import type {
  ApiSportsFixture,
  ApiSportsStandings,
  CleanOdds,
} from "@/services/sportsApi/allsportsApiService"; // Assuming these types exist

// Define the interfaces used by the prediction engine.
// These are duplicated here for clarity in this file; ideally, they would be in a shared `types` directory.
export interface PredictionResult {
  prediction: "1" | "X" | "2";
  text: string;
  confidence: number;
  homeScore: number;
  awayScore: number;
  drawScore: number;
}

interface PredictionData {
  fixture: ApiSportsFixture;
  h2h: ApiSportsFixture[];
  standings: ApiSportsStandings[];
  homeTeamForm: ApiSportsFixture[];
  awayTeamForm: ApiSportsFixture[];
}

/**
 * Generates a simple match prediction based on recent form, standings, and Head-to-Head (H2H) records.
 *
 * @param {PredictionData} data - An object containing fixture details, H2H matches, league standings,
 *                                 and recent form for both home and away teams.
 * @returns {PredictionResult} The predicted outcome (Home Win, Draw, or Away Win) with confidence score.
 */
export function generateSimplePrediction({
  fixture,
  h2h,
  standings,
  homeTeamForm,
  awayTeamForm,
}: PredictionData): PredictionResult {
  let homeScore = 1.0; // Base score for home team
  let awayScore = 1.0; // Base score for away team
  let drawScore = 1.0; // Base score for a draw

  const homeTeamId = fixture.teams.home.id;
  const awayTeamId = fixture.teams.away.id;

  // Helper function to analyze a team's recent form
  const analyzeForm = (formFixtures: ApiSportsFixture[], teamId: number) => {
    let formPoints = 0;
    // Filter for finished games and consider only the last 5 relevant matches
    const finishedGames = formFixtures
      .filter((f) => f.fixture.status.short === "FT")
      .slice(0, 5);
    finishedGames.forEach((game) => {
      // Check if the team won (either as home or away)
      if (
        (game.teams.home.id === teamId && game.teams.home.winner) ||
        (game.teams.away.id === teamId && game.teams.away.winner)
      ) {
        formPoints += 0.8; // Reward for a win
      } else if (!game.teams.home.winner && !game.teams.away.winner) {
        // It was a draw (neither team won)
        formPoints += 0.3; // Smaller reward for a draw
      }
      // No points for a loss
    });
    return formPoints;
  };

  // Apply form analysis to home and away teams
  homeScore += analyzeForm(homeTeamForm, homeTeamId);
  awayScore += analyzeForm(awayTeamForm, awayTeamId);

  // Analyze League Standings
  const leagueStandings = standings[0]?.league?.standings[0]; // Assuming first standing is the main one
  if (leagueStandings && leagueStandings.length > 0) {
    const homeTeamData = leagueStandings.find(
      (t: any) => t.team.id === homeTeamId
    );
    const awayTeamData = leagueStandings.find(
      (t: any) => t.team.id === awayTeamId
    );

    if (homeTeamData && awayTeamData) {
      const rankDiff = Math.abs(homeTeamData.rank - awayTeamData.rank);
      // Reward higher-ranked team based on rank difference, scaled by league size
      if (homeTeamData.rank < awayTeamData.rank) {
        homeScore += (rankDiff / leagueStandings.length) * 3;
      } else if (awayTeamData.rank < homeTeamData.rank) {
        awayScore += (rankDiff / leagueStandings.length) * 3;
      }
      // Increase draw potential if teams are very close in rank
      if (rankDiff <= 3) {
        drawScore += (1 - rankDiff / 4) * 2; // Stronger draw bias if rank difference is small
      }
    }
  }

  // Analyze Head-to-Head (H2H) Records
  if (h2h && h2h.length > 0) {
    let h2hHomeWins = 0;
    let h2hAwayWins = 0;
    // Consider only the most recent 5 H2H matches
    h2h.slice(0, 5).forEach((match) => {
      // Check if home team of the current fixture won the H2H match
      if (
        (match.teams.home.id === homeTeamId && match.teams.home.winner) ||
        (match.teams.away.id === homeTeamId && match.teams.away.winner)
      ) {
        h2hHomeWins++;
      }
      // Check if away team of the current fixture won the H2H match
      if (
        (match.teams.home.id === awayTeamId && match.teams.home.winner) ||
        (match.teams.away.id === awayTeamId && match.teams.away.winner)
      ) {
        h2hAwayWins++;
      }
    });
    homeScore += h2hHomeWins * 0.4;
    awayScore += h2hAwayWins * 0.4;
  }

  // Calculate total score and normalize to percentages for confidence
  const totalScore = homeScore + awayScore + drawScore;

  if (homeScore > awayScore && homeScore > drawScore) {
    return {
      prediction: "1", // Home Win
      text: "Home Win",
      confidence: Math.round((homeScore / totalScore) * 100),
      homeScore,
      awayScore,
      drawScore,
    };
  } else if (awayScore > homeScore && awayScore > drawScore) {
    return {
      prediction: "2", // Away Win
      text: "Away Win",
      confidence: Math.round((awayScore / totalScore) * 100),
      homeScore,
      awayScore,
      drawScore,
    };
  } else {
    return {
      prediction: "X", // Draw
      text: "Draw",
      confidence: Math.round((drawScore / totalScore) * 100),
      homeScore,
      awayScore,
      drawScore,
    };
  }
}


// ===== src/locales/en.json =====

{
  "live": "Live",
  "matches": "Matches",
  "yesterday": "Yesterday",
  "today": "Today",
  "tomorrow": "Tomorrow",
  "standings": "Standings",
  "news": "News",
  "analytics": "Analytics",
  "global": "Global",
  "loading": "Loading",
  "leagues": "Leagues",
  "teams": "Teams",
  "transfers": "Transfers",
  "football": "Football",
  "tennis": "Tennis",
  "basketball": "Basketball",
  "rugby": "Rugby",
  "badminton": "Badminton",
  "cancel": "Cancel",
  "saving": "Saving...",
  "previous": "Previous",
  "next": "Next",
  "advertisement": "Advertisement",
  "page_of": "Page {currentPage} of {totalPages}",
  "actions": "Actions",
  "admin_login": "Admin Login",
  "email": "Email",
  "password": "Password",
  "sign_in": "Sign In",
  "invalid_credentials": "Invalid credentials. Please try again.",
  "register": "Register",
  "user": "User",
  "role": "Role",
  "your_profile": "Your Profile",
  "view_account_settings": "View account settings",
  "admin_dashboard": "Admin Dashboard",
  "welcome_to_admin_area": "Welcome to the admin area.",
  "manage_users": "Manage Users",
  "view_and_edit_user_roles": "View and edit user roles",
  "manage_matches": "Manage Matches",
  "update_match_details": "Update match details",
  "view_analytics": "View Analytics",
  "check_site_traffic": "Check site traffic",
  "dashboard": "Dashboard",
  "users": "Users",
  "settings": "Settings",
  "admin_panel": "Admin Panel",
  "sign_out": "Sign Out",
  "create_new_post": "Create New Post",
  "edit_post": "Edit Post",
  "manage_news": "Manage News",
  "new_post": "New Post",
  "back_to_news_list": "← Back to News List",
  "loading_post_data": "Loading post data...",
  "failed_to_load_post_data": "Failed to load post data.",
  "save_post": "Save Post",
  "save_changes": "Save Changes",
  "featured_image": "Featured Image",
  "uploading": "Uploading...",
  "upload_a_file": "Upload a file",
  "or_drag_and_drop": "or drag and drop",
  "image_upload_formats": "PNG, JPG, GIF up to 10MB",
  "image_title_tooltip": "Image Title (Tooltip)",
  "image_title_placeholder": "e.g., Team celebrating a goal",
  "image_alt_text_label": "Image Alt Text (Accessibility & SEO)",
  "image_alt_text_placeholder": "e.g., Player in red jersey kicking a football",
  "image_alt_text_description": "Describe the image for screen readers and search engines.",
  "title": "Title",
  "content": "Content",
  "created_at": "Created At",
  "seo_settings": "SEO Settings",
  "meta_title": "Meta Title",
  "meta_title_placeholder": "e.g., Ultimate Guide to Sunday's Match",
  "meta_title_recommendation": "Recommended: 50-60 characters.",
  "meta_description": "Meta Description",
  "meta_description_placeholder": "A brief summary for search engines...",
  "meta_description_recommendation": "Recommended: 150-160 characters.",
  "status": "Status",
  "draft": "Draft",
  "published": "Published",
  "match_details": "Match Details",
  "view_match_details": "View Match Details",
  "finished": "Finished",
  "vote_and_see_poll": "Vote & See Poll",
  "hide_panel": "Hide Panel",
  "no_matches_for_day": "No matches found for {day}",
  "check_another_day": "Try checking another day or a different competition.",
  "match_not_found": "Match Not Found",
  "match_not_found_description": "Could not load the details for this match. It may have been removed or the ID is incorrect.",
  "team_not_found": "Team Not Found",
  "events": "Events",
  "lineups": "Lineups",
  "h2h": "H2H",
  "statistics": "Statistics",
  "prediction": "PREDICTION",
  "head_to_head": "HEAD-TO-HEAD",
  "wins": "Wins",
  "draws": "Draws",
  "no_previous_encounters": "No previous encounters found.",
  "recent_result": "Recent Result",
  "upcoming_match": "Upcoming Match",
  "no_matches_live": "No matches are currently live.",
  "live_matches": "Live Matches",
  "info": "Info",
  "fixtures": "Fixtures",
  "top_scorers": "Top Scorers",
  "back_to_global_view": "← Back to Global View",
  "standings_not_applicable_for_cups": "Standings not applicable for cup competitions.",
  "season": "Season:",
  "competition_name": "Competition Name",
  "country": "Country",
  "current_season": "Current Season",
  "season_coverage": "Season Coverage",
  "rank_short": "#",
  "team": "Team",
  "matches_played_short": "MP",
  "wins_short": "W",
  "draws_short": "D",
  "losses_short": "L",
  "goal_difference_short": "GD",
  "points_short": "Pts",
  "league_standings": "League Standings",
  "select_league_for_standings": "Select a league to see standings here.",
  "next_league": "Next League",
  "versus": "vs",
  "popular_leagues": "Popular Leagues",
  "popular_cups": "Popular Cups",
  "popular_teams": "Popular Teams",
  "published_by_on": "Published by {author} on {date}",
  "share_this_article": "Share this article",
  "total_goals_today": "Total Goals Today",
  "matches_today": "Matches Today",
  "match_spotlight": "Match Spotlight",
  "highest_scoring_match": "Highest Scoring Match",
  "show_odds": "Show Odds",
  "hide_odds": "Hide Odds",
  "exclusive_welcome_offer": "Exclusive Welcome Offer!",
  "bonus_description": "Get a 100% bonus on your first deposit to bet on today's matches.",
  "claim_your_bonus": "Claim Your Bonus Now",
  "gambling_disclaimer": "18+ | T&Cs apply. Please gamble responsibly.",
  "leagues_description": "Browse all competitions",
  "teams_description": "Find your favorite club",
  "news_description": "The latest headlines",
  "transfers_description": "Track player movements",
  "loading_banners": "Loading banners...",
  "banner_deleted_successfully": "Banner deleted successfully!",
  "failed_to_delete_banner": "Failed to delete banner.",
  "are_you_sure_you_want_to_delete_this_banner_this_action_cannot_be_undone": "Are you sure you want to delete this banner? This action cannot be undone.",
  "failed_to_load_banners": "Failed to load banners.",
  "manage_ad_banners": "Manage Ad Banners",
  "new_banner": "New Banner",
  "preview": "Preview",
  "location": "Location",
  "active": "Active",
  "inactive": "Inactive",
  "no_banners_found_click_new_banner_to_create_one": "No banners found. Click \"New Banner\" to create one.",
  "featured_preview": "Featured preview",
  "png_jpg_gif_up_to_10mb": "PNG, JPG, GIF up to 10MB",
  "image_uploaded": "Image uploaded!",
  "image_upload_failed": "Image upload failed.",
  "e_g_team_celebrating_a_goal": "e.g., Team celebrating a goal",
  "image_alt_text_accessibility_seo": "Image Alt Text (Accessibility & SEO)",
  "e_g_player_in_red_jersey_kicking_a_football": "e.g., Player in red jersey kicking a football",
  "describe_the_image_for_screen_readers_and_search_engines": "Describe the image for screen readers and search engines.",
  "e_g_ultimate_guide_to_sunday_s_match": "e.g., Ultimate Guide to Sunday's Match",
  "recommended_50_60_characters": "Recommended: 50-60 characters.",
  "a_brief_summary_for_search_engines": "A brief summary for search engines...",
  "recommended_150_160_characters": "Recommended: 150-160 characters.",
  "title_and_content_cannot_be_empty": "Title and content cannot be empty.",
  "post_created_successfully": "Post created successfully!",
  "failed_to_create_post": "Failed to create post.",
  "post_updated_successfully": "Post updated successfully!",
  "failed_to_update_post": "Failed to update post.",
  "loading_posts": "Loading posts...",
  "failed_to_load_posts": "Failed to load posts.",
  "are_you_sure_you_want_to_delete_this_post": "Are you sure you want to delete this post?",
  "post_deleted_successfully": "Post deleted successfully!",
  "error_deleting_post": "Error deleting post.",
  "server_error_fetching_banners": "Server error fetching banners",
  "forbidden": "Forbidden",
  "title_image_url_link_url_and_location_are_required": "Title, Image URL, Link URL, and Location are required",
  "server_error_creating_banner": "Server error creating banner",
  "banner_not_found": "Banner not found",
  "server_error_updating_banner": "Server error updating banner",
  "banner_deleted_successfully_message": "Banner deleted successfully",
  "server_error": "Server error",
  "failed_to_fetch_country_data": "Failed to fetch country data.",
  "failed_to_fetch_teams_data": "Failed to fetch teams data.",
  "failed_to_fetch_live_matches": "Failed to fetch live matches",
  "league_id_is_required": "League ID is required",
  "failed_to_fetch_live_odds_data_from_the_provider": "Failed to fetch live odds data from the provider.",
  "fixture_id_is_required": "Fixture ID is required",
  "failed_to_fetch_match_details": "Failed to fetch match details.",
  "failed_to_fetch_odds_data_from_the_provider": "Failed to fetch odds data from the provider.",
  "server_error_fetching_posts": "Server error fetching posts",
  "title_and_content_are_required_post": "Title and content are required",
  "a_post_with_the_slug": "A post with the slug '",
  "already_exists_please_use_a_different_title": "' already exists. Please use a different title.",
  "server_error_creating_post": "Server error creating post",
  "post_not_found": "Post not found",
  "server_error_updating_post": "Server error updating post",
  "post_deleted_successfully_message": "Post deleted successfully",
  "no_prediction_available": "No prediction available.",
  "failed_to_fetch_prediction_data": "Failed to fetch prediction data.",
  "failed_to_fetch_fixture_data_for_sport": "Failed to fetch fixture data for ",
  "failed_to_fetch_standings_data": "Failed to fetch standings data",
  "failed_to_fetch_team_details_or_team_not_found": "Failed to fetch team details or team not found",
  "league_id_and_season_are_required": "League ID and season are required",
  "failed_to_fetch_teams_data_for_this_country": "Failed to fetch teams data for this country.",
  "failed_to_fetch_top_scorers_data": "Failed to fetch top scorers data.",
  "no_upcoming_matches_for_league": "No upcoming matches for league ",
  "fetching_recent_results": ". Fetching recent results...",
  "failed_to_fetch_match_data": "Failed to fetch match data",
  "no_file_provided": "No file provided.",
  "image_uploaded_successfully": "Image uploaded successfully",
  "failed_to_upload_image": "Failed to upload image.",
  "valid_fixture_id_and_vote_type_are_required": "Valid fixtureId and vote type are required",
  "server_error_submitting_vote": "Server error submitting vote",
  "league_not_found": "League Not Found",
  "leagues_cups": "Leagues & Cups",
  "search_by_name": "Search by name...",
  "all": "All",
  "cups": "Cups",
  "no_results_found": "No Results Found",
  "try_adjusting_your_search_or_filter": "Try adjusting your search or filter.",
  "could_not_load_the_details_for_this_match_it_may_have_been_removed_or_the_id_is_incorrect": "Could not load the details for this match. It may have been removed or the ID is incorrect.",
  "latest_news": "Latest News",
  "no_news_available": "No News Available",
  "there_are_no_news_articles_to_display_at_the_moment": "There are no news articles to display at the moment.",
  "published_by": "Published by ",
  "on": " on ",
  "not_found": "Not Found",
  "browse_teams_by_country": "Browse Teams by Country",
  "select_a_country_to_view_all_associated_professional_teams": "Select a country to view all associated professional teams.",
  "search_for_a_country": "Search for a country...",
  "error_loading_countries": "Error Loading Countries",
  "could_not_fetch_the_list_of_countries_please_try_again_later": "Could not fetch the list of countries. Please try again later.",
  "your_search_for": "Your search for \"",
  "did_not_match_any_countries": "\" did not match any countries.",
  "teams_in": "Teams in ",
  "search_by_team_name": "Search by team name...",
  "try_adjusting_your_search_term_or_check_back_later": "Try adjusting your search term or check back later.",
  "404_page_not_found": "404 - Page Not Found",
  "the_page_you_are_looking_for_does_not_exist_or_has_been_moved": "The page you are looking for does not exist or has been moved.",
  "go_back_to_homepage": "Go back to Homepage",
  "fan_skor_turkiyenin_1_numarali_canli_skor_sitesi": "Fan Skor | Türkiye'nin 1 numaralı Canlı Skor sitesi",
  "loading_placeholder": "Loading...",
  "upcoming": "Upcoming",
  "table_header_team": "Team",
  "error_loading_fixtures": "Error loading fixtures.",
  "no_fixtures_found": "No fixtures found for this selection.",
  "no_standings_title": "No Standings",
  "standings_not_available": "Standings are not available for this competition.",
  "select_another_league_prompt": " Please select another league from the tabs above.",
  "manage_banners": "Manage Banners",
  "all_leagues": "All Leagues",
  "all_teams": "All Teams",
  "information": "Information",
  "about_us": "About Us",
  "privacy_policy": "Privacy Policy",
  "terms_of_service": "Terms of Service",
  "contact_us": "Contact Us",
  "footer_description": "Fanskor provides comprehensive sports insights, live scores, and expert analysis for football enthusiasts worldwide.",
  "match_seo_description": "[home_team_name] comes into this match showcasing strong form in recent weeks, with notable wins and solid defensive displays. Their attacking line has been sharp, creating multiple chances and capitalizing on opponent errors. Meanwhile, [away_team_name] has also shown resilience, bouncing back from early setbacks and steadily climbing up the standings. Fans can expect high energy, aggressive pressing, and creative plays from both sides."
}


// ===== src/locales/tr.json =====

{
  "live": "Canlı",
  "matches": "Maçlar",
  "yesterday": "Dün",
  "today": "Bugün",
  "tomorrow": "Yarın",
  "standings": "Puan Durumu",
  "news": "Haberler",
  "analytics": "Analizler",
  "global": "Genel",
  "loading": "Yükleniyor",
  "leagues": "Ligler",
  "teams": "Takımlar",
  "transfers": "Transferler",
  "football": "Futbol",
  "tennis": "Tenis",
  "basketball": "Basketbol",
  "rugby": "Ragbi",
  "badminton": "Badminton",
  "cancel": "İptal",
  "saving": "Kaydediliyor...",
  "previous": "Önceki",
  "next": "Sonraki",
  "advertisement": "Reklamcılık",
  "page_of": "Sayfa {currentPage} / {totalPages}",
  "actions": "Eylemler",
  "admin_login": "Yönetici Girişi",
  "email": "E-posta",
  "password": "Şifre",
  "sign_in": "Giriş Yap",
  "invalid_credentials": "Geçersiz kimlik bilgileri. Lütfen tekrar deneyin.",
  "register": "Kaydol",
  "user": "Kullanıcı",
  "role": "Rol",
  "your_profile": "Profiliniz",
  "view_account_settings": "Hesap ayarlarını görüntüle",
  "admin_dashboard": "Yönetici Paneli",
  "welcome_to_admin_area": "Yönetici alanına hoş geldiniz.",
  "manage_users": "Kullanıcıları Yönet",
  "view_and_edit_user_roles": "Kullanıcı rollerini görüntüle ve düzenle",
  "manage_matches": "Maçları Yönet",
  "update_match_details": "Maç detaylarını güncelle",
  "view_analytics": "Analizleri Görüntüle",
  "check_site_traffic": "Site trafiğini kontrol et",
  "dashboard": "Kontrol Paneli",
  "users": "Kullanıcılar",
  "settings": "Ayarlar",
  "admin_panel": "Yönetici Paneli",
  "sign_out": "Çıkış Yap",
  "create_new_post": "Yeni Yazı Oluştur",
  "edit_post": "Yazıyı Düzenle",
  "manage_news": "Haberleri Yönet",
  "new_post": "Yeni Yazı",
  "back_to_news_list": "← Haber Listesine Geri Dön",
  "loading_post_data": "Yazı verileri yükleniyor...",
  "failed_to_load_post_data": "Yazı verileri yüklenemedi.",
  "save_post": "Yazıyı Kaydet",
  "save_changes": "Değişiklikleri Kaydet",
  "featured_image": "Öne Çıkan Görsel",
  "uploading": "Yükleniyor...",
  "upload_a_file": "Bir dosya yükleyin",
  "or_drag_and_drop": "veya sürükleyip bırakın",
  "image_upload_formats": "PNG, JPG, GIF (maks. 10MB)",
  "image_title_tooltip": "Görsel Başlığı (İpucu)",
  "image_title_placeholder": "örn. Gol sevincini kutlayan takım",
  "image_alt_text_label": "Görsel Alternatif Metni (Erişilebilirlik ve SEO)",
  "image_alt_text_placeholder": "örn. Kırmızı formalı futbolcu topa vuruyor",
  "image_alt_text_description": "Ekran okuyucular ve arama motorları için görseli açıklayın.",
  "title": "Başlık",
  "content": "İçerik",
  "created_at": "Oluşturulma Tarihi",
  "seo_settings": "SEO Ayarları",
  "meta_title": "Meta Başlık",
  "meta_title_placeholder": "örn. Pazar Günkü Maç İçin Nihai Rehber",
  "meta_title_recommendation": "Önerilen: 50-60 karakter.",
  "meta_description": "Meta Açıklama",
  "meta_description_placeholder": "Arama motorları için kısa bir özet...",
  "meta_description_recommendation": "Önerilen: 150-160 karakter.",
  "status": "Durum",
  "draft": "Taslak",
  "published": "Yayınlandı",
  "match_details": "Maç Detayları",
  "view_match_details": "Maç Detaylarını Görüntüle",
  "finished": "Bitti",
  "vote_and_see_poll": "Oy Ver & Anketi Gör",
  "hide_panel": "Paneli Gizle",
  "no_matches_for_day": "{day} için maç bulunamadı",
  "check_another_day": "Başka bir gün veya farklı bir müsabaka kontrol etmeyi deneyin.",
  "match_not_found": "Maç Bulunamadı",
  "match_not_found_description": "Bu maçın detayları yüklenemedi. Kaldırılmış veya ID hatalı olabilir.",
  "team_not_found": "Takım Bulunamadı",
  "events": "Olaylar",
  "lineups": "Kadrolar",
  "h2h": "Kafa Kafaya",
  "statistics": "İstatistikler",
  "prediction": "TAHMİN",
  "head_to_head": "KAFA KAFAYA",
  "wins": "Galibiyetler",
  "draws": "Beraberlikler",
  "no_previous_encounters": "Önceki karşılaşma bulunamadı.",
  "recent_result": "Sonuç",
  "upcoming_match": "Yaklaşan Maç",
  "no_matches_live": "Şu anda canlı maç yok.",
  "live_matches": "Canlı Maçlar",
  "info": "Bilgi",
  "fixtures": "Fikstürler",
  "top_scorers": "Gol Krallığı",
  "back_to_global_view": "← Genel Görünüme Geri Dön",
  "standings_not_applicable_for_cups": "Puan durumu kupa müsabakaları için geçerli değildir.",
  "season": "Sezon:",
  "competition_name": "Müsabaka Adı",
  "country": "Ülke",
  "current_season": "Güncel Sezon",
  "season_coverage": "Sezon Kapsamı",
  "rank_short": "#",
  "team": "Takım",
  "matches_played_short": "O",
  "wins_short": "G",
  "draws_short": "B",
  "losses_short": "M",
  "goal_difference_short": "AV",
  "points_short": "P",
  "league_standings": "Lig Puan Durumu",
  "select_league_for_standings": "Puan durumunu görmek için bir lig seçin.",
  "next_league": "Sonraki Lig",
  "versus": "vs",
  "popular_leagues": "Popüler Ligler",
  "popular_cups": "Popüler Kupalar",
  "popular_teams": "Popüler Takımlar",
  "published_by_on": "{author} tarafından {date} tarihinde yayınlandı",
  "share_this_article": "Bu makaleyi paylaş",
  "total_goals_today": "Bugün Toplam Gol",
  "matches_today": "Bugünkü Maçlar",
  "match_spotlight": "Maç Odak Noktası",
  "highest_scoring_match": "En Gole Dayalı Maç",
  "show_odds": "Oranları Göster",
  "hide_odds": "Oranları Gizle",
  "exclusive_welcome_offer": "Özel Hoş Geldin Teklifi!",
  "bonus_description": "Bugünkü maçlara bahis oynamak için ilk para yatırma işleminizde %100 bonus kazanın.",
  "claim_your_bonus": "Bonusunuzu Şimdi Alın",
  "gambling_disclaimer": "18+ | Şartlar ve Koşullar geçerlidir. Lütfen sorumlu bir şekilde kumar oynayın.",
  "leagues_description": "Tüm müsabakalara göz atın",
  "teams_description": "Favori kulübünüzü bulun",
  "news_description": "En son manşetler",
  "transfers_description": "Oyuncu hareketlerini takip edin",
  "loading_banners": "Bannerlar yükleniyor...",
  "banner_deleted_successfully": "Banner başarıyla silindi!",
  "failed_to_delete_banner": "Banner silinemedi.",
  "are_you_sure_you_want_to_delete_this_banner_this_action_cannot_be_undone": "Bu bannerı silmek istediğinizden emin misiniz? Bu işlem geri alınamaz.",
  "failed_to_load_banners": "Bannerlar yüklenemedi.",
  "manage_ad_banners": "Reklam Bannerlarını Yönet",
  "new_banner": "Yeni Banner",
  "preview": "Önizleme",
  "location": "Konum",
  "active": "Aktif",
  "inactive": "Pasif",
  "no_banners_found_click_new_banner_to_create_one": "Banner bulunamadı. Bir tane oluşturmak için \"Yeni Banner\"a tıklayın.",
  "featured_preview": "Öne çıkan önizleme",
  "png_jpg_gif_up_to_10mb": "PNG, JPG, GIF (maks. 10MB)",
  "image_uploaded": "Görsel yüklendi!",
  "image_upload_failed": "Görsel yüklenemedi.",
  "e_g_team_celebrating_a_goal": "örn. Gol sevincini kutlayan takım",
  "image_alt_text_accessibility_seo": "Görsel Alternatif Metni (Erişilebilirlik ve SEO)",
  "e_g_player_in_red_jersey_kicking_a_football": "örn. Kırmızı formalı futbolcu topa vuruyor",
  "describe_the_image_for_screen_readers_and_search_engines": "Ekran okuyucular ve arama motorları için görseli açıklayın.",
  "e_g_ultimate_guide_to_sunday_s_match": "örn. Pazar Günkü Maç İçin Nihai Rehber",
  "recommended_50_60_characters": "Önerilen: 50-60 karakter.",
  "a_brief_summary_for_search_engines": "Arama motorları için kısa bir özet...",
  "recommended_150_160_characters": "Önerilen: 150-160 karakter.",
  "title_and_content_cannot_be_empty": "Başlık ve içerik boş olamaz.",
  "post_created_successfully": "Yazı başarıyla oluşturuldu!",
  "failed_to_create_post": "Yazı oluşturulamadı.",
  "post_updated_successfully": "Yazı başarıyla güncellendi!",
  "failed_to_update_post": "Yazı güncellenemedi.",
  "loading_posts": "Yazılar yükleniyor...",
  "failed_to_load_posts": "Yazılar yüklenemedi.",
  "are_you_sure_you_want_to_delete_this_post": "Bu yazıyı silmek istediğinizden emin misiniz?",
  "post_deleted_successfully": "Yazı başarıyla silindi!",
  "error_deleting_post": "Yazı silinirken hata oluştu.",
  "server_error_fetching_banners": "Bannerlar getirilirken sunucu hatası",
  "forbidden": "Yasak",
  "title_image_url_link_url_and_location_are_required": "Başlık, Görsel URL'si, Bağlantı URL'si ve Konum zorunludur",
  "server_error_creating_banner": "Banner oluşturulurken sunucu hatası",
  "banner_not_found": "Banner bulunamadı",
  "server_error_updating_banner": "Banner güncellenirken sunucu hatası",
  "banner_deleted_successfully_message": "Banner başarıyla silindi",
  "server_error": "Sunucu hatası",
  "failed_to_fetch_country_data": "Ülke verileri alınamadı.",
  "failed_to_fetch_teams_data": "Takım verileri alınamadı.",
  "failed_to_fetch_live_matches": "Canlı maçlar alınamadı",
  "league_id_is_required": "Lig ID'si zorunludur",
  "failed_to_fetch_live_odds_data_from_the_provider": "Sağlayıcıdan canlı oran verileri alınamadı.",
  "fixture_id_is_required": "Fikstür ID'si zorunludur",
  "failed_to_fetch_match_details": "Maç detayları alınamadı.",
  "failed_to_fetch_odds_data_from_the_provider": "Sağlayıcıdan oran verileri alınamadı.",
  "server_error_fetching_posts": "Yazılar getirilirken sunucu hatası",
  "title_and_content_are_required_post": "Başlık ve içerik zorunludur",
  "a_post_with_the_slug": "Başlık slug'ı ile bir yazı '",
  "already_exists_please_use_a_different_title": "' zaten mevcut. Lütfen farklı bir başlık kullanın.",
  "server_error_creating_post": "Yazı oluşturulurken sunucu hatası",
  "post_not_found": "Yazı bulunamadı",
  "server_error_updating_post": "Yazı güncellenirken sunucu hatası",
  "post_deleted_successfully_message": "Yazı başarıyla silindi",
  "no_prediction_available": "Tahmin mevcut değil.",
  "failed_to_fetch_prediction_data": "Tahmin verileri alınamadı.",
  "failed_to_fetch_fixture_data_for_sport": " spor dalı için fikstür verileri alınamadı.",
  "failed_to_fetch_standings_data": "Puan durumu verileri alınamadı",
  "failed_to_fetch_team_details_or_team_not_found": "Takım detayları alınamadı veya takım bulunamadı",
  "league_id_and_season_are_required": "Lig ID'si ve sezon zorunludur",
  "failed_to_fetch_teams_data_for_this_country": "Bu ülke için takım verileri alınamadı.",
  "failed_to_fetch_top_scorers_data": "Gol krallığı verileri alınamadı.",
  "no_upcoming_matches_for_league": " ligi için yaklaşan maç yok.",
  "fetching_recent_results": ". Son sonuçlar getiriliyor...",
  "failed_to_fetch_match_data": "Maç verileri alınamadı",
  "no_file_provided": "Dosya sağlanmadı.",
  "image_uploaded_successfully": "Görsel başarıyla yüklendi",
  "failed_to_upload_image": "Görsel yüklenemedi.",
  "valid_fixture_id_and_vote_type_are_required": "Geçerli fikstür ID'si ve oylama türü zorunludur",
  "server_error_submitting_vote": "Oy gönderilirken sunucu hatası",
  "league_not_found": "Lig Bulunamadı",
  "leagues_cups": "Ligler & Kupalar",
  "search_by_name": "İsme göre ara...",
  "all": "Tümü",
  "cups": "Kupalar",
  "no_results_found": "Sonuç Bulunamadı",
  "try_adjusting_your_search_or_filter": "Aramanızı veya filtrenizi ayarlamayı deneyin.",
  "could_not_load_the_details_for_this_match_it_may_have_been_removed_or_the_id_is_incorrect": "Bu maçın detayları yüklenemedi. Kaldırılmış veya ID hatalı olabilir.",
  "latest_news": "Son Haberler",
  "no_news_available": "Haber Yok",
  "there_are_no_news_articles_to_display_at_the_moment": "Şu anda görüntülenecek haber makalesi yok.",
  "published_by": "Yayınlayan: ",
  "on": " tarihinde ",
  "not_found": "Bulunamadı",
  "browse_teams_by_country": "Ülkeye Göre Takımlara Göz At",
  "select_a_country_to_view_all_associated_professional_teams": "Tüm ilgili profesyonel takımları görüntülemek için bir ülke seçin.",
  "search_for_a_country": "Bir ülke ara...",
  "error_loading_countries": "Ülkeler Yüklenirken Hata",
  "Ülkeler_fetch_list_error": "Ülkeler listesi alınamadı. Lütfen daha sonra tekrar deneyin.",
  "your_search_for": "Aramanız \"",
  "did_not_match_any_countries": "\" hiçbir ülkeyle eşleşmedi.",
  "teams_in": "Takımlar: ",
  "search_by_team_name": "Takım adına göre ara...",
  "try_adjusting_your_search_term_or_check_back_later": "Arama teriminizi ayarlamayı deneyin veya daha sonra tekrar kontrol edin.",
  "404_page_not_found": "404 - Sayfa Bulunamadı",
  "the_page_you_are_looking_for_does_not_exist_or_has_been_moved": "Aradığınız sayfa mevcut değil veya taşınmış olabilir.",
  "go_back_to_homepage": "Ana Sayfaya Geri Dön",
  "fan_skor_turkiyenin_1_numarali_canli_skor_sitesi": "Fan Skor | Türkiye'nin 1 numaralı Canlı Skor sitesi",
  "loading_placeholder": "Yükleniyor...",
  "upcoming": "Gelecek",
  "error_loading_fixtures": "Fikstürler yüklenirken hata oluştu.",
  "no_fixtures_found": "Bu seçim için fikstür bulunamadı.",
  "view_full_table": "Tüm Tabloyu Gör",
  "table_header_team": "Takım",
  "no_standings_title": "Puan Durumu Yok",
  "standings_not_available": "Bu turnuva için puan durumu mevcut değil.",
  "select_another_league_prompt": " Lütfen yukarıdaki sekmelerden başka bir lig seçin.",
  "manage_banners": "Bannerları Yönet",
  "all_leagues": "Tüm Ligler",
  "all_teams": "Tüm Takımlar",
  "information": "Bilgi",
  "about_us": "Hakkımızda",
  "privacy_policy": "Gizlilik Politikası",
  "terms_of_service": "Hizmet Şartları",
  "contact_us": "Bize Ulaşın",
  "footer_description": "Fanskor, dünya çapındaki futbol tutkunları için kapsamlı spor analizleri, canlı skorlar ve uzman yorumları sunar.",
  "match_seo_description": "[home_team_name] son haftalarda güçlü bir form grafiği sergiliyor, önemli galibiyetler ve sağlam defansif performanslar gösteriyor. Hücum hattı keskin, birçok pozisyon yaratıyor ve rakip hatalarından faydalanıyor. Bu arada, [away_team_name] de ilk aksiliklerden sonra toparlanarak puan tablosunda istikrarlı bir şekilde yükselişini sürdürdü. Taraftarlar her iki taraftan da yüksek enerji, agresif pres ve yaratıcı oyunlar bekleyebilir."
}


// ===== src/models/AIJournalist.ts =====

// src/models/AIJournalist.ts
import mongoose, { Schema, Document } from "mongoose";

// Interface for an AI Journalist profile
export interface IAIJournalist extends Document {
  name: string; // e.g., "Bold Reporter", "Analytical Guru"
  description?: string; // Short description for the admin UI
  tonePrompt: string; // The specific prompt segment defining the tone/style of this journalist
  isActive: boolean; // Whether this journalist profile can be used
  createdAt: Date;
  updatedAt: Date;
}

const AIJournalistSchema: Schema = new Schema(
  {
    name: { type: String, required: true, unique: true, trim: true },
    description: { type: String, trim: true },
    // This is the core prompt segment that defines the journalist's style/tone.
    // It will be injected into the main article generation prompt.
    tonePrompt: { type: String, required: true, trim: true },
    isActive: { type: Boolean, default: true },
  },
  {
    timestamps: true, // Adds createdAt and updatedAt
  }
);

// Ensure the model is only compiled once
const AIJournalist =
  mongoose.models.AIJournalist ||
  mongoose.model<IAIJournalist>("AIJournalist", AIJournalistSchema);

export default AIJournalist;


// ===== src/models/AIPrompt.ts =====

// src/models/AIPrompt.ts
import mongoose, { Schema, Document } from "mongoose";

// Define the types of AI prompts
export type AIPromptType = "title" | "content" | "prediction_content"; // <-- Added 'prediction_content'

export interface IAIPrompt extends Document {
  name: string;
  type: AIPromptType; // <-- NEW: Type field
  prompt: string;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}

const AIPromptSchema: Schema = new Schema(
  {
    name: { type: String, required: true, trim: true },
    type: {
      type: String,
      enum: ["title", "content", "prediction_content"],
      required: true,
    }, // <-- NEW: Type field definition
    prompt: { type: String, required: true },
    description: { type: String, trim: true },
  },
  {
    timestamps: true,
  }
);

// Add a unique compound index on 'name' and 'type' to ensure uniqueness for each prompt type
AIPromptSchema.index({ name: 1, type: 1 }, { unique: true });

export default (mongoose.models.AIPrompt as mongoose.Model<IAIPrompt>) ||
  mongoose.model<IAIPrompt>("AIPrompt", AIPromptSchema);


// ===== src/models/Banner.ts =====

// src/models/Banner.ts

import mongoose, { Document, Schema, Model } from "mongoose";

export interface IBanner extends Document {
  title: string;
  imageUrl: string;
  linkUrl: string;
  isActive: boolean;
  location: string; // This field MUST be here
  createdAt: Date;
  updatedAt: Date;
}

const BannerSchema: Schema<IBanner> = new Schema(
  {
    title: {
      type: String,
      required: [true, "Banner title is required."],
      trim: true,
    },
    imageUrl: {
      type: String,
      required: [true, "Image URL is required."],
    },
    linkUrl: {
      type: String,
      required: [true, "Link URL is required."],
    },
    isActive: {
      type: Boolean,
      default: true,
    },
    // This definition MUST be here
    location: {
      type: String,
      required: [true, "A location must be specified for the banner."],
      index: true,
    },
  },
  {
    timestamps: true,
  }
);

// This logic prevents Mongoose from redefining the model on every hot reload
const Banner: Model<IBanner> =
  mongoose.models.Banner || mongoose.model<IBanner>("Banner", BannerSchema);

export default Banner;


// ===== src/models/CasinoPartner.ts =====

// src/models/CasinoPartner.ts
import mongoose, { Schema, Document } from "mongoose";

// Interface for a Casino Partner
export interface ICasinoPartner extends Document {
  name: string; // Name of the casino/partner
  logoUrl: string; // URL to the partner's logo
  redirectUrl: string; // URL where users will be redirected (affiliate link)
  description?: string; // Short description for internal use or tooltip
  isFeatured: boolean; // If true, apply prominent styling on the frontend
  isActive: boolean; // Whether this partner is currently displayed
  order: number; // For manual sorting, lower number appears first
  createdAt: Date;
  updatedAt: Date;
}

const CasinoPartnerSchema: Schema = new Schema(
  {
    name: { type: String, required: true, unique: true, trim: true },
    logoUrl: { type: String, required: true, trim: true },
    redirectUrl: { type: String, required: true, trim: true },
    description: { type: String, trim: true },
    isFeatured: { type: Boolean, default: false },
    isActive: { type: Boolean, default: true },
    order: { type: Number, default: 0 }, // Default order, 0 means no specific order preference
  },
  {
    timestamps: true, // Adds createdAt and updatedAt
  }
);

// Ensure the model is only compiled once
const CasinoPartner =
  mongoose.models.CasinoPartner ||
  mongoose.model<ICasinoPartner>("CasinoPartner", CasinoPartnerSchema);

export default CasinoPartner;


// ===== src/models/ExternalNewsArticle.ts =====

// src/models/ExternalNewsArticle.ts
import mongoose, { Schema, Document } from "mongoose";

// Interface for a single external news article
export interface IExternalNewsArticle extends Document {
  articleId: string; // Unique ID from the newsdata.io API
  title: string;
  link: string; // Original URL of the article
  keywords?: string[];
  creator?: string | null;
  video_url?: string | null;
  description?: string | null;
  content?: string | null;
  pubDate: Date; // Published date from newsdata.io
  imageUrl?: string | null; // URL of the featured image
  source_id?: string; // ID of the source (e.g., cnn, bbc-news)
  source_priority?: number;
  source_url?: string;
  source_icon?: string | null;
  language?: string;
  country?: string[];
  category?: string[];
  sentiment?: string; // Positive, Negative, Neutral
  // --- UPDATED STATUS ENUM ---
  status: "fetched" | "processing" | "processed" | "skipped" | "error"; // Added 'processing'
  processedPostId?: mongoose.Types.ObjectId; // Link to the generated Post if processed
  createdAt: Date;
  updatedAt: Date;
}

const ExternalNewsArticleSchema: Schema = new Schema(
  {
    articleId: { type: String, required: true, unique: true, index: true },
    title: { type: String, required: true },
    link: { type: String, required: true },
    keywords: [{ type: String }],
    creator: { type: String },
    video_url: { type: String },
    description: { type: String },
    content: { type: String },
    pubDate: { type: Date, required: true, index: true },
    imageUrl: { type: String },
    source_id: { type: String },
    source_priority: { type: Number },
    source_url: { type: String },
    source_icon: { type: String },
    language: { type: String },
    country: [{ type: String }],
    category: [{ type: String }],
    sentiment: { type: String },
    // --- UPDATED SCHEMA ENUM ---
    status: {
      type: String,
      enum: ["fetched", "processing", "processed", "skipped", "error"],
      default: "fetched",
    }, // Added 'processing'
    processedPostId: { type: Schema.Types.ObjectId, ref: "Post" }, // Reference to our Post model
  },
  {
    timestamps: true, // Adds createdAt and updatedAt
  }
);

// Ensure the model is only compiled once
const ExternalNewsArticle =
  mongoose.models.ExternalNewsArticle ||
  mongoose.model<IExternalNewsArticle>(
    "ExternalNewsArticle",
    ExternalNewsArticleSchema
  );

export default ExternalNewsArticle;


// ===== src/models/Post.ts =====

// src/models/Post.ts
import mongoose, { Schema, Document } from "mongoose";

// Define the types of sports/categories a post can belong to
export type PostCategory =
  | "football"
  | "basketball"
  | "tennis"
  | "general"
  | "prediction"
  | "match_reports";

export interface IPost extends Document {
  title: string;
  content: string;
  slug: string;
  author: string;
  status: "draft" | "published";
  createdAt: Date;
  updatedAt: Date;
  featuredImage?: string;
  featuredImageTitle?: string;
  featuredImageAltText?: string;
  metaTitle?: string;
  metaDescription?: string;
  // --- MODIFIED: `sport` is now an array of PostCategory ---
  sport: PostCategory[];
  isAIGenerated?: boolean;
  originalExternalArticleId?: mongoose.Types.ObjectId;
  originalFixtureId?: number;
}

const PostSchema: Schema = new Schema(
  {
    title: { type: String, required: true, trim: true },
    content: { type: String, required: true },
    slug: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
    },
    author: { type: String, default: "Admin" },
    status: { type: String, enum: ["draft", "published"], default: "draft" },
    featuredImage: { type: String, trim: true },
    featuredImageTitle: { type: String, trim: true },
    featuredImageAltText: { type: String, trim: true },
    metaTitle: { type: String, trim: true },
    metaDescription: { type: String, trim: true },
    // --- MODIFIED: Schema definition for `sport` field ---
    sport: {
      type: [
        {
          type: String,
          enum: [
            "football",
            "basketball",
            "tennis",
            "general",
            "prediction",
            "match_reports",
          ],
        },
      ],
      default: ["general"], // Default to an array with 'general'
      required: true,
    },
    isAIGenerated: { type: Boolean, default: false },
    originalExternalArticleId: {
      type: Schema.Types.ObjectId,
      ref: "ExternalNewsArticle",
      required: false,
    },
    originalFixtureId: {
      type: Number,
      required: false,
      unique: true,
      sparse: true,
    },
  },
  {
    timestamps: true,
  }
);

export default (mongoose.models.Post as mongoose.Model<IPost>) ||
  mongoose.model<IPost>("Post", PostSchema);


// ===== src/models/User.ts =====

import mongoose, { Schema, models, model } from 'mongoose';

export interface IUser extends mongoose.Document {
  name?: string;
  email: string;
  image?: string;
  password?: string; // Add password field
  role: 'user' | 'admin'; // Add role field
  favoriteTeams?: number[];
}

const UserSchema = new Schema<IUser>({
  name: String,
  email: {
    type: String,
    unique: true,
    required: true,
  },
  image: String,
  // CRITICAL: Never return the password hash by default in queries
  password: {
    type: String,
    select: false, 
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user',
  },
  favoriteTeams: {
    type: [Number],
    default: [],
  },
}, { timestamps: true });

const User = models.User || model<IUser>('User', UserSchema);
export default User;

// ===== src/models/Vote.ts =====

import mongoose, { Schema, Document, models, Model } from 'mongoose';

// Interface for our Vote document
export interface IVote extends Document {
  fixtureId: number;
  homeVotes: number;
  drawVotes: number;
  awayVotes: number;
}

const VoteSchema: Schema = new Schema(
  {
    fixtureId: { 
        type: Number, 
        required: true, 
        unique: true, // Ensures one document per match
        index: true   // Speeds up finding votes for a fixture
    },
    homeVotes: { type: Number, default: 0 },
    drawVotes: { type: Number, default: 0 },
    awayVotes: { type: Number, default: 0 },
  },
  {
    timestamps: true,
  }
);

// Prevent model overwrite in Next.js hot-reloading environment
const Vote: Model<IVote> = models.Vote || mongoose.model<IVote>('Vote', VoteSchema);

export default Vote;

// ===== src/services/sports/football.service.ts =====

import axios from 'axios';
import { ISportService } from './ISportService';
import { format, addDays } from 'date-fns';

// All the logic that was in your API routes is now encapsulated here.
export class FootballApiService implements ISportService {
  private readonly apiKey = process.env.NEXT_PUBLIC_API_FOOTBALL_KEY;
  private readonly apiHost = process.env.NEXT_PUBLIC_API_FOOTBALL_HOST;

  private async request(endpoint: string, params: object) {
    const options = {
      method: 'GET',
      url: `${this.apiHost}/${endpoint}`,
      params,
      headers: { 'x-apisports-key': this.apiKey },
    };
    try {
      const response = await axios.request(options);
      return response.data.response;
    } catch (error) {
      console.error(`[FootballApiService] Error fetching '${endpoint}':`, error);
      throw new Error(`Failed to fetch data from ${endpoint}.`);
    }
  }

  async getCompetitions(params: { country?: string; type?: string; fetchAll?: boolean }): Promise<any[]> {
    // This logic is moved from your /api/leagues route
    const apiParams: any = { current: 'true' };
    if (params.country) apiParams.country = params.country;
    if (params.type) apiParams.type = params.type;

    let allLeagues = await this.request('leagues', apiParams);
    
    // ... add your filtering logic for popular leagues here if needed ...

    return allLeagues; // The transformation can happen in the API route or component
  }

  async getFixtures(params: { competitionId?: string; date?: string; teamId?: string }): Promise<any[]> {
    // This combines logic from your /api/fixtures and /api/upcoming-matches routes
    const apiParams: any = {};
    const season = new Date().getFullYear().toString();

    if (params.competitionId) apiParams.league = params.competitionId;
    if (params.date) apiParams.date = params.date;
    if (params.teamId) {
        apiParams.team = params.teamId;
        apiParams.last = 10; // Example: get last 10 matches for a team
    } else {
        // Default global fetch logic
        apiParams.season = season;
        const today = format(new Date(), 'yyyy-MM-dd');
        apiParams.from = today;
        apiParams.to = format(addDays(new Date(), 1), 'yyyy-MM-dd');
    }
    
    return this.request('fixtures', apiParams);
  }

  async getMatchDetails(matchId: string): Promise<any | null> {
    // This logic is from your /api/match-details route.
    // Combining multiple requests for full detail.
    const [fixture, events, stats, h2h, prediction] = await Promise.all([
        this.request('fixtures', { id: matchId }),
        this.request('fixtures/events', { fixture: matchId }),
        this.request('fixtures/statistics', { fixture: matchId }),
        this.request('fixtures/headtohead', { h2h: `...` }), // h2h needs team IDs
        this.request('predictions', { fixture: matchId })
    ]);
    // Structure and return the combined data
    return { fixture: fixture[0], events, statistics: stats, /* ...etc */ };
  }

  async getTeamDetails(teamId: string): Promise<any | null> {
      // Logic from your /lib/data/team.ts
      return await this.request('teams', { id: teamId });
  }

  async getStandings(params: { competitionId: string; season: string; }): Promise<any | null> {
      return this.request('standings', { league: params.competitionId, season: params.season });
  }
}

// ===== src/services/sports/index.ts =====

import { ISportService } from './ISportService';
import { FootballApiService } from './football.service';
// import { BasketballApiService } from './basketball.service'; // For the future

const services: { [key: string]: ISportService } = {
  football: new FootballApiService(),
  // basketball: new BasketballApiService(), // Add new sports here
};

export function getSportService(sport: string): ISportService {
  const service = services[sport];
  if (!service) {
    throw new Error(`Unsupported sport: ${sport}`);
  }
  return service;
}

// ===== src/services/sports/ISportService.ts =====

// This interface defines the "contract" that any sports data provider must follow.
export interface ISportService {
  // A competition can be a league, a tournament, a cup, etc.
  getCompetitions(params: { country?: string; type?: string; fetchAll?: boolean }): Promise<any[]>;

  // Fixtures are matches, games, races, etc.
  getFixtures(params: { competitionId?: string; date?: string; season?: string; live?: boolean; teamId?: string }): Promise<any[]>;

  getMatchDetails(matchId: string): Promise<any | null>;
  
  getTeamDetails(teamId: string): Promise<any | null>;

  getStandings(params: { competitionId: string; season: string }): Promise<any | null>;
  
  // You can add more methods as needed, like getPlayers, getTopScorers, etc.
}

// ===== src/services/sportsApi/allsportsApiService.ts =====

// src/services/sportsApi/allsportsApiService.ts
// This file centralizes common API-Football related types for consistency across the application.

// --- Core API-Football Types ---

/**
 * Represents a single team in an API-Football fixture or team response.
 */
export interface ApiSportsTeam {
  id: number;
  name: string;
  logo: string;
  winner?: boolean | null; // Indicates if this team won a specific fixture
}

/**
 * Represents fixture status.
 */
export interface ApiSportsFixtureStatus {
  long: string;
  short: string;
  elapsed: number | null;
}

/**
 * Represents basic league information.
 */
export interface ApiSportsLeague {
  id: number;
  name: string;
  type: string; // 'league' or 'cup'
  logo: string;
  season?: number; // Added for context, often present in fixture/standing responses
}

/**
 * Represents the score for a team at half-time, full-time, etc.
 */
export interface ApiSportsGoals {
  home: number | null;
  away: number | null;
}

/**
 * Represents a single API-Football fixture (match).
 */
export interface ApiSportsFixture {
  fixture: {
    id: number;
    referee: string | null;
    timezone: string;
    date: string; // ISO 8601 date string
    timestamp: number;
    periods: { first: number | null; second: number | null };
    venue: { id: number; name: string; city: string };
    status: ApiSportsFixtureStatus;
  };
  league: ApiSportsLeague;
  teams: {
    home: ApiSportsTeam;
    away: ApiSportsTeam;
  };
  goals: ApiSportsGoals; // Full-time goals
  score: {
    halftime: ApiSportsGoals;
    fulltime: ApiSportsGoals;
    extratime: ApiSportsGoals | null;
    penalty: ApiSportsGoals | null;
  };
  events?: any[]; // Optional: events can be fetched separately
  statistics?: any[]; // Optional: statistics can be fetched separately
  lineups?: any[]; // Optional: lineups can be fetched separately
}

/**
 * Represents a single team's entry in a league standing.
 */
export interface ApiSportsTeamStanding {
  rank: number;
  team: ApiSportsTeam;
  points: number;
  goalsDiff: number;
  group: string;
  form: string; // e.g., "WWDLW"
  status: string; // e.g., "same", "up", "down"
  description: string | null; // e.g., "Promotion - Champions League (Group Stage)"
  all: {
    played: number;
    win: number;
    draw: number;
    lose: number;
    goals: { for: number; against: number };
  };
  home: {
    played: number;
    win: number;
    draw: number;
    lose: number;
    goals: { for: number; against: number };
  };
  away: {
    played: number;
    win: number;
    draw: number;
    lose: number;
    goals: { for: number; against: number };
  };
  update: string; // Date string
}

/**
 * Represents a league's standings structure (can have multiple groups/stages).
 */
export interface ApiSportsStandings {
  league: {
    id: number;
    name: string;
    country: string;
    logo: string;
    flag: string;
    season: number;
    standings: ApiSportsTeamStanding[][]; // Array of arrays because a league can have multiple groups (e.g., Champions League)
  };
}

/**
 * Represents a simplified odds structure for display.
 */
export interface CleanOdds {
  home: string | null;
  draw: string | null;
  away: string | null;
  handicap?: string | null; // For Asian Handicap
  over?: string | null; // For Over/Under
  under?: string | null; // For Over/Under
}

/**
 * Represents a football player.
 */
export interface ApiSportsPlayer {
  id: number;
  name: string;
  firstname: string;
  lastname: string;
  age: number;
  birth: {
    date: string;
    place: string;
    country: string;
  };
  nationality: string;
  height: string;
  weight: string;
  injured: boolean;
  photo: string;
}

/**
 * Represents player statistics for a specific team/fixture.
 */
export interface ApiSportsPlayerStats {
  player: ApiSportsPlayer;
  statistics: {
    team: ApiSportsTeam;
    league: ApiSportsLeague;
    games: {
      appearences: number | null;
      lineups: number | null;
      minutes: number | null;
      number: number | null;
      position: string;
      rating: string | null;
      captain: boolean;
    };
    substitutes: {
      in: number | null;
      out: number | null;
      bench: number | null;
    };
    goals: {
      total: number | null;
      conceded: number | null;
      assists: number | null;
      saves: number | null;
    };
    passes: {
      total: number | null;
      key: number | null;
      accuracy: string | null;
    };
    tackles: {
      total: number | null;
      blocks: number | null;
      interceptions: number | null;
    };
    duels: {
      total: number | null;
      won: number | null;
    };
    dribbles: {
      attempts: number | null;
      success: number | null;
      past: number | null;
    };
    fouls: {
      drawn: number | null;
      committed: number | null;
    };
    cards: {
      yellow: number;
      red: number;
    };
    penalty: {
      won: number | null;
      commited: number | null;
      scored: number | null;
      missed: number | null;
      saved: number | null;
    };
  }[];
}

// --- Country type used in /api/countries ---
export interface Country {
  name: string;
  code: string | null; // ISO 3166-1 alpha-2 code
  flagUrl: string;
}


// ===== src/types/api-football.ts =====


// This is the new, simplified type for a league
export interface League {
  id: number;
  name: string;
  logoUrl: string;
  countryName: string;
  countryFlagUrl: string,
  type: string,
  href: string;
}

export interface Country {
  name: string;
  code: string | null; // Code can sometimes be null
  flagUrl: string;
}

// ===== src/types/global.d.ts =====

// /src/types/global.d.ts

import { Mongoose } from 'mongoose';

/* eslint-disable no-var */

declare global {
  var mongoose: {
    conn: Mongoose | null;
    promise: Promise<Mongoose> | null;
  };
}

// ===== src/types/next-auth.d.ts =====

// src/types/next-auth.d.ts

import 'next-auth';
import 'next-auth/jwt';

// Use module augmentation to extend the default types
declare module 'next-auth' {
  /**
   * Returned by `useSession`, `getSession` and received as a prop on the `SessionProvider` React Context
   */
  interface Session {
    user: {
      id: string;
      role: 'user' | 'admin';
    } & DefaultSession['user'];
  }

  interface User {
    role: 'user' | 'admin';
  }
}

declare module 'next-auth/jwt' {
  /** Returned by the `jwt` callback and `getToken`, when using JWT sessions */
  interface JWT {
    id: string;
    role: 'user' | 'admin';
  }
}

// ===== src/types/translations.d.ts =====

// src/types/translations.d.ts

export type TranslationKey =
  // General & Navigation
  | "live"
  | "matches"
  | "yesterday"
  | "today"
  | "tomorrow"
  | "standings"
  | "news"
  | "analytics"
  | "global"
  | "loading"
  | "leagues"
  | "teams"
  | "transfers"
  | "football"
  | "tennis"
  | "basketball"
  | "rugby"
  | "badminton"
  | "cancel"
  | "saving"
  | "previous"
  | "next"
  | "page_of"
  | "actions"
  | "advertisement"

  // Auth & User
  | "admin_login"
  | "email"
  | "password"
  | "sign_in"
  | "invalid_credentials"
  | "register"
  | "user"
  | "role"
  | "your_profile"
  | "view_account_settings"

  // Admin Panel
  | "admin_dashboard"
  | "welcome_to_admin_area"
  | "manage_users"
  | "view_and_edit_user_roles"
  | "manage_matches"
  | "update_match_details"
  | "view_analytics"
  | "check_site_traffic"
  | "dashboard"
  | "users"
  | "settings"
  | "admin_panel"
  | "sign_out"

  // Admin News/CMS
  | "create_new_post"
  | "edit_post"
  | "manage_news"
  | "new_post"
  | "back_to_news_list"
  | "loading_post_data"
  | "failed_to_load_post_data"
  | "save_post"
  | "save_changes"
  | "featured_image"
  | "uploading"
  | "upload_a_file"
  | "or_drag_and_drop"
  | "image_upload_formats"
  | "image_title_tooltip"
  | "image_title_placeholder"
  | "image_alt_text_label"
  | "image_alt_text_placeholder"
  | "image_alt_text_description"
  | "title"
  | "content"
  | "created_at"
  | "seo_settings"
  | "meta_title"
  | "meta_title_placeholder"
  | "meta_title_recommendation"
  | "meta_description"
  | "meta_description_placeholder"
  | "meta_description_recommendation"
  | "status"
  | "draft"
  | "published"
  | "latest_news"

  // Match & League Specific
  | "match_details"
  | "view_match_details"
  | "finished"
  | "vote_and_see_poll"
  | "hide_panel"
  | "no_matches_for_day"
  | "check_another_day"
  | "match_not_found"
  | "match_not_found_description"
  | "team_not_found"
  | "events"
  | "lineups"
  | "h2h"
  | "statistics"
  | "prediction"
  | "head_to_head"
  | "wins"
  | "draws"
  | "no_previous_encounters"
  | "recent_result"
  | "upcoming_match"
  | "no_matches_live"
  | "live_matches"
  | "info"
  | "fixtures"
  | "top_scorers"
  | "back_to_global_view"
  | "standings_not_applicable_for_cups"
  | "season"
  | "competition_name"
  | "country"
  | "current_season"
  | "season_coverage"
  | "rank_short"
  | "team"
  | "matches_played_short"
  | "wins_short"
  | "draws_short"
  | "losses_short"
  | "goal_difference_short"
  | "points_short"
  | "league_standings"
  | "select_league_for_standings"
  | "next_league"
  | "versus"

  // Homepage & Sidebar
  | "popular_leagues"
  | "popular_cups"
  | "popular_teams"

  // News Page
  | "published_by_on"
  | "share_this_article"

  // Analytics Tab
  | "total_goals_today"
  | "matches_today"
  | "match_spotlight"
  | "highest_scoring_match"

  // Betting
  | "show_odds"
  | "hide_odds"
  | "exclusive_welcome_offer"
  | "bonus_description"
  | "claim_your_bonus"
  | "gambling_disclaimer"
  | "leagues_description"
  | "teams_description"
  | "news_description"
  | "transfers_description";

